var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require3() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/@log4js-node/log4js-api/lib/index.js
var require_lib = __commonJS({
  "node_modules/@log4js-node/log4js-api/lib/index.js"(exports, module) {
    var Logger = class {
      log() {
      }
      isLevelEnabled() {
        return false;
      }
      addContext() {
      }
      removeContext() {
      }
      clearContext() {
      }
    };
    __name(Logger, "Logger");
    ["Trace", "Debug", "Info", "Warn", "Error", "Fatal", "Mark"].forEach((level) => {
      Logger.prototype[level.toLowerCase()] = () => {
      };
      Logger.prototype[`is${level}Enabled`] = () => false;
    });
    var checkForLog4js = /* @__PURE__ */ __name(() => {
      try {
        return __require("../node_modules/log4js/lib/log4js.js");
      } catch (e) {
        return null;
      }
    }, "checkForLog4js");
    var log4js2 = checkForLog4js();
    var loggerFn = log4js2 ? log4js2.getLogger : () => new Logger();
    module.exports = {
      getLogger: loggerFn
    };
  }
});

// node_modules/json2csv/dist/json2csv.umd.js
var require_json2csv_umd = __commonJS({
  "node_modules/json2csv/dist/json2csv.umd.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.json2csv = {}));
    })(exports, function(exports2) {
      "use strict";
      var domain;
      function EventHandlers() {
      }
      __name(EventHandlers, "EventHandlers");
      EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
      function EventEmitter() {
        EventEmitter.init.call(this);
      }
      __name(EventEmitter, "EventEmitter");
      EventEmitter.EventEmitter = EventEmitter;
      EventEmitter.usingDomains = false;
      EventEmitter.prototype.domain = void 0;
      EventEmitter.prototype._events = void 0;
      EventEmitter.prototype._maxListeners = void 0;
      EventEmitter.defaultMaxListeners = 10;
      EventEmitter.init = function() {
        this.domain = null;
        if (EventEmitter.usingDomains) {
          if (domain.active && !(this instanceof domain.Domain))
            ;
        }
        if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || void 0;
      };
      EventEmitter.prototype.setMaxListeners = /* @__PURE__ */ __name(function setMaxListeners(n) {
        if (typeof n !== "number" || n < 0 || isNaN(n))
          throw new TypeError('"n" argument must be a positive number');
        this._maxListeners = n;
        return this;
      }, "setMaxListeners");
      function $getMaxListeners(that) {
        if (that._maxListeners === void 0)
          return EventEmitter.defaultMaxListeners;
        return that._maxListeners;
      }
      __name($getMaxListeners, "$getMaxListeners");
      EventEmitter.prototype.getMaxListeners = /* @__PURE__ */ __name(function getMaxListeners() {
        return $getMaxListeners(this);
      }, "getMaxListeners");
      function emitNone(handler, isFn, self2) {
        if (isFn)
          handler.call(self2);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            listeners[i].call(self2);
        }
      }
      __name(emitNone, "emitNone");
      function emitOne(handler, isFn, self2, arg1) {
        if (isFn)
          handler.call(self2, arg1);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            listeners[i].call(self2, arg1);
        }
      }
      __name(emitOne, "emitOne");
      function emitTwo(handler, isFn, self2, arg1, arg2) {
        if (isFn)
          handler.call(self2, arg1, arg2);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            listeners[i].call(self2, arg1, arg2);
        }
      }
      __name(emitTwo, "emitTwo");
      function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
        if (isFn)
          handler.call(self2, arg1, arg2, arg3);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            listeners[i].call(self2, arg1, arg2, arg3);
        }
      }
      __name(emitThree, "emitThree");
      function emitMany(handler, isFn, self2, args) {
        if (isFn)
          handler.apply(self2, args);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            listeners[i].apply(self2, args);
        }
      }
      __name(emitMany, "emitMany");
      EventEmitter.prototype.emit = /* @__PURE__ */ __name(function emit(type2) {
        var er, handler, len, args, i, events, domain2;
        var doError = type2 === "error";
        events = this._events;
        if (events)
          doError = doError && events.error == null;
        else if (!doError)
          return false;
        domain2 = this.domain;
        if (doError) {
          er = arguments[1];
          if (domain2) {
            if (!er)
              er = new Error('Uncaught, unspecified "error" event');
            er.domainEmitter = this;
            er.domain = domain2;
            er.domainThrown = false;
            domain2.emit("error", er);
          } else if (er instanceof Error) {
            throw er;
          } else {
            var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
            err.context = er;
            throw err;
          }
          return false;
        }
        handler = events[type2];
        if (!handler)
          return false;
        var isFn = typeof handler === "function";
        len = arguments.length;
        switch (len) {
          case 1:
            emitNone(handler, isFn, this);
            break;
          case 2:
            emitOne(handler, isFn, this, arguments[1]);
            break;
          case 3:
            emitTwo(handler, isFn, this, arguments[1], arguments[2]);
            break;
          case 4:
            emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
            break;
          default:
            args = new Array(len - 1);
            for (i = 1; i < len; i++)
              args[i - 1] = arguments[i];
            emitMany(handler, isFn, this, args);
        }
        return true;
      }, "emit");
      function _addListener(target, type2, listener, prepend) {
        var m;
        var events;
        var existing;
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        events = target._events;
        if (!events) {
          events = target._events = new EventHandlers();
          target._eventsCount = 0;
        } else {
          if (events.newListener) {
            target.emit(
              "newListener",
              type2,
              listener.listener ? listener.listener : listener
            );
            events = target._events;
          }
          existing = events[type2];
        }
        if (!existing) {
          existing = events[type2] = listener;
          ++target._eventsCount;
        } else {
          if (typeof existing === "function") {
            existing = events[type2] = prepend ? [listener, existing] : [existing, listener];
          } else {
            if (prepend) {
              existing.unshift(listener);
            } else {
              existing.push(listener);
            }
          }
          if (!existing.warned) {
            m = $getMaxListeners(target);
            if (m && m > 0 && existing.length > m) {
              existing.warned = true;
              var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type2 + " listeners added. Use emitter.setMaxListeners() to increase limit");
              w.name = "MaxListenersExceededWarning";
              w.emitter = target;
              w.type = type2;
              w.count = existing.length;
              emitWarning(w);
            }
          }
        }
        return target;
      }
      __name(_addListener, "_addListener");
      function emitWarning(e) {
        typeof console.warn === "function" ? console.warn(e) : console.log(e);
      }
      __name(emitWarning, "emitWarning");
      EventEmitter.prototype.addListener = /* @__PURE__ */ __name(function addListener(type2, listener) {
        return _addListener(this, type2, listener, false);
      }, "addListener");
      EventEmitter.prototype.on = EventEmitter.prototype.addListener;
      EventEmitter.prototype.prependListener = /* @__PURE__ */ __name(function prependListener2(type2, listener) {
        return _addListener(this, type2, listener, true);
      }, "prependListener");
      function _onceWrap(target, type2, listener) {
        var fired = false;
        function g() {
          target.removeListener(type2, g);
          if (!fired) {
            fired = true;
            listener.apply(target, arguments);
          }
        }
        __name(g, "g");
        g.listener = listener;
        return g;
      }
      __name(_onceWrap, "_onceWrap");
      EventEmitter.prototype.once = /* @__PURE__ */ __name(function once(type2, listener) {
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        this.on(type2, _onceWrap(this, type2, listener));
        return this;
      }, "once");
      EventEmitter.prototype.prependOnceListener = /* @__PURE__ */ __name(function prependOnceListener(type2, listener) {
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        this.prependListener(type2, _onceWrap(this, type2, listener));
        return this;
      }, "prependOnceListener");
      EventEmitter.prototype.removeListener = /* @__PURE__ */ __name(function removeListener(type2, listener) {
        var list, events, position, i, originalListener;
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        events = this._events;
        if (!events)
          return this;
        list = events[type2];
        if (!list)
          return this;
        if (list === listener || list.listener && list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else {
            delete events[type2];
            if (events.removeListener)
              this.emit("removeListener", type2, list.listener || listener);
          }
        } else if (typeof list !== "function") {
          position = -1;
          for (i = list.length; i-- > 0; ) {
            if (list[i] === listener || list[i].listener && list[i].listener === listener) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }
          if (position < 0)
            return this;
          if (list.length === 1) {
            list[0] = void 0;
            if (--this._eventsCount === 0) {
              this._events = new EventHandlers();
              return this;
            } else {
              delete events[type2];
            }
          } else {
            spliceOne(list, position);
          }
          if (events.removeListener)
            this.emit("removeListener", type2, originalListener || listener);
        }
        return this;
      }, "removeListener");
      EventEmitter.prototype.removeAllListeners = /* @__PURE__ */ __name(function removeAllListeners(type2) {
        var listeners, events;
        events = this._events;
        if (!events)
          return this;
        if (!events.removeListener) {
          if (arguments.length === 0) {
            this._events = new EventHandlers();
            this._eventsCount = 0;
          } else if (events[type2]) {
            if (--this._eventsCount === 0)
              this._events = new EventHandlers();
            else
              delete events[type2];
          }
          return this;
        }
        if (arguments.length === 0) {
          var keys2 = Object.keys(events);
          for (var i = 0, key; i < keys2.length; ++i) {
            key = keys2[i];
            if (key === "removeListener")
              continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners("removeListener");
          this._events = new EventHandlers();
          this._eventsCount = 0;
          return this;
        }
        listeners = events[type2];
        if (typeof listeners === "function") {
          this.removeListener(type2, listeners);
        } else if (listeners) {
          do {
            this.removeListener(type2, listeners[listeners.length - 1]);
          } while (listeners[0]);
        }
        return this;
      }, "removeAllListeners");
      EventEmitter.prototype.listeners = /* @__PURE__ */ __name(function listeners(type2) {
        var evlistener;
        var ret;
        var events = this._events;
        if (!events)
          ret = [];
        else {
          evlistener = events[type2];
          if (!evlistener)
            ret = [];
          else if (typeof evlistener === "function")
            ret = [evlistener.listener || evlistener];
          else
            ret = unwrapListeners(evlistener);
        }
        return ret;
      }, "listeners");
      EventEmitter.listenerCount = function(emitter, type2) {
        if (typeof emitter.listenerCount === "function") {
          return emitter.listenerCount(type2);
        } else {
          return listenerCount.call(emitter, type2);
        }
      };
      EventEmitter.prototype.listenerCount = listenerCount;
      function listenerCount(type2) {
        var events = this._events;
        if (events) {
          var evlistener = events[type2];
          if (typeof evlistener === "function") {
            return 1;
          } else if (evlistener) {
            return evlistener.length;
          }
        }
        return 0;
      }
      __name(listenerCount, "listenerCount");
      EventEmitter.prototype.eventNames = /* @__PURE__ */ __name(function eventNames() {
        return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
      }, "eventNames");
      function spliceOne(list, index) {
        for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
          list[i] = list[k];
        list.pop();
      }
      __name(spliceOne, "spliceOne");
      function arrayClone(arr, i) {
        var copy = new Array(i);
        while (i--)
          copy[i] = arr[i];
        return copy;
      }
      __name(arrayClone, "arrayClone");
      function unwrapListeners(arr) {
        var ret = new Array(arr.length);
        for (var i = 0; i < ret.length; ++i) {
          ret[i] = arr[i].listener || arr[i];
        }
        return ret;
      }
      __name(unwrapListeners, "unwrapListeners");
      var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var inited = false;
      function init() {
        inited = true;
        var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        for (var i = 0, len = code.length; i < len; ++i) {
          lookup[i] = code[i];
          revLookup[code.charCodeAt(i)] = i;
        }
        revLookup["-".charCodeAt(0)] = 62;
        revLookup["_".charCodeAt(0)] = 63;
      }
      __name(init, "init");
      function toByteArray(b64) {
        if (!inited) {
          init();
        }
        var i, j, l, tmp, placeHolders, arr;
        var len = b64.length;
        if (len % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
        arr = new Arr(len * 3 / 4 - placeHolders);
        l = placeHolders > 0 ? len - 4 : len;
        var L = 0;
        for (i = 0, j = 0; i < l; i += 4, j += 3) {
          tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
          arr[L++] = tmp >> 16 & 255;
          arr[L++] = tmp >> 8 & 255;
          arr[L++] = tmp & 255;
        }
        if (placeHolders === 2) {
          tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
          arr[L++] = tmp & 255;
        } else if (placeHolders === 1) {
          tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
          arr[L++] = tmp >> 8 & 255;
          arr[L++] = tmp & 255;
        }
        return arr;
      }
      __name(toByteArray, "toByteArray");
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      __name(tripletToBase64, "tripletToBase64");
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i = start; i < end; i += 3) {
          tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      __name(encodeChunk, "encodeChunk");
      function fromByteArray(uint8) {
        if (!inited) {
          init();
        }
        var tmp;
        var len = uint8.length;
        var extraBytes = len % 3;
        var output = "";
        var parts = [];
        var maxChunkLength = 16383;
        for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
          parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len - 1];
          output += lookup[tmp >> 2];
          output += lookup[tmp << 4 & 63];
          output += "==";
        } else if (extraBytes === 2) {
          tmp = (uint8[len - 2] << 8) + uint8[len - 1];
          output += lookup[tmp >> 10];
          output += lookup[tmp >> 4 & 63];
          output += lookup[tmp << 2 & 63];
          output += "=";
        }
        parts.push(output);
        return parts.join("");
      }
      __name(fromByteArray, "fromByteArray");
      function read(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      }
      __name(read, "read");
      function write(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s * 128;
      }
      __name(write, "write");
      var toString = {}.toString;
      var isArray = Array.isArray || function(arr) {
        return toString.call(arr) == "[object Array]";
      };
      var INSPECT_MAX_BYTES = 50;
      Buffer2.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== void 0 ? global$1.TYPED_ARRAY_SUPPORT : true;
      function kMaxLength() {
        return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
      }
      __name(kMaxLength, "kMaxLength");
      function createBuffer(that, length) {
        if (kMaxLength() < length) {
          throw new RangeError("Invalid typed array length");
        }
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          that = new Uint8Array(length);
          that.__proto__ = Buffer2.prototype;
        } else {
          if (that === null) {
            that = new Buffer2(length);
          }
          that.length = length;
        }
        return that;
      }
      __name(createBuffer, "createBuffer");
      function Buffer2(arg, encodingOrOffset, length) {
        if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
          return new Buffer2(arg, encodingOrOffset, length);
        }
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new Error(
              "If encoding is specified then the first argument must be a string"
            );
          }
          return allocUnsafe(this, arg);
        }
        return from(this, arg, encodingOrOffset, length);
      }
      __name(Buffer2, "Buffer");
      Buffer2.poolSize = 8192;
      Buffer2._augment = function(arr) {
        arr.__proto__ = Buffer2.prototype;
        return arr;
      };
      function from(that, value, encodingOrOffset, length) {
        if (typeof value === "number") {
          throw new TypeError('"value" argument must not be a number');
        }
        if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
          return fromArrayBuffer(that, value, encodingOrOffset, length);
        }
        if (typeof value === "string") {
          return fromString(that, value, encodingOrOffset);
        }
        return fromObject(that, value);
      }
      __name(from, "from");
      Buffer2.from = function(value, encodingOrOffset, length) {
        return from(null, value, encodingOrOffset, length);
      };
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        Buffer2.prototype.__proto__ = Uint8Array.prototype;
        Buffer2.__proto__ = Uint8Array;
      }
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be a number');
        } else if (size < 0) {
          throw new RangeError('"size" argument must not be negative');
        }
      }
      __name(assertSize, "assertSize");
      function alloc(that, size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(that, size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
        }
        return createBuffer(that, size);
      }
      __name(alloc, "alloc");
      Buffer2.alloc = function(size, fill, encoding) {
        return alloc(null, size, fill, encoding);
      };
      function allocUnsafe(that, size) {
        assertSize(size);
        that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
        if (!Buffer2.TYPED_ARRAY_SUPPORT) {
          for (var i = 0; i < size; ++i) {
            that[i] = 0;
          }
        }
        return that;
      }
      __name(allocUnsafe, "allocUnsafe");
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe(null, size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe(null, size);
      };
      function fromString(that, string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer2.isEncoding(encoding)) {
          throw new TypeError('"encoding" must be a valid string encoding');
        }
        var length = byteLength(string, encoding) | 0;
        that = createBuffer(that, length);
        var actual = that.write(string, encoding);
        if (actual !== length) {
          that = that.slice(0, actual);
        }
        return that;
      }
      __name(fromString, "fromString");
      function fromArrayLike(that, array) {
        var length = array.length < 0 ? 0 : checked(array.length) | 0;
        that = createBuffer(that, length);
        for (var i = 0; i < length; i += 1) {
          that[i] = array[i] & 255;
        }
        return that;
      }
      __name(fromArrayLike, "fromArrayLike");
      function fromArrayBuffer(that, array, byteOffset, length) {
        array.byteLength;
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError("'offset' is out of bounds");
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError("'length' is out of bounds");
        }
        if (byteOffset === void 0 && length === void 0) {
          array = new Uint8Array(array);
        } else if (length === void 0) {
          array = new Uint8Array(array, byteOffset);
        } else {
          array = new Uint8Array(array, byteOffset, length);
        }
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          that = array;
          that.__proto__ = Buffer2.prototype;
        } else {
          that = fromArrayLike(that, array);
        }
        return that;
      }
      __name(fromArrayBuffer, "fromArrayBuffer");
      function fromObject(that, obj) {
        if (internalIsBuffer(obj)) {
          var len = checked(obj.length) | 0;
          that = createBuffer(that, len);
          if (that.length === 0) {
            return that;
          }
          obj.copy(that, 0, 0, len);
          return that;
        }
        if (obj) {
          if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
            if (typeof obj.length !== "number" || isnan(obj.length)) {
              return createBuffer(that, 0);
            }
            return fromArrayLike(that, obj);
          }
          if (obj.type === "Buffer" && isArray(obj.data)) {
            return fromArrayLike(that, obj.data);
          }
        }
        throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
      }
      __name(fromObject, "fromObject");
      function checked(length) {
        if (length >= kMaxLength()) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
        }
        return length | 0;
      }
      __name(checked, "checked");
      Buffer2.isBuffer = isBuffer;
      function internalIsBuffer(b) {
        return !!(b != null && b._isBuffer);
      }
      __name(internalIsBuffer, "internalIsBuffer");
      Buffer2.compare = /* @__PURE__ */ __name(function compare(a, b) {
        if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
          throw new TypeError("Arguments must be Buffers");
        }
        if (a === b)
          return 0;
        var x = a.length;
        var y = b.length;
        for (var i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      }, "compare");
      Buffer2.isEncoding = /* @__PURE__ */ __name(function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      }, "isEncoding");
      Buffer2.concat = /* @__PURE__ */ __name(function concat(list, length) {
        if (!isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        var i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        var buffer = Buffer2.allocUnsafe(length);
        var pos = 0;
        for (i = 0; i < list.length; ++i) {
          var buf = list[i];
          if (!internalIsBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          }
          buf.copy(buffer, pos);
          pos += buf.length;
        }
        return buffer;
      }, "concat");
      function byteLength(string, encoding) {
        if (internalIsBuffer(string)) {
          return string.length;
        }
        if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          string = "" + string;
        }
        var len = string.length;
        if (len === 0)
          return 0;
        var loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
            case void 0:
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase)
                return utf8ToBytes(string).length;
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      __name(byteLength, "byteLength");
      Buffer2.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        var loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      __name(slowToString, "slowToString");
      Buffer2.prototype._isBuffer = true;
      function swap(b, n, m) {
        var i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      __name(swap, "swap");
      Buffer2.prototype.swap16 = /* @__PURE__ */ __name(function swap16() {
        var len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (var i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      }, "swap16");
      Buffer2.prototype.swap32 = /* @__PURE__ */ __name(function swap32() {
        var len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (var i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      }, "swap32");
      Buffer2.prototype.swap64 = /* @__PURE__ */ __name(function swap64() {
        var len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (var i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      }, "swap64");
      Buffer2.prototype.toString = /* @__PURE__ */ __name(function toString2() {
        var length = this.length | 0;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      }, "toString");
      Buffer2.prototype.equals = /* @__PURE__ */ __name(function equals(b) {
        if (!internalIsBuffer(b))
          throw new TypeError("Argument must be a Buffer");
        if (this === b)
          return true;
        return Buffer2.compare(this, b) === 0;
      }, "equals");
      Buffer2.prototype.inspect = /* @__PURE__ */ __name(function inspect2() {
        var str = "";
        var max = INSPECT_MAX_BYTES;
        if (this.length > 0) {
          str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
          if (this.length > max)
            str += " ... ";
        }
        return "<Buffer " + str + ">";
      }, "inspect");
      Buffer2.prototype.compare = /* @__PURE__ */ __name(function compare(target, start, end, thisStart, thisEnd) {
        if (!internalIsBuffer(target)) {
          throw new TypeError("Argument must be a Buffer");
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        var x = thisEnd - thisStart;
        var y = end - start;
        var len = Math.min(x, y);
        var thisCopy = this.slice(thisStart, thisEnd);
        var targetCopy = target.slice(start, end);
        for (var i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      }, "compare");
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (isNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer2.from(val, encoding);
        }
        if (internalIsBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      __name(bidirectionalIndexOf, "bidirectionalIndexOf");
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        var indexSize = 1;
        var arrLength = arr.length;
        var valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read2(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        __name(read2, "read");
        var i;
        if (dir) {
          var foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i;
              if (i - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            var found = true;
            for (var j = 0; j < valLength; j++) {
              if (read2(arr, i + j) !== read2(val, j)) {
                found = false;
                break;
              }
            }
            if (found)
              return i;
          }
        }
        return -1;
      }
      __name(arrayIndexOf, "arrayIndexOf");
      Buffer2.prototype.includes = /* @__PURE__ */ __name(function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      }, "includes");
      Buffer2.prototype.indexOf = /* @__PURE__ */ __name(function indexOf2(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      }, "indexOf");
      Buffer2.prototype.lastIndexOf = /* @__PURE__ */ __name(function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      }, "lastIndexOf");
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        var remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        var strLen = string.length;
        if (strLen % 2 !== 0)
          throw new TypeError("Invalid hex string");
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        for (var i = 0; i < length; ++i) {
          var parsed = parseInt(string.substr(i * 2, 2), 16);
          if (isNaN(parsed))
            return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      __name(hexWrite, "hexWrite");
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      __name(utf8Write, "utf8Write");
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      __name(asciiWrite, "asciiWrite");
      function latin1Write(buf, string, offset, length) {
        return asciiWrite(buf, string, offset, length);
      }
      __name(latin1Write, "latin1Write");
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      __name(base64Write, "base64Write");
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      __name(ucs2Write, "ucs2Write");
      Buffer2.prototype.write = /* @__PURE__ */ __name(function write2(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset | 0;
          if (isFinite(length)) {
            length = length | 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        var remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        var loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
              return asciiWrite(this, string, offset, length);
            case "latin1":
            case "binary":
              return latin1Write(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }, "write");
      Buffer2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      }, "toJSON");
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return fromByteArray(buf);
        } else {
          return fromByteArray(buf.slice(start, end));
        }
      }
      __name(base64Slice, "base64Slice");
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        var res = [];
        var i = start;
        while (i < end) {
          var firstByte = buf[i];
          var codePoint = null;
          var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      __name(utf8Slice, "utf8Slice");
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        var len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        var res = "";
        var i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      __name(decodeCodePointsArray, "decodeCodePointsArray");
      function asciiSlice(buf, start, end) {
        var ret = "";
        end = Math.min(buf.length, end);
        for (var i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      __name(asciiSlice, "asciiSlice");
      function latin1Slice(buf, start, end) {
        var ret = "";
        end = Math.min(buf.length, end);
        for (var i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      __name(latin1Slice, "latin1Slice");
      function hexSlice(buf, start, end) {
        var len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        var out = "";
        for (var i = start; i < end; ++i) {
          out += toHex(buf[i]);
        }
        return out;
      }
      __name(hexSlice, "hexSlice");
      function utf16leSlice(buf, start, end) {
        var bytes = buf.slice(start, end);
        var res = "";
        for (var i = 0; i < bytes.length; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      __name(utf16leSlice, "utf16leSlice");
      Buffer2.prototype.slice = /* @__PURE__ */ __name(function slice(start, end) {
        var len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        var newBuf;
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          newBuf = this.subarray(start, end);
          newBuf.__proto__ = Buffer2.prototype;
        } else {
          var sliceLen = end - start;
          newBuf = new Buffer2(sliceLen, void 0);
          for (var i = 0; i < sliceLen; ++i) {
            newBuf[i] = this[i + start];
          }
        }
        return newBuf;
      }, "slice");
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      __name(checkOffset, "checkOffset");
      Buffer2.prototype.readUIntLE = /* @__PURE__ */ __name(function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        var val = this[offset];
        var mul = 1;
        var i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      }, "readUIntLE");
      Buffer2.prototype.readUIntBE = /* @__PURE__ */ __name(function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        var val = this[offset + --byteLength2];
        var mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      }, "readUIntBE");
      Buffer2.prototype.readUInt8 = /* @__PURE__ */ __name(function readUInt8(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      }, "readUInt8");
      Buffer2.prototype.readUInt16LE = /* @__PURE__ */ __name(function readUInt16LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      }, "readUInt16LE");
      Buffer2.prototype.readUInt16BE = /* @__PURE__ */ __name(function readUInt16BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      }, "readUInt16BE");
      Buffer2.prototype.readUInt32LE = /* @__PURE__ */ __name(function readUInt32LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      }, "readUInt32LE");
      Buffer2.prototype.readUInt32BE = /* @__PURE__ */ __name(function readUInt32BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      }, "readUInt32BE");
      Buffer2.prototype.readIntLE = /* @__PURE__ */ __name(function readIntLE(offset, byteLength2, noAssert) {
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        var val = this[offset];
        var mul = 1;
        var i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      }, "readIntLE");
      Buffer2.prototype.readIntBE = /* @__PURE__ */ __name(function readIntBE(offset, byteLength2, noAssert) {
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        var i = byteLength2;
        var mul = 1;
        var val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      }, "readIntBE");
      Buffer2.prototype.readInt8 = /* @__PURE__ */ __name(function readInt8(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      }, "readInt8");
      Buffer2.prototype.readInt16LE = /* @__PURE__ */ __name(function readInt16LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        var val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      }, "readInt16LE");
      Buffer2.prototype.readInt16BE = /* @__PURE__ */ __name(function readInt16BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        var val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      }, "readInt16BE");
      Buffer2.prototype.readInt32LE = /* @__PURE__ */ __name(function readInt32LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      }, "readInt32LE");
      Buffer2.prototype.readInt32BE = /* @__PURE__ */ __name(function readInt32BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      }, "readInt32BE");
      Buffer2.prototype.readFloatLE = /* @__PURE__ */ __name(function readFloatLE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return read(this, offset, true, 23, 4);
      }, "readFloatLE");
      Buffer2.prototype.readFloatBE = /* @__PURE__ */ __name(function readFloatBE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return read(this, offset, false, 23, 4);
      }, "readFloatBE");
      Buffer2.prototype.readDoubleLE = /* @__PURE__ */ __name(function readDoubleLE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return read(this, offset, true, 52, 8);
      }, "readDoubleLE");
      Buffer2.prototype.readDoubleBE = /* @__PURE__ */ __name(function readDoubleBE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return read(this, offset, false, 52, 8);
      }, "readDoubleBE");
      function checkInt(buf, value, offset, ext, max, min) {
        if (!internalIsBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      __name(checkInt, "checkInt");
      Buffer2.prototype.writeUIntLE = /* @__PURE__ */ __name(function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        var mul = 1;
        var i = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      }, "writeUIntLE");
      Buffer2.prototype.writeUIntBE = /* @__PURE__ */ __name(function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        var i = byteLength2 - 1;
        var mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      }, "writeUIntBE");
      Buffer2.prototype.writeUInt8 = /* @__PURE__ */ __name(function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        if (!Buffer2.TYPED_ARRAY_SUPPORT)
          value = Math.floor(value);
        this[offset] = value & 255;
        return offset + 1;
      }, "writeUInt8");
      function objectWriteUInt16(buf, value, offset, littleEndian) {
        if (value < 0)
          value = 65535 + value + 1;
        for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
          buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
        }
      }
      __name(objectWriteUInt16, "objectWriteUInt16");
      Buffer2.prototype.writeUInt16LE = /* @__PURE__ */ __name(function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
        } else {
          objectWriteUInt16(this, value, offset, true);
        }
        return offset + 2;
      }, "writeUInt16LE");
      Buffer2.prototype.writeUInt16BE = /* @__PURE__ */ __name(function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 8;
          this[offset + 1] = value & 255;
        } else {
          objectWriteUInt16(this, value, offset, false);
        }
        return offset + 2;
      }, "writeUInt16BE");
      function objectWriteUInt32(buf, value, offset, littleEndian) {
        if (value < 0)
          value = 4294967295 + value + 1;
        for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
          buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
        }
      }
      __name(objectWriteUInt32, "objectWriteUInt32");
      Buffer2.prototype.writeUInt32LE = /* @__PURE__ */ __name(function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset + 3] = value >>> 24;
          this[offset + 2] = value >>> 16;
          this[offset + 1] = value >>> 8;
          this[offset] = value & 255;
        } else {
          objectWriteUInt32(this, value, offset, true);
        }
        return offset + 4;
      }, "writeUInt32LE");
      Buffer2.prototype.writeUInt32BE = /* @__PURE__ */ __name(function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 24;
          this[offset + 1] = value >>> 16;
          this[offset + 2] = value >>> 8;
          this[offset + 3] = value & 255;
        } else {
          objectWriteUInt32(this, value, offset, false);
        }
        return offset + 4;
      }, "writeUInt32BE");
      Buffer2.prototype.writeIntLE = /* @__PURE__ */ __name(function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        var i = 0;
        var mul = 1;
        var sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      }, "writeIntLE");
      Buffer2.prototype.writeIntBE = /* @__PURE__ */ __name(function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        var i = byteLength2 - 1;
        var mul = 1;
        var sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      }, "writeIntBE");
      Buffer2.prototype.writeInt8 = /* @__PURE__ */ __name(function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (!Buffer2.TYPED_ARRAY_SUPPORT)
          value = Math.floor(value);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      }, "writeInt8");
      Buffer2.prototype.writeInt16LE = /* @__PURE__ */ __name(function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
        } else {
          objectWriteUInt16(this, value, offset, true);
        }
        return offset + 2;
      }, "writeInt16LE");
      Buffer2.prototype.writeInt16BE = /* @__PURE__ */ __name(function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 8;
          this[offset + 1] = value & 255;
        } else {
          objectWriteUInt16(this, value, offset, false);
        }
        return offset + 2;
      }, "writeInt16BE");
      Buffer2.prototype.writeInt32LE = /* @__PURE__ */ __name(function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
          this[offset + 2] = value >>> 16;
          this[offset + 3] = value >>> 24;
        } else {
          objectWriteUInt32(this, value, offset, true);
        }
        return offset + 4;
      }, "writeInt32LE");
      Buffer2.prototype.writeInt32BE = /* @__PURE__ */ __name(function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 24;
          this[offset + 1] = value >>> 16;
          this[offset + 2] = value >>> 8;
          this[offset + 3] = value & 255;
        } else {
          objectWriteUInt32(this, value, offset, false);
        }
        return offset + 4;
      }, "writeInt32BE");
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      __name(checkIEEE754, "checkIEEE754");
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4);
        }
        write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      __name(writeFloat, "writeFloat");
      Buffer2.prototype.writeFloatLE = /* @__PURE__ */ __name(function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      }, "writeFloatLE");
      Buffer2.prototype.writeFloatBE = /* @__PURE__ */ __name(function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      }, "writeFloatBE");
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8);
        }
        write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      __name(writeDouble, "writeDouble");
      Buffer2.prototype.writeDoubleLE = /* @__PURE__ */ __name(function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      }, "writeDoubleLE");
      Buffer2.prototype.writeDoubleBE = /* @__PURE__ */ __name(function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      }, "writeDoubleBE");
      Buffer2.prototype.copy = /* @__PURE__ */ __name(function copy(target, targetStart, start, end) {
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("sourceStart out of bounds");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        var len = end - start;
        var i;
        if (this === target && start < targetStart && targetStart < end) {
          for (i = len - 1; i >= 0; --i) {
            target[i + targetStart] = this[i + start];
          }
        } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
          for (i = 0; i < len; ++i) {
            target[i + targetStart] = this[i + start];
          }
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start, start + len),
            targetStart
          );
        }
        return len;
      }, "copy");
      Buffer2.prototype.fill = /* @__PURE__ */ __name(function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (code < 256) {
              val = code;
            }
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
        } else if (typeof val === "number") {
          val = val & 255;
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        var i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString());
          var len = bytes.length;
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      }, "fill");
      var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = stringtrim(str).replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      __name(base64clean, "base64clean");
      function stringtrim(str) {
        if (str.trim)
          return str.trim();
        return str.replace(/^\s+|\s+$/g, "");
      }
      __name(stringtrim, "stringtrim");
      function toHex(n) {
        if (n < 16)
          return "0" + n.toString(16);
        return n.toString(16);
      }
      __name(toHex, "toHex");
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        var codePoint;
        var length = string.length;
        var leadSurrogate = null;
        var bytes = [];
        for (var i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      __name(utf8ToBytes, "utf8ToBytes");
      function asciiToBytes(str) {
        var byteArray = [];
        for (var i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      __name(asciiToBytes, "asciiToBytes");
      function utf16leToBytes(str, units) {
        var c, hi, lo;
        var byteArray = [];
        for (var i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0)
            break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      __name(utf16leToBytes, "utf16leToBytes");
      function base64ToBytes(str) {
        return toByteArray(base64clean(str));
      }
      __name(base64ToBytes, "base64ToBytes");
      function blitBuffer(src, dst, offset, length) {
        for (var i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length)
            break;
          dst[i + offset] = src[i];
        }
        return i;
      }
      __name(blitBuffer, "blitBuffer");
      function isnan(val) {
        return val !== val;
      }
      __name(isnan, "isnan");
      function isBuffer(obj) {
        return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
      }
      __name(isBuffer, "isBuffer");
      function isFastBuffer(obj) {
        return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
      }
      __name(isFastBuffer, "isFastBuffer");
      function isSlowBuffer(obj) {
        return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
      }
      __name(isSlowBuffer, "isSlowBuffer");
      function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
      }
      __name(defaultSetTimout, "defaultSetTimout");
      function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
      }
      __name(defaultClearTimeout, "defaultClearTimeout");
      var cachedSetTimeout = defaultSetTimout;
      var cachedClearTimeout = defaultClearTimeout;
      if (typeof global$1.setTimeout === "function") {
        cachedSetTimeout = setTimeout;
      }
      if (typeof global$1.clearTimeout === "function") {
        cachedClearTimeout = clearTimeout;
      }
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          return setTimeout(fun, 0);
        }
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e2) {
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      __name(runTimeout, "runTimeout");
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          return clearTimeout(marker);
        }
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            return cachedClearTimeout.call(null, marker);
          } catch (e2) {
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      __name(runClearTimeout, "runClearTimeout");
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }
      __name(cleanUpNextTick, "cleanUpNextTick");
      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }
      __name(drainQueue, "drainQueue");
      function nextTick(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      }
      __name(nextTick, "nextTick");
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      __name(Item, "Item");
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      var performance2 = global$1.performance || {};
      var performanceNow = performance2.now || performance2.mozNow || performance2.msNow || performance2.oNow || performance2.webkitNow || function() {
        return new Date().getTime();
      };
      var inherits;
      if (typeof Object.create === "function") {
        inherits = /* @__PURE__ */ __name(function inherits2(ctor, superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }, "inherits");
      } else {
        inherits = /* @__PURE__ */ __name(function inherits2(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = /* @__PURE__ */ __name(function() {
          }, "TempCtor");
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }, "inherits");
      }
      var inherits$1 = inherits;
      var formatRegExp = /%[sdj%]/g;
      function format2(f) {
        if (!isString(f)) {
          var objects = [];
          for (var i = 0; i < arguments.length; i++) {
            objects.push(inspect(arguments[i]));
          }
          return objects.join(" ");
        }
        var i = 1;
        var args = arguments;
        var len = args.length;
        var str = String(f).replace(formatRegExp, function(x2) {
          if (x2 === "%%")
            return "%";
          if (i >= len)
            return x2;
          switch (x2) {
            case "%s":
              return String(args[i++]);
            case "%d":
              return Number(args[i++]);
            case "%j":
              try {
                return JSON.stringify(args[i++]);
              } catch (_) {
                return "[Circular]";
              }
            default:
              return x2;
          }
        });
        for (var x = args[i]; i < len; x = args[++i]) {
          if (isNull(x) || !isObject(x)) {
            str += " " + x;
          } else {
            str += " " + inspect(x);
          }
        }
        return str;
      }
      __name(format2, "format");
      function deprecate(fn, msg) {
        if (isUndefined(global$1.process)) {
          return function() {
            return deprecate(fn, msg).apply(this, arguments);
          };
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            {
              console.error(msg);
            }
            warned = true;
          }
          return fn.apply(this, arguments);
        }
        __name(deprecated, "deprecated");
        return deprecated;
      }
      __name(deprecate, "deprecate");
      var debugs = {};
      var debugEnviron;
      function debuglog(set) {
        if (isUndefined(debugEnviron))
          debugEnviron = "";
        set = set.toUpperCase();
        if (!debugs[set]) {
          if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
            var pid = 0;
            debugs[set] = function() {
              var msg = format2.apply(null, arguments);
              console.error("%s %d: %s", set, pid, msg);
            };
          } else {
            debugs[set] = function() {
            };
          }
        }
        return debugs[set];
      }
      __name(debuglog, "debuglog");
      function inspect(obj, opts) {
        var ctx = {
          seen: [],
          stylize: stylizeNoColor
        };
        if (arguments.length >= 3)
          ctx.depth = arguments[2];
        if (arguments.length >= 4)
          ctx.colors = arguments[3];
        if (isBoolean(opts)) {
          ctx.showHidden = opts;
        } else if (opts) {
          _extend(ctx, opts);
        }
        if (isUndefined(ctx.showHidden))
          ctx.showHidden = false;
        if (isUndefined(ctx.depth))
          ctx.depth = 2;
        if (isUndefined(ctx.colors))
          ctx.colors = false;
        if (isUndefined(ctx.customInspect))
          ctx.customInspect = true;
        if (ctx.colors)
          ctx.stylize = stylizeWithColor;
        return formatValue(ctx, obj, ctx.depth);
      }
      __name(inspect, "inspect");
      inspect.colors = {
        "bold": [1, 22],
        "italic": [3, 23],
        "underline": [4, 24],
        "inverse": [7, 27],
        "white": [37, 39],
        "grey": [90, 39],
        "black": [30, 39],
        "blue": [34, 39],
        "cyan": [36, 39],
        "green": [32, 39],
        "magenta": [35, 39],
        "red": [31, 39],
        "yellow": [33, 39]
      };
      inspect.styles = {
        "special": "cyan",
        "number": "yellow",
        "boolean": "yellow",
        "undefined": "grey",
        "null": "bold",
        "string": "green",
        "date": "magenta",
        "regexp": "red"
      };
      function stylizeWithColor(str, styleType) {
        var style = inspect.styles[styleType];
        if (style) {
          return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
        } else {
          return str;
        }
      }
      __name(stylizeWithColor, "stylizeWithColor");
      function stylizeNoColor(str, styleType) {
        return str;
      }
      __name(stylizeNoColor, "stylizeNoColor");
      function arrayToHash(array) {
        var hash = {};
        array.forEach(function(val, idx) {
          hash[val] = true;
        });
        return hash;
      }
      __name(arrayToHash, "arrayToHash");
      function formatValue(ctx, value, recurseTimes) {
        if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== inspect && !(value.constructor && value.constructor.prototype === value)) {
          var ret = value.inspect(recurseTimes, ctx);
          if (!isString(ret)) {
            ret = formatValue(ctx, ret, recurseTimes);
          }
          return ret;
        }
        var primitive = formatPrimitive(ctx, value);
        if (primitive) {
          return primitive;
        }
        var keys2 = Object.keys(value);
        var visibleKeys = arrayToHash(keys2);
        if (ctx.showHidden) {
          keys2 = Object.getOwnPropertyNames(value);
        }
        if (isError(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
          return formatError(value);
        }
        if (keys2.length === 0) {
          if (isFunction(value)) {
            var name = value.name ? ": " + value.name : "";
            return ctx.stylize("[Function" + name + "]", "special");
          }
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          }
          if (isDate(value)) {
            return ctx.stylize(Date.prototype.toString.call(value), "date");
          }
          if (isError(value)) {
            return formatError(value);
          }
        }
        var base = "", array = false, braces = ["{", "}"];
        if (isArray$1(value)) {
          array = true;
          braces = ["[", "]"];
        }
        if (isFunction(value)) {
          var n = value.name ? ": " + value.name : "";
          base = " [Function" + n + "]";
        }
        if (isRegExp(value)) {
          base = " " + RegExp.prototype.toString.call(value);
        }
        if (isDate(value)) {
          base = " " + Date.prototype.toUTCString.call(value);
        }
        if (isError(value)) {
          base = " " + formatError(value);
        }
        if (keys2.length === 0 && (!array || value.length == 0)) {
          return braces[0] + base + braces[1];
        }
        if (recurseTimes < 0) {
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          } else {
            return ctx.stylize("[Object]", "special");
          }
        }
        ctx.seen.push(value);
        var output;
        if (array) {
          output = formatArray(ctx, value, recurseTimes, visibleKeys, keys2);
        } else {
          output = keys2.map(function(key) {
            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
          });
        }
        ctx.seen.pop();
        return reduceToSingleString(output, base, braces);
      }
      __name(formatValue, "formatValue");
      function formatPrimitive(ctx, value) {
        if (isUndefined(value))
          return ctx.stylize("undefined", "undefined");
        if (isString(value)) {
          var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return ctx.stylize(simple, "string");
        }
        if (isNumber(value))
          return ctx.stylize("" + value, "number");
        if (isBoolean(value))
          return ctx.stylize("" + value, "boolean");
        if (isNull(value))
          return ctx.stylize("null", "null");
      }
      __name(formatPrimitive, "formatPrimitive");
      function formatError(value) {
        return "[" + Error.prototype.toString.call(value) + "]";
      }
      __name(formatError, "formatError");
      function formatArray(ctx, value, recurseTimes, visibleKeys, keys2) {
        var output = [];
        for (var i = 0, l = value.length; i < l; ++i) {
          if (hasOwnProperty(value, String(i))) {
            output.push(formatProperty(
              ctx,
              value,
              recurseTimes,
              visibleKeys,
              String(i),
              true
            ));
          } else {
            output.push("");
          }
        }
        keys2.forEach(function(key) {
          if (!key.match(/^\d+$/)) {
            output.push(formatProperty(
              ctx,
              value,
              recurseTimes,
              visibleKeys,
              key,
              true
            ));
          }
        });
        return output;
      }
      __name(formatArray, "formatArray");
      function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
        var name, str, desc;
        desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
        if (desc.get) {
          if (desc.set) {
            str = ctx.stylize("[Getter/Setter]", "special");
          } else {
            str = ctx.stylize("[Getter]", "special");
          }
        } else {
          if (desc.set) {
            str = ctx.stylize("[Setter]", "special");
          }
        }
        if (!hasOwnProperty(visibleKeys, key)) {
          name = "[" + key + "]";
        }
        if (!str) {
          if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) {
              str = formatValue(ctx, desc.value, null);
            } else {
              str = formatValue(ctx, desc.value, recurseTimes - 1);
            }
            if (str.indexOf("\n") > -1) {
              if (array) {
                str = str.split("\n").map(function(line) {
                  return "  " + line;
                }).join("\n").substr(2);
              } else {
                str = "\n" + str.split("\n").map(function(line) {
                  return "   " + line;
                }).join("\n");
              }
            }
          } else {
            str = ctx.stylize("[Circular]", "special");
          }
        }
        if (isUndefined(name)) {
          if (array && key.match(/^\d+$/)) {
            return str;
          }
          name = JSON.stringify("" + key);
          if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.substr(1, name.length - 2);
            name = ctx.stylize(name, "name");
          } else {
            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name = ctx.stylize(name, "string");
          }
        }
        return name + ": " + str;
      }
      __name(formatProperty, "formatProperty");
      function reduceToSingleString(output, base, braces) {
        var length = output.reduce(function(prev, cur) {
          if (cur.indexOf("\n") >= 0)
            ;
          return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0);
        if (length > 60) {
          return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
        }
        return braces[0] + base + " " + output.join(", ") + " " + braces[1];
      }
      __name(reduceToSingleString, "reduceToSingleString");
      function isArray$1(ar) {
        return Array.isArray(ar);
      }
      __name(isArray$1, "isArray$1");
      function isBoolean(arg) {
        return typeof arg === "boolean";
      }
      __name(isBoolean, "isBoolean");
      function isNull(arg) {
        return arg === null;
      }
      __name(isNull, "isNull");
      function isNumber(arg) {
        return typeof arg === "number";
      }
      __name(isNumber, "isNumber");
      function isString(arg) {
        return typeof arg === "string";
      }
      __name(isString, "isString");
      function isUndefined(arg) {
        return arg === void 0;
      }
      __name(isUndefined, "isUndefined");
      function isRegExp(re) {
        return isObject(re) && objectToString(re) === "[object RegExp]";
      }
      __name(isRegExp, "isRegExp");
      function isObject(arg) {
        return typeof arg === "object" && arg !== null;
      }
      __name(isObject, "isObject");
      function isDate(d) {
        return isObject(d) && objectToString(d) === "[object Date]";
      }
      __name(isDate, "isDate");
      function isError(e) {
        return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
      }
      __name(isError, "isError");
      function isFunction(arg) {
        return typeof arg === "function";
      }
      __name(isFunction, "isFunction");
      function objectToString(o) {
        return Object.prototype.toString.call(o);
      }
      __name(objectToString, "objectToString");
      function _extend(origin, add) {
        if (!add || !isObject(add))
          return origin;
        var keys2 = Object.keys(add);
        var i = keys2.length;
        while (i--) {
          origin[keys2[i]] = add[keys2[i]];
        }
        return origin;
      }
      __name(_extend, "_extend");
      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      __name(hasOwnProperty, "hasOwnProperty");
      function BufferList() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      __name(BufferList, "BufferList");
      BufferList.prototype.push = function(v2) {
        var entry = { data: v2, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function(v2) {
        var entry = { data: v2, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        if (this.length === 1)
          return this.head.data;
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          p.data.copy(ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      var isBufferEncoding = Buffer2.isEncoding || function(encoding) {
        switch (encoding && encoding.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;
          default:
            return false;
        }
      };
      function assertEncoding(encoding) {
        if (encoding && !isBufferEncoding(encoding)) {
          throw new Error("Unknown encoding: " + encoding);
        }
      }
      __name(assertEncoding, "assertEncoding");
      function StringDecoder(encoding) {
        this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
        assertEncoding(encoding);
        switch (this.encoding) {
          case "utf8":
            this.surrogateSize = 3;
            break;
          case "ucs2":
          case "utf16le":
            this.surrogateSize = 2;
            this.detectIncompleteChar = utf16DetectIncompleteChar;
            break;
          case "base64":
            this.surrogateSize = 3;
            this.detectIncompleteChar = base64DetectIncompleteChar;
            break;
          default:
            this.write = passThroughWrite;
            return;
        }
        this.charBuffer = new Buffer2(6);
        this.charReceived = 0;
        this.charLength = 0;
      }
      __name(StringDecoder, "StringDecoder");
      StringDecoder.prototype.write = function(buffer) {
        var charStr = "";
        while (this.charLength) {
          var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
          buffer.copy(this.charBuffer, this.charReceived, 0, available);
          this.charReceived += available;
          if (this.charReceived < this.charLength) {
            return "";
          }
          buffer = buffer.slice(available, buffer.length);
          charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
          var charCode = charStr.charCodeAt(charStr.length - 1);
          if (charCode >= 55296 && charCode <= 56319) {
            this.charLength += this.surrogateSize;
            charStr = "";
            continue;
          }
          this.charReceived = this.charLength = 0;
          if (buffer.length === 0) {
            return charStr;
          }
          break;
        }
        this.detectIncompleteChar(buffer);
        var end = buffer.length;
        if (this.charLength) {
          buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
          end -= this.charReceived;
        }
        charStr += buffer.toString(this.encoding, 0, end);
        var end = charStr.length - 1;
        var charCode = charStr.charCodeAt(end);
        if (charCode >= 55296 && charCode <= 56319) {
          var size = this.surrogateSize;
          this.charLength += size;
          this.charReceived += size;
          this.charBuffer.copy(this.charBuffer, size, 0, size);
          buffer.copy(this.charBuffer, 0, 0, size);
          return charStr.substring(0, end);
        }
        return charStr;
      };
      StringDecoder.prototype.detectIncompleteChar = function(buffer) {
        var i = buffer.length >= 3 ? 3 : buffer.length;
        for (; i > 0; i--) {
          var c = buffer[buffer.length - i];
          if (i == 1 && c >> 5 == 6) {
            this.charLength = 2;
            break;
          }
          if (i <= 2 && c >> 4 == 14) {
            this.charLength = 3;
            break;
          }
          if (i <= 3 && c >> 3 == 30) {
            this.charLength = 4;
            break;
          }
        }
        this.charReceived = i;
      };
      StringDecoder.prototype.end = function(buffer) {
        var res = "";
        if (buffer && buffer.length)
          res = this.write(buffer);
        if (this.charReceived) {
          var cr = this.charReceived;
          var buf = this.charBuffer;
          var enc = this.encoding;
          res += buf.slice(0, cr).toString(enc);
        }
        return res;
      };
      function passThroughWrite(buffer) {
        return buffer.toString(this.encoding);
      }
      __name(passThroughWrite, "passThroughWrite");
      function utf16DetectIncompleteChar(buffer) {
        this.charReceived = buffer.length % 2;
        this.charLength = this.charReceived ? 2 : 0;
      }
      __name(utf16DetectIncompleteChar, "utf16DetectIncompleteChar");
      function base64DetectIncompleteChar(buffer) {
        this.charReceived = buffer.length % 3;
        this.charLength = this.charReceived ? 3 : 0;
      }
      __name(base64DetectIncompleteChar, "base64DetectIncompleteChar");
      Readable.ReadableState = ReadableState;
      var debug = debuglog("stream");
      inherits$1(Readable, EventEmitter);
      function prependListener(emitter, event, fn) {
        if (typeof emitter.prependListener === "function") {
          return emitter.prependListener(event, fn);
        } else {
          if (!emitter._events || !emitter._events[event])
            emitter.on(event, fn);
          else if (Array.isArray(emitter._events[event]))
            emitter._events[event].unshift(fn);
          else
            emitter._events[event] = [fn, emitter._events[event]];
        }
      }
      __name(prependListener, "prependListener");
      function listenerCount$1(emitter, type2) {
        return emitter.listeners(type2).length;
      }
      __name(listenerCount$1, "listenerCount$1");
      function ReadableState(options, stream) {
        options = options || {};
        this.objectMode = !!options.objectMode;
        if (stream instanceof Duplex)
          this.objectMode = this.objectMode || !!options.readableObjectMode;
        var hwm = options.highWaterMark;
        var defaultHwm = this.objectMode ? 16 : 16 * 1024;
        this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
        this.highWaterMark = ~~this.highWaterMark;
        this.buffer = new BufferList();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.ranOut = false;
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          this.decoder = new StringDecoder(options.encoding);
          this.encoding = options.encoding;
        }
      }
      __name(ReadableState, "ReadableState");
      function Readable(options) {
        if (!(this instanceof Readable))
          return new Readable(options);
        this._readableState = new ReadableState(options, this);
        this.readable = true;
        if (options && typeof options.read === "function")
          this._read = options.read;
        EventEmitter.call(this);
      }
      __name(Readable, "Readable");
      Readable.prototype.push = function(chunk, encoding) {
        var state = this._readableState;
        if (!state.objectMode && typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
        }
        return readableAddChunk(this, state, chunk, encoding, false);
      };
      Readable.prototype.unshift = function(chunk) {
        var state = this._readableState;
        return readableAddChunk(this, state, chunk, "", true);
      };
      Readable.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      function readableAddChunk(stream, state, chunk, encoding, addToFront) {
        var er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit("error", er);
        } else if (chunk === null) {
          state.reading = false;
          onEofChunk(stream, state);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (state.ended && !addToFront) {
            var e = new Error("stream.push() after EOF");
            stream.emit("error", e);
          } else if (state.endEmitted && addToFront) {
            var _e = new Error("stream.unshift() after end event");
            stream.emit("error", _e);
          } else {
            var skipAdd;
            if (state.decoder && !addToFront && !encoding) {
              chunk = state.decoder.write(chunk);
              skipAdd = !state.objectMode && chunk.length === 0;
            }
            if (!addToFront)
              state.reading = false;
            if (!skipAdd) {
              if (state.flowing && state.length === 0 && !state.sync) {
                stream.emit("data", chunk);
                stream.read(0);
              } else {
                state.length += state.objectMode ? 1 : chunk.length;
                if (addToFront)
                  state.buffer.unshift(chunk);
                else
                  state.buffer.push(chunk);
                if (state.needReadable)
                  emitReadable(stream);
              }
            }
            maybeReadMore(stream, state);
          }
        } else if (!addToFront) {
          state.reading = false;
        }
        return needMoreData(state);
      }
      __name(readableAddChunk, "readableAddChunk");
      function needMoreData(state) {
        return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
      }
      __name(needMoreData, "needMoreData");
      Readable.prototype.setEncoding = function(enc) {
        this._readableState.decoder = new StringDecoder(enc);
        this._readableState.encoding = enc;
        return this;
      };
      var MAX_HWM = 8388608;
      function computeNewHighWaterMark(n) {
        if (n >= MAX_HWM) {
          n = MAX_HWM;
        } else {
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }
      __name(computeNewHighWaterMark, "computeNewHighWaterMark");
      function howMuchToRead(n, state) {
        if (n <= 0 || state.length === 0 && state.ended)
          return 0;
        if (state.objectMode)
          return 1;
        if (n !== n) {
          if (state.flowing && state.length)
            return state.buffer.head.data.length;
          else
            return state.length;
        }
        if (n > state.highWaterMark)
          state.highWaterMark = computeNewHighWaterMark(n);
        if (n <= state.length)
          return n;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      __name(howMuchToRead, "howMuchToRead");
      Readable.prototype.read = function(n) {
        debug("read", n);
        n = parseInt(n, 10);
        var state = this._readableState;
        var nOrig = n;
        if (n !== 0)
          state.emittedReadable = false;
        if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
          debug("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended)
            endReadable(this);
          else
            emitReadable(this);
          return null;
        }
        n = howMuchToRead(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0)
            endReadable(this);
          return null;
        }
        var doRead = state.needReadable;
        debug("need readable", doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug("reading or ended", doRead);
        } else if (doRead) {
          debug("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0)
            state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading)
            n = howMuchToRead(nOrig, state);
        }
        var ret;
        if (n > 0)
          ret = fromList(n, state);
        else
          ret = null;
        if (ret === null) {
          state.needReadable = true;
          n = 0;
        } else {
          state.length -= n;
        }
        if (state.length === 0) {
          if (!state.ended)
            state.needReadable = true;
          if (nOrig !== n && state.ended)
            endReadable(this);
        }
        if (ret !== null)
          this.emit("data", ret);
        return ret;
      };
      function chunkInvalid(state, chunk) {
        var er = null;
        if (!isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state.objectMode) {
          er = new TypeError("Invalid non-string/buffer chunk");
        }
        return er;
      }
      __name(chunkInvalid, "chunkInvalid");
      function onEofChunk(stream, state) {
        if (state.ended)
          return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        emitReadable(stream);
      }
      __name(onEofChunk, "onEofChunk");
      function emitReadable(stream) {
        var state = stream._readableState;
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug("emitReadable", state.flowing);
          state.emittedReadable = true;
          if (state.sync)
            nextTick(emitReadable_, stream);
          else
            emitReadable_(stream);
        }
      }
      __name(emitReadable, "emitReadable");
      function emitReadable_(stream) {
        debug("emit readable");
        stream.emit("readable");
        flow(stream);
      }
      __name(emitReadable_, "emitReadable_");
      function maybeReadMore(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          nextTick(maybeReadMore_, stream, state);
        }
      }
      __name(maybeReadMore, "maybeReadMore");
      function maybeReadMore_(stream, state) {
        var len = state.length;
        while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
          debug("maybeReadMore read 0");
          stream.read(0);
          if (len === state.length)
            break;
          else
            len = state.length;
        }
        state.readingMore = false;
      }
      __name(maybeReadMore_, "maybeReadMore_");
      Readable.prototype._read = function(n) {
        this.emit("error", new Error("not implemented"));
      };
      Readable.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = !pipeOpts || pipeOpts.end !== false;
        var endFn = doEnd ? onend2 : cleanup;
        if (state.endEmitted)
          nextTick(endFn);
        else
          src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable) {
          debug("onunpipe");
          if (readable === src) {
            cleanup();
          }
        }
        __name(onunpipe, "onunpipe");
        function onend2() {
          debug("onend");
          dest.end();
        }
        __name(onend2, "onend");
        var ondrain = pipeOnDrain(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend2);
          src.removeListener("end", cleanup);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        __name(cleanup, "cleanup");
        var increasedAwaitDrain = false;
        src.on("data", ondata);
        function ondata(chunk) {
          debug("ondata");
          increasedAwaitDrain = false;
          var ret = dest.write(chunk);
          if (false === ret && !increasedAwaitDrain) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
              debug("false write response, pause", src._readableState.awaitDrain);
              src._readableState.awaitDrain++;
              increasedAwaitDrain = true;
            }
            src.pause();
          }
        }
        __name(ondata, "ondata");
        function onerror(er) {
          debug("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (listenerCount$1(dest, "error") === 0)
            dest.emit("error", er);
        }
        __name(onerror, "onerror");
        prependListener(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        __name(onclose, "onclose");
        dest.once("close", onclose);
        function onfinish() {
          debug("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        __name(onfinish, "onfinish");
        dest.once("finish", onfinish);
        function unpipe() {
          debug("unpipe");
          src.unpipe(dest);
        }
        __name(unpipe, "unpipe");
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain(src) {
        return function() {
          var state = src._readableState;
          debug("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain)
            state.awaitDrain--;
          if (state.awaitDrain === 0 && src.listeners("data").length) {
            state.flowing = true;
            flow(src);
          }
        };
      }
      __name(pipeOnDrain, "pipeOnDrain");
      Readable.prototype.unpipe = function(dest) {
        var state = this._readableState;
        if (state.pipesCount === 0)
          return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes)
            return this;
          if (!dest)
            dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest)
            dest.emit("unpipe", this);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var _i = 0; _i < len; _i++) {
            dests[_i].emit("unpipe", this);
          }
          return this;
        }
        var i = indexOf(state.pipes, dest);
        if (i === -1)
          return this;
        state.pipes.splice(i, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1)
          state.pipes = state.pipes[0];
        dest.emit("unpipe", this);
        return this;
      };
      Readable.prototype.on = function(ev, fn) {
        var res = EventEmitter.prototype.on.call(this, ev, fn);
        if (ev === "data") {
          if (this._readableState.flowing !== false)
            this.resume();
        } else if (ev === "readable") {
          var state = this._readableState;
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.emittedReadable = false;
            if (!state.reading) {
              nextTick(nReadingNextTick, this);
            } else if (state.length) {
              emitReadable(this);
            }
          }
        }
        return res;
      };
      Readable.prototype.addListener = Readable.prototype.on;
      function nReadingNextTick(self2) {
        debug("readable nexttick read 0");
        self2.read(0);
      }
      __name(nReadingNextTick, "nReadingNextTick");
      Readable.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug("resume");
          state.flowing = true;
          resume(this, state);
        }
        return this;
      };
      function resume(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          nextTick(resume_, stream, state);
        }
      }
      __name(resume, "resume");
      function resume_(stream, state) {
        if (!state.reading) {
          debug("resume read 0");
          stream.read(0);
        }
        state.resumeScheduled = false;
        state.awaitDrain = 0;
        stream.emit("resume");
        flow(stream);
        if (state.flowing && !state.reading)
          stream.read(0);
      }
      __name(resume_, "resume_");
      Readable.prototype.pause = function() {
        debug("call pause flowing=%j", this._readableState.flowing);
        if (false !== this._readableState.flowing) {
          debug("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        return this;
      };
      function flow(stream) {
        var state = stream._readableState;
        debug("flow", state.flowing);
        while (state.flowing && stream.read() !== null) {
        }
      }
      __name(flow, "flow");
      Readable.prototype.wrap = function(stream) {
        var state = this._readableState;
        var paused = false;
        var self2 = this;
        stream.on("end", function() {
          debug("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
              self2.push(chunk);
          }
          self2.push(null);
        });
        stream.on("data", function(chunk) {
          debug("wrapped data");
          if (state.decoder)
            chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0))
            return;
          else if (!state.objectMode && (!chunk || !chunk.length))
            return;
          var ret = self2.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i in stream) {
          if (this[i] === void 0 && typeof stream[i] === "function") {
            this[i] = function(method2) {
              return function() {
                return stream[method2].apply(stream, arguments);
              };
            }(i);
          }
        }
        var events = ["error", "close", "destroy", "pause", "resume"];
        forEach(events, function(ev) {
          stream.on(ev, self2.emit.bind(self2, ev));
        });
        self2._read = function(n) {
          debug("wrapped _read", n);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return self2;
      };
      Readable._fromList = fromList;
      function fromList(n, state) {
        if (state.length === 0)
          return null;
        var ret;
        if (state.objectMode)
          ret = state.buffer.shift();
        else if (!n || n >= state.length) {
          if (state.decoder)
            ret = state.buffer.join("");
          else if (state.buffer.length === 1)
            ret = state.buffer.head.data;
          else
            ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = fromListPartial(n, state.buffer, state.decoder);
        }
        return ret;
      }
      __name(fromList, "fromList");
      function fromListPartial(n, list, hasStrings) {
        var ret;
        if (n < list.head.data.length) {
          ret = list.head.data.slice(0, n);
          list.head.data = list.head.data.slice(n);
        } else if (n === list.head.data.length) {
          ret = list.shift();
        } else {
          ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
        }
        return ret;
      }
      __name(fromListPartial, "fromListPartial");
      function copyFromBufferString(n, list) {
        var p = list.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length)
            ret += str;
          else
            ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next)
                list.head = p.next;
              else
                list.head = list.tail = null;
            } else {
              list.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c;
        }
        list.length -= c;
        return ret;
      }
      __name(copyFromBufferString, "copyFromBufferString");
      function copyFromBuffer(n, list) {
        var ret = Buffer2.allocUnsafe(n);
        var p = list.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next)
                list.head = p.next;
              else
                list.head = list.tail = null;
            } else {
              list.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c;
        }
        list.length -= c;
        return ret;
      }
      __name(copyFromBuffer, "copyFromBuffer");
      function endReadable(stream) {
        var state = stream._readableState;
        if (state.length > 0)
          throw new Error('"endReadable()" called on non-empty stream');
        if (!state.endEmitted) {
          state.ended = true;
          nextTick(endReadableNT, state, stream);
        }
      }
      __name(endReadable, "endReadable");
      function endReadableNT(state, stream) {
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit("end");
        }
      }
      __name(endReadableNT, "endReadableNT");
      function forEach(xs, f) {
        for (var i = 0, l = xs.length; i < l; i++) {
          f(xs[i], i);
        }
      }
      __name(forEach, "forEach");
      function indexOf(xs, x) {
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x)
            return i;
        }
        return -1;
      }
      __name(indexOf, "indexOf");
      Writable.WritableState = WritableState;
      inherits$1(Writable, EventEmitter);
      function nop() {
      }
      __name(nop, "nop");
      function WriteReq(chunk, encoding, cb) {
        this.chunk = chunk;
        this.encoding = encoding;
        this.callback = cb;
        this.next = null;
      }
      __name(WriteReq, "WriteReq");
      function WritableState(options, stream) {
        Object.defineProperty(this, "buffer", {
          get: deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
        });
        options = options || {};
        this.objectMode = !!options.objectMode;
        if (stream instanceof Duplex)
          this.objectMode = this.objectMode || !!options.writableObjectMode;
        var hwm = options.highWaterMark;
        var defaultHwm = this.objectMode ? 16 : 16 * 1024;
        this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
        this.highWaterMark = ~~this.highWaterMark;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite(stream, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest(this);
      }
      __name(WritableState, "WritableState");
      WritableState.prototype.getBuffer = /* @__PURE__ */ __name(function writableStateGetBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      }, "writableStateGetBuffer");
      function Writable(options) {
        if (!(this instanceof Writable) && !(this instanceof Duplex))
          return new Writable(options);
        this._writableState = new WritableState(options, this);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function")
            this._write = options.write;
          if (typeof options.writev === "function")
            this._writev = options.writev;
        }
        EventEmitter.call(this);
      }
      __name(Writable, "Writable");
      Writable.prototype.pipe = function() {
        this.emit("error", new Error("Cannot pipe, not readable"));
      };
      function writeAfterEnd(stream, cb) {
        var er = new Error("write after end");
        stream.emit("error", er);
        nextTick(cb, er);
      }
      __name(writeAfterEnd, "writeAfterEnd");
      function validChunk(stream, state, chunk, cb) {
        var valid = true;
        var er = false;
        if (chunk === null) {
          er = new TypeError("May not write null values to stream");
        } else if (!Buffer2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new TypeError("Invalid non-string/buffer chunk");
        }
        if (er) {
          stream.emit("error", er);
          nextTick(cb, er);
          valid = false;
        }
        return valid;
      }
      __name(validChunk, "validChunk");
      Writable.prototype.write = function(chunk, encoding, cb) {
        var state = this._writableState;
        var ret = false;
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (Buffer2.isBuffer(chunk))
          encoding = "buffer";
        else if (!encoding)
          encoding = state.defaultEncoding;
        if (typeof cb !== "function")
          cb = nop;
        if (state.ended)
          writeAfterEnd(this, cb);
        else if (validChunk(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer(this, state, chunk, encoding, cb);
        }
        return ret;
      };
      Writable.prototype.cork = function() {
        var state = this._writableState;
        state.corked++;
      };
      Writable.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
            clearBuffer(this, state);
        }
      };
      Writable.prototype.setDefaultEncoding = /* @__PURE__ */ __name(function setDefaultEncoding(encoding) {
        if (typeof encoding === "string")
          encoding = encoding.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
          throw new TypeError("Unknown encoding: " + encoding);
        this._writableState.defaultEncoding = encoding;
        return this;
      }, "setDefaultEncoding");
      function decodeChunk(state, chunk, encoding) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer2.from(chunk, encoding);
        }
        return chunk;
      }
      __name(decodeChunk, "decodeChunk");
      function writeOrBuffer(stream, state, chunk, encoding, cb) {
        chunk = decodeChunk(state, chunk, encoding);
        if (Buffer2.isBuffer(chunk))
          encoding = "buffer";
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret)
          state.needDrain = true;
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite(stream, state, false, len, chunk, encoding, cb);
        }
        return ret;
      }
      __name(writeOrBuffer, "writeOrBuffer");
      function doWrite(stream, state, writev, len, chunk, encoding, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (writev)
          stream._writev(chunk, state.onwrite);
        else
          stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      __name(doWrite, "doWrite");
      function onwriteError(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync)
          nextTick(cb, er);
        else
          cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      }
      __name(onwriteError, "onwriteError");
      function onwriteStateUpdate(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      __name(onwriteStateUpdate, "onwriteStateUpdate");
      function onwrite(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        onwriteStateUpdate(state);
        if (er)
          onwriteError(stream, state, sync, er, cb);
        else {
          var finished = needFinish(state);
          if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer(stream, state);
          }
          if (sync) {
            nextTick(afterWrite, stream, state, finished, cb);
          } else {
            afterWrite(stream, state, finished, cb);
          }
        }
      }
      __name(onwrite, "onwrite");
      function afterWrite(stream, state, finished, cb) {
        if (!finished)
          onwriteDrain(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe(stream, state);
      }
      __name(afterWrite, "afterWrite");
      function onwriteDrain(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit("drain");
        }
      }
      __name(onwriteDrain, "onwriteDrain");
      function clearBuffer(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var l = state.bufferedRequestCount;
          var buffer = new Array(l);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          while (entry) {
            buffer[count] = entry;
            entry = entry.next;
            count += 1;
          }
          doWrite(stream, state, true, state.length, buffer, "", holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest(state);
          }
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            if (state.writing) {
              break;
            }
          }
          if (entry === null)
            state.lastBufferedRequest = null;
        }
        state.bufferedRequestCount = 0;
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }
      __name(clearBuffer, "clearBuffer");
      Writable.prototype._write = function(chunk, encoding, cb) {
        cb(new Error("not implemented"));
      };
      Writable.prototype._writev = null;
      Writable.prototype.end = function(chunk, encoding, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding = null;
        } else if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (chunk !== null && chunk !== void 0)
          this.write(chunk, encoding);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending && !state.finished)
          endWritable(this, state, cb);
      };
      function needFinish(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      __name(needFinish, "needFinish");
      function prefinish(stream, state) {
        if (!state.prefinished) {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
      __name(prefinish, "prefinish");
      function finishMaybe(stream, state) {
        var need = needFinish(state);
        if (need) {
          if (state.pendingcb === 0) {
            prefinish(stream, state);
            state.finished = true;
            stream.emit("finish");
          } else {
            prefinish(stream, state);
          }
        }
        return need;
      }
      __name(finishMaybe, "finishMaybe");
      function endWritable(stream, state, cb) {
        state.ending = true;
        finishMaybe(stream, state);
        if (cb) {
          if (state.finished)
            nextTick(cb);
          else
            stream.once("finish", cb);
        }
        state.ended = true;
        stream.writable = false;
      }
      __name(endWritable, "endWritable");
      function CorkedRequest(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function(err) {
          var entry = _this.entry;
          _this.entry = null;
          while (entry) {
            var cb = entry.callback;
            state.pendingcb--;
            cb(err);
            entry = entry.next;
          }
          if (state.corkedRequestsFree) {
            state.corkedRequestsFree.next = _this;
          } else {
            state.corkedRequestsFree = _this;
          }
        };
      }
      __name(CorkedRequest, "CorkedRequest");
      inherits$1(Duplex, Readable);
      var keys = Object.keys(Writable.prototype);
      for (var v = 0; v < keys.length; v++) {
        var method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
      function Duplex(options) {
        if (!(this instanceof Duplex))
          return new Duplex(options);
        Readable.call(this, options);
        Writable.call(this, options);
        if (options && options.readable === false)
          this.readable = false;
        if (options && options.writable === false)
          this.writable = false;
        this.allowHalfOpen = true;
        if (options && options.allowHalfOpen === false)
          this.allowHalfOpen = false;
        this.once("end", onend);
      }
      __name(Duplex, "Duplex");
      function onend() {
        if (this.allowHalfOpen || this._writableState.ended)
          return;
        nextTick(onEndNT, this);
      }
      __name(onend, "onend");
      function onEndNT(self2) {
        self2.end();
      }
      __name(onEndNT, "onEndNT");
      inherits$1(Transform, Duplex);
      function TransformState(stream) {
        this.afterTransform = function(er, data) {
          return afterTransform(stream, er, data);
        };
        this.needTransform = false;
        this.transforming = false;
        this.writecb = null;
        this.writechunk = null;
        this.writeencoding = null;
      }
      __name(TransformState, "TransformState");
      function afterTransform(stream, er, data) {
        var ts = stream._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (!cb)
          return stream.emit("error", new Error("no writecb in Transform class"));
        ts.writechunk = null;
        ts.writecb = null;
        if (data !== null && data !== void 0)
          stream.push(data);
        cb(er);
        var rs = stream._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          stream._read(rs.highWaterMark);
        }
      }
      __name(afterTransform, "afterTransform");
      function Transform(options) {
        if (!(this instanceof Transform))
          return new Transform(options);
        Duplex.call(this, options);
        this._transformState = new TransformState(this);
        var stream = this;
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.once("prefinish", function() {
          if (typeof this._flush === "function")
            this._flush(function(er) {
              done(stream, er);
            });
          else
            done(stream);
        });
      }
      __name(Transform, "Transform");
      Transform.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding);
      };
      Transform.prototype._transform = function(chunk, encoding, cb) {
        throw new Error("Not implemented");
      };
      Transform.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      function done(stream, er) {
        if (er)
          return stream.emit("error", er);
        var ws = stream._writableState;
        var ts = stream._transformState;
        if (ws.length)
          throw new Error("Calling transform done when ws.length != 0");
        if (ts.transforming)
          throw new Error("Calling transform done when still transforming");
        return stream.push(null);
      }
      __name(done, "done");
      inherits$1(PassThrough, Transform);
      function PassThrough(options) {
        if (!(this instanceof PassThrough))
          return new PassThrough(options);
        Transform.call(this, options);
      }
      __name(PassThrough, "PassThrough");
      PassThrough.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
      inherits$1(Stream, EventEmitter);
      Stream.Readable = Readable;
      Stream.Writable = Writable;
      Stream.Duplex = Duplex;
      Stream.Transform = Transform;
      Stream.PassThrough = PassThrough;
      Stream.Stream = Stream;
      function Stream() {
        EventEmitter.call(this);
      }
      __name(Stream, "Stream");
      Stream.prototype.pipe = function(dest, options) {
        var source = this;
        function ondata(chunk) {
          if (dest.writable) {
            if (false === dest.write(chunk) && source.pause) {
              source.pause();
            }
          }
        }
        __name(ondata, "ondata");
        source.on("data", ondata);
        function ondrain() {
          if (source.readable && source.resume) {
            source.resume();
          }
        }
        __name(ondrain, "ondrain");
        dest.on("drain", ondrain);
        if (!dest._isStdio && (!options || options.end !== false)) {
          source.on("end", onend2);
          source.on("close", onclose);
        }
        var didOnEnd = false;
        function onend2() {
          if (didOnEnd)
            return;
          didOnEnd = true;
          dest.end();
        }
        __name(onend2, "onend");
        function onclose() {
          if (didOnEnd)
            return;
          didOnEnd = true;
          if (typeof dest.destroy === "function")
            dest.destroy();
        }
        __name(onclose, "onclose");
        function onerror(er) {
          cleanup();
          if (EventEmitter.listenerCount(this, "error") === 0) {
            throw er;
          }
        }
        __name(onerror, "onerror");
        source.on("error", onerror);
        dest.on("error", onerror);
        function cleanup() {
          source.removeListener("data", ondata);
          dest.removeListener("drain", ondrain);
          source.removeListener("end", onend2);
          source.removeListener("close", onclose);
          source.removeListener("error", onerror);
          dest.removeListener("error", onerror);
          source.removeListener("end", cleanup);
          source.removeListener("close", cleanup);
          dest.removeListener("close", cleanup);
        }
        __name(cleanup, "cleanup");
        source.on("end", cleanup);
        source.on("close", cleanup);
        dest.on("close", cleanup);
        dest.emit("pipe", source);
        return dest;
      };
      function _typeof(obj) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = /* @__PURE__ */ __name(function(obj2) {
            return typeof obj2;
          }, "_typeof");
        } else {
          _typeof = /* @__PURE__ */ __name(function(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          }, "_typeof");
        }
        return _typeof(obj);
      }
      __name(_typeof, "_typeof");
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      __name(_classCallCheck, "_classCallCheck");
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      __name(_defineProperties, "_defineProperties");
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      __name(_createClass, "_createClass");
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      __name(_defineProperty, "_defineProperty");
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          var ownKeys = Object.keys(source);
          if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
              return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
          }
          ownKeys.forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        }
        return target;
      }
      __name(_objectSpread, "_objectSpread");
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass)
          _setPrototypeOf(subClass, superClass);
      }
      __name(_inherits, "_inherits");
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : /* @__PURE__ */ __name(function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        }, "_getPrototypeOf");
        return _getPrototypeOf(o);
      }
      __name(_getPrototypeOf, "_getPrototypeOf");
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || /* @__PURE__ */ __name(function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        }, "_setPrototypeOf");
        return _setPrototypeOf(o, p);
      }
      __name(_setPrototypeOf, "_setPrototypeOf");
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      __name(_assertThisInitialized, "_assertThisInitialized");
      function _possibleConstructorReturn(self2, call) {
        if (call && (typeof call === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self2);
      }
      __name(_possibleConstructorReturn, "_possibleConstructorReturn");
      function _toArray(arr) {
        return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest();
      }
      __name(_toArray, "_toArray");
      function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
      }
      __name(_toConsumableArray, "_toConsumableArray");
      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)
            arr2[i] = arr[i];
          return arr2;
        }
      }
      __name(_arrayWithoutHoles, "_arrayWithoutHoles");
      function _arrayWithHoles(arr) {
        if (Array.isArray(arr))
          return arr;
      }
      __name(_arrayWithHoles, "_arrayWithHoles");
      function _iterableToArray(iter) {
        if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]")
          return Array.from(iter);
      }
      __name(_iterableToArray, "_iterableToArray");
      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance");
      }
      __name(_nonIterableSpread, "_nonIterableSpread");
      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
      __name(_nonIterableRest, "_nonIterableRest");
      var _endianness;
      function endianness() {
        if (typeof _endianness === "undefined") {
          var a = new ArrayBuffer(2);
          var b = new Uint8Array(a);
          var c = new Uint16Array(a);
          b[0] = 1;
          b[1] = 2;
          if (c[0] === 258) {
            _endianness = "BE";
          } else if (c[0] === 513) {
            _endianness = "LE";
          } else {
            throw new Error("unable to figure out endianess");
          }
        }
        return _endianness;
      }
      __name(endianness, "endianness");
      function hostname() {
        if (typeof global$1.location !== "undefined") {
          return global$1.location.hostname;
        } else
          return "";
      }
      __name(hostname, "hostname");
      function loadavg() {
        return [];
      }
      __name(loadavg, "loadavg");
      function uptime() {
        return 0;
      }
      __name(uptime, "uptime");
      function freemem() {
        return Number.MAX_VALUE;
      }
      __name(freemem, "freemem");
      function totalmem() {
        return Number.MAX_VALUE;
      }
      __name(totalmem, "totalmem");
      function cpus() {
        return [];
      }
      __name(cpus, "cpus");
      function type() {
        return "Browser";
      }
      __name(type, "type");
      function release() {
        if (typeof global$1.navigator !== "undefined") {
          return global$1.navigator.appVersion;
        }
        return "";
      }
      __name(release, "release");
      function networkInterfaces() {
      }
      __name(networkInterfaces, "networkInterfaces");
      function getNetworkInterfaces() {
      }
      __name(getNetworkInterfaces, "getNetworkInterfaces");
      function tmpDir() {
        return "/tmp";
      }
      __name(tmpDir, "tmpDir");
      var tmpdir = tmpDir;
      var EOL = "\n";
      var os = {
        EOL,
        tmpdir,
        tmpDir,
        networkInterfaces,
        getNetworkInterfaces,
        release,
        type,
        cpus,
        totalmem,
        freemem,
        uptime,
        loadavg,
        hostname,
        endianness
      };
      var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      var FUNC_ERROR_TEXT = "Expected a function";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var INFINITY = 1 / 0;
      var funcTag = "[object Function]", genTag = "[object GeneratorFunction]", symbolTag = "[object Symbol]";
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reEscapeChar = /\\(\\)?/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root2 = freeGlobal || freeSelf || Function("return this")();
      function getValue(object, key) {
        return object == null ? void 0 : object[key];
      }
      __name(getValue, "getValue");
      function isHostObject(value) {
        var result = false;
        if (value != null && typeof value.toString != "function") {
          try {
            result = !!(value + "");
          } catch (e) {
          }
        }
        return result;
      }
      __name(isHostObject, "isHostObject");
      var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
      var coreJsData = root2["__core-js_shared__"];
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var funcToString = funcProto.toString;
      var hasOwnProperty$1 = objectProto.hasOwnProperty;
      var objectToString$1 = objectProto.toString;
      var reIsNative = RegExp(
        "^" + funcToString.call(hasOwnProperty$1).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      var Symbol$1 = root2.Symbol, splice = arrayProto.splice;
      var Map2 = getNative(root2, "Map"), nativeCreate = getNative(Object, "create");
      var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
      function Hash(entries) {
        var index = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      __name(Hash, "Hash");
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
      }
      __name(hashClear, "hashClear");
      function hashDelete(key) {
        return this.has(key) && delete this.__data__[key];
      }
      __name(hashDelete, "hashDelete");
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? void 0 : result;
        }
        return hasOwnProperty$1.call(data, key) ? data[key] : void 0;
      }
      __name(hashGet, "hashGet");
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty$1.call(data, key);
      }
      __name(hashHas, "hashHas");
      function hashSet(key, value) {
        var data = this.__data__;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
        return this;
      }
      __name(hashSet, "hashSet");
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      __name(ListCache, "ListCache");
      function listCacheClear() {
        this.__data__ = [];
      }
      __name(listCacheClear, "listCacheClear");
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        return true;
      }
      __name(listCacheDelete, "listCacheDelete");
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }
      __name(listCacheGet, "listCacheGet");
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      __name(listCacheHas, "listCacheHas");
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      __name(listCacheSet, "listCacheSet");
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      __name(MapCache, "MapCache");
      function mapCacheClear() {
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      __name(mapCacheClear, "mapCacheClear");
      function mapCacheDelete(key) {
        return getMapData(this, key)["delete"](key);
      }
      __name(mapCacheDelete, "mapCacheDelete");
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      __name(mapCacheGet, "mapCacheGet");
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      __name(mapCacheHas, "mapCacheHas");
      function mapCacheSet(key, value) {
        getMapData(this, key).set(key, value);
        return this;
      }
      __name(mapCacheSet, "mapCacheSet");
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      __name(assocIndexOf, "assocIndexOf");
      function baseGet(object, path) {
        path = isKey(path, object) ? [path] : castPath(path);
        var index = 0, length = path.length;
        while (object != null && index < length) {
          object = object[toKey(path[index++])];
        }
        return index && index == length ? object : void 0;
      }
      __name(baseGet, "baseGet");
      function baseIsNative(value) {
        if (!isObject$1(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction$1(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      __name(baseIsNative, "baseIsNative");
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      __name(baseToString, "baseToString");
      function castPath(value) {
        return isArray$2(value) ? value : stringToPath(value);
      }
      __name(castPath, "castPath");
      function getMapData(map, key) {
        var data = map.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      __name(getMapData, "getMapData");
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : void 0;
      }
      __name(getNative, "getNative");
      function isKey(value, object) {
        if (isArray$2(value)) {
          return false;
        }
        var type2 = typeof value;
        if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
      }
      __name(isKey, "isKey");
      function isKeyable(value) {
        var type2 = typeof value;
        return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
      }
      __name(isKeyable, "isKeyable");
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      __name(isMasked, "isMasked");
      var stringToPath = memoize(function(string) {
        string = toString$1(string);
        var result = [];
        if (reLeadingDot.test(string)) {
          result.push("");
        }
        string.replace(rePropName, function(match, number, quote, string2) {
          result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
        });
        return result;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      __name(toKey, "toKey");
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      __name(toSource, "toSource");
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        var memoized = /* @__PURE__ */ __name(function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache.set(key, result);
          return result;
        }, "memoized");
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      __name(memoize, "memoize");
      memoize.Cache = MapCache;
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      __name(eq, "eq");
      var isArray$2 = Array.isArray;
      function isFunction$1(value) {
        var tag = isObject$1(value) ? objectToString$1.call(value) : "";
        return tag == funcTag || tag == genTag;
      }
      __name(isFunction$1, "isFunction$1");
      function isObject$1(value) {
        var type2 = typeof value;
        return !!value && (type2 == "object" || type2 == "function");
      }
      __name(isObject$1, "isObject$1");
      function isObjectLike(value) {
        return !!value && typeof value == "object";
      }
      __name(isObjectLike, "isObjectLike");
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && objectToString$1.call(value) == symbolTag;
      }
      __name(isSymbol, "isSymbol");
      function toString$1(value) {
        return value == null ? "" : baseToString(value);
      }
      __name(toString$1, "toString$1");
      function get(object, path, defaultValue) {
        var result = object == null ? void 0 : baseGet(object, path);
        return result === void 0 ? defaultValue : result;
      }
      __name(get, "get");
      var lodash_get = get;
      function getProp(obj, path, defaultValue) {
        return obj[path] === void 0 ? defaultValue : obj[path];
      }
      __name(getProp, "getProp");
      function setProp(obj, path, value) {
        var pathArray = Array.isArray(path) ? path : path.split(".");
        var _pathArray = _toArray(pathArray), key = _pathArray[0], restPath = _pathArray.slice(1);
        return _objectSpread({}, obj, _defineProperty({}, key, pathArray.length > 1 ? setProp(obj[key] || {}, restPath, value) : value));
      }
      __name(setProp, "setProp");
      function unsetProp(obj, path) {
        var pathArray = Array.isArray(path) ? path : path.split(".");
        var _pathArray2 = _toArray(pathArray), key = _pathArray2[0], restPath = _pathArray2.slice(1);
        if (_typeof(obj[key]) !== "object") {
          return obj;
        }
        if (pathArray.length === 1) {
          return Object.keys(obj).filter(function(prop) {
            return prop !== key;
          }).reduce(function(acc, prop) {
            return Object.assign(acc, _defineProperty({}, prop, obj[prop]));
          }, {});
        }
        return Object.keys(obj).reduce(function(acc, prop) {
          return _objectSpread({}, acc, _defineProperty({}, prop, prop !== key ? obj[prop] : unsetProp(obj[key], restPath)));
        }, {});
      }
      __name(unsetProp, "unsetProp");
      function flattenReducer(acc, arr) {
        try {
          acc.push.apply(acc, _toConsumableArray(arr));
          return acc;
        } catch (err) {
          return acc.concat(arr);
        }
      }
      __name(flattenReducer, "flattenReducer");
      function fastJoin(arr, separator) {
        var isFirst = true;
        return arr.reduce(function(acc, elem) {
          if (elem === null || elem === void 0) {
            elem = "";
          }
          if (isFirst) {
            isFirst = false;
            return "".concat(elem);
          }
          return "".concat(acc).concat(separator).concat(elem);
        }, "");
      }
      __name(fastJoin, "fastJoin");
      var utils = {
        getProp,
        setProp,
        unsetProp,
        fastJoin,
        flattenReducer
      };
      var getProp$1 = utils.getProp, fastJoin$1 = utils.fastJoin, flattenReducer$1 = utils.flattenReducer;
      var JSON2CSVBase = /* @__PURE__ */ function() {
        function JSON2CSVBase2(opts) {
          _classCallCheck(this, JSON2CSVBase2);
          this.opts = this.preprocessOpts(opts);
        }
        __name(JSON2CSVBase2, "JSON2CSVBase");
        _createClass(JSON2CSVBase2, [{
          key: "preprocessOpts",
          value: /* @__PURE__ */ __name(function preprocessOpts(opts) {
            var processedOpts = Object.assign({}, opts);
            processedOpts.transforms = !Array.isArray(processedOpts.transforms) ? processedOpts.transforms ? [processedOpts.transforms] : [] : processedOpts.transforms;
            processedOpts.delimiter = processedOpts.delimiter || ",";
            processedOpts.eol = processedOpts.eol || os.EOL;
            processedOpts.quote = typeof processedOpts.quote === "string" ? processedOpts.quote : '"';
            processedOpts.escapedQuote = typeof processedOpts.escapedQuote === "string" ? processedOpts.escapedQuote : "".concat(processedOpts.quote).concat(processedOpts.quote);
            processedOpts.header = processedOpts.header !== false;
            processedOpts.includeEmptyRows = processedOpts.includeEmptyRows || false;
            processedOpts.withBOM = processedOpts.withBOM || false;
            return processedOpts;
          }, "preprocessOpts")
        }, {
          key: "preprocessFieldsInfo",
          value: /* @__PURE__ */ __name(function preprocessFieldsInfo(fields) {
            var _this = this;
            return fields.map(function(fieldInfo) {
              if (typeof fieldInfo === "string") {
                return {
                  label: fieldInfo,
                  value: fieldInfo.includes(".") || fieldInfo.includes("[") ? function(row) {
                    return lodash_get(row, fieldInfo, _this.opts.defaultValue);
                  } : function(row) {
                    return getProp$1(row, fieldInfo, _this.opts.defaultValue);
                  }
                };
              }
              if (_typeof(fieldInfo) === "object") {
                var defaultValue = "default" in fieldInfo ? fieldInfo.default : _this.opts.defaultValue;
                if (typeof fieldInfo.value === "string") {
                  return {
                    label: fieldInfo.label || fieldInfo.value,
                    value: fieldInfo.value.includes(".") || fieldInfo.value.includes("[") ? function(row) {
                      return lodash_get(row, fieldInfo.value, defaultValue);
                    } : function(row) {
                      return getProp$1(row, fieldInfo.value, defaultValue);
                    }
                  };
                }
                if (typeof fieldInfo.value === "function") {
                  var label = fieldInfo.label || fieldInfo.value.name || "";
                  var field = {
                    label,
                    default: defaultValue
                  };
                  return {
                    label,
                    value: /* @__PURE__ */ __name(function value(row) {
                      var value2 = fieldInfo.value(row, field);
                      return value2 === null || value2 === void 0 ? defaultValue : value2;
                    }, "value")
                  };
                }
              }
              throw new Error("Invalid field info option. " + JSON.stringify(fieldInfo));
            });
          }, "preprocessFieldsInfo")
        }, {
          key: "getHeader",
          value: /* @__PURE__ */ __name(function getHeader() {
            var _this2 = this;
            return fastJoin$1(this.opts.fields.map(function(fieldInfo) {
              return _this2.processValue(fieldInfo.label);
            }), this.opts.delimiter);
          }, "getHeader")
        }, {
          key: "preprocessRow",
          value: /* @__PURE__ */ __name(function preprocessRow(row) {
            return this.opts.transforms.reduce(function(rows, transform) {
              return rows.map(function(row2) {
                return transform(row2);
              }).reduce(flattenReducer$1, []);
            }, [row]);
          }, "preprocessRow")
        }, {
          key: "processRow",
          value: /* @__PURE__ */ __name(function processRow(row) {
            var _this3 = this;
            if (!row) {
              return void 0;
            }
            var processedRow = this.opts.fields.map(function(fieldInfo) {
              return _this3.processCell(row, fieldInfo);
            });
            if (!this.opts.includeEmptyRows && processedRow.every(function(field) {
              return field === void 0;
            })) {
              return void 0;
            }
            return fastJoin$1(processedRow, this.opts.delimiter);
          }, "processRow")
        }, {
          key: "processCell",
          value: /* @__PURE__ */ __name(function processCell(row, fieldInfo) {
            return this.processValue(fieldInfo.value(row));
          }, "processCell")
        }, {
          key: "processValue",
          value: /* @__PURE__ */ __name(function processValue(value) {
            if (value === null || value === void 0) {
              return void 0;
            }
            var valueType = _typeof(value);
            if (valueType !== "boolean" && valueType !== "number" && valueType !== "string") {
              value = JSON.stringify(value);
              if (value === void 0) {
                return void 0;
              }
              if (value[0] === '"') {
                value = value.replace(/^"(.+)"$/, "$1");
              }
            }
            if (typeof value === "string") {
              if (this.opts.excelStrings) {
                if (value.includes(this.opts.quote)) {
                  value = value.replace(new RegExp(this.opts.quote, "g"), "".concat(this.opts.escapedQuote).concat(this.opts.escapedQuote));
                }
                value = '"=""'.concat(value, '"""');
              } else {
                if (value.includes(this.opts.quote)) {
                  value = value.replace(new RegExp(this.opts.quote, "g"), this.opts.escapedQuote);
                }
                value = "".concat(this.opts.quote).concat(value).concat(this.opts.quote);
              }
            }
            return value;
          }, "processValue")
        }]);
        return JSON2CSVBase2;
      }();
      var JSON2CSVBase_1 = JSON2CSVBase;
      var fastJoin$2 = utils.fastJoin, flattenReducer$2 = utils.flattenReducer;
      var JSON2CSVParser = /* @__PURE__ */ function(_JSON2CSVBase) {
        _inherits(JSON2CSVParser2, _JSON2CSVBase);
        function JSON2CSVParser2(opts) {
          var _this;
          _classCallCheck(this, JSON2CSVParser2);
          _this = _possibleConstructorReturn(this, _getPrototypeOf(JSON2CSVParser2).call(this, opts));
          if (_this.opts.fields) {
            _this.opts.fields = _this.preprocessFieldsInfo(_this.opts.fields);
          }
          return _this;
        }
        __name(JSON2CSVParser2, "JSON2CSVParser");
        _createClass(JSON2CSVParser2, [{
          key: "parse",
          value: /* @__PURE__ */ __name(function parse3(data) {
            var processedData = this.preprocessData(data);
            if (!this.opts.fields) {
              this.opts.fields = processedData.reduce(function(fields, item) {
                Object.keys(item).forEach(function(field) {
                  if (!fields.includes(field)) {
                    fields.push(field);
                  }
                });
                return fields;
              }, []);
              this.opts.fields = this.preprocessFieldsInfo(this.opts.fields);
            }
            var header = this.opts.header ? this.getHeader() : "";
            var rows = this.processData(processedData);
            var csv = (this.opts.withBOM ? "\uFEFF" : "") + header + (header && rows ? this.opts.eol : "") + rows;
            return csv;
          }, "parse")
        }, {
          key: "preprocessData",
          value: /* @__PURE__ */ __name(function preprocessData(data) {
            var _this2 = this;
            var processedData = Array.isArray(data) ? data : [data];
            if (!this.opts.fields && (processedData.length === 0 || _typeof(processedData[0]) !== "object")) {
              throw new Error('Data should not be empty or the "fields" option should be included');
            }
            if (this.opts.transforms.length === 0)
              return processedData;
            return processedData.map(function(row) {
              return _this2.preprocessRow(row);
            }).reduce(flattenReducer$2, []);
          }, "preprocessData")
        }, {
          key: "processData",
          value: /* @__PURE__ */ __name(function processData(data) {
            var _this3 = this;
            return fastJoin$2(
              data.map(function(row) {
                return _this3.processRow(row);
              }).filter(function(row) {
                return row;
              }),
              this.opts.eol
            );
          }, "processData")
        }]);
        return JSON2CSVParser2;
      }(JSON2CSVBase_1);
      var JSON2CSVParser_1 = JSON2CSVParser;
      var C = {};
      var LEFT_BRACE = C.LEFT_BRACE = 1;
      var RIGHT_BRACE = C.RIGHT_BRACE = 2;
      var LEFT_BRACKET = C.LEFT_BRACKET = 3;
      var RIGHT_BRACKET = C.RIGHT_BRACKET = 4;
      var COLON = C.COLON = 5;
      var COMMA = C.COMMA = 6;
      var TRUE = C.TRUE = 7;
      var FALSE = C.FALSE = 8;
      var NULL = C.NULL = 9;
      var STRING2 = C.STRING = 10;
      var NUMBER = C.NUMBER = 11;
      var START = C.START = 17;
      var STOP = C.STOP = 18;
      var TRUE1 = C.TRUE1 = 33;
      var TRUE2 = C.TRUE2 = 34;
      var TRUE3 = C.TRUE3 = 35;
      var FALSE1 = C.FALSE1 = 49;
      var FALSE2 = C.FALSE2 = 50;
      var FALSE3 = C.FALSE3 = 51;
      var FALSE4 = C.FALSE4 = 52;
      var NULL1 = C.NULL1 = 65;
      var NULL2 = C.NULL2 = 66;
      var NULL3 = C.NULL3 = 67;
      var NUMBER1 = C.NUMBER1 = 81;
      var NUMBER3 = C.NUMBER3 = 83;
      var STRING1 = C.STRING1 = 97;
      var STRING22 = C.STRING2 = 98;
      var STRING3 = C.STRING3 = 99;
      var STRING4 = C.STRING4 = 100;
      var STRING5 = C.STRING5 = 101;
      var STRING6 = C.STRING6 = 102;
      var VALUE = C.VALUE = 113;
      var KEY = C.KEY = 114;
      var OBJECT = C.OBJECT = 129;
      var ARRAY = C.ARRAY = 130;
      var BACK_SLASH = "\\".charCodeAt(0);
      var FORWARD_SLASH = "/".charCodeAt(0);
      var BACKSPACE = "\b".charCodeAt(0);
      var FORM_FEED = "\f".charCodeAt(0);
      var NEWLINE = "\n".charCodeAt(0);
      var CARRIAGE_RETURN = "\r".charCodeAt(0);
      var TAB = "	".charCodeAt(0);
      var STRING_BUFFER_SIZE = 64 * 1024;
      function Parser() {
        this.tState = START;
        this.value = void 0;
        this.string = void 0;
        this.stringBuffer = Buffer2.alloc ? Buffer2.alloc(STRING_BUFFER_SIZE) : new Buffer2(STRING_BUFFER_SIZE);
        this.stringBufferOffset = 0;
        this.unicode = void 0;
        this.highSurrogate = void 0;
        this.key = void 0;
        this.mode = void 0;
        this.stack = [];
        this.state = VALUE;
        this.bytes_remaining = 0;
        this.bytes_in_sequence = 0;
        this.temp_buffs = { "2": new Buffer2(2), "3": new Buffer2(3), "4": new Buffer2(4) };
        this.offset = -1;
      }
      __name(Parser, "Parser");
      Parser.toknam = function(code) {
        var keys2 = Object.keys(C);
        for (var i = 0, l = keys2.length; i < l; i++) {
          var key = keys2[i];
          if (C[key] === code) {
            return key;
          }
        }
        return code && "0x" + code.toString(16);
      };
      var proto = Parser.prototype;
      proto.onError = function(err) {
        throw err;
      };
      proto.charError = function(buffer, i) {
        this.tState = STOP;
        this.onError(new Error("Unexpected " + JSON.stringify(String.fromCharCode(buffer[i])) + " at position " + i + " in state " + Parser.toknam(this.tState)));
      };
      proto.appendStringChar = function(char) {
        if (this.stringBufferOffset >= STRING_BUFFER_SIZE) {
          this.string += this.stringBuffer.toString("utf8");
          this.stringBufferOffset = 0;
        }
        this.stringBuffer[this.stringBufferOffset++] = char;
      };
      proto.appendStringBuf = function(buf, start, end) {
        var size = buf.length;
        if (typeof start === "number") {
          if (typeof end === "number") {
            if (end < 0) {
              size = buf.length - start + end;
            } else {
              size = end - start;
            }
          } else {
            size = buf.length - start;
          }
        }
        if (size < 0) {
          size = 0;
        }
        if (this.stringBufferOffset + size > STRING_BUFFER_SIZE) {
          this.string += this.stringBuffer.toString("utf8", 0, this.stringBufferOffset);
          this.stringBufferOffset = 0;
        }
        buf.copy(this.stringBuffer, this.stringBufferOffset, start, end);
        this.stringBufferOffset += size;
      };
      proto.write = function(buffer) {
        if (typeof buffer === "string")
          buffer = new Buffer2(buffer);
        var n;
        for (var i = 0, l = buffer.length; i < l; i++) {
          if (this.tState === START) {
            n = buffer[i];
            this.offset++;
            if (n === 123) {
              this.onToken(LEFT_BRACE, "{");
            } else if (n === 125) {
              this.onToken(RIGHT_BRACE, "}");
            } else if (n === 91) {
              this.onToken(LEFT_BRACKET, "[");
            } else if (n === 93) {
              this.onToken(RIGHT_BRACKET, "]");
            } else if (n === 58) {
              this.onToken(COLON, ":");
            } else if (n === 44) {
              this.onToken(COMMA, ",");
            } else if (n === 116) {
              this.tState = TRUE1;
            } else if (n === 102) {
              this.tState = FALSE1;
            } else if (n === 110) {
              this.tState = NULL1;
            } else if (n === 34) {
              this.string = "";
              this.stringBufferOffset = 0;
              this.tState = STRING1;
            } else if (n === 45) {
              this.string = "-";
              this.tState = NUMBER1;
            } else {
              if (n >= 48 && n < 64) {
                this.string = String.fromCharCode(n);
                this.tState = NUMBER3;
              } else if (n === 32 || n === 9 || n === 10 || n === 13)
                ;
              else {
                return this.charError(buffer, i);
              }
            }
          } else if (this.tState === STRING1) {
            n = buffer[i];
            if (this.bytes_remaining > 0) {
              for (var j = 0; j < this.bytes_remaining; j++) {
                this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + j] = buffer[j];
              }
              this.appendStringBuf(this.temp_buffs[this.bytes_in_sequence]);
              this.bytes_in_sequence = this.bytes_remaining = 0;
              i = i + j - 1;
            } else if (this.bytes_remaining === 0 && n >= 128) {
              if (n <= 193 || n > 244) {
                return this.onError(new Error("Invalid UTF-8 character at position " + i + " in state " + Parser.toknam(this.tState)));
              }
              if (n >= 194 && n <= 223)
                this.bytes_in_sequence = 2;
              if (n >= 224 && n <= 239)
                this.bytes_in_sequence = 3;
              if (n >= 240 && n <= 244)
                this.bytes_in_sequence = 4;
              if (this.bytes_in_sequence + i > buffer.length) {
                for (var k = 0; k <= buffer.length - 1 - i; k++) {
                  this.temp_buffs[this.bytes_in_sequence][k] = buffer[i + k];
                }
                this.bytes_remaining = i + this.bytes_in_sequence - buffer.length;
                i = buffer.length - 1;
              } else {
                this.appendStringBuf(buffer, i, i + this.bytes_in_sequence);
                i = i + this.bytes_in_sequence - 1;
              }
            } else if (n === 34) {
              this.tState = START;
              this.string += this.stringBuffer.toString("utf8", 0, this.stringBufferOffset);
              this.stringBufferOffset = 0;
              this.onToken(STRING2, this.string);
              this.offset += Buffer2.byteLength(this.string, "utf8") + 1;
              this.string = void 0;
            } else if (n === 92) {
              this.tState = STRING22;
            } else if (n >= 32) {
              this.appendStringChar(n);
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === STRING22) {
            n = buffer[i];
            if (n === 34) {
              this.appendStringChar(n);
              this.tState = STRING1;
            } else if (n === 92) {
              this.appendStringChar(BACK_SLASH);
              this.tState = STRING1;
            } else if (n === 47) {
              this.appendStringChar(FORWARD_SLASH);
              this.tState = STRING1;
            } else if (n === 98) {
              this.appendStringChar(BACKSPACE);
              this.tState = STRING1;
            } else if (n === 102) {
              this.appendStringChar(FORM_FEED);
              this.tState = STRING1;
            } else if (n === 110) {
              this.appendStringChar(NEWLINE);
              this.tState = STRING1;
            } else if (n === 114) {
              this.appendStringChar(CARRIAGE_RETURN);
              this.tState = STRING1;
            } else if (n === 116) {
              this.appendStringChar(TAB);
              this.tState = STRING1;
            } else if (n === 117) {
              this.unicode = "";
              this.tState = STRING3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === STRING3 || this.tState === STRING4 || this.tState === STRING5 || this.tState === STRING6) {
            n = buffer[i];
            if (n >= 48 && n < 64 || n > 64 && n <= 70 || n > 96 && n <= 102) {
              this.unicode += String.fromCharCode(n);
              if (this.tState++ === STRING6) {
                var intVal = parseInt(this.unicode, 16);
                this.unicode = void 0;
                if (this.highSurrogate !== void 0 && intVal >= 56320 && intVal < 57343 + 1) {
                  this.appendStringBuf(new Buffer2(String.fromCharCode(this.highSurrogate, intVal)));
                  this.highSurrogate = void 0;
                } else if (this.highSurrogate === void 0 && intVal >= 55296 && intVal < 56319 + 1) {
                  this.highSurrogate = intVal;
                } else {
                  if (this.highSurrogate !== void 0) {
                    this.appendStringBuf(new Buffer2(String.fromCharCode(this.highSurrogate)));
                    this.highSurrogate = void 0;
                  }
                  this.appendStringBuf(new Buffer2(String.fromCharCode(intVal)));
                }
                this.tState = STRING1;
              }
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === NUMBER1 || this.tState === NUMBER3) {
            n = buffer[i];
            switch (n) {
              case 48:
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
              case 46:
              case 101:
              case 69:
              case 43:
              case 45:
                this.string += String.fromCharCode(n);
                this.tState = NUMBER3;
                break;
              default:
                this.tState = START;
                var result = Number(this.string);
                if (isNaN(result)) {
                  return this.charError(buffer, i);
                }
                if (this.string.match(/[0-9]+/) == this.string && result.toString() != this.string) {
                  this.onToken(STRING2, this.string);
                } else {
                  this.onToken(NUMBER, result);
                }
                this.offset += this.string.length - 1;
                this.string = void 0;
                i--;
                break;
            }
          } else if (this.tState === TRUE1) {
            if (buffer[i] === 114) {
              this.tState = TRUE2;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === TRUE2) {
            if (buffer[i] === 117) {
              this.tState = TRUE3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === TRUE3) {
            if (buffer[i] === 101) {
              this.tState = START;
              this.onToken(TRUE, true);
              this.offset += 3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === FALSE1) {
            if (buffer[i] === 97) {
              this.tState = FALSE2;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === FALSE2) {
            if (buffer[i] === 108) {
              this.tState = FALSE3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === FALSE3) {
            if (buffer[i] === 115) {
              this.tState = FALSE4;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === FALSE4) {
            if (buffer[i] === 101) {
              this.tState = START;
              this.onToken(FALSE, false);
              this.offset += 4;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === NULL1) {
            if (buffer[i] === 117) {
              this.tState = NULL2;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === NULL2) {
            if (buffer[i] === 108) {
              this.tState = NULL3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === NULL3) {
            if (buffer[i] === 108) {
              this.tState = START;
              this.onToken(NULL, null);
              this.offset += 3;
            } else {
              return this.charError(buffer, i);
            }
          }
        }
      };
      proto.onToken = function(token, value) {
      };
      proto.parseError = function(token, value) {
        this.tState = STOP;
        this.onError(new Error("Unexpected " + Parser.toknam(token) + (value ? "(" + JSON.stringify(value) + ")" : "") + " in state " + Parser.toknam(this.state)));
      };
      proto.push = function() {
        this.stack.push({ value: this.value, key: this.key, mode: this.mode });
      };
      proto.pop = function() {
        var value = this.value;
        var parent = this.stack.pop();
        this.value = parent.value;
        this.key = parent.key;
        this.mode = parent.mode;
        this.emit(value);
        if (!this.mode) {
          this.state = VALUE;
        }
      };
      proto.emit = function(value) {
        if (this.mode) {
          this.state = COMMA;
        }
        this.onValue(value);
      };
      proto.onValue = function(value) {
      };
      proto.onToken = function(token, value) {
        if (this.state === VALUE) {
          if (token === STRING2 || token === NUMBER || token === TRUE || token === FALSE || token === NULL) {
            if (this.value) {
              this.value[this.key] = value;
            }
            this.emit(value);
          } else if (token === LEFT_BRACE) {
            this.push();
            if (this.value) {
              this.value = this.value[this.key] = {};
            } else {
              this.value = {};
            }
            this.key = void 0;
            this.state = KEY;
            this.mode = OBJECT;
          } else if (token === LEFT_BRACKET) {
            this.push();
            if (this.value) {
              this.value = this.value[this.key] = [];
            } else {
              this.value = [];
            }
            this.key = 0;
            this.mode = ARRAY;
            this.state = VALUE;
          } else if (token === RIGHT_BRACE) {
            if (this.mode === OBJECT) {
              this.pop();
            } else {
              return this.parseError(token, value);
            }
          } else if (token === RIGHT_BRACKET) {
            if (this.mode === ARRAY) {
              this.pop();
            } else {
              return this.parseError(token, value);
            }
          } else {
            return this.parseError(token, value);
          }
        } else if (this.state === KEY) {
          if (token === STRING2) {
            this.key = value;
            this.state = COLON;
          } else if (token === RIGHT_BRACE) {
            this.pop();
          } else {
            return this.parseError(token, value);
          }
        } else if (this.state === COLON) {
          if (token === COLON) {
            this.state = VALUE;
          } else {
            return this.parseError(token, value);
          }
        } else if (this.state === COMMA) {
          if (token === COMMA) {
            if (this.mode === ARRAY) {
              this.key++;
              this.state = VALUE;
            } else if (this.mode === OBJECT) {
              this.state = KEY;
            }
          } else if (token === RIGHT_BRACKET && this.mode === ARRAY || token === RIGHT_BRACE && this.mode === OBJECT) {
            this.pop();
          } else {
            return this.parseError(token, value);
          }
        } else {
          return this.parseError(token, value);
        }
      };
      Parser.C = C;
      var jsonparse = Parser;
      var Transform$1 = Stream.Transform;
      var JSON2CSVTransform = /* @__PURE__ */ function(_Transform) {
        _inherits(JSON2CSVTransform2, _Transform);
        function JSON2CSVTransform2(opts, transformOpts) {
          var _this;
          _classCallCheck(this, JSON2CSVTransform2);
          _this = _possibleConstructorReturn(this, _getPrototypeOf(JSON2CSVTransform2).call(this, transformOpts));
          Object.getOwnPropertyNames(JSON2CSVBase_1.prototype).forEach(function(key) {
            return _this[key] = JSON2CSVBase_1.prototype[key];
          });
          _this.opts = _this.preprocessOpts(opts);
          _this._data = "";
          _this._hasWritten = false;
          if (_this._readableState.objectMode) {
            _this.initObjectModeParse();
          } else if (_this.opts.ndjson) {
            _this.initNDJSONParse();
          } else {
            _this.initJSONParser();
          }
          if (_this.opts.withBOM) {
            _this.push("\uFEFF");
          }
          if (_this.opts.fields) {
            _this.opts.fields = _this.preprocessFieldsInfo(_this.opts.fields);
            _this.pushHeader();
          }
          return _this;
        }
        __name(JSON2CSVTransform2, "JSON2CSVTransform");
        _createClass(JSON2CSVTransform2, [{
          key: "initObjectModeParse",
          value: /* @__PURE__ */ __name(function initObjectModeParse() {
            var transform = this;
            this.parser = {
              write: /* @__PURE__ */ __name(function write2(line) {
                transform.pushLine(line);
              }, "write"),
              getPendingData: /* @__PURE__ */ __name(function getPendingData() {
                return void 0;
              }, "getPendingData")
            };
          }, "initObjectModeParse")
        }, {
          key: "initNDJSONParse",
          value: /* @__PURE__ */ __name(function initNDJSONParse() {
            var transform = this;
            this.parser = {
              _data: "",
              write: /* @__PURE__ */ __name(function write2(chunk) {
                this._data += chunk.toString();
                var lines = this._data.split("\n").map(function(line) {
                  return line.trim();
                }).filter(function(line) {
                  return line !== "";
                });
                var pendingData = false;
                lines.forEach(function(line, i) {
                  try {
                    transform.pushLine(JSON.parse(line));
                  } catch (e) {
                    if (i === lines.length - 1) {
                      pendingData = true;
                    } else {
                      e.message = "Invalid JSON (".concat(line, ")");
                      transform.emit("error", e);
                    }
                  }
                });
                this._data = pendingData ? this._data.slice(this._data.lastIndexOf("\n")) : "";
              }, "write"),
              getPendingData: /* @__PURE__ */ __name(function getPendingData() {
                return this._data;
              }, "getPendingData")
            };
          }, "initNDJSONParse")
        }, {
          key: "initJSONParser",
          value: /* @__PURE__ */ __name(function initJSONParser() {
            var transform = this;
            this.parser = new jsonparse();
            this.parser.onValue = function(value) {
              if (this.stack.length !== this.depthToEmit)
                return;
              transform.pushLine(value);
            };
            this.parser._onToken = this.parser.onToken;
            this.parser.onToken = function(token, value) {
              transform.parser._onToken(token, value);
              if (this.stack.length === 0 && !transform.opts.fields && this.mode !== jsonparse.C.ARRAY && this.mode !== jsonparse.C.OBJECT) {
                this.onError(new Error('Data should not be empty or the "fields" option should be included'));
              }
              if (this.stack.length === 1) {
                if (this.depthToEmit === void 0) {
                  this.depthToEmit = this.mode === jsonparse.C.ARRAY ? 1 : 0;
                }
                if (this.depthToEmit !== 0 && this.stack.length === 1) {
                  this.value = void 0;
                }
              }
            };
            this.parser.getPendingData = function() {
              return this.value;
            };
            this.parser.onError = function(err) {
              if (err.message.includes("Unexpected")) {
                err.message = "Invalid JSON (".concat(err.message, ")");
              }
              transform.emit("error", err);
            };
          }, "initJSONParser")
        }, {
          key: "_transform",
          value: /* @__PURE__ */ __name(function _transform(chunk, encoding, done2) {
            this.parser.write(chunk);
            done2();
          }, "_transform")
        }, {
          key: "_flush",
          value: /* @__PURE__ */ __name(function _flush(done2) {
            if (this.parser.getPendingData()) {
              done2(new Error("Invalid data received from stdin", this.parser.getPendingData()));
            }
            done2();
          }, "_flush")
        }, {
          key: "pushHeader",
          value: /* @__PURE__ */ __name(function pushHeader() {
            if (this.opts.header) {
              var header = this.getHeader();
              this.emit("header", header);
              this.push(header);
              this._hasWritten = true;
            }
          }, "pushHeader")
        }, {
          key: "pushLine",
          value: /* @__PURE__ */ __name(function pushLine(data) {
            var _this2 = this;
            var processedData = this.preprocessRow(data);
            if (!this._hasWritten) {
              this.opts.fields = this.opts.fields || this.preprocessFieldsInfo(Object.keys(processedData[0]));
              this.pushHeader();
            }
            processedData.forEach(function(row) {
              var line = _this2.processRow(row, _this2.opts);
              if (line === void 0)
                return;
              _this2.emit("line", line);
              _this2.push(_this2._hasWritten ? _this2.opts.eol + line : line);
              _this2._hasWritten = true;
            });
          }, "pushLine")
        }]);
        return JSON2CSVTransform2;
      }(Transform$1);
      var JSON2CSVTransform_1 = JSON2CSVTransform;
      var Transform$2 = Stream.Transform;
      var fastJoin$3 = utils.fastJoin;
      var JSON2CSVAsyncParser = /* @__PURE__ */ function() {
        function JSON2CSVAsyncParser2(opts, transformOpts) {
          _classCallCheck(this, JSON2CSVAsyncParser2);
          this.input = new Transform$2(transformOpts);
          this.input._read = function() {
          };
          this.transform = new JSON2CSVTransform_1(opts, transformOpts);
          this.processor = this.input.pipe(this.transform);
        }
        __name(JSON2CSVAsyncParser2, "JSON2CSVAsyncParser");
        _createClass(JSON2CSVAsyncParser2, [{
          key: "fromInput",
          value: /* @__PURE__ */ __name(function fromInput(input) {
            if (this._input) {
              throw new Error("Async parser already has an input.");
            }
            this._input = input;
            this.input = this._input.pipe(this.processor);
            return this;
          }, "fromInput")
        }, {
          key: "throughTransform",
          value: /* @__PURE__ */ __name(function throughTransform(transform) {
            if (this._output) {
              throw new Error("Can't add transforms once an output has been added.");
            }
            this.processor = this.processor.pipe(transform);
            return this;
          }, "throughTransform")
        }, {
          key: "toOutput",
          value: /* @__PURE__ */ __name(function toOutput(output) {
            if (this._output) {
              throw new Error("Async parser already has an output.");
            }
            this._output = output;
            this.processor = this.processor.pipe(output);
            return this;
          }, "toOutput")
        }, {
          key: "promise",
          value: /* @__PURE__ */ __name(function promise() {
            var _this = this;
            var returnCSV = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
            return new Promise(function(resolve, reject) {
              if (!returnCSV) {
                _this.processor.on("finish", function() {
                  return resolve();
                }).on("error", function(err) {
                  return reject(err);
                });
                return;
              }
              var csvBuffer = [];
              _this.processor.on("data", function(chunk) {
                return csvBuffer.push(chunk.toString());
              }).on("finish", function() {
                return resolve(fastJoin$3(csvBuffer, ""));
              }).on("error", function(err) {
                return reject(err);
              });
            });
          }, "promise")
        }]);
        return JSON2CSVAsyncParser2;
      }();
      var JSON2CSVAsyncParser_1 = JSON2CSVAsyncParser;
      function flatten() {
        var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$objects = _ref.objects, objects = _ref$objects === void 0 ? true : _ref$objects, _ref$arrays = _ref.arrays, arrays = _ref$arrays === void 0 ? false : _ref$arrays, _ref$separator = _ref.separator, separator = _ref$separator === void 0 ? "." : _ref$separator;
        function step(obj, flatDataRow, currentPath) {
          Object.keys(obj).forEach(function(key) {
            var newPath = currentPath ? "".concat(currentPath).concat(separator).concat(key) : key;
            var value = obj[key];
            if (objects && _typeof(value) === "object" && value !== null && !Array.isArray(value) && Object.prototype.toString.call(value.toJSON) !== "[object Function]" && Object.keys(value).length) {
              step(value, flatDataRow, newPath);
              return;
            }
            if (arrays && Array.isArray(value)) {
              step(value, flatDataRow, newPath);
              return;
            }
            flatDataRow[newPath] = value;
          });
          return flatDataRow;
        }
        __name(step, "step");
        return function(dataRow) {
          return step(dataRow, {});
        };
      }
      __name(flatten, "flatten");
      var flatten_1 = flatten;
      var setProp$1 = utils.setProp, unsetProp$1 = utils.unsetProp, flattenReducer$3 = utils.flattenReducer;
      function getUnwindablePaths(obj, currentPath) {
        return Object.keys(obj).reduce(function(unwindablePaths, key) {
          var newPath = currentPath ? "".concat(currentPath, ".").concat(key) : key;
          var value = obj[key];
          if (_typeof(value) === "object" && value !== null && !Array.isArray(value) && Object.prototype.toString.call(value.toJSON) !== "[object Function]" && Object.keys(value).length) {
            unwindablePaths = unwindablePaths.concat(getUnwindablePaths(value, newPath));
          } else if (Array.isArray(value)) {
            unwindablePaths.push(newPath);
            unwindablePaths = unwindablePaths.concat(value.map(function(arrObj) {
              return getUnwindablePaths(arrObj, newPath);
            }).reduce(flattenReducer$3, []).filter(function(item, index, arr) {
              return arr.indexOf(item) !== index;
            }));
          }
          return unwindablePaths;
        }, []);
      }
      __name(getUnwindablePaths, "getUnwindablePaths");
      function unwind() {
        var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$paths = _ref.paths, paths = _ref$paths === void 0 ? void 0 : _ref$paths, _ref$blankOut = _ref.blankOut, blankOut = _ref$blankOut === void 0 ? false : _ref$blankOut;
        function unwindReducer(rows, unwindPath) {
          return rows.map(function(row) {
            var unwindArray = lodash_get(row, unwindPath);
            if (!Array.isArray(unwindArray)) {
              return row;
            }
            if (!unwindArray.length) {
              return unsetProp$1(row, unwindPath);
            }
            return unwindArray.map(function(unwindRow, index) {
              var clonedRow = blankOut && index > 0 ? {} : row;
              return setProp$1(clonedRow, unwindPath, unwindRow);
            });
          }).reduce(flattenReducer$3, []);
        }
        __name(unwindReducer, "unwindReducer");
        paths = Array.isArray(paths) ? paths : paths ? [paths] : void 0;
        return function(dataRow) {
          return (paths || getUnwindablePaths(dataRow)).reduce(unwindReducer, [dataRow]);
        };
      }
      __name(unwind, "unwind");
      var unwind_1 = unwind;
      var Readable$1 = Stream.Readable;
      var Parser$1 = JSON2CSVParser_1;
      var AsyncParser = JSON2CSVAsyncParser_1;
      var Transform$3 = JSON2CSVTransform_1;
      var parse2 = /* @__PURE__ */ __name(function parse3(data, opts) {
        return new JSON2CSVParser_1(opts).parse(data);
      }, "parse");
      var parseAsync = /* @__PURE__ */ __name(function parseAsync2(data, opts, transformOpts) {
        try {
          if (!(data instanceof Readable$1)) {
            transformOpts = Object.assign({}, transformOpts, {
              objectMode: true
            });
          }
          var asyncParser = new JSON2CSVAsyncParser_1(opts, transformOpts);
          var promise = asyncParser.promise();
          if (Array.isArray(data)) {
            data.forEach(function(item) {
              return asyncParser.input.push(item);
            });
            asyncParser.input.push(null);
          } else if (data instanceof Readable$1) {
            asyncParser.fromInput(data);
          } else {
            asyncParser.input.push(data);
            asyncParser.input.push(null);
          }
          return promise;
        } catch (err) {
          return Promise.reject(err);
        }
      }, "parseAsync");
      var transforms = {
        flatten: flatten_1,
        unwind: unwind_1
      };
      var json2csv = {
        Parser: Parser$1,
        AsyncParser,
        Transform: Transform$3,
        parse: parse2,
        parseAsync,
        transforms
      };
      exports2.AsyncParser = AsyncParser;
      exports2.Parser = Parser$1;
      exports2.Transform = Transform$3;
      exports2.default = json2csv;
      exports2.parse = parse2;
      exports2.parseAsync = parseAsync;
      exports2.transforms = transforms;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/filer/dist/filer.min.js
var require_filer_min = __commonJS({
  "node_modules/filer/dist/filer.min.js"(exports, module) {
    parcelRequire = function(e, r, t, n) {
      var i, o = "function" == typeof parcelRequire && parcelRequire, u = "function" == typeof __require && __require;
      function f(t2, n2) {
        if (!r[t2]) {
          if (!e[t2]) {
            var i2 = "function" == typeof parcelRequire && parcelRequire;
            if (!n2 && i2)
              return i2(t2, true);
            if (o)
              return o(t2, true);
            if (u && "string" == typeof t2)
              return u(t2);
            var c2 = new Error("Cannot find module '" + t2 + "'");
            throw c2.code = "MODULE_NOT_FOUND", c2;
          }
          p.resolve = function(r2) {
            return e[t2][1][r2] || r2;
          }, p.cache = {};
          var l2 = r[t2] = new f.Module(t2);
          e[t2][0].call(l2.exports, p, l2, l2.exports, this);
        }
        return r[t2].exports;
        function p(e2) {
          return f(p.resolve(e2));
        }
        __name(p, "p");
      }
      __name(f, "f");
      f.isParcelRequire = true, f.Module = function(e2) {
        this.id = e2, this.bundle = f, this.exports = {};
      }, f.modules = e, f.cache = r, f.parent = o, f.register = function(r2, t2) {
        e[r2] = [function(e2, r3) {
          r3.exports = t2;
        }, {}];
      };
      for (var c = 0; c < t.length; c++)
        try {
          f(t[c]);
        } catch (e2) {
          i || (i = e2);
        }
      if (t.length) {
        var l = f(t[t.length - 1]);
        "object" == typeof exports && "undefined" != typeof module ? module.exports = l : "function" == typeof define && define.amd ? define(function() {
          return l;
        }) : n && (this[n] = l);
      }
      if (parcelRequire = f, i)
        throw i;
      return f;
    }({ "b1ZG": [function(require2, module2, exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true }), exports2.promisify = e;
      var r = "__ES6-PROMISIFY--CUSTOM-ARGUMENTS__";
      function e(o) {
        if ("function" != typeof o)
          throw new TypeError("Argument to promisify must be a function");
        var n = o[r], t = e.Promise || Promise;
        if ("function" != typeof t)
          throw new Error("No Promise implementation found; do you need a polyfill?");
        return function() {
          for (var r2 = this, e2 = arguments.length, i = Array(e2), f = 0; f < e2; f++)
            i[f] = arguments[f];
          return new t(function(e3, t2) {
            i.push(function(r3) {
              if (r3)
                return t2(r3);
              for (var o2 = arguments.length, i2 = Array(1 < o2 ? o2 - 1 : 0), f2 = 1; f2 < o2; f2++)
                i2[f2 - 1] = arguments[f2];
              if (1 === i2.length || !n)
                return e3(i2[0]);
              var u = {};
              i2.forEach(function(r4, e4) {
                var o3 = n[e4];
                o3 && (u[o3] = r4);
              }), e3(u);
            }), o.apply(r2, i);
          });
        };
      }
      __name(e, "e");
      e.argumentNames = "__ES6-PROMISIFY--CUSTOM-ARGUMENTS__", e.Promise = void 0;
    }, {}], "pBGv": [function(require2, module2, exports2) {
      var t, e, n = module2.exports = {};
      function r() {
        throw new Error("setTimeout has not been defined");
      }
      __name(r, "r");
      function o() {
        throw new Error("clearTimeout has not been defined");
      }
      __name(o, "o");
      function i(e2) {
        if (t === setTimeout)
          return setTimeout(e2, 0);
        if ((t === r || !t) && setTimeout)
          return t = setTimeout, setTimeout(e2, 0);
        try {
          return t(e2, 0);
        } catch (n2) {
          try {
            return t.call(null, e2, 0);
          } catch (n3) {
            return t.call(this, e2, 0);
          }
        }
      }
      __name(i, "i");
      function u(t2) {
        if (e === clearTimeout)
          return clearTimeout(t2);
        if ((e === o || !e) && clearTimeout)
          return e = clearTimeout, clearTimeout(t2);
        try {
          return e(t2);
        } catch (n2) {
          try {
            return e.call(null, t2);
          } catch (n3) {
            return e.call(this, t2);
          }
        }
      }
      __name(u, "u");
      !function() {
        try {
          t = "function" == typeof setTimeout ? setTimeout : r;
        } catch (n2) {
          t = r;
        }
        try {
          e = "function" == typeof clearTimeout ? clearTimeout : o;
        } catch (n2) {
          e = o;
        }
      }();
      var c, s = [], l = false, a = -1;
      function f() {
        l && c && (l = false, c.length ? s = c.concat(s) : a = -1, s.length && h());
      }
      __name(f, "f");
      function h() {
        if (!l) {
          var t2 = i(f);
          l = true;
          for (var e2 = s.length; e2; ) {
            for (c = s, s = []; ++a < e2; )
              c && c[a].run();
            a = -1, e2 = s.length;
          }
          c = null, l = false, u(t2);
        }
      }
      __name(h, "h");
      function m(t2, e2) {
        this.fun = t2, this.array = e2;
      }
      __name(m, "m");
      function p() {
      }
      __name(p, "p");
      n.nextTick = function(t2) {
        var e2 = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var n2 = 1; n2 < arguments.length; n2++)
            e2[n2 - 1] = arguments[n2];
        s.push(new m(t2, e2)), 1 !== s.length || l || i(h);
      }, m.prototype.run = function() {
        this.fun.apply(null, this.array);
      }, n.title = "browser", n.env = {}, n.argv = [], n.version = "", n.versions = {}, n.on = p, n.addListener = p, n.once = p, n.off = p, n.removeListener = p, n.removeAllListeners = p, n.emit = p, n.prependListener = p, n.prependOnceListener = p, n.listeners = function(t2) {
        return [];
      }, n.binding = function(t2) {
        throw new Error("process.binding is not supported");
      }, n.cwd = function() {
        return "/";
      }, n.chdir = function(t2) {
        throw new Error("process.chdir is not supported");
      }, n.umask = function() {
        return 0;
      };
    }, {}], "UUq2": [function(require2, module2, exports2) {
      var process2 = require2("process");
      var r = require2("process");
      function t(r2, t2) {
        for (var e2 = 0, n2 = r2.length - 1; n2 >= 0; n2--) {
          var o2 = r2[n2];
          "." === o2 ? r2.splice(n2, 1) : ".." === o2 ? (r2.splice(n2, 1), e2++) : e2 && (r2.splice(n2, 1), e2--);
        }
        if (t2)
          for (; e2--; e2)
            r2.unshift("..");
        return r2;
      }
      __name(t, "t");
      function e(r2) {
        "string" != typeof r2 && (r2 += "");
        var t2, e2 = 0, n2 = -1, o2 = true;
        for (t2 = r2.length - 1; t2 >= 0; --t2)
          if (47 === r2.charCodeAt(t2)) {
            if (!o2) {
              e2 = t2 + 1;
              break;
            }
          } else
            -1 === n2 && (o2 = false, n2 = t2 + 1);
        return -1 === n2 ? "" : r2.slice(e2, n2);
      }
      __name(e, "e");
      function n(r2, t2) {
        if (r2.filter)
          return r2.filter(t2);
        for (var e2 = [], n2 = 0; n2 < r2.length; n2++)
          t2(r2[n2], n2, r2) && e2.push(r2[n2]);
        return e2;
      }
      __name(n, "n");
      exports2.resolve = function() {
        for (var e2 = "", o2 = false, s = arguments.length - 1; s >= -1 && !o2; s--) {
          var i = s >= 0 ? arguments[s] : r.cwd();
          if ("string" != typeof i)
            throw new TypeError("Arguments to path.resolve must be strings");
          i && (e2 = i + "/" + e2, o2 = "/" === i.charAt(0));
        }
        return (o2 ? "/" : "") + (e2 = t(n(e2.split("/"), function(r2) {
          return !!r2;
        }), !o2).join("/")) || ".";
      }, exports2.normalize = function(r2) {
        var e2 = exports2.isAbsolute(r2), s = "/" === o(r2, -1);
        return (r2 = t(n(r2.split("/"), function(r3) {
          return !!r3;
        }), !e2).join("/")) || e2 || (r2 = "."), r2 && s && (r2 += "/"), (e2 ? "/" : "") + r2;
      }, exports2.isAbsolute = function(r2) {
        return "/" === r2.charAt(0);
      }, exports2.join = function() {
        var r2 = Array.prototype.slice.call(arguments, 0);
        return exports2.normalize(n(r2, function(r3, t2) {
          if ("string" != typeof r3)
            throw new TypeError("Arguments to path.join must be strings");
          return r3;
        }).join("/"));
      }, exports2.relative = function(r2, t2) {
        function e2(r3) {
          for (var t3 = 0; t3 < r3.length && "" === r3[t3]; t3++)
            ;
          for (var e3 = r3.length - 1; e3 >= 0 && "" === r3[e3]; e3--)
            ;
          return t3 > e3 ? [] : r3.slice(t3, e3 - t3 + 1);
        }
        __name(e2, "e");
        r2 = exports2.resolve(r2).substr(1), t2 = exports2.resolve(t2).substr(1);
        for (var n2 = e2(r2.split("/")), o2 = e2(t2.split("/")), s = Math.min(n2.length, o2.length), i = s, u = 0; u < s; u++)
          if (n2[u] !== o2[u]) {
            i = u;
            break;
          }
        var f = [];
        for (u = i; u < n2.length; u++)
          f.push("..");
        return (f = f.concat(o2.slice(i))).join("/");
      }, exports2.sep = "/", exports2.delimiter = ":", exports2.dirname = function(r2) {
        if ("string" != typeof r2 && (r2 += ""), 0 === r2.length)
          return ".";
        for (var t2 = r2.charCodeAt(0), e2 = 47 === t2, n2 = -1, o2 = true, s = r2.length - 1; s >= 1; --s)
          if (47 === (t2 = r2.charCodeAt(s))) {
            if (!o2) {
              n2 = s;
              break;
            }
          } else
            o2 = false;
        return -1 === n2 ? e2 ? "/" : "." : e2 && 1 === n2 ? "/" : r2.slice(0, n2);
      }, exports2.basename = function(r2, t2) {
        var n2 = e(r2);
        return t2 && n2.substr(-1 * t2.length) === t2 && (n2 = n2.substr(0, n2.length - t2.length)), n2;
      }, exports2.extname = function(r2) {
        "string" != typeof r2 && (r2 += "");
        for (var t2 = -1, e2 = 0, n2 = -1, o2 = true, s = 0, i = r2.length - 1; i >= 0; --i) {
          var u = r2.charCodeAt(i);
          if (47 !== u)
            -1 === n2 && (o2 = false, n2 = i + 1), 46 === u ? -1 === t2 ? t2 = i : 1 !== s && (s = 1) : -1 !== t2 && (s = -1);
          else if (!o2) {
            e2 = i + 1;
            break;
          }
        }
        return -1 === t2 || -1 === n2 || 0 === s || 1 === s && t2 === n2 - 1 && t2 === e2 + 1 ? "" : r2.slice(t2, n2);
      };
      var o = "b" === "ab".substr(-1) ? function(r2, t2, e2) {
        return r2.substr(t2, e2);
      } : function(r2, t2, e2) {
        return t2 < 0 && (t2 = r2.length + t2), r2.substr(t2, e2);
      };
    }, { "process": "pBGv" }], "UzoP": [function(require2, module2, exports2) {
      var process2 = require2("process");
      var r = require2("process");
      r.cwd = function() {
        return "/";
      };
      var e = require2("path"), n = Object.assign({}, e);
      n.basename = function(r2, n2) {
        var i = e.basename(r2, n2);
        return "" === i ? "/" : i;
      }, n.normalize = function(r2) {
        return "/" === (r2 = e.normalize(r2)) ? r2 : n.removeTrailing(r2);
      }, n.isNull = function(r2) {
        return -1 !== ("" + r2).indexOf("\0");
      }, n.addTrailing = function(r2) {
        return r2.replace(/\/*$/, "/");
      }, n.removeTrailing = function(r2) {
        return "" === (r2 = r2.replace(/\/*$/, "")) ? "/" : r2;
      }, module2.exports = n;
    }, { "path": "UUq2", "process": "pBGv" }], "iJA9": [function(require2, module2, exports2) {
      var _ = "READ", E = "WRITE", O = "CREATE", R = "EXCLUSIVE", I = "TRUNCATE", S = "APPEND", T = "CREATE", N = "REPLACE";
      module2.exports = { FILE_SYSTEM_NAME: "local", FILE_STORE_NAME: "files", IDB_RO: "readonly", IDB_RW: "readwrite", WSQL_VERSION: "1", WSQL_SIZE: 5242880, WSQL_DESC: "FileSystem Storage", NODE_TYPE_FILE: "FILE", NODE_TYPE_DIRECTORY: "DIRECTORY", NODE_TYPE_SYMBOLIC_LINK: "SYMLINK", NODE_TYPE_META: "META", DEFAULT_DIR_PERMISSIONS: 493, DEFAULT_FILE_PERMISSIONS: 420, FULL_READ_WRITE_EXEC_PERMISSIONS: 511, READ_WRITE_PERMISSIONS: 438, SYMLOOP_MAX: 10, BINARY_MIME_TYPE: "application/octet-stream", JSON_MIME_TYPE: "application/json", ROOT_DIRECTORY_NAME: "/", FS_FORMAT: "FORMAT", FS_NOCTIME: "NOCTIME", FS_NOMTIME: "NOMTIME", FS_NODUPEIDCHECK: "FS_NODUPEIDCHECK", O_READ: _, O_WRITE: E, O_CREATE: O, O_EXCLUSIVE: R, O_TRUNCATE: I, O_APPEND: S, O_FLAGS: { r: [_], "r+": [_, E], w: [E, O, I], "w+": [E, _, O, I], wx: [E, O, R, I], "wx+": [E, _, O, R, I], a: [E, O, S], "a+": [E, _, O, S], ax: [E, O, R, S], "ax+": [E, _, O, R, S] }, XATTR_CREATE: T, XATTR_REPLACE: N, FS_READY: "READY", FS_PENDING: "PENDING", FS_ERROR: "ERROR", SUPER_NODE_ID: "00000000-0000-0000-0000-000000000000", STDIN: 0, STDOUT: 1, STDERR: 2, FIRST_DESCRIPTOR: 3, ENVIRONMENT: { TMP: "/tmp", PATH: "" }, fsConstants: { O_RDONLY: 0, O_WRONLY: 1, O_RDWR: 2, S_IFMT: 61440, S_IFREG: 32768, S_IFDIR: 16384, S_IFCHR: 8192, S_IFBLK: 24576, S_IFIFO: 4096, S_IFLNK: 40960, S_IFSOCK: 49152, O_CREAT: 512, O_EXCL: 2048, O_NOCTTY: 131072, O_TRUNC: 1024, O_APPEND: 8, O_DIRECTORY: 1048576, O_NOFOLLOW: 256, O_SYNC: 128, O_DSYNC: 4194304, O_SYMLINK: 2097152, O_NONBLOCK: 4, S_IRWXU: 448, S_IRUSR: 256, S_IWUSR: 128, S_IXUSR: 64, S_IRWXG: 56, S_IRGRP: 32, S_IWGRP: 16, S_IXGRP: 8, S_IRWXO: 7, S_IROTH: 4, S_IWOTH: 2, S_IXOTH: 1, F_OK: 0, R_OK: 4, W_OK: 2, X_OK: 1, UV_FS_COPYFILE_EXCL: 1, COPYFILE_EXCL: 1 } };
    }, {}], "yh9p": [function(require2, module2, exports2) {
      "use strict";
      exports2.byteLength = u, exports2.toByteArray = i, exports2.fromByteArray = d;
      for (var r = [], t = [], e = "undefined" != typeof Uint8Array ? Uint8Array : Array, n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", o = 0, a = n.length; o < a; ++o)
        r[o] = n[o], t[n.charCodeAt(o)] = o;
      function h(r2) {
        var t2 = r2.length;
        if (t2 % 4 > 0)
          throw new Error("Invalid string. Length must be a multiple of 4");
        var e2 = r2.indexOf("=");
        return -1 === e2 && (e2 = t2), [e2, e2 === t2 ? 0 : 4 - e2 % 4];
      }
      __name(h, "h");
      function u(r2) {
        var t2 = h(r2), e2 = t2[0], n2 = t2[1];
        return 3 * (e2 + n2) / 4 - n2;
      }
      __name(u, "u");
      function c(r2, t2, e2) {
        return 3 * (t2 + e2) / 4 - e2;
      }
      __name(c, "c");
      function i(r2) {
        var n2, o2, a2 = h(r2), u2 = a2[0], i2 = a2[1], f2 = new e(c(r2, u2, i2)), A2 = 0, d2 = i2 > 0 ? u2 - 4 : u2;
        for (o2 = 0; o2 < d2; o2 += 4)
          n2 = t[r2.charCodeAt(o2)] << 18 | t[r2.charCodeAt(o2 + 1)] << 12 | t[r2.charCodeAt(o2 + 2)] << 6 | t[r2.charCodeAt(o2 + 3)], f2[A2++] = n2 >> 16 & 255, f2[A2++] = n2 >> 8 & 255, f2[A2++] = 255 & n2;
        return 2 === i2 && (n2 = t[r2.charCodeAt(o2)] << 2 | t[r2.charCodeAt(o2 + 1)] >> 4, f2[A2++] = 255 & n2), 1 === i2 && (n2 = t[r2.charCodeAt(o2)] << 10 | t[r2.charCodeAt(o2 + 1)] << 4 | t[r2.charCodeAt(o2 + 2)] >> 2, f2[A2++] = n2 >> 8 & 255, f2[A2++] = 255 & n2), f2;
      }
      __name(i, "i");
      function f(t2) {
        return r[t2 >> 18 & 63] + r[t2 >> 12 & 63] + r[t2 >> 6 & 63] + r[63 & t2];
      }
      __name(f, "f");
      function A(r2, t2, e2) {
        for (var n2, o2 = [], a2 = t2; a2 < e2; a2 += 3)
          n2 = (r2[a2] << 16 & 16711680) + (r2[a2 + 1] << 8 & 65280) + (255 & r2[a2 + 2]), o2.push(f(n2));
        return o2.join("");
      }
      __name(A, "A");
      function d(t2) {
        for (var e2, n2 = t2.length, o2 = n2 % 3, a2 = [], h2 = 0, u2 = n2 - o2; h2 < u2; h2 += 16383)
          a2.push(A(t2, h2, h2 + 16383 > u2 ? u2 : h2 + 16383));
        return 1 === o2 ? (e2 = t2[n2 - 1], a2.push(r[e2 >> 2] + r[e2 << 4 & 63] + "==")) : 2 === o2 && (e2 = (t2[n2 - 2] << 8) + t2[n2 - 1], a2.push(r[e2 >> 10] + r[e2 >> 4 & 63] + r[e2 << 2 & 63] + "=")), a2.join("");
      }
      __name(d, "d");
      t["-".charCodeAt(0)] = 62, t["_".charCodeAt(0)] = 63;
    }, {}], "JgNJ": [function(require2, module2, exports2) {
      exports2.read = function(a, o, t, r, h) {
        var M, p, w = 8 * h - r - 1, f = (1 << w) - 1, e = f >> 1, i = -7, N = t ? h - 1 : 0, n = t ? -1 : 1, s = a[o + N];
        for (N += n, M = s & (1 << -i) - 1, s >>= -i, i += w; i > 0; M = 256 * M + a[o + N], N += n, i -= 8)
          ;
        for (p = M & (1 << -i) - 1, M >>= -i, i += r; i > 0; p = 256 * p + a[o + N], N += n, i -= 8)
          ;
        if (0 === M)
          M = 1 - e;
        else {
          if (M === f)
            return p ? NaN : 1 / 0 * (s ? -1 : 1);
          p += Math.pow(2, r), M -= e;
        }
        return (s ? -1 : 1) * p * Math.pow(2, M - r);
      }, exports2.write = function(a, o, t, r, h, M) {
        var p, w, f, e = 8 * M - h - 1, i = (1 << e) - 1, N = i >> 1, n = 23 === h ? Math.pow(2, -24) - Math.pow(2, -77) : 0, s = r ? 0 : M - 1, u = r ? 1 : -1, l = o < 0 || 0 === o && 1 / o < 0 ? 1 : 0;
        for (o = Math.abs(o), isNaN(o) || o === 1 / 0 ? (w = isNaN(o) ? 1 : 0, p = i) : (p = Math.floor(Math.log(o) / Math.LN2), o * (f = Math.pow(2, -p)) < 1 && (p--, f *= 2), (o += p + N >= 1 ? n / f : n * Math.pow(2, 1 - N)) * f >= 2 && (p++, f /= 2), p + N >= i ? (w = 0, p = i) : p + N >= 1 ? (w = (o * f - 1) * Math.pow(2, h), p += N) : (w = o * Math.pow(2, N - 1) * Math.pow(2, h), p = 0)); h >= 8; a[t + s] = 255 & w, s += u, w /= 256, h -= 8)
          ;
        for (p = p << h | w, e += h; e > 0; a[t + s] = 255 & p, s += u, p /= 256, e -= 8)
          ;
        a[t + s - u] |= 128 * l;
      };
    }, {}], "REa7": [function(require2, module2, exports2) {
      var r = {}.toString;
      module2.exports = Array.isArray || function(t) {
        return "[object Array]" == r.call(t);
      };
    }, {}], "dskh": [function(require2, module2, exports2) {
      var global2 = arguments[3];
      var t = arguments[3], r = require2("base64-js"), e = require2("ieee754"), n = require2("isarray");
      function i() {
        try {
          var t2 = new Uint8Array(1);
          return t2.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
            return 42;
          } }, 42 === t2.foo() && "function" == typeof t2.subarray && 0 === t2.subarray(1, 1).byteLength;
        } catch (r2) {
          return false;
        }
      }
      __name(i, "i");
      function o() {
        return f.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
      }
      __name(o, "o");
      function u(t2, r2) {
        if (o() < r2)
          throw new RangeError("Invalid typed array length");
        return f.TYPED_ARRAY_SUPPORT ? (t2 = new Uint8Array(r2)).__proto__ = f.prototype : (null === t2 && (t2 = new f(r2)), t2.length = r2), t2;
      }
      __name(u, "u");
      function f(t2, r2, e2) {
        if (!(f.TYPED_ARRAY_SUPPORT || this instanceof f))
          return new f(t2, r2, e2);
        if ("number" == typeof t2) {
          if ("string" == typeof r2)
            throw new Error("If encoding is specified then the first argument must be a string");
          return c(this, t2);
        }
        return s(this, t2, r2, e2);
      }
      __name(f, "f");
      function s(t2, r2, e2, n2) {
        if ("number" == typeof r2)
          throw new TypeError('"value" argument must not be a number');
        return "undefined" != typeof ArrayBuffer && r2 instanceof ArrayBuffer ? g(t2, r2, e2, n2) : "string" == typeof r2 ? l(t2, r2, e2) : y(t2, r2);
      }
      __name(s, "s");
      function h(t2) {
        if ("number" != typeof t2)
          throw new TypeError('"size" argument must be a number');
        if (t2 < 0)
          throw new RangeError('"size" argument must not be negative');
      }
      __name(h, "h");
      function a(t2, r2, e2, n2) {
        return h(r2), r2 <= 0 ? u(t2, r2) : void 0 !== e2 ? "string" == typeof n2 ? u(t2, r2).fill(e2, n2) : u(t2, r2).fill(e2) : u(t2, r2);
      }
      __name(a, "a");
      function c(t2, r2) {
        if (h(r2), t2 = u(t2, r2 < 0 ? 0 : 0 | w(r2)), !f.TYPED_ARRAY_SUPPORT)
          for (var e2 = 0; e2 < r2; ++e2)
            t2[e2] = 0;
        return t2;
      }
      __name(c, "c");
      function l(t2, r2, e2) {
        if ("string" == typeof e2 && "" !== e2 || (e2 = "utf8"), !f.isEncoding(e2))
          throw new TypeError('"encoding" must be a valid string encoding');
        var n2 = 0 | v(r2, e2), i2 = (t2 = u(t2, n2)).write(r2, e2);
        return i2 !== n2 && (t2 = t2.slice(0, i2)), t2;
      }
      __name(l, "l");
      function p(t2, r2) {
        var e2 = r2.length < 0 ? 0 : 0 | w(r2.length);
        t2 = u(t2, e2);
        for (var n2 = 0; n2 < e2; n2 += 1)
          t2[n2] = 255 & r2[n2];
        return t2;
      }
      __name(p, "p");
      function g(t2, r2, e2, n2) {
        if (r2.byteLength, e2 < 0 || r2.byteLength < e2)
          throw new RangeError("'offset' is out of bounds");
        if (r2.byteLength < e2 + (n2 || 0))
          throw new RangeError("'length' is out of bounds");
        return r2 = void 0 === e2 && void 0 === n2 ? new Uint8Array(r2) : void 0 === n2 ? new Uint8Array(r2, e2) : new Uint8Array(r2, e2, n2), f.TYPED_ARRAY_SUPPORT ? (t2 = r2).__proto__ = f.prototype : t2 = p(t2, r2), t2;
      }
      __name(g, "g");
      function y(t2, r2) {
        if (f.isBuffer(r2)) {
          var e2 = 0 | w(r2.length);
          return 0 === (t2 = u(t2, e2)).length ? t2 : (r2.copy(t2, 0, 0, e2), t2);
        }
        if (r2) {
          if ("undefined" != typeof ArrayBuffer && r2.buffer instanceof ArrayBuffer || "length" in r2)
            return "number" != typeof r2.length || W(r2.length) ? u(t2, 0) : p(t2, r2);
          if ("Buffer" === r2.type && n(r2.data))
            return p(t2, r2.data);
        }
        throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
      }
      __name(y, "y");
      function w(t2) {
        if (t2 >= o())
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + o().toString(16) + " bytes");
        return 0 | t2;
      }
      __name(w, "w");
      function d(t2) {
        return +t2 != t2 && (t2 = 0), f.alloc(+t2);
      }
      __name(d, "d");
      function v(t2, r2) {
        if (f.isBuffer(t2))
          return t2.length;
        if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(t2) || t2 instanceof ArrayBuffer))
          return t2.byteLength;
        "string" != typeof t2 && (t2 = "" + t2);
        var e2 = t2.length;
        if (0 === e2)
          return 0;
        for (var n2 = false; ; )
          switch (r2) {
            case "ascii":
            case "latin1":
            case "binary":
              return e2;
            case "utf8":
            case "utf-8":
            case void 0:
              return $(t2).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return 2 * e2;
            case "hex":
              return e2 >>> 1;
            case "base64":
              return K(t2).length;
            default:
              if (n2)
                return $(t2).length;
              r2 = ("" + r2).toLowerCase(), n2 = true;
          }
      }
      __name(v, "v");
      function E(t2, r2, e2) {
        var n2 = false;
        if ((void 0 === r2 || r2 < 0) && (r2 = 0), r2 > this.length)
          return "";
        if ((void 0 === e2 || e2 > this.length) && (e2 = this.length), e2 <= 0)
          return "";
        if ((e2 >>>= 0) <= (r2 >>>= 0))
          return "";
        for (t2 || (t2 = "utf8"); ; )
          switch (t2) {
            case "hex":
              return x(this, r2, e2);
            case "utf8":
            case "utf-8":
              return Y(this, r2, e2);
            case "ascii":
              return L(this, r2, e2);
            case "latin1":
            case "binary":
              return D(this, r2, e2);
            case "base64":
              return S(this, r2, e2);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return C(this, r2, e2);
            default:
              if (n2)
                throw new TypeError("Unknown encoding: " + t2);
              t2 = (t2 + "").toLowerCase(), n2 = true;
          }
      }
      __name(E, "E");
      function b(t2, r2, e2) {
        var n2 = t2[r2];
        t2[r2] = t2[e2], t2[e2] = n2;
      }
      __name(b, "b");
      function R(t2, r2, e2, n2, i2) {
        if (0 === t2.length)
          return -1;
        if ("string" == typeof e2 ? (n2 = e2, e2 = 0) : e2 > 2147483647 ? e2 = 2147483647 : e2 < -2147483648 && (e2 = -2147483648), e2 = +e2, isNaN(e2) && (e2 = i2 ? 0 : t2.length - 1), e2 < 0 && (e2 = t2.length + e2), e2 >= t2.length) {
          if (i2)
            return -1;
          e2 = t2.length - 1;
        } else if (e2 < 0) {
          if (!i2)
            return -1;
          e2 = 0;
        }
        if ("string" == typeof r2 && (r2 = f.from(r2, n2)), f.isBuffer(r2))
          return 0 === r2.length ? -1 : _(t2, r2, e2, n2, i2);
        if ("number" == typeof r2)
          return r2 &= 255, f.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? i2 ? Uint8Array.prototype.indexOf.call(t2, r2, e2) : Uint8Array.prototype.lastIndexOf.call(t2, r2, e2) : _(t2, [r2], e2, n2, i2);
        throw new TypeError("val must be string, number or Buffer");
      }
      __name(R, "R");
      function _(t2, r2, e2, n2, i2) {
        var o2, u2 = 1, f2 = t2.length, s2 = r2.length;
        if (void 0 !== n2 && ("ucs2" === (n2 = String(n2).toLowerCase()) || "ucs-2" === n2 || "utf16le" === n2 || "utf-16le" === n2)) {
          if (t2.length < 2 || r2.length < 2)
            return -1;
          u2 = 2, f2 /= 2, s2 /= 2, e2 /= 2;
        }
        function h2(t3, r3) {
          return 1 === u2 ? t3[r3] : t3.readUInt16BE(r3 * u2);
        }
        __name(h2, "h");
        if (i2) {
          var a2 = -1;
          for (o2 = e2; o2 < f2; o2++)
            if (h2(t2, o2) === h2(r2, -1 === a2 ? 0 : o2 - a2)) {
              if (-1 === a2 && (a2 = o2), o2 - a2 + 1 === s2)
                return a2 * u2;
            } else
              -1 !== a2 && (o2 -= o2 - a2), a2 = -1;
        } else
          for (e2 + s2 > f2 && (e2 = f2 - s2), o2 = e2; o2 >= 0; o2--) {
            for (var c2 = true, l2 = 0; l2 < s2; l2++)
              if (h2(t2, o2 + l2) !== h2(r2, l2)) {
                c2 = false;
                break;
              }
            if (c2)
              return o2;
          }
        return -1;
      }
      __name(_, "_");
      function A(t2, r2, e2, n2) {
        e2 = Number(e2) || 0;
        var i2 = t2.length - e2;
        n2 ? (n2 = Number(n2)) > i2 && (n2 = i2) : n2 = i2;
        var o2 = r2.length;
        if (o2 % 2 != 0)
          throw new TypeError("Invalid hex string");
        n2 > o2 / 2 && (n2 = o2 / 2);
        for (var u2 = 0; u2 < n2; ++u2) {
          var f2 = parseInt(r2.substr(2 * u2, 2), 16);
          if (isNaN(f2))
            return u2;
          t2[e2 + u2] = f2;
        }
        return u2;
      }
      __name(A, "A");
      function m(t2, r2, e2, n2) {
        return Q($(r2, t2.length - e2), t2, e2, n2);
      }
      __name(m, "m");
      function P(t2, r2, e2, n2) {
        return Q(G(r2), t2, e2, n2);
      }
      __name(P, "P");
      function T(t2, r2, e2, n2) {
        return P(t2, r2, e2, n2);
      }
      __name(T, "T");
      function B(t2, r2, e2, n2) {
        return Q(K(r2), t2, e2, n2);
      }
      __name(B, "B");
      function U(t2, r2, e2, n2) {
        return Q(H(r2, t2.length - e2), t2, e2, n2);
      }
      __name(U, "U");
      function S(t2, e2, n2) {
        return 0 === e2 && n2 === t2.length ? r.fromByteArray(t2) : r.fromByteArray(t2.slice(e2, n2));
      }
      __name(S, "S");
      function Y(t2, r2, e2) {
        e2 = Math.min(t2.length, e2);
        for (var n2 = [], i2 = r2; i2 < e2; ) {
          var o2, u2, f2, s2, h2 = t2[i2], a2 = null, c2 = h2 > 239 ? 4 : h2 > 223 ? 3 : h2 > 191 ? 2 : 1;
          if (i2 + c2 <= e2)
            switch (c2) {
              case 1:
                h2 < 128 && (a2 = h2);
                break;
              case 2:
                128 == (192 & (o2 = t2[i2 + 1])) && (s2 = (31 & h2) << 6 | 63 & o2) > 127 && (a2 = s2);
                break;
              case 3:
                o2 = t2[i2 + 1], u2 = t2[i2 + 2], 128 == (192 & o2) && 128 == (192 & u2) && (s2 = (15 & h2) << 12 | (63 & o2) << 6 | 63 & u2) > 2047 && (s2 < 55296 || s2 > 57343) && (a2 = s2);
                break;
              case 4:
                o2 = t2[i2 + 1], u2 = t2[i2 + 2], f2 = t2[i2 + 3], 128 == (192 & o2) && 128 == (192 & u2) && 128 == (192 & f2) && (s2 = (15 & h2) << 18 | (63 & o2) << 12 | (63 & u2) << 6 | 63 & f2) > 65535 && s2 < 1114112 && (a2 = s2);
            }
          null === a2 ? (a2 = 65533, c2 = 1) : a2 > 65535 && (a2 -= 65536, n2.push(a2 >>> 10 & 1023 | 55296), a2 = 56320 | 1023 & a2), n2.push(a2), i2 += c2;
        }
        return O(n2);
      }
      __name(Y, "Y");
      exports2.Buffer = f, exports2.SlowBuffer = d, exports2.INSPECT_MAX_BYTES = 50, f.TYPED_ARRAY_SUPPORT = void 0 !== t.TYPED_ARRAY_SUPPORT ? t.TYPED_ARRAY_SUPPORT : i(), exports2.kMaxLength = o(), f.poolSize = 8192, f._augment = function(t2) {
        return t2.__proto__ = f.prototype, t2;
      }, f.from = function(t2, r2, e2) {
        return s(null, t2, r2, e2);
      }, f.TYPED_ARRAY_SUPPORT && (f.prototype.__proto__ = Uint8Array.prototype, f.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && f[Symbol.species] === f && Object.defineProperty(f, Symbol.species, { value: null, configurable: true })), f.alloc = function(t2, r2, e2) {
        return a(null, t2, r2, e2);
      }, f.allocUnsafe = function(t2) {
        return c(null, t2);
      }, f.allocUnsafeSlow = function(t2) {
        return c(null, t2);
      }, f.isBuffer = function(t2) {
        return !(null == t2 || !t2._isBuffer);
      }, f.compare = function(t2, r2) {
        if (!f.isBuffer(t2) || !f.isBuffer(r2))
          throw new TypeError("Arguments must be Buffers");
        if (t2 === r2)
          return 0;
        for (var e2 = t2.length, n2 = r2.length, i2 = 0, o2 = Math.min(e2, n2); i2 < o2; ++i2)
          if (t2[i2] !== r2[i2]) {
            e2 = t2[i2], n2 = r2[i2];
            break;
          }
        return e2 < n2 ? -1 : n2 < e2 ? 1 : 0;
      }, f.isEncoding = function(t2) {
        switch (String(t2).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      }, f.concat = function(t2, r2) {
        if (!n(t2))
          throw new TypeError('"list" argument must be an Array of Buffers');
        if (0 === t2.length)
          return f.alloc(0);
        var e2;
        if (void 0 === r2)
          for (r2 = 0, e2 = 0; e2 < t2.length; ++e2)
            r2 += t2[e2].length;
        var i2 = f.allocUnsafe(r2), o2 = 0;
        for (e2 = 0; e2 < t2.length; ++e2) {
          var u2 = t2[e2];
          if (!f.isBuffer(u2))
            throw new TypeError('"list" argument must be an Array of Buffers');
          u2.copy(i2, o2), o2 += u2.length;
        }
        return i2;
      }, f.byteLength = v, f.prototype._isBuffer = true, f.prototype.swap16 = function() {
        var t2 = this.length;
        if (t2 % 2 != 0)
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (var r2 = 0; r2 < t2; r2 += 2)
          b(this, r2, r2 + 1);
        return this;
      }, f.prototype.swap32 = function() {
        var t2 = this.length;
        if (t2 % 4 != 0)
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (var r2 = 0; r2 < t2; r2 += 4)
          b(this, r2, r2 + 3), b(this, r2 + 1, r2 + 2);
        return this;
      }, f.prototype.swap64 = function() {
        var t2 = this.length;
        if (t2 % 8 != 0)
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (var r2 = 0; r2 < t2; r2 += 8)
          b(this, r2, r2 + 7), b(this, r2 + 1, r2 + 6), b(this, r2 + 2, r2 + 5), b(this, r2 + 3, r2 + 4);
        return this;
      }, f.prototype.toString = function() {
        var t2 = 0 | this.length;
        return 0 === t2 ? "" : 0 === arguments.length ? Y(this, 0, t2) : E.apply(this, arguments);
      }, f.prototype.equals = function(t2) {
        if (!f.isBuffer(t2))
          throw new TypeError("Argument must be a Buffer");
        return this === t2 || 0 === f.compare(this, t2);
      }, f.prototype.inspect = function() {
        var t2 = "", r2 = exports2.INSPECT_MAX_BYTES;
        return this.length > 0 && (t2 = this.toString("hex", 0, r2).match(/.{2}/g).join(" "), this.length > r2 && (t2 += " ... ")), "<Buffer " + t2 + ">";
      }, f.prototype.compare = function(t2, r2, e2, n2, i2) {
        if (!f.isBuffer(t2))
          throw new TypeError("Argument must be a Buffer");
        if (void 0 === r2 && (r2 = 0), void 0 === e2 && (e2 = t2 ? t2.length : 0), void 0 === n2 && (n2 = 0), void 0 === i2 && (i2 = this.length), r2 < 0 || e2 > t2.length || n2 < 0 || i2 > this.length)
          throw new RangeError("out of range index");
        if (n2 >= i2 && r2 >= e2)
          return 0;
        if (n2 >= i2)
          return -1;
        if (r2 >= e2)
          return 1;
        if (this === t2)
          return 0;
        for (var o2 = (i2 >>>= 0) - (n2 >>>= 0), u2 = (e2 >>>= 0) - (r2 >>>= 0), s2 = Math.min(o2, u2), h2 = this.slice(n2, i2), a2 = t2.slice(r2, e2), c2 = 0; c2 < s2; ++c2)
          if (h2[c2] !== a2[c2]) {
            o2 = h2[c2], u2 = a2[c2];
            break;
          }
        return o2 < u2 ? -1 : u2 < o2 ? 1 : 0;
      }, f.prototype.includes = function(t2, r2, e2) {
        return -1 !== this.indexOf(t2, r2, e2);
      }, f.prototype.indexOf = function(t2, r2, e2) {
        return R(this, t2, r2, e2, true);
      }, f.prototype.lastIndexOf = function(t2, r2, e2) {
        return R(this, t2, r2, e2, false);
      }, f.prototype.write = function(t2, r2, e2, n2) {
        if (void 0 === r2)
          n2 = "utf8", e2 = this.length, r2 = 0;
        else if (void 0 === e2 && "string" == typeof r2)
          n2 = r2, e2 = this.length, r2 = 0;
        else {
          if (!isFinite(r2))
            throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
          r2 |= 0, isFinite(e2) ? (e2 |= 0, void 0 === n2 && (n2 = "utf8")) : (n2 = e2, e2 = void 0);
        }
        var i2 = this.length - r2;
        if ((void 0 === e2 || e2 > i2) && (e2 = i2), t2.length > 0 && (e2 < 0 || r2 < 0) || r2 > this.length)
          throw new RangeError("Attempt to write outside buffer bounds");
        n2 || (n2 = "utf8");
        for (var o2 = false; ; )
          switch (n2) {
            case "hex":
              return A(this, t2, r2, e2);
            case "utf8":
            case "utf-8":
              return m(this, t2, r2, e2);
            case "ascii":
              return P(this, t2, r2, e2);
            case "latin1":
            case "binary":
              return T(this, t2, r2, e2);
            case "base64":
              return B(this, t2, r2, e2);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return U(this, t2, r2, e2);
            default:
              if (o2)
                throw new TypeError("Unknown encoding: " + n2);
              n2 = ("" + n2).toLowerCase(), o2 = true;
          }
      }, f.prototype.toJSON = function() {
        return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
      };
      var I = 4096;
      function O(t2) {
        var r2 = t2.length;
        if (r2 <= I)
          return String.fromCharCode.apply(String, t2);
        for (var e2 = "", n2 = 0; n2 < r2; )
          e2 += String.fromCharCode.apply(String, t2.slice(n2, n2 += I));
        return e2;
      }
      __name(O, "O");
      function L(t2, r2, e2) {
        var n2 = "";
        e2 = Math.min(t2.length, e2);
        for (var i2 = r2; i2 < e2; ++i2)
          n2 += String.fromCharCode(127 & t2[i2]);
        return n2;
      }
      __name(L, "L");
      function D(t2, r2, e2) {
        var n2 = "";
        e2 = Math.min(t2.length, e2);
        for (var i2 = r2; i2 < e2; ++i2)
          n2 += String.fromCharCode(t2[i2]);
        return n2;
      }
      __name(D, "D");
      function x(t2, r2, e2) {
        var n2 = t2.length;
        (!r2 || r2 < 0) && (r2 = 0), (!e2 || e2 < 0 || e2 > n2) && (e2 = n2);
        for (var i2 = "", o2 = r2; o2 < e2; ++o2)
          i2 += Z(t2[o2]);
        return i2;
      }
      __name(x, "x");
      function C(t2, r2, e2) {
        for (var n2 = t2.slice(r2, e2), i2 = "", o2 = 0; o2 < n2.length; o2 += 2)
          i2 += String.fromCharCode(n2[o2] + 256 * n2[o2 + 1]);
        return i2;
      }
      __name(C, "C");
      function M(t2, r2, e2) {
        if (t2 % 1 != 0 || t2 < 0)
          throw new RangeError("offset is not uint");
        if (t2 + r2 > e2)
          throw new RangeError("Trying to access beyond buffer length");
      }
      __name(M, "M");
      function k(t2, r2, e2, n2, i2, o2) {
        if (!f.isBuffer(t2))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (r2 > i2 || r2 < o2)
          throw new RangeError('"value" argument is out of bounds');
        if (e2 + n2 > t2.length)
          throw new RangeError("Index out of range");
      }
      __name(k, "k");
      function N(t2, r2, e2, n2) {
        r2 < 0 && (r2 = 65535 + r2 + 1);
        for (var i2 = 0, o2 = Math.min(t2.length - e2, 2); i2 < o2; ++i2)
          t2[e2 + i2] = (r2 & 255 << 8 * (n2 ? i2 : 1 - i2)) >>> 8 * (n2 ? i2 : 1 - i2);
      }
      __name(N, "N");
      function z(t2, r2, e2, n2) {
        r2 < 0 && (r2 = 4294967295 + r2 + 1);
        for (var i2 = 0, o2 = Math.min(t2.length - e2, 4); i2 < o2; ++i2)
          t2[e2 + i2] = r2 >>> 8 * (n2 ? i2 : 3 - i2) & 255;
      }
      __name(z, "z");
      function F(t2, r2, e2, n2, i2, o2) {
        if (e2 + n2 > t2.length)
          throw new RangeError("Index out of range");
        if (e2 < 0)
          throw new RangeError("Index out of range");
      }
      __name(F, "F");
      function j(t2, r2, n2, i2, o2) {
        return o2 || F(t2, r2, n2, 4, 34028234663852886e22, -34028234663852886e22), e.write(t2, r2, n2, i2, 23, 4), n2 + 4;
      }
      __name(j, "j");
      function q(t2, r2, n2, i2, o2) {
        return o2 || F(t2, r2, n2, 8, 17976931348623157e292, -17976931348623157e292), e.write(t2, r2, n2, i2, 52, 8), n2 + 8;
      }
      __name(q, "q");
      f.prototype.slice = function(t2, r2) {
        var e2, n2 = this.length;
        if ((t2 = ~~t2) < 0 ? (t2 += n2) < 0 && (t2 = 0) : t2 > n2 && (t2 = n2), (r2 = void 0 === r2 ? n2 : ~~r2) < 0 ? (r2 += n2) < 0 && (r2 = 0) : r2 > n2 && (r2 = n2), r2 < t2 && (r2 = t2), f.TYPED_ARRAY_SUPPORT)
          (e2 = this.subarray(t2, r2)).__proto__ = f.prototype;
        else {
          var i2 = r2 - t2;
          e2 = new f(i2, void 0);
          for (var o2 = 0; o2 < i2; ++o2)
            e2[o2] = this[o2 + t2];
        }
        return e2;
      }, f.prototype.readUIntLE = function(t2, r2, e2) {
        t2 |= 0, r2 |= 0, e2 || M(t2, r2, this.length);
        for (var n2 = this[t2], i2 = 1, o2 = 0; ++o2 < r2 && (i2 *= 256); )
          n2 += this[t2 + o2] * i2;
        return n2;
      }, f.prototype.readUIntBE = function(t2, r2, e2) {
        t2 |= 0, r2 |= 0, e2 || M(t2, r2, this.length);
        for (var n2 = this[t2 + --r2], i2 = 1; r2 > 0 && (i2 *= 256); )
          n2 += this[t2 + --r2] * i2;
        return n2;
      }, f.prototype.readUInt8 = function(t2, r2) {
        return r2 || M(t2, 1, this.length), this[t2];
      }, f.prototype.readUInt16LE = function(t2, r2) {
        return r2 || M(t2, 2, this.length), this[t2] | this[t2 + 1] << 8;
      }, f.prototype.readUInt16BE = function(t2, r2) {
        return r2 || M(t2, 2, this.length), this[t2] << 8 | this[t2 + 1];
      }, f.prototype.readUInt32LE = function(t2, r2) {
        return r2 || M(t2, 4, this.length), (this[t2] | this[t2 + 1] << 8 | this[t2 + 2] << 16) + 16777216 * this[t2 + 3];
      }, f.prototype.readUInt32BE = function(t2, r2) {
        return r2 || M(t2, 4, this.length), 16777216 * this[t2] + (this[t2 + 1] << 16 | this[t2 + 2] << 8 | this[t2 + 3]);
      }, f.prototype.readIntLE = function(t2, r2, e2) {
        t2 |= 0, r2 |= 0, e2 || M(t2, r2, this.length);
        for (var n2 = this[t2], i2 = 1, o2 = 0; ++o2 < r2 && (i2 *= 256); )
          n2 += this[t2 + o2] * i2;
        return n2 >= (i2 *= 128) && (n2 -= Math.pow(2, 8 * r2)), n2;
      }, f.prototype.readIntBE = function(t2, r2, e2) {
        t2 |= 0, r2 |= 0, e2 || M(t2, r2, this.length);
        for (var n2 = r2, i2 = 1, o2 = this[t2 + --n2]; n2 > 0 && (i2 *= 256); )
          o2 += this[t2 + --n2] * i2;
        return o2 >= (i2 *= 128) && (o2 -= Math.pow(2, 8 * r2)), o2;
      }, f.prototype.readInt8 = function(t2, r2) {
        return r2 || M(t2, 1, this.length), 128 & this[t2] ? -1 * (255 - this[t2] + 1) : this[t2];
      }, f.prototype.readInt16LE = function(t2, r2) {
        r2 || M(t2, 2, this.length);
        var e2 = this[t2] | this[t2 + 1] << 8;
        return 32768 & e2 ? 4294901760 | e2 : e2;
      }, f.prototype.readInt16BE = function(t2, r2) {
        r2 || M(t2, 2, this.length);
        var e2 = this[t2 + 1] | this[t2] << 8;
        return 32768 & e2 ? 4294901760 | e2 : e2;
      }, f.prototype.readInt32LE = function(t2, r2) {
        return r2 || M(t2, 4, this.length), this[t2] | this[t2 + 1] << 8 | this[t2 + 2] << 16 | this[t2 + 3] << 24;
      }, f.prototype.readInt32BE = function(t2, r2) {
        return r2 || M(t2, 4, this.length), this[t2] << 24 | this[t2 + 1] << 16 | this[t2 + 2] << 8 | this[t2 + 3];
      }, f.prototype.readFloatLE = function(t2, r2) {
        return r2 || M(t2, 4, this.length), e.read(this, t2, true, 23, 4);
      }, f.prototype.readFloatBE = function(t2, r2) {
        return r2 || M(t2, 4, this.length), e.read(this, t2, false, 23, 4);
      }, f.prototype.readDoubleLE = function(t2, r2) {
        return r2 || M(t2, 8, this.length), e.read(this, t2, true, 52, 8);
      }, f.prototype.readDoubleBE = function(t2, r2) {
        return r2 || M(t2, 8, this.length), e.read(this, t2, false, 52, 8);
      }, f.prototype.writeUIntLE = function(t2, r2, e2, n2) {
        (t2 = +t2, r2 |= 0, e2 |= 0, n2) || k(this, t2, r2, e2, Math.pow(2, 8 * e2) - 1, 0);
        var i2 = 1, o2 = 0;
        for (this[r2] = 255 & t2; ++o2 < e2 && (i2 *= 256); )
          this[r2 + o2] = t2 / i2 & 255;
        return r2 + e2;
      }, f.prototype.writeUIntBE = function(t2, r2, e2, n2) {
        (t2 = +t2, r2 |= 0, e2 |= 0, n2) || k(this, t2, r2, e2, Math.pow(2, 8 * e2) - 1, 0);
        var i2 = e2 - 1, o2 = 1;
        for (this[r2 + i2] = 255 & t2; --i2 >= 0 && (o2 *= 256); )
          this[r2 + i2] = t2 / o2 & 255;
        return r2 + e2;
      }, f.prototype.writeUInt8 = function(t2, r2, e2) {
        return t2 = +t2, r2 |= 0, e2 || k(this, t2, r2, 1, 255, 0), f.TYPED_ARRAY_SUPPORT || (t2 = Math.floor(t2)), this[r2] = 255 & t2, r2 + 1;
      }, f.prototype.writeUInt16LE = function(t2, r2, e2) {
        return t2 = +t2, r2 |= 0, e2 || k(this, t2, r2, 2, 65535, 0), f.TYPED_ARRAY_SUPPORT ? (this[r2] = 255 & t2, this[r2 + 1] = t2 >>> 8) : N(this, t2, r2, true), r2 + 2;
      }, f.prototype.writeUInt16BE = function(t2, r2, e2) {
        return t2 = +t2, r2 |= 0, e2 || k(this, t2, r2, 2, 65535, 0), f.TYPED_ARRAY_SUPPORT ? (this[r2] = t2 >>> 8, this[r2 + 1] = 255 & t2) : N(this, t2, r2, false), r2 + 2;
      }, f.prototype.writeUInt32LE = function(t2, r2, e2) {
        return t2 = +t2, r2 |= 0, e2 || k(this, t2, r2, 4, 4294967295, 0), f.TYPED_ARRAY_SUPPORT ? (this[r2 + 3] = t2 >>> 24, this[r2 + 2] = t2 >>> 16, this[r2 + 1] = t2 >>> 8, this[r2] = 255 & t2) : z(this, t2, r2, true), r2 + 4;
      }, f.prototype.writeUInt32BE = function(t2, r2, e2) {
        return t2 = +t2, r2 |= 0, e2 || k(this, t2, r2, 4, 4294967295, 0), f.TYPED_ARRAY_SUPPORT ? (this[r2] = t2 >>> 24, this[r2 + 1] = t2 >>> 16, this[r2 + 2] = t2 >>> 8, this[r2 + 3] = 255 & t2) : z(this, t2, r2, false), r2 + 4;
      }, f.prototype.writeIntLE = function(t2, r2, e2, n2) {
        if (t2 = +t2, r2 |= 0, !n2) {
          var i2 = Math.pow(2, 8 * e2 - 1);
          k(this, t2, r2, e2, i2 - 1, -i2);
        }
        var o2 = 0, u2 = 1, f2 = 0;
        for (this[r2] = 255 & t2; ++o2 < e2 && (u2 *= 256); )
          t2 < 0 && 0 === f2 && 0 !== this[r2 + o2 - 1] && (f2 = 1), this[r2 + o2] = (t2 / u2 >> 0) - f2 & 255;
        return r2 + e2;
      }, f.prototype.writeIntBE = function(t2, r2, e2, n2) {
        if (t2 = +t2, r2 |= 0, !n2) {
          var i2 = Math.pow(2, 8 * e2 - 1);
          k(this, t2, r2, e2, i2 - 1, -i2);
        }
        var o2 = e2 - 1, u2 = 1, f2 = 0;
        for (this[r2 + o2] = 255 & t2; --o2 >= 0 && (u2 *= 256); )
          t2 < 0 && 0 === f2 && 0 !== this[r2 + o2 + 1] && (f2 = 1), this[r2 + o2] = (t2 / u2 >> 0) - f2 & 255;
        return r2 + e2;
      }, f.prototype.writeInt8 = function(t2, r2, e2) {
        return t2 = +t2, r2 |= 0, e2 || k(this, t2, r2, 1, 127, -128), f.TYPED_ARRAY_SUPPORT || (t2 = Math.floor(t2)), t2 < 0 && (t2 = 255 + t2 + 1), this[r2] = 255 & t2, r2 + 1;
      }, f.prototype.writeInt16LE = function(t2, r2, e2) {
        return t2 = +t2, r2 |= 0, e2 || k(this, t2, r2, 2, 32767, -32768), f.TYPED_ARRAY_SUPPORT ? (this[r2] = 255 & t2, this[r2 + 1] = t2 >>> 8) : N(this, t2, r2, true), r2 + 2;
      }, f.prototype.writeInt16BE = function(t2, r2, e2) {
        return t2 = +t2, r2 |= 0, e2 || k(this, t2, r2, 2, 32767, -32768), f.TYPED_ARRAY_SUPPORT ? (this[r2] = t2 >>> 8, this[r2 + 1] = 255 & t2) : N(this, t2, r2, false), r2 + 2;
      }, f.prototype.writeInt32LE = function(t2, r2, e2) {
        return t2 = +t2, r2 |= 0, e2 || k(this, t2, r2, 4, 2147483647, -2147483648), f.TYPED_ARRAY_SUPPORT ? (this[r2] = 255 & t2, this[r2 + 1] = t2 >>> 8, this[r2 + 2] = t2 >>> 16, this[r2 + 3] = t2 >>> 24) : z(this, t2, r2, true), r2 + 4;
      }, f.prototype.writeInt32BE = function(t2, r2, e2) {
        return t2 = +t2, r2 |= 0, e2 || k(this, t2, r2, 4, 2147483647, -2147483648), t2 < 0 && (t2 = 4294967295 + t2 + 1), f.TYPED_ARRAY_SUPPORT ? (this[r2] = t2 >>> 24, this[r2 + 1] = t2 >>> 16, this[r2 + 2] = t2 >>> 8, this[r2 + 3] = 255 & t2) : z(this, t2, r2, false), r2 + 4;
      }, f.prototype.writeFloatLE = function(t2, r2, e2) {
        return j(this, t2, r2, true, e2);
      }, f.prototype.writeFloatBE = function(t2, r2, e2) {
        return j(this, t2, r2, false, e2);
      }, f.prototype.writeDoubleLE = function(t2, r2, e2) {
        return q(this, t2, r2, true, e2);
      }, f.prototype.writeDoubleBE = function(t2, r2, e2) {
        return q(this, t2, r2, false, e2);
      }, f.prototype.copy = function(t2, r2, e2, n2) {
        if (e2 || (e2 = 0), n2 || 0 === n2 || (n2 = this.length), r2 >= t2.length && (r2 = t2.length), r2 || (r2 = 0), n2 > 0 && n2 < e2 && (n2 = e2), n2 === e2)
          return 0;
        if (0 === t2.length || 0 === this.length)
          return 0;
        if (r2 < 0)
          throw new RangeError("targetStart out of bounds");
        if (e2 < 0 || e2 >= this.length)
          throw new RangeError("sourceStart out of bounds");
        if (n2 < 0)
          throw new RangeError("sourceEnd out of bounds");
        n2 > this.length && (n2 = this.length), t2.length - r2 < n2 - e2 && (n2 = t2.length - r2 + e2);
        var i2, o2 = n2 - e2;
        if (this === t2 && e2 < r2 && r2 < n2)
          for (i2 = o2 - 1; i2 >= 0; --i2)
            t2[i2 + r2] = this[i2 + e2];
        else if (o2 < 1e3 || !f.TYPED_ARRAY_SUPPORT)
          for (i2 = 0; i2 < o2; ++i2)
            t2[i2 + r2] = this[i2 + e2];
        else
          Uint8Array.prototype.set.call(t2, this.subarray(e2, e2 + o2), r2);
        return o2;
      }, f.prototype.fill = function(t2, r2, e2, n2) {
        if ("string" == typeof t2) {
          if ("string" == typeof r2 ? (n2 = r2, r2 = 0, e2 = this.length) : "string" == typeof e2 && (n2 = e2, e2 = this.length), 1 === t2.length) {
            var i2 = t2.charCodeAt(0);
            i2 < 256 && (t2 = i2);
          }
          if (void 0 !== n2 && "string" != typeof n2)
            throw new TypeError("encoding must be a string");
          if ("string" == typeof n2 && !f.isEncoding(n2))
            throw new TypeError("Unknown encoding: " + n2);
        } else
          "number" == typeof t2 && (t2 &= 255);
        if (r2 < 0 || this.length < r2 || this.length < e2)
          throw new RangeError("Out of range index");
        if (e2 <= r2)
          return this;
        var o2;
        if (r2 >>>= 0, e2 = void 0 === e2 ? this.length : e2 >>> 0, t2 || (t2 = 0), "number" == typeof t2)
          for (o2 = r2; o2 < e2; ++o2)
            this[o2] = t2;
        else {
          var u2 = f.isBuffer(t2) ? t2 : $(new f(t2, n2).toString()), s2 = u2.length;
          for (o2 = 0; o2 < e2 - r2; ++o2)
            this[o2 + r2] = u2[o2 % s2];
        }
        return this;
      };
      var V = /[^+\/0-9A-Za-z-_]/g;
      function X(t2) {
        if ((t2 = J(t2).replace(V, "")).length < 2)
          return "";
        for (; t2.length % 4 != 0; )
          t2 += "=";
        return t2;
      }
      __name(X, "X");
      function J(t2) {
        return t2.trim ? t2.trim() : t2.replace(/^\s+|\s+$/g, "");
      }
      __name(J, "J");
      function Z(t2) {
        return t2 < 16 ? "0" + t2.toString(16) : t2.toString(16);
      }
      __name(Z, "Z");
      function $(t2, r2) {
        var e2;
        r2 = r2 || 1 / 0;
        for (var n2 = t2.length, i2 = null, o2 = [], u2 = 0; u2 < n2; ++u2) {
          if ((e2 = t2.charCodeAt(u2)) > 55295 && e2 < 57344) {
            if (!i2) {
              if (e2 > 56319) {
                (r2 -= 3) > -1 && o2.push(239, 191, 189);
                continue;
              }
              if (u2 + 1 === n2) {
                (r2 -= 3) > -1 && o2.push(239, 191, 189);
                continue;
              }
              i2 = e2;
              continue;
            }
            if (e2 < 56320) {
              (r2 -= 3) > -1 && o2.push(239, 191, 189), i2 = e2;
              continue;
            }
            e2 = 65536 + (i2 - 55296 << 10 | e2 - 56320);
          } else
            i2 && (r2 -= 3) > -1 && o2.push(239, 191, 189);
          if (i2 = null, e2 < 128) {
            if ((r2 -= 1) < 0)
              break;
            o2.push(e2);
          } else if (e2 < 2048) {
            if ((r2 -= 2) < 0)
              break;
            o2.push(e2 >> 6 | 192, 63 & e2 | 128);
          } else if (e2 < 65536) {
            if ((r2 -= 3) < 0)
              break;
            o2.push(e2 >> 12 | 224, e2 >> 6 & 63 | 128, 63 & e2 | 128);
          } else {
            if (!(e2 < 1114112))
              throw new Error("Invalid code point");
            if ((r2 -= 4) < 0)
              break;
            o2.push(e2 >> 18 | 240, e2 >> 12 & 63 | 128, e2 >> 6 & 63 | 128, 63 & e2 | 128);
          }
        }
        return o2;
      }
      __name($, "$");
      function G(t2) {
        for (var r2 = [], e2 = 0; e2 < t2.length; ++e2)
          r2.push(255 & t2.charCodeAt(e2));
        return r2;
      }
      __name(G, "G");
      function H(t2, r2) {
        for (var e2, n2, i2, o2 = [], u2 = 0; u2 < t2.length && !((r2 -= 2) < 0); ++u2)
          n2 = (e2 = t2.charCodeAt(u2)) >> 8, i2 = e2 % 256, o2.push(i2), o2.push(n2);
        return o2;
      }
      __name(H, "H");
      function K(t2) {
        return r.toByteArray(X(t2));
      }
      __name(K, "K");
      function Q(t2, r2, e2, n2) {
        for (var i2 = 0; i2 < n2 && !(i2 + e2 >= r2.length || i2 >= t2.length); ++i2)
          r2[i2 + e2] = t2[i2];
        return i2;
      }
      __name(Q, "Q");
      function W(t2) {
        return t2 != t2;
      }
      __name(W, "W");
    }, { "base64-js": "yh9p", "ieee754": "JgNJ", "isarray": "REa7", "buffer": "dskh" }], "QO4x": [function(require2, module2, exports2) {
      var Buffer2 = require2("buffer").Buffer;
      var global2 = arguments[3];
      var t = require2("buffer").Buffer, e = arguments[3], r = require2("../constants.js").FILE_SYSTEM_NAME, n = require2("../constants.js").FILE_STORE_NAME, o = require2("../constants.js").IDB_RW, u = require2("../constants.js").IDB_RO;
      function c(t2, e2) {
        this.db = t2, this.mode = e2;
      }
      __name(c, "c");
      function i(t2) {
        this.name = t2 || r, this.db = null;
      }
      __name(i, "i");
      c.prototype._getObjectStore = function() {
        if (this.objectStore)
          return this.objectStore;
        var t2 = this.db.transaction(n, this.mode);
        return this.objectStore = t2.objectStore(n), this.objectStore;
      }, c.prototype.clear = function(t2) {
        try {
          var e2 = this._getObjectStore().clear();
          e2.onsuccess = function() {
            t2();
          }, e2.onerror = function(e3) {
            e3.preventDefault(), t2(e3.error);
          };
        } catch (r2) {
          t2(r2);
        }
      }, c.prototype._get = function(t2, e2) {
        try {
          var r2 = this._getObjectStore().get(t2);
          r2.onsuccess = function(t3) {
            var r3 = t3.target.result;
            e2(null, r3);
          }, r2.onerror = function(t3) {
            t3.preventDefault(), e2(t3.error);
          };
        } catch (n2) {
          e2(n2);
        }
      }, c.prototype.getObject = function(t2, e2) {
        this._get(t2, e2);
      }, c.prototype.getBuffer = function(e2, r2) {
        this._get(e2, function(e3, n2) {
          if (e3)
            return r2(e3);
          r2(null, t.from(n2));
        });
      }, c.prototype._put = function(t2, e2, r2) {
        try {
          var n2 = this._getObjectStore().put(e2, t2);
          n2.onsuccess = function(t3) {
            var e3 = t3.target.result;
            r2(null, e3);
          }, n2.onerror = function(t3) {
            t3.preventDefault(), r2(t3.error);
          };
        } catch (o2) {
          r2(o2);
        }
      }, c.prototype.putObject = function(t2, e2, r2) {
        this._put(t2, e2, r2);
      }, c.prototype.putBuffer = function(t2, e2, r2) {
        var n2 = e2.buffer;
        this._put(t2, n2, r2);
      }, c.prototype.delete = function(t2, e2) {
        try {
          var r2 = this._getObjectStore().delete(t2);
          r2.onsuccess = function(t3) {
            var r3 = t3.target.result;
            e2(null, r3);
          }, r2.onerror = function(t3) {
            t3.preventDefault(), e2(t3.error);
          };
        } catch (n2) {
          e2(n2);
        }
      }, i.isSupported = function() {
        return !!(e.indexedDB || e.mozIndexedDB || e.webkitIndexedDB || e.msIndexedDB);
      }, i.prototype.open = function(t2) {
        var r2 = this;
        if (r2.db)
          return t2();
        try {
          var o2 = (e.indexedDB || e.mozIndexedDB || e.webkitIndexedDB || e.msIndexedDB).open(r2.name);
          o2.onupgradeneeded = function(t3) {
            var e2 = t3.target.result;
            e2.objectStoreNames.contains(n) && e2.deleteObjectStore(n), e2.createObjectStore(n);
          }, o2.onsuccess = function(e2) {
            r2.db = e2.target.result, t2();
          }, o2.onerror = function(e2) {
            e2.preventDefault(), t2(e2.error);
          };
        } catch (u2) {
          t2(u2);
        }
      }, i.prototype.getReadOnlyContext = function() {
        return new c(this.db, u);
      }, i.prototype.getReadWriteContext = function() {
        return new c(this.db, o);
      }, module2.exports = i;
    }, { "../constants.js": "iJA9", "buffer": "dskh" }], "u4Zs": [function(require2, module2, exports2) {
      var process2 = require2("process");
      var define2;
      var e, t = require2("process");
      !function() {
        var n = {};
        void 0 !== t && t.nextTick ? (n.nextTick = t.nextTick, "undefined" != typeof setImmediate ? n.setImmediate = function(e2) {
          setImmediate(e2);
        } : n.setImmediate = n.nextTick) : "function" == typeof setImmediate ? (n.nextTick = function(e2) {
          setImmediate(e2);
        }, n.setImmediate = n.nextTick) : (n.nextTick = function(e2) {
          setTimeout(e2, 0);
        }, n.setImmediate = n.nextTick), n.eachSeries = function(e2, t2, n2) {
          if (n2 = n2 || function() {
          }, !e2.length)
            return n2();
          var i = 0;
          !(/* @__PURE__ */ __name(function o() {
            t2(e2[i], function(t3) {
              t3 ? (n2(t3), n2 = /* @__PURE__ */ __name(function() {
              }, "n")) : (i += 1) >= e2.length ? n2() : o();
            });
          }, "o"))();
        }, n.forEachSeries = n.eachSeries, void 0 !== e && e.amd ? e([], function() {
          return n;
        }) : "undefined" != typeof module2 && module2.exports ? module2.exports = n : root.async = n;
      }();
    }, { "process": "pBGv" }], "OWym": [function(require2, module2, exports2) {
      var t = require2("../constants.js").FILE_SYSTEM_NAME, e = require2("../../lib/async.js").setImmediate, o = function() {
        var t2 = {};
        return function(e2) {
          return Object.prototype.hasOwnProperty.call(t2, e2) || (t2[e2] = {}), t2[e2];
        };
      }();
      function n(t2, e2) {
        this.readOnly = e2, this.objectStore = t2;
      }
      __name(n, "n");
      function r(e2) {
        this.name = e2 || t;
      }
      __name(r, "r");
      n.prototype.clear = function(t2) {
        if (this.readOnly)
          e(function() {
            t2("[MemoryContext] Error: write operation on read only context");
          });
        else {
          var o2 = this.objectStore;
          Object.keys(o2).forEach(function(t3) {
            delete o2[t3];
          }), e(t2);
        }
      }, n.prototype.getObject = n.prototype.getBuffer = function(t2, o2) {
        var n2 = this;
        e(function() {
          o2(null, n2.objectStore[t2]);
        });
      }, n.prototype.putObject = n.prototype.putBuffer = function(t2, o2, n2) {
        this.readOnly ? e(function() {
          n2("[MemoryContext] Error: write operation on read only context");
        }) : (this.objectStore[t2] = o2, e(n2));
      }, n.prototype.delete = function(t2, o2) {
        this.readOnly ? e(function() {
          o2("[MemoryContext] Error: write operation on read only context");
        }) : (delete this.objectStore[t2], e(o2));
      }, r.isSupported = function() {
        return true;
      }, r.prototype.open = function(t2) {
        this.db = o(this.name), e(t2);
      }, r.prototype.getReadOnlyContext = function() {
        return new n(this.db, true);
      }, r.prototype.getReadWriteContext = function() {
        return new n(this.db, false);
      }, module2.exports = r;
    }, { "../constants.js": "iJA9", "../../lib/async.js": "u4Zs" }], "AiW7": [function(require2, module2, exports2) {
      var e = require2("./indexeddb.js"), r = require2("./memory.js");
      module2.exports = { IndexedDB: e, Default: e, Memory: r };
    }, { "./indexeddb.js": "QO4x", "./memory.js": "OWym" }], "p8GN": [function(require2, module2, exports2) {
      var t = {};
      ["3:EACCES:permission denied", "9:EBADF:bad file descriptor", "10:EBUSY:resource busy or locked", "18:EINVAL:invalid argument", "27:ENOTDIR:not a directory", "28:EISDIR:illegal operation on a directory", "34:ENOENT:no such file or directory", "47:EEXIST:file already exists", "50:EPERM:operation not permitted", "51:ELOOP:too many symbolic links encountered", "53:ENOTEMPTY:directory not empty", "55:EIO:i/o error", "1000:ENOTMOUNTED:not mounted", "1001:EFILESYSTEMERROR:missing super node, use 'FORMAT' flag to format filesystem.", "1002:ENOATTR:attribute does not exist"].forEach(function(e) {
        var o = +(e = e.split(":"))[0], r = e[1], i = e[2];
        function s(t2, e2) {
          Error.call(this), this.name = r, this.code = r, this.errno = o, this.message = t2 || i, e2 && (this.path = e2), this.stack = new Error(this.message).stack;
        }
        __name(s, "s");
        s.prototype = Object.create(Error.prototype), s.prototype.constructor = s, s.prototype.toString = function() {
          var t2 = this.path ? ", '" + this.path + "'" : "";
          return this.name + ": " + this.message + t2;
        }, t[r] = t[o] = s;
      }), module2.exports = t;
    }, {}], "QMiB": [function(require2, module2, exports2) {
      "use strict";
      var t = require2("../constants.js").ENVIRONMENT;
      module2.exports = function(n) {
        (n = n || {}).TMP = n.TMP || t.TMP, n.PATH = n.PATH || t.PATH, this.get = function(t2) {
          return n[t2];
        }, this.set = function(t2, s) {
          n[t2] = s;
        };
      };
    }, { "../constants.js": "iJA9" }], "bQx9": [function(require2, module2, exports2) {
      module2.exports = function(t, o) {
        for (var a = [], e = 0; e < t.length; e++) {
          var n = o(t[e], e);
          r(n) ? a.push.apply(a, n) : a.push(n);
        }
        return a;
      };
      var r = Array.isArray || function(r2) {
        return "[object Array]" === Object.prototype.toString.call(r2);
      };
    }, {}], "D9yG": [function(require2, module2, exports2) {
      "use strict";
      function e(e2, r, i) {
        e2 instanceof RegExp && (e2 = n(e2, i)), r instanceof RegExp && (r = n(r, i));
        var o = t(e2, r, i);
        return o && { start: o[0], end: o[1], pre: i.slice(0, o[0]), body: i.slice(o[0] + e2.length, o[1]), post: i.slice(o[1] + r.length) };
      }
      __name(e, "e");
      function n(e2, n2) {
        var t2 = n2.match(e2);
        return t2 ? t2[0] : null;
      }
      __name(n, "n");
      function t(e2, n2, t2) {
        var r, i, o, f, l, s = t2.indexOf(e2), c = t2.indexOf(n2, s + 1), p = s;
        if (s >= 0 && c > 0) {
          for (r = [], o = t2.length; p >= 0 && !l; )
            p == s ? (r.push(p), s = t2.indexOf(e2, p + 1)) : 1 == r.length ? l = [r.pop(), c] : ((i = r.pop()) < o && (o = i, f = c), c = t2.indexOf(n2, p + 1)), p = s < c && s >= 0 ? s : c;
          r.length && (l = [o, f]);
        }
        return l;
      }
      __name(t, "t");
      module2.exports = e, e.range = t;
    }, {}], "dwXQ": [function(require2, module2, exports2) {
      var t = require2("concat-map"), r = require2("balanced-match");
      module2.exports = f;
      var n = "\0SLASH" + Math.random() + "\0", e = "\0OPEN" + Math.random() + "\0", i = "\0CLOSE" + Math.random() + "\0", o = "\0COMMA" + Math.random() + "\0", a = "\0PERIOD" + Math.random() + "\0";
      function s(t2) {
        return parseInt(t2, 10) == t2 ? parseInt(t2, 10) : t2.charCodeAt(0);
      }
      __name(s, "s");
      function p(t2) {
        return t2.split("\\\\").join(n).split("\\{").join(e).split("\\}").join(i).split("\\,").join(o).split("\\.").join(a);
      }
      __name(p, "p");
      function u(t2) {
        return t2.split(n).join("\\").split(e).join("{").split(i).join("}").split(o).join(",").split(a).join(".");
      }
      __name(u, "u");
      function l(t2) {
        if (!t2)
          return [""];
        var n2 = [], e2 = r("{", "}", t2);
        if (!e2)
          return t2.split(",");
        var i2 = e2.pre, o2 = e2.body, a2 = e2.post, s2 = i2.split(",");
        s2[s2.length - 1] += "{" + o2 + "}";
        var p2 = l(a2);
        return a2.length && (s2[s2.length - 1] += p2.shift(), s2.push.apply(s2, p2)), n2.push.apply(n2, s2), n2;
      }
      __name(l, "l");
      function f(t2) {
        return t2 ? ("{}" === t2.substr(0, 2) && (t2 = "\\{\\}" + t2.substr(2)), m(p(t2), true).map(u)) : [];
      }
      __name(f, "f");
      function h(t2) {
        return t2;
      }
      __name(h, "h");
      function d(t2) {
        return "{" + t2 + "}";
      }
      __name(d, "d");
      function c(t2) {
        return /^-?0\d/.test(t2);
      }
      __name(c, "c");
      function v(t2, r2) {
        return t2 <= r2;
      }
      __name(v, "v");
      function g(t2, r2) {
        return t2 >= r2;
      }
      __name(g, "g");
      function m(n2, e2) {
        var o2 = [], a2 = r("{", "}", n2);
        if (!a2 || /\$$/.test(a2.pre))
          return [n2];
        var p2, u2 = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(a2.body), f2 = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(a2.body), h2 = u2 || f2, b = a2.body.indexOf(",") >= 0;
        if (!h2 && !b)
          return a2.post.match(/,.*\}/) ? m(n2 = a2.pre + "{" + a2.body + i + a2.post) : [n2];
        if (h2)
          p2 = a2.body.split(/\.\./);
        else if (1 === (p2 = l(a2.body)).length && 1 === (p2 = m(p2[0], false).map(d)).length)
          return (M = a2.post.length ? m(a2.post, false) : [""]).map(function(t2) {
            return a2.pre + p2[0] + t2;
          });
        var j, y = a2.pre, M = a2.post.length ? m(a2.post, false) : [""];
        if (h2) {
          var A = s(p2[0]), C = s(p2[1]), O = Math.max(p2[0].length, p2[1].length), S = 3 == p2.length ? Math.abs(s(p2[2])) : 1, $ = v;
          C < A && (S *= -1, $ = g);
          var x = p2.some(c);
          j = [];
          for (var E = A; $(E, C); E += S) {
            var I;
            if (f2)
              "\\" === (I = String.fromCharCode(E)) && (I = "");
            else if (I = String(E), x) {
              var q = O - I.length;
              if (q > 0) {
                var z = new Array(q + 1).join("0");
                I = E < 0 ? "-" + z + I.slice(1) : z + I;
              }
            }
            j.push(I);
          }
        } else
          j = t(p2, function(t2) {
            return m(t2, false);
          });
        for (var L = 0; L < j.length; L++)
          for (var P = 0; P < M.length; P++) {
            var Z = y + j[L] + M[P];
            (!e2 || h2 || Z) && o2.push(Z);
          }
        return o2;
      }
      __name(m, "m");
    }, { "concat-map": "bQx9", "balanced-match": "D9yG" }], "NtKi": [function(require2, module2, exports2) {
      module2.exports = g, g.Minimatch = l;
      var t = { sep: "/" };
      try {
        t = require2("path");
      } catch (O) {
      }
      var e = g.GLOBSTAR = l.GLOBSTAR = {}, n = require2("brace-expansion"), r = { "!": { open: "(?:(?!(?:", close: "))[^/]*?)" }, "?": { open: "(?:", close: ")?" }, "+": { open: "(?:", close: ")+" }, "*": { open: "(?:", close: ")*" }, "@": { open: "(?:", close: ")" } }, i = "[^/]", s = i + "*?", a = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", o = "(?:(?!(?:\\/|^)\\.).)*?", h = c("().*{}+?[]^$\\!");
      function c(t2) {
        return t2.split("").reduce(function(t3, e2) {
          return t3[e2] = true, t3;
        }, {});
      }
      __name(c, "c");
      var u = /\/+/;
      function p(t2, e2) {
        return e2 = e2 || {}, function(n2, r2, i2) {
          return g(n2, t2, e2);
        };
      }
      __name(p, "p");
      function f(t2, e2) {
        t2 = t2 || {}, e2 = e2 || {};
        var n2 = {};
        return Object.keys(e2).forEach(function(t3) {
          n2[t3] = e2[t3];
        }), Object.keys(t2).forEach(function(e3) {
          n2[e3] = t2[e3];
        }), n2;
      }
      __name(f, "f");
      function g(t2, e2, n2) {
        if ("string" != typeof e2)
          throw new TypeError("glob pattern string required");
        return n2 || (n2 = {}), !(!n2.nocomment && "#" === e2.charAt(0)) && ("" === e2.trim() ? "" === t2 : new l(e2, n2).match(t2));
      }
      __name(g, "g");
      function l(e2, n2) {
        if (!(this instanceof l))
          return new l(e2, n2);
        if ("string" != typeof e2)
          throw new TypeError("glob pattern string required");
        n2 || (n2 = {}), e2 = e2.trim(), "/" !== t.sep && (e2 = e2.split(t.sep).join("/")), this.options = n2, this.set = [], this.pattern = e2, this.regexp = null, this.negate = false, this.comment = false, this.empty = false, this.make();
      }
      __name(l, "l");
      function d() {
        if (!this._made) {
          var t2 = this.pattern, e2 = this.options;
          if (e2.nocomment || "#" !== t2.charAt(0))
            if (t2) {
              this.parseNegate();
              var n2 = this.globSet = this.braceExpand();
              e2.debug && (this.debug = console.error), this.debug(this.pattern, n2), n2 = this.globParts = n2.map(function(t3) {
                return t3.split(u);
              }), this.debug(this.pattern, n2), n2 = n2.map(function(t3, e3, n3) {
                return t3.map(this.parse, this);
              }, this), this.debug(this.pattern, n2), n2 = n2.filter(function(t3) {
                return -1 === t3.indexOf(false);
              }), this.debug(this.pattern, n2), this.set = n2;
            } else
              this.empty = true;
          else
            this.comment = true;
        }
      }
      __name(d, "d");
      function b() {
        var t2 = this.pattern, e2 = false, n2 = 0;
        if (!this.options.nonegate) {
          for (var r2 = 0, i2 = t2.length; r2 < i2 && "!" === t2.charAt(r2); r2++)
            e2 = !e2, n2++;
          n2 && (this.pattern = t2.substr(n2)), this.negate = e2;
        }
      }
      __name(b, "b");
      function m(t2, e2) {
        if (e2 || (e2 = this instanceof l ? this.options : {}), void 0 === (t2 = void 0 === t2 ? this.pattern : t2))
          throw new TypeError("undefined pattern");
        return e2.nobrace || !t2.match(/\{.*\}/) ? [t2] : n(t2);
      }
      __name(m, "m");
      g.filter = p, g.defaults = function(t2) {
        if (!t2 || !Object.keys(t2).length)
          return g;
        var e2 = g, n2 = /* @__PURE__ */ __name(function(n3, r2, i2) {
          return e2.minimatch(n3, r2, f(t2, i2));
        }, "n");
        return n2.Minimatch = function(n3, r2) {
          return new e2.Minimatch(n3, f(t2, r2));
        }, n2;
      }, l.defaults = function(t2) {
        return t2 && Object.keys(t2).length ? g.defaults(t2).Minimatch : l;
      }, l.prototype.debug = function() {
      }, l.prototype.make = d, l.prototype.parseNegate = b, g.braceExpand = function(t2, e2) {
        return m(t2, e2);
      }, l.prototype.braceExpand = m, l.prototype.parse = y;
      var v = {};
      function y(t2, n2) {
        if (t2.length > 65536)
          throw new TypeError("pattern is too long");
        var a2 = this.options;
        if (!a2.noglobstar && "**" === t2)
          return e;
        if ("" === t2)
          return "";
        var o2, c2 = "", u2 = !!a2.nocase, p2 = false, f2 = [], g2 = [], l2 = false, d2 = -1, b2 = -1, m2 = "." === t2.charAt(0) ? "" : a2.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", y2 = this;
        function w2() {
          if (o2) {
            switch (o2) {
              case "*":
                c2 += s, u2 = true;
                break;
              case "?":
                c2 += i, u2 = true;
                break;
              default:
                c2 += "\\" + o2;
            }
            y2.debug("clearStateChar %j %j", o2, c2), o2 = false;
          }
        }
        __name(w2, "w");
        for (var x2, j2 = 0, k = t2.length; j2 < k && (x2 = t2.charAt(j2)); j2++)
          if (this.debug("%s	%s %s %j", t2, j2, c2, x2), p2 && h[x2])
            c2 += "\\" + x2, p2 = false;
          else
            switch (x2) {
              case "/":
                return false;
              case "\\":
                w2(), p2 = true;
                continue;
              case "?":
              case "*":
              case "+":
              case "@":
              case "!":
                if (this.debug("%s	%s %s %j <-- stateChar", t2, j2, c2, x2), l2) {
                  this.debug("  in class"), "!" === x2 && j2 === b2 + 1 && (x2 = "^"), c2 += x2;
                  continue;
                }
                y2.debug("call clearStateChar %j", o2), w2(), o2 = x2, a2.noext && w2();
                continue;
              case "(":
                if (l2) {
                  c2 += "(";
                  continue;
                }
                if (!o2) {
                  c2 += "\\(";
                  continue;
                }
                f2.push({ type: o2, start: j2 - 1, reStart: c2.length, open: r[o2].open, close: r[o2].close }), c2 += "!" === o2 ? "(?:(?!(?:" : "(?:", this.debug("plType %j %j", o2, c2), o2 = false;
                continue;
              case ")":
                if (l2 || !f2.length) {
                  c2 += "\\)";
                  continue;
                }
                w2(), u2 = true;
                var A = f2.pop();
                c2 += A.close, "!" === A.type && g2.push(A), A.reEnd = c2.length;
                continue;
              case "|":
                if (l2 || !f2.length || p2) {
                  c2 += "\\|", p2 = false;
                  continue;
                }
                w2(), c2 += "|";
                continue;
              case "[":
                if (w2(), l2) {
                  c2 += "\\" + x2;
                  continue;
                }
                l2 = true, b2 = j2, d2 = c2.length, c2 += x2;
                continue;
              case "]":
                if (j2 === b2 + 1 || !l2) {
                  c2 += "\\" + x2, p2 = false;
                  continue;
                }
                if (l2) {
                  var S = t2.substring(b2 + 1, j2);
                  try {
                    RegExp("[" + S + "]");
                  } catch (O) {
                    var $ = this.parse(S, v);
                    c2 = c2.substr(0, d2) + "\\[" + $[0] + "\\]", u2 = u2 || $[1], l2 = false;
                    continue;
                  }
                }
                u2 = true, l2 = false, c2 += x2;
                continue;
              default:
                w2(), p2 ? p2 = false : !h[x2] || "^" === x2 && l2 || (c2 += "\\"), c2 += x2;
            }
        for (l2 && (S = t2.substr(b2 + 1), $ = this.parse(S, v), c2 = c2.substr(0, d2) + "\\[" + $[0], u2 = u2 || $[1]), A = f2.pop(); A; A = f2.pop()) {
          var R = c2.slice(A.reStart + A.open.length);
          this.debug("setting tail", c2, A), R = R.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(t3, e2, n3) {
            return n3 || (n3 = "\\"), e2 + e2 + n3 + "|";
          }), this.debug("tail=%j\n   %s", R, R, A, c2);
          var T = "*" === A.type ? s : "?" === A.type ? i : "\\" + A.type;
          u2 = true, c2 = c2.slice(0, A.reStart) + T + "\\(" + R;
        }
        w2(), p2 && (c2 += "\\\\");
        var C = false;
        switch (c2.charAt(0)) {
          case ".":
          case "[":
          case "(":
            C = true;
        }
        for (var L = g2.length - 1; L > -1; L--) {
          var q = g2[L], B = c2.slice(0, q.reStart), M = c2.slice(q.reStart, q.reEnd - 8), N = c2.slice(q.reEnd - 8, q.reEnd), _ = c2.slice(q.reEnd);
          N += _;
          var G = B.split("(").length - 1, P = _;
          for (j2 = 0; j2 < G; j2++)
            P = P.replace(/\)[+*?]?/, "");
          var z = "";
          "" === (_ = P) && n2 !== v && (z = "$"), c2 = B + M + _ + z + N;
        }
        if ("" !== c2 && u2 && (c2 = "(?=.)" + c2), C && (c2 = m2 + c2), n2 === v)
          return [c2, u2];
        if (!u2)
          return E(t2);
        var D = a2.nocase ? "i" : "";
        try {
          var F = new RegExp("^" + c2 + "$", D);
        } catch (O) {
          return new RegExp("$.");
        }
        return F._glob = t2, F._src = c2, F;
      }
      __name(y, "y");
      function w() {
        if (this.regexp || false === this.regexp)
          return this.regexp;
        var t2 = this.set;
        if (!t2.length)
          return this.regexp = false, this.regexp;
        var n2 = this.options, r2 = n2.noglobstar ? s : n2.dot ? a : o, i2 = n2.nocase ? "i" : "", h2 = t2.map(function(t3) {
          return t3.map(function(t4) {
            return t4 === e ? r2 : "string" == typeof t4 ? j(t4) : t4._src;
          }).join("\\/");
        }).join("|");
        h2 = "^(?:" + h2 + ")$", this.negate && (h2 = "^(?!" + h2 + ").*$");
        try {
          this.regexp = new RegExp(h2, i2);
        } catch (c2) {
          this.regexp = false;
        }
        return this.regexp;
      }
      __name(w, "w");
      function x(e2, n2) {
        if (this.debug("match", e2, this.pattern), this.comment)
          return false;
        if (this.empty)
          return "" === e2;
        if ("/" === e2 && n2)
          return true;
        var r2 = this.options;
        "/" !== t.sep && (e2 = e2.split(t.sep).join("/")), e2 = e2.split(u), this.debug(this.pattern, "split", e2);
        var i2, s2, a2 = this.set;
        for (this.debug(this.pattern, "set", a2), s2 = e2.length - 1; s2 >= 0 && !(i2 = e2[s2]); s2--)
          ;
        for (s2 = 0; s2 < a2.length; s2++) {
          var o2 = a2[s2], h2 = e2;
          if (r2.matchBase && 1 === o2.length && (h2 = [i2]), this.matchOne(h2, o2, n2))
            return !!r2.flipNegate || !this.negate;
        }
        return !r2.flipNegate && this.negate;
      }
      __name(x, "x");
      function E(t2) {
        return t2.replace(/\\(.)/g, "$1");
      }
      __name(E, "E");
      function j(t2) {
        return t2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
      }
      __name(j, "j");
      g.makeRe = function(t2, e2) {
        return new l(t2, e2 || {}).makeRe();
      }, l.prototype.makeRe = w, g.match = function(t2, e2, n2) {
        var r2 = new l(e2, n2 = n2 || {});
        return t2 = t2.filter(function(t3) {
          return r2.match(t3);
        }), r2.options.nonull && !t2.length && t2.push(e2), t2;
      }, l.prototype.match = x, l.prototype.matchOne = function(t2, n2, r2) {
        var i2 = this.options;
        this.debug("matchOne", { this: this, file: t2, pattern: n2 }), this.debug("matchOne", t2.length, n2.length);
        for (var s2 = 0, a2 = 0, o2 = t2.length, h2 = n2.length; s2 < o2 && a2 < h2; s2++, a2++) {
          this.debug("matchOne loop");
          var c2, u2 = n2[a2], p2 = t2[s2];
          if (this.debug(n2, u2, p2), false === u2)
            return false;
          if (u2 === e) {
            this.debug("GLOBSTAR", [n2, u2, p2]);
            var f2 = s2, g2 = a2 + 1;
            if (g2 === h2) {
              for (this.debug("** at the end"); s2 < o2; s2++)
                if ("." === t2[s2] || ".." === t2[s2] || !i2.dot && "." === t2[s2].charAt(0))
                  return false;
              return true;
            }
            for (; f2 < o2; ) {
              var l2 = t2[f2];
              if (this.debug("\nglobstar while", t2, f2, n2, g2, l2), this.matchOne(t2.slice(f2), n2.slice(g2), r2))
                return this.debug("globstar found match!", f2, o2, l2), true;
              if ("." === l2 || ".." === l2 || !i2.dot && "." === l2.charAt(0)) {
                this.debug("dot detected!", t2, f2, n2, g2);
                break;
              }
              this.debug("globstar swallow a segment, and continue"), f2++;
            }
            return !(!r2 || (this.debug("\n>>> no match, partial?", t2, f2, n2, g2), f2 !== o2));
          }
          if ("string" == typeof u2 ? (c2 = i2.nocase ? p2.toLowerCase() === u2.toLowerCase() : p2 === u2, this.debug("string match", u2, p2, c2)) : (c2 = p2.match(u2), this.debug("pattern match", u2, p2, c2)), !c2)
            return false;
        }
        if (s2 === o2 && a2 === h2)
          return true;
        if (s2 === o2)
          return r2;
        if (a2 === h2)
          return s2 === o2 - 1 && "" === t2[s2];
        throw new Error("wtf?");
      };
    }, { "path": "UUq2", "brace-expansion": "dwXQ" }], "D1Ra": [function(require2, module2, exports2) {
      var n = require2("es6-promisify"), t = n.promisify, e = require2("../path.js"), i = require2("../errors.js"), r = require2("./environment.js"), o = require2("../../lib/async.js"), u = require2("minimatch");
      function c(n2, o2) {
        var u2 = this, c2 = new r((o2 = o2 || {}).env), f = "/";
        Object.defineProperty(this, "fs", { get: function() {
          return n2;
        }, enumerable: true }), Object.defineProperty(this, "env", { get: function() {
          return c2;
        }, enumerable: true }), this.cd = function(t2, r2) {
          t2 = e.resolve(f, t2), n2.stat(t2, function(n3, e2) {
            n3 ? r2(new i.ENOTDIR(null, t2)) : "DIRECTORY" === e2.type ? (f = t2, r2()) : r2(new i.ENOTDIR(null, t2));
          });
        }, this.pwd = function() {
          return f;
        }, this.promises = {}, ["cd", "exec", "touch", "cat", "ls", "rm", "tempDir", "mkdirp", "find"].forEach(function(n3) {
          u2.promises[n3] = t(u2[n3].bind(u2));
        });
      }
      __name(c, "c");
      c.prototype.exec = function(n2, t2, i2) {
        var r2 = this.fs;
        "function" == typeof t2 && (i2 = t2, t2 = []), t2 = t2 || [], i2 = i2 || function() {
        }, n2 = e.resolve(this.pwd(), n2), r2.readFile(n2, "utf8", function(n3, e2) {
          if (n3)
            i2(n3);
          else
            try {
              new Function("fs", "args", "callback", e2)(r2, t2, i2);
            } catch (o2) {
              i2(o2);
            }
        });
      }, c.prototype.touch = function(n2, t2, i2) {
        var r2 = this.fs;
        "function" == typeof t2 && (i2 = t2, t2 = {}), t2 = t2 || {}, i2 = i2 || function() {
        }, n2 = e.resolve(this.pwd(), n2), r2.stat(n2, function(e2) {
          e2 ? true === t2.updateOnly ? i2() : function(n3) {
            r2.writeFile(n3, "", i2);
          }(n2) : function(n3) {
            var e3 = Date.now(), o2 = t2.date || e3, u2 = t2.date || e3;
            r2.utimes(n3, o2, u2, i2);
          }(n2);
        });
      }, c.prototype.cat = function(n2, t2) {
        var r2 = this, u2 = r2.fs, c2 = "";
        t2 = t2 || function() {
        }, n2 ? (n2 = "string" == typeof n2 ? [n2] : n2, o.eachSeries(n2, function(n3, t3) {
          var i2 = e.resolve(r2.pwd(), n3);
          u2.readFile(i2, "utf8", function(n4, e2) {
            n4 ? t3(n4) : (c2 += e2 + "\n", t3());
          });
        }, function(n3) {
          n3 ? t2(n3) : t2(null, c2.replace(/\n$/, ""));
        })) : t2(new i.EINVAL("Missing files argument"));
      }, c.prototype.ls = function(n2, t2, r2) {
        var u2 = this, c2 = u2.fs;
        "function" == typeof t2 && (r2 = t2, t2 = {}), t2 = t2 || {}, r2 = r2 || function() {
        }, n2 ? (/* @__PURE__ */ __name(function n3(i2, r3) {
          var f = e.resolve(u2.pwd(), i2), s = [];
          c2.readdir(f, function(i3, u3) {
            i3 ? r3(i3) : o.eachSeries(u3, function(i4, r4) {
              i4 = e.join(f, i4), c2.stat(i4, function(i5, o2) {
                if (i5)
                  r4(i5);
                else {
                  var u4 = o2;
                  t2.recursive && "DIRECTORY" === o2.type ? n3(e.join(f, u4.name), function(n4, t3) {
                    n4 ? r4(n4) : (u4.contents = t3, s.push(u4), r4());
                  }) : (s.push(u4), r4());
                }
              });
            }, function(n4) {
              r3(n4, s);
            });
          });
        }, "n"))(n2, r2) : r2(new i.EINVAL("Missing dir argument"));
      }, c.prototype.rm = function(n2, t2, r2) {
        var u2 = this, c2 = u2.fs;
        "function" == typeof t2 && (r2 = t2, t2 = {}), t2 = t2 || {}, r2 = r2 || function() {
        }, n2 ? (/* @__PURE__ */ __name(function n3(r3, f) {
          r3 = e.resolve(u2.pwd(), r3), c2.stat(r3, function(u3, s) {
            u3 ? f(u3) : "FILE" !== s.type ? c2.readdir(r3, function(u4, s2) {
              u4 ? f(u4) : 0 !== s2.length ? t2.recursive ? (s2 = s2.map(function(n4) {
                return e.join(r3, n4);
              }), o.eachSeries(s2, n3, function(n4) {
                n4 ? f(n4) : c2.rmdir(r3, f);
              })) : f(new i.ENOTEMPTY(null, r3)) : c2.rmdir(r3, f);
            }) : c2.unlink(r3, f);
          });
        }, "n"))(n2, r2) : r2(new i.EINVAL("Missing path argument"));
      }, c.prototype.tempDir = function(n2) {
        var t2 = this.fs, e2 = this.env.get("TMP");
        n2 = n2 || function() {
        }, t2.mkdir(e2, function() {
          n2(null, e2);
        });
      }, c.prototype.mkdirp = function(n2, t2) {
        var r2 = this.fs;
        t2 = t2 || function() {
        }, n2 ? "/" !== (n2 = e.resolve(this.pwd(), n2)) ? (/* @__PURE__ */ __name(function n3(t3, o2) {
          r2.stat(t3, function(u2, c2) {
            if (c2) {
              if (c2.isDirectory())
                return void o2();
              if (c2.isFile())
                return void o2(new i.ENOTDIR(null, t3));
            } else {
              if (u2 && "ENOENT" !== u2.code)
                return void o2(u2);
              var f = e.dirname(t3);
              "/" === f ? r2.mkdir(t3, function(n4) {
                n4 && "EEXIST" !== n4.code ? o2(n4) : o2();
              }) : n3(f, function(n4) {
                if (n4)
                  return o2(n4);
                r2.mkdir(t3, function(n5) {
                  n5 && "EEXIST" !== n5.code ? o2(n5) : o2();
                });
              });
            }
          });
        }, "n"))(n2, t2) : t2() : t2(new i.EINVAL("Missing path argument"));
      }, c.prototype.find = function(n2, t2, r2) {
        var c2 = this, f = c2.fs;
        "function" == typeof t2 && (r2 = t2, t2 = {}), r2 = r2 || function() {
        };
        var s = (t2 = t2 || {}).exec || function(n3, t3) {
          t3();
        }, a = [];
        function p(n3, i2) {
          var r3 = e.removeTrailing(n3);
          !t2.regex || t2.regex.test(r3) ? t2.name && !u(e.basename(r3), t2.name) || t2.path && !u(e.dirname(r3), t2.path) ? i2() : function(n4, t3) {
            s(n4, function(e2) {
              e2 ? t3(e2) : (a.push(n4), t3());
            });
          }(n3, i2) : i2();
        }
        __name(p, "p");
        function d(n3, t3) {
          n3 = e.resolve(c2.pwd(), n3), f.readdir(n3, function(i2, r3) {
            i2 ? "ENOTDIR" === i2.code ? p(n3, t3) : t3(i2) : p(e.addTrailing(n3), function(i3) {
              i3 ? t3(i3) : (r3 = r3.map(function(t4) {
                return e.join(n3, t4);
              }), o.eachSeries(r3, d, function(n4) {
                t3(n4, a);
              }));
            });
          });
        }
        __name(d, "d");
        n2 ? f.stat(n2, function(t3, e2) {
          t3 ? r2(t3) : e2.isDirectory() ? d(n2, r2) : r2(new i.ENOTDIR(null, n2));
        }) : r2(new i.EINVAL("Missing path argument"));
      }, module2.exports = c;
    }, { "es6-promisify": "b1ZG", "../path.js": "UzoP", "../errors.js": "p8GN", "./environment.js": "QMiB", "../../lib/async.js": "u4Zs", "minimatch": "NtKi" }], "J4Qg": [function(require2, module2, exports2) {
      function t(t2, r2) {
        for (var o2 = r2.length - 1; o2 >= 0; o2--)
          r2[o2] === t2 && r2.splice(o2, 1);
        return r2;
      }
      __name(t, "t");
      var r = /* @__PURE__ */ __name(function() {
      }, "r");
      r.createInterface = function(r2) {
        var o2 = { on: function(t2, o3) {
          void 0 === this[r2] && (this[r2] = {}), this[r2].hasOwnProperty(t2) || (this[r2][t2] = []), this[r2][t2].push(o3);
        }, off: function(o3, e2) {
          void 0 !== this[r2] && this[r2].hasOwnProperty(o3) && t(e2, this[r2][o3]);
        }, trigger: function(t2) {
          if (void 0 !== this[r2] && this[r2].hasOwnProperty(t2))
            for (var o3 = Array.prototype.slice.call(arguments, 1), e2 = 0; e2 < this[r2][t2].length; e2++)
              this[r2][t2][e2].apply(this[r2][t2][e2], o3);
        }, removeAllListeners: function(t2) {
          if (void 0 !== this[r2]) {
            var o3 = this;
            o3[r2][t2].forEach(function(r3) {
              o3.off(t2, r3);
            });
          }
        } };
        return o2;
      };
      var o = r.createInterface("_handlers");
      r.prototype._on = o.on, r.prototype._off = o.off, r.prototype._trigger = o.trigger;
      var e = r.createInterface("handlers");
      r.prototype.on = function() {
        e.on.apply(this, arguments), Array.prototype.unshift.call(arguments, "on"), this._trigger.apply(this, arguments);
      }, r.prototype.off = e.off, r.prototype.trigger = e.trigger, r.prototype.removeAllListeners = e.removeAllListeners, module2.exports = r;
    }, {}], "zBMa": [function(require2, module2, exports2) {
      function x(x2) {
        return x2.replace(/[xy]/g, function(x3) {
          var n2 = 16 * Math.random() | 0;
          return ("x" === x3 ? n2 : 3 & n2 | 8).toString(16);
        });
      }
      __name(x, "x");
      function n() {
        return x("xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx").toUpperCase();
      }
      __name(n, "n");
      function r(n2) {
        return x("x".repeat(n2 = n2 || 6));
      }
      __name(r, "r");
      function t() {
      }
      __name(t, "t");
      module2.exports = { guid: n, nop: t, randomChars: r };
    }, {}], "u7Jv": [function(require2, module2, exports2) {
      var global2 = arguments[3];
      var t = arguments[3];
      function e(t2) {
        return (e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      __name(e, "e");
      var n = require2("./eventemitter.js"), o = require2("../src/shared.js").guid;
      function r(t2, e2) {
        var n2 = 0;
        return function() {
          var o2 = Date.now();
          o2 - n2 > t2 && (n2 = o2, e2.apply(this, arguments));
        };
      }
      __name(r, "r");
      function i(t2, n2) {
        if (void 0 !== t2 && t2 || (t2 = {}), "object" === e(n2))
          for (var o2 in n2)
            n2.hasOwnProperty(o2) && (t2[o2] = n2[o2]);
        return t2;
      }
      __name(i, "i");
      var a = function(t2) {
        return void 0 === t2 || void 0 === t2.localStorage ? { getItem: function() {
        }, setItem: function() {
        }, removeItem: function() {
        } } : t2.localStorage;
      }(t);
      function s() {
        var e2 = this, n2 = Date.now();
        this.origin = o(), this.lastMessage = n2, this.receivedIDs = {}, this.previousValues = {};
        var r2 = /* @__PURE__ */ __name(function() {
          e2._onStorageEvent.apply(e2, arguments);
        }, "r");
        "undefined" != typeof document && (document.attachEvent ? document.attachEvent("onstorage", r2) : t.addEventListener("storage", r2, false));
      }
      __name(s, "s");
      s.prototype._transaction = function(t2) {
        var e2 = 1e3, n2 = 20, o2 = this, r2 = false, i2 = false, s2 = null;
        function c2() {
          if (!r2) {
            var u2 = Date.now(), f2 = 0 | a.getItem(p);
            if (f2 && u2 - f2 < e2)
              return i2 || (o2._on("storage", c2), i2 = true), void (s2 = setTimeout(c2, n2));
            r2 = true, a.setItem(p, u2), t2(), function() {
              i2 && o2._off("storage", c2);
              s2 && clearTimeout(s2);
              a.removeItem(p);
            }();
          }
        }
        __name(c2, "c");
        c2();
      }, s.prototype._cleanup_emit = r(100, function() {
        this._transaction(function() {
          var t2, e2 = Date.now() - f, n2 = 0;
          try {
            t2 = JSON.parse(a.getItem(c) || "[]");
          } catch (r2) {
            t2 = [];
          }
          for (var o2 = t2.length - 1; o2 >= 0; o2--)
            t2[o2].timestamp < e2 && (t2.splice(o2, 1), n2++);
          n2 > 0 && a.setItem(c, JSON.stringify(t2));
        });
      }), s.prototype._cleanup_once = r(100, function() {
        var t2 = this;
        t2._transaction(function() {
          Date.now();
          var e2, n2, o2 = 0;
          try {
            n2 = JSON.parse(a.getItem(u) || "{}");
          } catch (r2) {
            n2 = {};
          }
          for (e2 in n2)
            t2._once_expired(e2, n2) && (delete n2[e2], o2++);
          o2 > 0 && a.setItem(u, JSON.stringify(n2));
        });
      }), s.prototype._once_expired = function(t2, n2) {
        if (!n2)
          return true;
        if (!n2.hasOwnProperty(t2))
          return true;
        if ("object" !== e(n2[t2]))
          return true;
        var o2 = n2[t2].ttl || m, r2 = Date.now();
        return n2[t2].timestamp < r2 - o2;
      }, s.prototype._localStorageChanged = function(t2, e2) {
        if (t2 && t2.key)
          return t2.key === e2;
        var n2 = a.getItem(e2);
        return n2 !== this.previousValues[e2] && (this.previousValues[e2] = n2, true);
      }, s.prototype._onStorageEvent = function(e2) {
        e2 = e2 || t.event;
        var n2 = this;
        this._localStorageChanged(e2, c) && this._transaction(function() {
          var t2, e3 = Date.now(), o2 = a.getItem(c);
          try {
            t2 = JSON.parse(o2 || "[]");
          } catch (i2) {
            t2 = [];
          }
          for (var r2 = 0; r2 < t2.length; r2++)
            if (t2[r2].origin !== n2.origin && !(t2[r2].timestamp < n2.lastMessage)) {
              if (t2[r2].id) {
                if (n2.receivedIDs.hasOwnProperty(t2[r2].id))
                  continue;
                n2.receivedIDs[t2[r2].id] = true;
              }
              n2.trigger(t2[r2].name, t2[r2].payload);
            }
          n2.lastMessage = e3;
        }), this._trigger("storage", e2);
      }, s.prototype._emit = function(t2, e2, n2) {
        if ((n2 = "string" == typeof n2 || "number" == typeof n2 ? String(n2) : null) && n2.length) {
          if (this.receivedIDs.hasOwnProperty(n2))
            return;
          this.receivedIDs[n2] = true;
        }
        var o2 = { id: n2, name: t2, origin: this.origin, timestamp: Date.now(), payload: e2 }, r2 = this;
        this._transaction(function() {
          var n3 = a.getItem(c) || "[]", i2 = "[]" === n3 ? "" : ",";
          n3 = [n3.substring(0, n3.length - 1), i2, JSON.stringify(o2), "]"].join(""), a.setItem(c, n3), r2.trigger(t2, e2), setTimeout(function() {
            r2._cleanup_emit();
          }, 50);
        });
      }, s.prototype.emit = function(t2, e2) {
        this._emit.apply(this, arguments), this._trigger("emit", t2, e2);
      }, s.prototype.once = function(t2, e2, n2) {
        if (s.supported) {
          var o2 = this;
          this._transaction(function() {
            var r2;
            try {
              r2 = JSON.parse(a.getItem(u) || "{}");
            } catch (i2) {
              r2 = {};
            }
            o2._once_expired(t2, r2) && (r2[t2] = {}, r2[t2].timestamp = Date.now(), "number" == typeof n2 && (r2[t2].ttl = 1e3 * n2), a.setItem(u, JSON.stringify(r2)), e2(), setTimeout(function() {
              o2._cleanup_once();
            }, 50));
          });
        }
      }, i(s.prototype, n.prototype), s.supported = void 0 !== a;
      var c = "intercom", u = "intercom_once", p = "intercom_lock", f = 5e4, m = 36e5;
      s.destroy = function() {
        a.removeItem(p), a.removeItem(c), a.removeItem(u);
      }, s.getInstance = function() {
        var t2;
        return function() {
          return t2 || (t2 = new s()), t2;
        };
      }(), module2.exports = s;
    }, { "./eventemitter.js": "J4Qg", "../src/shared.js": "zBMa" }], "VLEe": [function(require2, module2, exports2) {
      var e = require2("../lib/eventemitter.js"), t = require2("./path.js"), n = require2("../lib/intercom.js");
      function r() {
        e.call(this);
        var r2, i, o = this, s = false;
        function c(e2) {
          (i === e2 || s && 0 === e2.indexOf(r2)) && o.trigger("change", "change", e2);
        }
        __name(c, "c");
        o.start = function(e2, o2, a) {
          if (!i) {
            if (t.isNull(e2))
              throw new Error("Path must be a string without null bytes.");
            i = t.normalize(e2), (s = true === a) && (r2 = "/" === i ? "/" : i + "/"), n.getInstance().on("change", c);
          }
        }, o.close = function() {
          n.getInstance().off("change", c), o.removeAllListeners("change");
        };
      }
      __name(r, "r");
      r.prototype = new e(), r.prototype.constructor = r, module2.exports = r;
    }, { "../lib/eventemitter.js": "J4Qg", "./path.js": "UzoP", "../lib/intercom.js": "u7Jv" }], "ZECt": [function(require2, module2, exports2) {
      var t = require2("./constants.js").NODE_TYPE_FILE;
      module2.exports = function(s, e) {
        this.id = s, this.type = e || t;
      };
    }, { "./constants.js": "iJA9" }], "osLK": [function(require2, module2, exports2) {
      var r = require2("./constants"), e = r.FIRST_DESCRIPTOR, n = {}, t = /* @__PURE__ */ __name(function() {
        for (var r2 = e; o(r2); )
          r2++;
        return r2;
      }, "t"), o = /* @__PURE__ */ __name(function(r2) {
        return n[r2];
      }, "o"), i = /* @__PURE__ */ __name(function(r2) {
        var e2 = t();
        return n[e2] = r2, e2;
      }, "i"), u = /* @__PURE__ */ __name(function(r2) {
        return delete n[r2];
      }, "u");
      module2.exports = { allocDescriptor: i, releaseDescriptor: u, getOpenFileDescription: o };
    }, { "./constants": "iJA9" }], "KKNo": [function(require2, module2, exports2) {
      function t(t2, i2) {
        if (!(t2 instanceof i2))
          throw new TypeError("Cannot call a class as a function");
      }
      __name(t, "t");
      function i(t2, i2) {
        for (var s2 = 0; s2 < i2.length; s2++) {
          var e2 = i2[s2];
          e2.enumerable = e2.enumerable || false, e2.configurable = true, "value" in e2 && (e2.writable = true), Object.defineProperty(t2, e2.key, e2);
        }
      }
      __name(i, "i");
      function s(t2, s2, e2) {
        return s2 && i(t2.prototype, s2), e2 && i(t2, e2), t2;
      }
      __name(s, "s");
      var e = require2("./constants"), n = e.NODE_TYPE_FILE, r = e.NODE_TYPE_DIRECTORY, a = e.NODE_TYPE_SYMBOLIC_LINK, o = e.DEFAULT_FILE_PERMISSIONS, u = e.DEFAULT_DIR_PERMISSIONS, h = require2("./constants").fsConstants, c = h.S_IFREG, f = h.S_IFDIR, m = h.S_IFLNK;
      function d(t2, i2, s2) {
        if (t2[i2])
          return s2();
        t2.guid(function(e2, n2) {
          if (e2)
            return s2(e2);
          t2[i2] = n2, s2();
        });
      }
      __name(d, "d");
      function l(t2, i2) {
        switch (t2) {
          case r:
            return (i2 || u) | f;
          case a:
            return (i2 || o) | m;
          case n:
          default:
            return (i2 || o) | c;
        }
      }
      __name(l, "l");
      var p = function() {
        function i2(s2) {
          t(this, i2);
          var e2 = Date.now();
          this.id = s2.id, this.data = s2.data, this.size = s2.size || 0, this.atime = s2.atime || e2, this.ctime = s2.ctime || e2, this.mtime = s2.mtime || e2, this.flags = s2.flags || [], this.xattrs = s2.xattrs || {}, this.nlinks = s2.nlinks || 0, "string" == typeof s2.type ? this.type = s2.type : "string" == typeof s2.mode ? this.type = s2.mode : this.type = n, this.permissions = s2.permissions || l(this.type), this.uid = s2.uid || 0, this.gid = s2.gid || 0;
        }
        __name(i2, "i");
        return s(i2, [{ key: "toJSON", value: function() {
          return { id: this.id, data: this.data, size: this.size, atime: this.atime, ctime: this.ctime, mtime: this.ctime, flags: this.flags, xattrs: this.xattrs, nlinks: this.nlinks, mode: this.type, permissions: this.permissions, uid: this.uid, gid: this.gid };
        } }, { key: "mode", get: function() {
          return l(this.type, this.permissions);
        }, set: function(t2) {
          this.permissions = t2;
        } }]), i2;
      }();
      module2.exports.create = function(t2, i2) {
        d(t2, "id", function(s2) {
          if (s2)
            return i2(s2);
          d(t2, "data", function(s3) {
            if (s3)
              return i2(s3);
            i2(null, new p(t2));
          });
        });
      };
    }, { "./constants": "iJA9" }], "XWaV": [function(require2, module2, exports2) {
      var e = require2("./errors.js"), t = require2("./node");
      function i(e2, t2, i2, r) {
        this.path = e2, this.id = t2, this.flags = i2, this.position = r;
      }
      __name(i, "i");
      i.prototype.getNode = function(i2, r) {
        var o = this.id, n = this.path;
        i2.getObject(o, function(i3, o2) {
          return i3 ? r(i3) : o2 ? void t.create(o2, r) : r(new e.EBADF("file descriptor refers to unknown node", n));
        });
      }, module2.exports = i;
    }, { "./errors.js": "p8GN", "./node": "KKNo" }], "JEp0": [function(require2, module2, exports2) {
      var t = require2("./constants.js");
      function e(e2) {
        var i = Date.now();
        this.id = t.SUPER_NODE_ID, this.type = t.NODE_TYPE_META, this.atime = e2.atime || i, this.ctime = e2.ctime || i, this.mtime = e2.mtime || i, this.rnode = e2.rnode;
      }
      __name(e, "e");
      e.create = function(t2, i) {
        t2.guid(function(n, o) {
          n ? i(n) : (t2.rnode = t2.rnode || o, i(null, new e(t2)));
        });
      }, module2.exports = e;
    }, { "./constants.js": "iJA9" }], "dsCT": [function(require2, module2, exports2) {
      "use strict";
      var t = require2("./constants.js"), i = require2("./path.js");
      function e(t2) {
        return new Date(Number(t2));
      }
      __name(e, "e");
      function s(t2, s2, o) {
        this.dev = o, this.node = s2.id, this.type = s2.type, this.size = s2.size, this.nlinks = s2.nlinks, this.atime = e(s2.atime), this.mtime = e(s2.mtime), this.ctime = e(s2.ctime), this.atimeMs = s2.atime, this.mtimeMs = s2.mtime, this.ctimeMs = s2.ctime, this.version = s2.version, this.mode = s2.mode, this.uid = s2.uid, this.gid = s2.gid, this.name = i.basename(t2);
      }
      __name(s, "s");
      s.prototype.isFile = function() {
        return this.type === t.NODE_TYPE_FILE;
      }, s.prototype.isDirectory = function() {
        return this.type === t.NODE_TYPE_DIRECTORY;
      }, s.prototype.isSymbolicLink = function() {
        return this.type === t.NODE_TYPE_SYMBOLIC_LINK;
      }, s.prototype.isSocket = s.prototype.isFIFO = s.prototype.isCharacterDevice = s.prototype.isBlockDevice = function() {
        return false;
      }, module2.exports = s;
    }, { "./constants.js": "iJA9", "./path.js": "UzoP" }], "q4Wu": [function(require2, module2, exports2) {
      "use strict";
      var t = require2("./stats.js");
      function o(r, s, e) {
        this.constructor = o, t.call(this, r, s, e);
      }
      __name(o, "o");
      o.prototype = t.prototype, module2.exports = o;
    }, { "./stats.js": "dsCT" }], "bsBG": [function(require2, module2, exports2) {
      var Buffer2 = require2("buffer").Buffer;
      var e = require2("buffer").Buffer;
      function n(e2) {
        return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
          return typeof e3;
        } : function(e3) {
          return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
        })(e2);
      }
      __name(n, "n");
      var t = require2("../path.js"), i = t.normalize, o = t.dirname, r = t.basename, u = t.isAbsolute, a = require2("../shared.js"), c = require2("../../lib/async.js"), f = require2("../constants.js"), l = f.NODE_TYPE_FILE, s = f.NODE_TYPE_DIRECTORY, p = f.NODE_TYPE_SYMBOLIC_LINK, d = f.NODE_TYPE_META, m = f.FULL_READ_WRITE_EXEC_PERMISSIONS, E = f.ROOT_DIRECTORY_NAME, g = f.SUPER_NODE_ID, w = f.SYMLOOP_MAX, O = f.O_READ, b = f.O_WRITE, y = f.O_CREATE, v = f.O_EXCLUSIVE, N = f.O_APPEND, h = f.O_FLAGS, I = f.XATTR_CREATE, j = f.XATTR_REPLACE, A = f.FS_NOMTIME, D = f.FS_NOCTIME, T = require2("../errors.js"), L = require2("../directory-entry.js"), R = require2("../open-files.js"), _ = require2("../open-file-description.js"), F = require2("../super-node.js"), S = require2("../node.js"), V = require2("../dirent.js"), B = require2("../stats.js");
      function P(e2, n2, t2, i2, o2) {
        var r2 = e2.flags;
        r2.includes(D) && delete i2.ctime, r2.includes(A) && delete i2.mtime;
        var u2 = false;
        function a2(t3) {
          e2.changes.push({ event: "change", path: n2 }), o2(t3);
        }
        __name(a2, "a");
        i2.ctime && (t2.ctime = i2.ctime, t2.atime = i2.ctime, u2 = true), i2.atime && (t2.atime = i2.atime, u2 = true), i2.mtime && (t2.mtime = i2.mtime, u2 = true), u2 ? e2.putObject(t2.id, t2, a2) : a2();
      }
      __name(P, "P");
      function x(e2, n2, t2, u2) {
        if (t2 !== s && t2 !== l)
          return u2(new T.EINVAL("type must be a directory or file", n2));
        n2 = i(n2);
        var a2, c2, f2, p2 = r(n2), d2 = o(n2);
        function m2(t3, i2) {
          !t3 && i2 ? u2(new T.EEXIST("path name already exists", n2)) : !t3 || t3 instanceof T.ENOENT ? e2.getObject(a2.data, E2) : u2(t3);
        }
        __name(m2, "m");
        function E2(n3, i2) {
          n3 ? u2(n3) : (c2 = i2, S.create({ guid: e2.guid, type: t2 }, function(n4, t3) {
            n4 ? u2(n4) : ((f2 = t3).nlinks += 1, e2.putObject(f2.id, f2, w2));
          }));
        }
        __name(E2, "E");
        function g2(n3) {
          if (n3)
            u2(n3);
          else {
            var t3 = Date.now();
            P(e2, d2, f2, { mtime: t3, ctime: t3 }, u2);
          }
        }
        __name(g2, "g");
        function w2(n3) {
          n3 ? u2(n3) : (c2[p2] = new L(f2.id, t2), e2.putObject(a2.data, c2, g2));
        }
        __name(w2, "w");
        k(e2, d2, function(t3, i2) {
          t3 ? u2(t3) : i2.type !== s ? u2(new T.ENOTDIR("a component of the path prefix is not a directory", n2)) : (a2 = i2, k(e2, n2, m2));
        });
      }
      __name(x, "x");
      function k(e2, n2, t2) {
        if (!(n2 = i(n2)))
          return t2(new T.ENOENT("path is an empty string"));
        var u2 = r(n2), a2 = o(n2), c2 = 0;
        function f2(n3, i2) {
          if (n3)
            return t2(n3);
          var o2 = new F(i2);
          o2 && o2.type === d && o2.rnode ? e2.getObject(o2.rnode, l2) : t2(new T.EFILESYSTEMERROR());
        }
        __name(f2, "f");
        function l2(e3, n3) {
          e3 ? t2(e3) : n3 ? S.create(n3, t2) : t2(new T.ENOENT());
        }
        __name(l2, "l");
        function m2(i2, o2) {
          i2 ? t2(i2) : o2.type === s && o2.data ? e2.getObject(o2.data, O2) : t2(new T.ENOTDIR("a component of the path prefix is not a directory", n2));
        }
        __name(m2, "m");
        function O2(i2, o2) {
          if (i2)
            t2(i2);
          else if (Object.prototype.hasOwnProperty.call(o2, u2)) {
            var r2 = o2[u2].id;
            e2.getObject(r2, b2);
          } else
            t2(new T.ENOENT(null, n2));
        }
        __name(O2, "O");
        function b2(e3, n3) {
          if (e3)
            return t2(e3);
          S.create(n3, y2);
        }
        __name(b2, "b");
        function y2(l3, s2) {
          var d2;
          l3 ? t2(l3) : s2.type === p ? ++c2 > w ? t2(new T.ELOOP(null, n2)) : (d2 = s2.data, d2 = i(d2), a2 = o(d2), u2 = r(d2), E === u2 ? e2.getObject(g, f2) : k(e2, a2, m2)) : t2(null, s2);
        }
        __name(y2, "y");
        E === u2 ? e2.getObject(g, f2) : k(e2, a2, m2);
      }
      __name(k, "k");
      function C(e2, n2, t2, i2, o2, r2, u2) {
        var a2 = t2.xattrs;
        r2 === I && Object.prototype.hasOwnProperty.call(a2, i2) ? u2(new T.EEXIST("attribute already exists", n2)) : r2 !== j || Object.prototype.hasOwnProperty.call(a2, i2) ? (a2[i2] = o2, e2.putObject(t2.id, t2, function(i3) {
          i3 ? u2(i3) : P(e2, n2, t2, { ctime: Date.now() }, u2);
        })) : u2(new T.ENOATTR(null, n2));
      }
      __name(C, "C");
      function X(e2, n2) {
        var t2, i2, o2;
        function r2(o3) {
          o3 ? n2(o3) : S.create({ guid: e2.guid, id: t2.rnode, type: s }, function(t3, o4) {
            t3 ? n2(t3) : ((i2 = o4).nlinks += 1, e2.putObject(i2.id, i2, u2));
          });
        }
        __name(r2, "r");
        function u2(t3) {
          t3 ? n2(t3) : (o2 = {}, e2.putObject(i2.data, o2, n2));
        }
        __name(u2, "u");
        e2.getObject(g, function(i3, o3) {
          !i3 && o3 ? n2() : !i3 || i3 instanceof T.ENOENT ? F.create({ guid: e2.guid }, function(i4, o4) {
            i4 ? n2(i4) : (t2 = o4, e2.putObject(t2.id, t2, r2));
          }) : n2(i3);
        });
      }
      __name(X, "X");
      function q(e2, n2, t2) {
        n2 = i(n2);
        var u2, a2, c2, f2, l2 = r(n2), p2 = o(n2);
        function d2(n3, i2) {
          n3 ? t2(n3) : (c2 = i2, e2.getObject(c2.data, m2));
        }
        __name(d2, "d");
        function m2(n3, i2) {
          n3 ? t2(n3) : (f2 = i2, S.create({ guid: e2.guid, type: s }, function(n4, i3) {
            n4 ? t2(n4) : ((u2 = i3).nlinks += 1, e2.putObject(u2.id, u2, E2));
          }));
        }
        __name(m2, "m");
        function E2(n3) {
          n3 ? t2(n3) : (a2 = {}, e2.putObject(u2.data, a2, w2));
        }
        __name(E2, "E");
        function g2(n3) {
          if (n3)
            t2(n3);
          else {
            var i2 = Date.now();
            P(e2, p2, c2, { mtime: i2, ctime: i2 }, t2);
          }
        }
        __name(g2, "g");
        function w2(n3) {
          n3 ? t2(n3) : (f2[l2] = new L(u2.id, s), e2.putObject(c2.data, f2, g2));
        }
        __name(w2, "w");
        k(e2, n2, function(i2, o2) {
          !i2 && o2 ? t2(new T.EEXIST(null, n2)) : !i2 || i2 instanceof T.ENOENT ? k(e2, p2, d2) : t2(i2);
        });
      }
      __name(q, "q");
      function M(e2, n2, t2, o2) {
        var r2 = f.fsConstants, u2 = r2.F_OK, a2 = r2.R_OK, c2 = r2.W_OK, l2 = r2.X_OK, s2 = r2.S_IXUSR, p2 = r2.S_IXGRP, d2 = r2.S_IXOTH;
        k(e2, n2 = i(n2), function(e3, i2) {
          if (e3)
            return o2(e3);
          if (t2 === u2)
            return o2(null);
          var r3 = xe(i2.mode, o2);
          return r3 ? t2 & (a2 | c2) ? o2(null) : t2 & l2 && r3 & (s2 | p2 | d2) ? o2(null) : void o2(new T.EACCES("permission denied", n2)) : void 0;
        });
      }
      __name(M, "M");
      function z(e2, n2, t2) {
        n2 = i(n2);
        var u2, a2, c2, f2, l2 = r(n2), p2 = o(n2);
        function d2(i2, o2) {
          i2 ? t2(i2) : E === l2 ? t2(new T.EBUSY(null, n2)) : Object.prototype.hasOwnProperty.call(o2, l2) ? (u2 = (f2 = o2)[l2].id, e2.getObject(u2, m2)) : t2(new T.ENOENT(null, n2));
        }
        __name(d2, "d");
        function m2(i2, o2) {
          i2 ? t2(i2) : o2.type !== s ? t2(new T.ENOTDIR(null, n2)) : (u2 = o2, e2.getObject(u2.data, g2));
        }
        __name(m2, "m");
        function g2(i2, o2) {
          i2 ? t2(i2) : (a2 = o2, Object.keys(a2).length > 0 ? t2(new T.ENOTEMPTY(null, n2)) : (delete f2[l2], e2.putObject(c2.data, f2, w2)));
        }
        __name(g2, "g");
        function w2(n3) {
          if (n3)
            t2(n3);
          else {
            var i2 = Date.now();
            P(e2, p2, c2, { mtime: i2, ctime: i2 }, O2);
          }
        }
        __name(w2, "w");
        function O2(n3) {
          n3 ? t2(n3) : e2.delete(u2.id, b2);
        }
        __name(O2, "O");
        function b2(n3) {
          n3 ? t2(n3) : e2.delete(u2.data, t2);
        }
        __name(b2, "b");
        k(e2, p2, function(n3, i2) {
          n3 ? t2(n3) : (c2 = i2, e2.getObject(c2.data, d2));
        });
      }
      __name(z, "z");
      function Y(n2, t2, u2, a2, c2) {
        "function" == typeof a2 && (c2 = a2, a2 = null), t2 = i(t2);
        var f2, d2, m2, g2, O2, N2 = r(t2), h2 = o(t2), I2 = 0;
        function j2(e2, i2) {
          e2 ? c2(e2) : i2.type !== s ? c2(new T.ENOENT(null, t2)) : (f2 = i2, n2.getObject(f2.data, A2));
        }
        __name(j2, "j");
        function A2(e2, i2) {
          e2 ? c2(e2) : (d2 = i2, Object.prototype.hasOwnProperty.call(d2, N2) ? u2.includes(v) ? c2(new T.EEXIST("O_CREATE and O_EXCLUSIVE are set, and the named file exists", t2)) : (m2 = d2[N2]).type === s && u2.includes(b) ? c2(new T.EISDIR("the named file is a directory and O_WRITE is set", t2)) : n2.getObject(m2.id, D2) : u2.includes(y) ? S.create({ guid: n2.guid, type: l }, function(e3, t3) {
            e3 ? c2(e3) : ((g2 = t3).nlinks += 1, a2 && (g2.mode = a2), n2.putObject(g2.id, g2, _2));
          }) : c2(new T.ENOENT("O_CREATE is not set and the named file does not exist", t2)));
        }
        __name(A2, "A");
        function D2(e2, a3) {
          if (e2)
            c2(e2);
          else {
            var f3 = a3;
            f3.type === p ? ++I2 > w ? c2(new T.ELOOP(null, t2)) : function(e3) {
              e3 = i(e3), h2 = o(e3), N2 = r(e3), E === N2 && (u2.includes(b) ? c2(new T.EISDIR("the named file is a directory and O_WRITE is set", t2)) : k(n2, t2, R2));
              k(n2, h2, j2);
            }(f3.data) : R2(void 0, f3);
          }
        }
        __name(D2, "D");
        function R2(e2, n3) {
          e2 ? c2(e2) : c2(null, g2 = n3);
        }
        __name(R2, "R");
        function _2(t3) {
          t3 ? c2(t3) : (O2 = e.alloc(0), n2.putBuffer(g2.data, O2, V2));
        }
        __name(_2, "_");
        function F2(e2) {
          if (e2)
            c2(e2);
          else {
            var t3 = Date.now();
            P(n2, h2, f2, { mtime: t3, ctime: t3 }, B2);
          }
        }
        __name(F2, "F");
        function V2(e2) {
          e2 ? c2(e2) : (d2[N2] = new L(g2.id, l), n2.putObject(f2.data, d2, F2));
        }
        __name(V2, "V");
        function B2(e2) {
          e2 ? c2(e2) : c2(null, g2);
        }
        __name(B2, "B");
        E === N2 ? u2.includes(b) ? c2(new T.EISDIR("the named file is a directory and O_WRITE is set", t2)) : k(n2, t2, R2) : k(n2, h2, j2);
      }
      __name(Y, "Y");
      function K(n2, t2, i2, o2, r2, u2) {
        var a2;
        function c2(e2) {
          e2 ? u2(e2) : u2(null, r2);
        }
        __name(c2, "c");
        function f2(e2) {
          if (e2)
            u2(e2);
          else {
            var i3 = Date.now();
            P(n2, t2.path, a2, { mtime: i3, ctime: i3 }, c2);
          }
        }
        __name(f2, "f");
        function l2(e2) {
          e2 ? u2(e2) : n2.putObject(a2.id, a2, f2);
        }
        __name(l2, "l");
        n2.getObject(t2.id, function(c3, f3) {
          if (c3)
            u2(c3);
          else {
            a2 = f3;
            var s2 = e.alloc(r2);
            i2.copy(s2, 0, o2, o2 + r2), t2.position = r2, a2.size = r2, a2.version += 1, n2.putBuffer(a2.data, s2, l2);
          }
        });
      }
      __name(K, "K");
      function U(n2, t2, i2, o2, r2, u2, a2) {
        var c2, f2;
        function l2(e2) {
          e2 ? a2(e2) : a2(null, r2);
        }
        __name(l2, "l");
        function s2(e2) {
          if (e2)
            a2(e2);
          else {
            var i3 = Date.now();
            P(n2, t2.path, c2, { mtime: i3, ctime: i3 }, l2);
          }
        }
        __name(s2, "s");
        function p2(e2) {
          e2 ? a2(e2) : n2.putObject(c2.id, c2, s2);
        }
        __name(p2, "p");
        function d2(l3, s3) {
          if (l3)
            a2(l3);
          else {
            if (!(f2 = s3))
              return a2(new T.EIO("Expected Buffer"));
            var d3 = null != u2 ? u2 : t2.position, m2 = Math.max(f2.length, d3 + r2), E2 = e.alloc(m2);
            f2 && f2.copy(E2), i2.copy(E2, d3, o2, o2 + r2), void 0 === u2 && (t2.position += r2), c2.size = m2, c2.version += 1, n2.putBuffer(c2.data, E2, p2);
          }
        }
        __name(d2, "d");
        n2.getObject(t2.id, function(e2, t3) {
          e2 ? a2(e2) : (c2 = t3, n2.getBuffer(c2.data, d2));
        });
      }
      __name(U, "U");
      function W(e2, n2, t2, i2, o2, r2, u2) {
        var a2, c2;
        function f2(e3, a3) {
          if (e3)
            u2(e3);
          else {
            if (!(c2 = a3))
              return u2(new T.EIO("Expected Buffer"));
            var f3 = null != r2 ? r2 : n2.position;
            o2 = f3 + o2 > t2.length ? o2 - f3 : o2, c2.copy(t2, i2, f3, f3 + o2), void 0 === r2 && (n2.position += o2), u2(null, o2);
          }
        }
        __name(f2, "f");
        e2.getObject(n2.id, function(t3, i3) {
          t3 ? u2(t3) : i3.type === s ? u2(new T.EISDIR("the named file is a directory", n2.path)) : (a2 = i3, e2.getBuffer(a2.data, f2));
        });
      }
      __name(W, "W");
      function G(e2, n2, t2) {
        k(e2, n2 = i(n2), t2);
      }
      __name(G, "G");
      function H(e2, n2, t2) {
        n2.getNode(e2, t2);
      }
      __name(H, "H");
      function $(e2, n2, t2) {
        n2 = i(n2);
        var u2, a2, c2 = r(n2), f2 = o(n2);
        function l2(e3, n3) {
          if (e3)
            return t2(e3);
          S.create(n3, t2);
        }
        __name(l2, "l");
        function s2(i2, o2) {
          i2 ? t2(i2) : (a2 = o2, Object.prototype.hasOwnProperty.call(a2, c2) ? e2.getObject(a2[c2].id, l2) : t2(new T.ENOENT("a component of the path does not name an existing file", n2)));
        }
        __name(s2, "s");
        E === c2 ? k(e2, n2, t2) : k(e2, f2, function(n3, i2) {
          n3 ? t2(n3) : (u2 = i2, e2.getObject(u2.data, s2));
        });
      }
      __name($, "$");
      function J(e2, n2, t2, u2) {
        n2 = i(n2);
        var a2 = r(n2), c2 = o(n2);
        t2 = i(t2);
        var f2, l2, p2, d2, m2, E2, g2 = r(t2), w2 = o(t2), O2 = Date.now();
        function b2(n3) {
          n3 ? u2(n3) : P(e2, t2, E2, { ctime: O2 }, u2);
        }
        __name(b2, "b");
        function y2(n3, t3) {
          n3 ? u2(n3) : ((E2 = t3).nlinks += 1, e2.putObject(E2.id, E2, b2));
        }
        __name(y2, "y");
        function v2(n3) {
          n3 ? u2(n3) : e2.getObject(m2, y2);
        }
        __name(v2, "v");
        function N2(n3, t3) {
          n3 ? u2(n3) : (d2 = t3, Object.prototype.hasOwnProperty.call(d2, g2) ? u2(new T.EEXIST("newpath resolves to an existing file", g2)) : (d2[g2] = l2[a2], m2 = d2[g2].id, e2.putObject(p2.data, d2, v2)));
        }
        __name(N2, "N");
        function h2(n3, t3) {
          n3 ? u2(n3) : (p2 = t3, e2.getObject(p2.data, N2));
        }
        __name(h2, "h");
        function I2(n3, t3) {
          n3 ? u2(n3) : (l2 = t3, Object.prototype.hasOwnProperty.call(l2, a2) ? l2[a2].type === s ? u2(new T.EPERM("oldpath refers to a directory")) : k(e2, w2, h2) : u2(new T.ENOENT("a component of either path prefix does not exist", a2)));
        }
        __name(I2, "I");
        k(e2, c2, function(n3, t3) {
          n3 ? u2(n3) : (f2 = t3, e2.getObject(f2.data, I2));
        });
      }
      __name(J, "J");
      function Q(e2, n2, t2) {
        n2 = i(n2);
        var u2, a2, c2, f2 = r(n2), l2 = o(n2);
        function p2(n3) {
          n3 ? t2(n3) : (delete a2[f2], e2.putObject(u2.data, a2, function(n4) {
            if (n4)
              t2(n4);
            else {
              var i2 = Date.now();
              P(e2, l2, u2, { mtime: i2, ctime: i2 }, t2);
            }
          }));
        }
        __name(p2, "p");
        function d2(n3) {
          n3 ? t2(n3) : e2.delete(c2.data, p2);
        }
        __name(d2, "d");
        function m2(i2, o2) {
          i2 ? t2(i2) : o2.type === s ? t2(new T.EPERM("unlink not permitted on directories", f2)) : function(i3, o3) {
            i3 ? t2(i3) : ((c2 = o3).nlinks -= 1, c2.nlinks < 1 ? e2.delete(c2.id, d2) : e2.putObject(c2.id, c2, function(i4) {
              i4 ? t2(i4) : P(e2, n2, c2, { ctime: Date.now() }, p2);
            }));
          }(null, o2);
        }
        __name(m2, "m");
        function E2(n3, i2) {
          n3 ? t2(n3) : (a2 = i2, Object.prototype.hasOwnProperty.call(a2, f2) ? e2.getObject(a2[f2].id, m2) : t2(new T.ENOENT("a component of the path does not name an existing file", f2)));
        }
        __name(E2, "E");
        k(e2, l2, function(n3, i2) {
          n3 ? t2(n3) : (u2 = i2, e2.getObject(u2.data, E2));
        });
      }
      __name(Q, "Q");
      function Z(n2, o2, r2, u2) {
        var a2, f2;
        function l2(i2, a3) {
          if (i2)
            u2(i2);
          else {
            f2 = a3;
            var l3 = Object.keys(f2);
            if (r2.encoding) {
              var s2 = l3.map(function(n3) {
                return e.from(n3);
              });
              l3 = "buffer" === r2.encoding ? s2 : s2.map(function(e2) {
                return e2.toString(r2.encoding);
              });
            }
            if (r2.withFileTypes) {
              var p2 = [];
              c.eachSeries(l3, function(i3, u3) {
                var a4 = e.from(i3, r2.encoding).toString(), c2 = t.join(o2, a4);
                ee(n2, c2, function(e2, n3) {
                  e2 && u3(e2), n3.name = i3, p2.push(n3), u3();
                });
              }, function(e2) {
                u2(e2, p2);
              });
            } else
              u2(null, l3);
          }
        }
        __name(l2, "l");
        o2 = i(o2), "function" == typeof r2 && (u2 = r2, r2 = {}), r2 = ne(r2), k(n2, o2, function(e2, t2) {
          e2 ? u2(e2) : t2.type !== s ? u2(new T.ENOTDIR(null, o2)) : (a2 = t2, n2.getObject(a2.data, l2));
        });
      }
      __name(Z, "Z");
      function ee(e2, n2, t2) {
        $(e2, n2, function(i2, o2) {
          if (i2)
            t2(i2);
          else {
            var r2 = new V(n2, o2, e2.name);
            t2(null, r2);
          }
        });
      }
      __name(ee, "ee");
      function ne(e2, n2) {
        return e2 ? "function" == typeof e2 ? e2 = { encoding: n2 } : "string" == typeof e2 && (e2 = { encoding: e2 }) : e2 = { encoding: n2 }, e2;
      }
      __name(ne, "ne");
      function te(e2, n2, a2, c2) {
        a2 = i(a2);
        var f2, l2, s2, d2 = r(a2), m2 = o(a2);
        function g2(i2, o2) {
          i2 ? c2(i2) : (l2 = o2, Object.prototype.hasOwnProperty.call(l2, d2) ? c2(new T.EEXIST(null, d2)) : S.create({ guid: e2.guid, type: p }, function(i3, o3) {
            i3 ? c2(i3) : ((s2 = o3).nlinks += 1, u(n2) || (s2.symlink_relpath = n2, n2 = t.resolve(m2, n2)), s2.size = n2.length, s2.data = n2, e2.putObject(s2.id, s2, O2));
          }));
        }
        __name(g2, "g");
        function w2(n3) {
          if (n3)
            c2(n3);
          else {
            var t2 = Date.now();
            P(e2, m2, f2, { mtime: t2, ctime: t2 }, c2);
          }
        }
        __name(w2, "w");
        function O2(n3) {
          n3 ? c2(n3) : (l2[d2] = new L(s2.id, p), e2.putObject(f2.data, l2, w2));
        }
        __name(O2, "O");
        E === d2 ? c2(new T.EEXIST(null, d2)) : k(e2, m2, function(n3, t2) {
          n3 ? c2(n3) : (f2 = t2, e2.getObject(f2.data, g2));
        });
      }
      __name(te, "te");
      function ie(e2, n2, t2) {
        n2 = i(n2);
        var u2, a2, c2 = r(n2), f2 = o(n2);
        function l2(n3, i2) {
          n3 ? t2(n3) : (a2 = i2, Object.prototype.hasOwnProperty.call(a2, c2) ? e2.getObject(a2[c2].id, s2) : t2(new T.ENOENT("a component of the path does not name an existing file", c2)));
        }
        __name(l2, "l");
        function s2(e3, i2) {
          if (e3)
            t2(e3);
          else if (i2.type !== p)
            t2(new T.EINVAL("path not a symbolic link", n2));
          else {
            var o2 = i2.symlink_relpath ? i2.symlink_relpath : i2.data;
            t2(null, o2);
          }
        }
        __name(s2, "s");
        k(e2, f2, function(n3, i2) {
          n3 ? t2(n3) : (u2 = i2, e2.getObject(u2.data, l2));
        });
      }
      __name(ie, "ie");
      function oe(n2, t2, o2, r2) {
        var u2;
        function a2(t3, i2) {
          if (t3)
            r2(t3);
          else {
            if (!i2)
              return r2(new T.EIO("Expected Buffer"));
            var a3 = e.alloc(o2);
            i2 && i2.copy(a3), n2.putBuffer(u2.data, a3, f2);
          }
        }
        __name(a2, "a");
        function c2(e2) {
          if (e2)
            r2(e2);
          else {
            var i2 = Date.now();
            P(n2, t2, u2, { mtime: i2, ctime: i2 }, r2);
          }
        }
        __name(c2, "c");
        function f2(e2) {
          e2 ? r2(e2) : (u2.size = o2, u2.version += 1, n2.putObject(u2.id, u2, c2));
        }
        __name(f2, "f");
        t2 = i(t2), o2 < 0 ? r2(new T.EINVAL("length cannot be negative")) : k(n2, t2, function(e2, i2) {
          e2 ? r2(e2) : i2.type === s ? r2(new T.EISDIR(null, t2)) : (u2 = i2, n2.getBuffer(u2.data, a2));
        });
      }
      __name(oe, "oe");
      function re(n2, t2, i2, o2) {
        var r2;
        function u2(t3, u3) {
          if (t3)
            o2(t3);
          else {
            var a3;
            if (!u3)
              return o2(new T.EIO("Expected Buffer"));
            a3 = u3 ? u3.slice(0, i2) : e.alloc(i2), n2.putBuffer(r2.data, a3, c2);
          }
        }
        __name(u2, "u");
        function a2(e2) {
          if (e2)
            o2(e2);
          else {
            var i3 = Date.now();
            P(n2, t2.path, r2, { mtime: i3, ctime: i3 }, o2);
          }
        }
        __name(a2, "a");
        function c2(e2) {
          e2 ? o2(e2) : (r2.size = i2, r2.version += 1, n2.putObject(r2.id, r2, a2));
        }
        __name(c2, "c");
        i2 < 0 ? o2(new T.EINVAL("length cannot be negative")) : t2.getNode(n2, function(e2, t3) {
          e2 ? o2(e2) : t3.type === s ? o2(new T.EISDIR()) : (r2 = t3, n2.getBuffer(r2.data, u2));
        });
      }
      __name(re, "re");
      function ue(e2, n2, t2, o2, r2) {
        n2 = i(n2), "number" != typeof t2 || "number" != typeof o2 ? r2(new T.EINVAL("atime and mtime must be number", n2)) : t2 < 0 || o2 < 0 ? r2(new T.EINVAL("atime and mtime must be positive integers", n2)) : k(e2, n2, function(i2, u2) {
          i2 ? r2(i2) : P(e2, n2, u2, { atime: t2, ctime: o2, mtime: o2 }, r2);
        });
      }
      __name(ue, "ue");
      function ae(e2, n2, t2, i2, o2) {
        "number" != typeof t2 || "number" != typeof i2 ? o2(new T.EINVAL("atime and mtime must be a number")) : t2 < 0 || i2 < 0 ? o2(new T.EINVAL("atime and mtime must be positive integers")) : n2.getNode(e2, function(r2, u2) {
          r2 ? o2(r2) : P(e2, n2.path, u2, { atime: t2, ctime: i2, mtime: i2 }, o2);
        });
      }
      __name(ae, "ae");
      function ce(e2, n2, t2, o2, r2, u2) {
        n2 = i(n2), "string" != typeof t2 ? u2(new T.EINVAL("attribute name must be a string", n2)) : t2 ? null !== r2 && r2 !== I && r2 !== j ? u2(new T.EINVAL("invalid flag, must be null, XATTR_CREATE or XATTR_REPLACE", n2)) : k(e2, n2, function(i2, a2) {
          if (i2)
            return u2(i2);
          C(e2, n2, a2, t2, o2, r2, u2);
        }) : u2(new T.EINVAL("attribute name cannot be an empty string", n2));
      }
      __name(ce, "ce");
      function fe(e2, n2, t2, i2, o2, r2) {
        "string" != typeof t2 ? r2(new T.EINVAL("attribute name must be a string")) : t2 ? null !== o2 && o2 !== I && o2 !== j ? r2(new T.EINVAL("invalid flag, must be null, XATTR_CREATE or XATTR_REPLACE")) : n2.getNode(e2, function(u2, a2) {
          if (u2)
            return r2(u2);
          C(e2, n2.path, a2, t2, i2, o2, r2);
        }) : r2(new T.EINVAL("attribute name cannot be an empty string"));
      }
      __name(fe, "fe");
      function le(e2, n2, t2, o2) {
        n2 = i(n2), "string" != typeof t2 ? o2(new T.EINVAL("attribute name must be a string", n2)) : t2 ? k(e2, n2, function(e3, i2) {
          if (e3)
            return o2(e3);
          var r2 = i2.xattrs;
          Object.prototype.hasOwnProperty.call(r2, t2) ? o2(null, r2[t2]) : o2(new T.ENOATTR(null, n2));
        }) : o2(new T.EINVAL("attribute name cannot be an empty string", n2));
      }
      __name(le, "le");
      function se(e2, n2, t2, i2) {
        "string" != typeof t2 ? i2(new T.EINVAL()) : t2 ? n2.getNode(e2, function(e3, n3) {
          if (e3)
            return i2(e3);
          var o2 = n3.xattrs;
          Object.prototype.hasOwnProperty.call(o2, t2) ? i2(null, o2[t2]) : i2(new T.ENOATTR());
        }) : i2(new T.EINVAL("attribute name cannot be an empty string"));
      }
      __name(se, "se");
      function pe(e2, n2, t2, o2) {
        n2 = i(n2), "string" != typeof t2 ? o2(new T.EINVAL("attribute name must be a string", n2)) : t2 ? k(e2, n2, function(i2, r2) {
          if (i2)
            return o2(i2);
          var u2 = r2.xattrs;
          Object.prototype.hasOwnProperty.call(u2, t2) ? (delete u2[t2], e2.putObject(r2.id, r2, function(t3) {
            t3 ? o2(t3) : P(e2, n2, r2, { ctime: Date.now() }, o2);
          })) : o2(new T.ENOATTR(null, n2));
        }) : o2(new T.EINVAL("attribute name cannot be an empty string", n2));
      }
      __name(pe, "pe");
      function de(e2, n2, t2, i2) {
        "string" != typeof t2 ? i2(new T.EINVAL("attribute name must be a string")) : t2 ? n2.getNode(e2, function(o2, r2) {
          if (o2)
            return i2(o2);
          var u2 = r2.xattrs;
          Object.prototype.hasOwnProperty.call(u2, t2) ? (delete u2[t2], e2.putObject(r2.id, r2, function(t3) {
            t3 ? i2(t3) : P(e2, n2.path, r2, { ctime: Date.now() }, i2);
          })) : i2(new T.ENOATTR());
        }) : i2(new T.EINVAL("attribute name cannot be an empty string"));
      }
      __name(de, "de");
      function me(e2) {
        return Object.prototype.hasOwnProperty.call(h, e2) ? h[e2] : null;
      }
      __name(me, "me");
      function Ee(e2, n2, t2) {
        return e2 ? "function" == typeof e2 ? e2 = { encoding: n2, flag: t2 } : "string" == typeof e2 && (e2 = { encoding: e2, flag: t2 }) : e2 = { encoding: n2, flag: t2 }, e2;
      }
      __name(Ee, "Ee");
      function ge(e2, n2, t2, i2, o2) {
        if (arguments.length < 5 ? (o2 = arguments[arguments.length - 1], i2 = 420) : i2 = xe(i2, m, o2), !(t2 = me(t2)))
          return o2(new T.EINVAL("flags is not valid"), n2);
        Y(e2, n2, t2, i2, function(e3, i3) {
          if (e3)
            o2(e3);
          else {
            var r2;
            r2 = t2.includes(N) ? i3.size : 0;
            var u2 = new _(n2, i3.id, t2, r2), a2 = R.allocDescriptor(u2);
            o2(null, a2);
          }
        });
      }
      __name(ge, "ge");
      function we(e2, n2, t2) {
        R.getOpenFileDescription(n2) ? (R.releaseDescriptor(n2), t2(null)) : t2(new T.EBADF());
      }
      __name(we, "we");
      function Oe(e2, n2, t2, i2) {
        x(e2, n2, t2, i2);
      }
      __name(Oe, "Oe");
      function be(e2, n2, t2, i2) {
        if (arguments.length < 4)
          i2 = t2, t2 = m;
        else if (!(t2 = xe(t2, m, i2)))
          return;
        q(e2, n2, i2);
      }
      __name(be, "be");
      function ye(e2, n2, t2, i2) {
        "function" == typeof t2 && (i2 = t2, t2 = f.fsConstants.F_OK), M(e2, n2, t2 |= f.fsConstants.F_OK, i2);
      }
      __name(ye, "ye");
      function ve(e2, n2, t2, i2) {
        if (i2 = arguments[arguments.length - 1], !n2)
          return i2(new Error("filename prefix is required"));
        var o2 = n2 + "-" + a.randomChars(6);
        q(e2, o2, function(e3) {
          i2(e3, o2);
        });
      }
      __name(ve, "ve");
      function Ne(e2, n2, t2) {
        z(e2, n2, t2);
      }
      __name(Ne, "Ne");
      function he(e2, n2, t2) {
        G(e2, n2, function(i2, o2) {
          if (i2)
            t2(i2);
          else {
            var r2 = new B(n2, o2, e2.name);
            t2(null, r2);
          }
        });
      }
      __name(he, "he");
      function Ie(e2, n2, t2) {
        var i2 = R.getOpenFileDescription(n2);
        i2 ? H(e2, i2, function(n3, o2) {
          if (n3)
            t2(n3);
          else {
            var r2 = new B(i2.path, o2, e2.name);
            t2(null, r2);
          }
        }) : t2(new T.EBADF());
      }
      __name(Ie, "Ie");
      function je(e2, n2, t2, i2) {
        J(e2, n2, t2, i2);
      }
      __name(je, "je");
      function Ae(e2, n2, t2) {
        Q(e2, n2, t2);
      }
      __name(Ae, "Ae");
      function De(e2, n2, t2, i2, o2, r2, u2) {
        i2 = void 0 === i2 ? 0 : i2, o2 = void 0 === o2 ? t2.length - i2 : o2, u2 = arguments[arguments.length - 1];
        var a2 = R.getOpenFileDescription(n2);
        a2 ? a2.flags.includes(O) ? W(e2, a2, t2, i2, o2, r2, function(e3, n3) {
          u2(e3, n3 || 0, t2);
        }) : u2(new T.EBADF("descriptor does not permit reading")) : u2(new T.EBADF());
      }
      __name(De, "De");
      function Te(e2, n2, t2) {
        Ve(n2, t2) === n2 && (R.getOpenFileDescription(n2) ? t2() : t2(new T.EBADF()));
      }
      __name(Te, "Te");
      function Le(n2, t2, i2, o2) {
        o2 = arguments[arguments.length - 1];
        var r2 = me((i2 = Ee(i2, null, "r")).flag || "r");
        if (!r2)
          return o2(new T.EINVAL("flags is not valid", t2));
        Y(n2, t2, r2, function(u2, a2) {
          if (u2)
            return o2(u2);
          var c2 = new _(t2, a2.id, r2, 0), f2 = R.allocDescriptor(c2);
          function l2() {
            R.releaseDescriptor(f2);
          }
          __name(l2, "l");
          H(n2, c2, function(r3, u3) {
            if (r3)
              return l2(), o2(r3);
            var a3 = new B(c2.path, u3, n2.name);
            if (a3.isDirectory())
              return l2(), o2(new T.EISDIR("illegal operation on directory", t2));
            var f3 = a3.size, s2 = e.alloc(f3);
            W(n2, c2, s2, 0, f3, 0, function(e2) {
              if (l2(), e2)
                return o2(e2);
              var n3;
              n3 = "utf8" === i2.encoding ? s2.toString("utf8") : s2, o2(null, n3);
            });
          });
        });
      }
      __name(Le, "Le");
      function Re(e2, n2, t2, i2, o2, r2, u2) {
        u2 = arguments[arguments.length - 1], i2 = void 0 === i2 ? 0 : i2, o2 = void 0 === o2 ? t2.length - i2 : o2;
        var a2 = R.getOpenFileDescription(n2);
        a2 ? a2.flags.includes(b) ? t2.length - i2 < o2 ? u2(new T.EIO("input buffer is too small")) : U(e2, a2, t2, i2, o2, r2, u2) : u2(new T.EBADF("descriptor does not permit writing")) : u2(new T.EBADF());
      }
      __name(Re, "Re");
      function _e(n2, t2, i2, o2, r2) {
        r2 = arguments[arguments.length - 1];
        var u2 = me((o2 = Ee(o2, "utf8", "w")).flag || "w");
        if (!u2)
          return r2(new T.EINVAL("flags is not valid", t2));
        e.isBuffer(i2) || ("number" == typeof i2 && (i2 = "" + i2), i2 = "string" != typeof (i2 = i2 || "") ? e.from(i2.toString()) : e.from(i2 || "", o2.encoding || "utf8")), Y(n2, t2, u2, function(e2, o3) {
          if (e2)
            return r2(e2);
          var a2 = new _(t2, o3.id, u2, 0), c2 = R.allocDescriptor(a2);
          K(n2, a2, i2, 0, i2.length, function(e3) {
            if (R.releaseDescriptor(c2), e3)
              return r2(e3);
            r2(null);
          });
        });
      }
      __name(_e, "_e");
      function Fe(n2, t2, i2, o2, r2) {
        r2 = arguments[arguments.length - 1];
        var u2 = me((o2 = Ee(o2, "utf8", "a")).flag || "a");
        if (!u2)
          return r2(new T.EINVAL("flags is not valid", t2));
        "number" == typeof (i2 = i2 || "") && (i2 = "" + i2), "string" == typeof i2 && "utf8" === o2.encoding && (i2 = e.from(i2)), Y(n2, t2, u2, function(e2, o3) {
          if (e2)
            return r2(e2);
          var a2 = new _(t2, o3.id, u2, o3.size), c2 = R.allocDescriptor(a2);
          U(n2, a2, i2, 0, i2.length, a2.position, function(e3) {
            if (R.releaseDescriptor(c2), e3)
              return r2(e3);
            r2(null);
          });
        });
      }
      __name(Fe, "Fe");
      function Se(e2, n2, t2) {
        he(e2, n2, function(e3) {
          t2(!e3);
        });
      }
      __name(Se, "Se");
      function Ve(e2, n2) {
        if ("number" == typeof e2)
          return e2;
        n2(new T.EINVAL("Expected integer", e2));
      }
      __name(Ve, "Ve");
      var Be = /^[0-7]+$/;
      function Pe(e2) {
        return e2 === e2 >>> 0;
      }
      __name(Pe, "Pe");
      function xe(e2, n2, t2) {
        return "function" == typeof n2 && (t2 = n2, n2 = void 0), Pe(e2) ? e2 & m : "number" == typeof e2 ? (Number.isInteger(e2), t2(new T.EINVAL("mode not a valid an integer value", e2)), false) : "string" == typeof e2 ? Be.test(e2) ? parseInt(e2, 8) & m : (t2(new T.EINVAL("mode not a valid octal string", e2)), false) : void 0 !== n2 ? n2 : (t2(new T.EINVAL("mode not valid", e2)), false);
      }
      __name(xe, "xe");
      function ke(e2, n2, t2, o2) {
        n2 = i(n2), "number" != typeof t2 ? o2(new T.EINVAL("mode must be number", n2)) : k(e2, n2, function(i2, r2) {
          i2 ? o2(i2) : (r2.mode = t2, P(e2, n2, r2, { mtime: Date.now() }, o2));
        });
      }
      __name(ke, "ke");
      function Ce(e2, n2, t2, i2) {
        "number" != typeof t2 ? i2(new T.EINVAL("mode must be a number")) : n2.getNode(e2, function(o2, r2) {
          o2 ? i2(o2) : (r2.mode = t2, P(e2, n2.path, r2, { mtime: Date.now() }, i2));
        });
      }
      __name(Ce, "Ce");
      function Xe(e2, n2, t2, o2, r2) {
        n2 = i(n2), k(e2, n2, function(i2, u2) {
          i2 ? r2(i2) : (u2.uid = t2, u2.gid = o2, P(e2, n2, u2, { mtime: Date.now() }, r2));
        });
      }
      __name(Xe, "Xe");
      function qe(e2, n2, t2, i2, o2) {
        n2.getNode(e2, function(r2, u2) {
          r2 ? o2(r2) : (u2.uid = t2, u2.gid = i2, P(e2, n2.path, u2, { mtime: Date.now() }, o2));
        });
      }
      __name(qe, "qe");
      function Me(e2, n2, t2, i2) {
        le(e2, n2, t2, i2);
      }
      __name(Me, "Me");
      function ze(e2, n2, t2, i2) {
        var o2 = R.getOpenFileDescription(n2);
        o2 ? se(e2, o2, t2, i2) : i2(new T.EBADF());
      }
      __name(ze, "ze");
      function Ye(e2, n2, t2, i2, o2, r2) {
        "function" == typeof o2 && (r2 = o2, o2 = null), ce(e2, n2, t2, i2, o2, r2);
      }
      __name(Ye, "Ye");
      function Ke(e2, n2, t2, i2, o2, r2) {
        "function" == typeof o2 && (r2 = o2, o2 = null);
        var u2 = R.getOpenFileDescription(n2);
        u2 ? u2.flags.includes(b) ? fe(e2, u2, t2, i2, o2, r2) : r2(new T.EBADF("descriptor does not permit writing")) : r2(new T.EBADF());
      }
      __name(Ke, "Ke");
      function Ue(e2, n2, t2, i2) {
        pe(e2, n2, t2, i2);
      }
      __name(Ue, "Ue");
      function We(e2, n2, t2, i2) {
        var o2 = R.getOpenFileDescription(n2);
        o2 ? o2.flags.includes(b) ? de(e2, o2, t2, i2) : i2(new T.EBADF("descriptor does not permit writing")) : i2(new T.EBADF());
      }
      __name(We, "We");
      function Ge(e2, n2, t2, i2, o2) {
        var r2 = R.getOpenFileDescription(n2);
        r2 || o2(new T.EBADF()), "SET" === i2 ? t2 < 0 ? o2(new T.EINVAL("resulting file offset would be negative")) : (r2.position = t2, o2(null, r2.position)) : "CUR" === i2 ? r2.position + t2 < 0 ? o2(new T.EINVAL("resulting file offset would be negative")) : (r2.position += t2, o2(null, r2.position)) : "END" === i2 ? H(e2, r2, function(e3, n3) {
          e3 ? o2(e3) : n3.size + t2 < 0 ? o2(new T.EINVAL("resulting file offset would be negative")) : (r2.position = n3.size + t2, o2(null, r2.position));
        }) : o2(new T.EINVAL("whence argument is not a proper value"));
      }
      __name(Ge, "Ge");
      function He(e2, n2, t2, i2) {
        Z(e2, n2, t2, i2);
      }
      __name(He, "He");
      function $e(e2) {
        return "number" == typeof e2 ? e2 : "object" === n(e2) && "function" == typeof e2.getTime ? e2.getTime() : void 0;
      }
      __name($e, "$e");
      function Je(e2, n2, t2, i2, o2) {
        var r2 = Date.now();
        ue(e2, n2, t2 = $e(t2 || r2), i2 = $e(i2 || r2), o2);
      }
      __name(Je, "Je");
      function Qe(e2, n2, t2, i2, o2) {
        var r2 = Date.now();
        t2 = $e(t2 || r2), i2 = $e(i2 || r2);
        var u2 = R.getOpenFileDescription(n2);
        u2 ? u2.flags.includes(b) ? ae(e2, u2, t2, i2, o2) : o2(new T.EBADF("descriptor does not permit writing")) : o2(new T.EBADF());
      }
      __name(Qe, "Qe");
      function Ze(e2, n2, t2, i2) {
        (t2 = xe(t2, i2)) && ke(e2, n2, t2, i2);
      }
      __name(Ze, "Ze");
      function en(e2, n2, t2, i2) {
        if (t2 = xe(t2, i2)) {
          var o2 = R.getOpenFileDescription(n2);
          o2 ? o2.flags.includes(b) ? Ce(e2, o2, t2, i2) : i2(new T.EBADF("descriptor does not permit writing")) : i2(new T.EBADF());
        }
      }
      __name(en, "en");
      function nn(e2, n2, t2, i2, o2) {
        return Pe(t2) ? Pe(i2) ? void Xe(e2, n2, t2, i2, o2) : o2(new T.EINVAL("gid must be a valid integer", i2)) : o2(new T.EINVAL("uid must be a valid integer", t2));
      }
      __name(nn, "nn");
      function tn(e2, n2, t2, i2, o2) {
        if (!Pe(t2))
          return o2(new T.EINVAL("uid must be a valid integer", t2));
        if (!Pe(i2))
          return o2(new T.EINVAL("gid must be a valid integer", i2));
        var r2 = R.getOpenFileDescription(n2);
        r2 ? r2.flags.includes(b) ? qe(e2, r2, t2, i2, o2) : o2(new T.EBADF("descriptor does not permit writing")) : o2(new T.EBADF());
      }
      __name(tn, "tn");
      function on(e2, n2, o2, r2) {
        n2 = i(n2), o2 = i(o2);
        var u2, a2, c2, f2, l2 = t.dirname(n2), p2 = t.dirname(o2), d2 = t.basename(n2), m2 = t.basename(o2), E2 = Date.now();
        function g2(n3, t2) {
          n3 ? r2(n3) : P(e2, o2, t2, { ctime: E2 }, r2);
        }
        __name(g2, "g");
        function w2(n3) {
          n3 ? r2(n3) : e2.getObject(f2[m2].id, g2);
        }
        __name(w2, "w");
        function O2(n3) {
          n3 ? r2(n3) : (u2.id === c2.id && (a2 = f2), delete a2[d2], e2.putObject(u2.data, a2, w2));
        }
        __name(O2, "O");
        function b2(n3) {
          n3 ? r2(n3) : (f2[m2] = a2[d2], e2.putObject(c2.data, f2, O2));
        }
        __name(b2, "b");
        function y2(n3, t2) {
          n3 ? r2(n3) : (f2 = t2, Object.prototype.hasOwnProperty.call(f2, m2) ? z(e2, o2, b2) : b2());
        }
        __name(y2, "y");
        function v2(n3, t2) {
          n3 ? r2(n3) : (c2 = t2, e2.getObject(c2.data, y2));
        }
        __name(v2, "v");
        function N2(n3, t2) {
          n3 ? r2(n3) : (a2 = t2, k(e2, p2, v2));
        }
        __name(N2, "N");
        function h2(n3, t2) {
          n3 ? r2(n3) : (u2 = t2, e2.getObject(t2.data, N2));
        }
        __name(h2, "h");
        function I2(t2) {
          t2 ? r2(t2) : Q(e2, n2, r2);
        }
        __name(I2, "I");
        k(e2, n2, function(t2, i2) {
          t2 ? r2(t2) : i2.type === s ? k(e2, l2, h2) : J(e2, n2, o2, I2);
        });
      }
      __name(on, "on");
      function rn(e2, n2, t2, i2, o2) {
        te(e2, n2, t2, o2 = arguments[arguments.length - 1]);
      }
      __name(rn, "rn");
      function un(e2, n2, t2) {
        ie(e2, n2, t2);
      }
      __name(un, "un");
      function an(e2, n2, t2) {
        $(e2, n2, function(i2, o2) {
          if (i2)
            t2(i2);
          else {
            var r2 = new B(n2, o2, e2.name);
            t2(null, r2);
          }
        });
      }
      __name(an, "an");
      function cn(e2, n2, t2, i2) {
        Ve(t2 = t2 || 0, i2 = arguments[arguments.length - 1]) === t2 && oe(e2, n2, t2, i2);
      }
      __name(cn, "cn");
      function fn(e2, n2, t2, i2) {
        i2 = arguments[arguments.length - 1], t2 = t2 || 0;
        var o2 = R.getOpenFileDescription(n2);
        if (o2)
          if (o2.flags.includes(b)) {
            if (Ve(t2, i2) !== t2)
              return;
            re(e2, o2, t2, i2);
          } else
            i2(new T.EBADF("descriptor does not permit writing"));
        else
          i2(new T.EBADF());
      }
      __name(fn, "fn");
      module2.exports = { appendFile: Fe, access: ye, chown: nn, chmod: Ze, close: we, ensureRootDirectory: X, exists: Se, fchown: tn, fchmod: en, fgetxattr: ze, fremovexattr: We, fsetxattr: Ke, fstat: Ie, fsync: Te, ftruncate: fn, futimes: Qe, getxattr: Me, link: je, lseek: Ge, lstat: an, mkdir: be, mkdtemp: ve, mknod: Oe, open: ge, readdir: He, read: De, readFile: Le, readlink: un, removexattr: Ue, rename: on, rmdir: Ne, setxattr: Ye, stat: he, symlink: rn, truncate: cn, unlink: Ae, utimes: Je, writeFile: _e, write: Re };
    }, { "../path.js": "UzoP", "../shared.js": "zBMa", "../../lib/async.js": "u4Zs", "../constants.js": "iJA9", "../errors.js": "p8GN", "../directory-entry.js": "ZECt", "../open-files.js": "osLK", "../open-file-description.js": "XWaV", "../super-node.js": "JEp0", "../node.js": "KKNo", "../dirent.js": "q4Wu", "../stats.js": "dsCT", "buffer": "dskh" }], "GMi4": [function(require2, module2, exports2) {
      var Buffer2 = require2("buffer").Buffer;
      var e = require2("buffer").Buffer, r = require2("es6-promisify"), t = r.promisify, n = require2("../path.js"), a = require2("../providers/index.js"), s = require2("../shell/shell.js"), o = require2("../../lib/intercom.js"), i = require2("../fs-watcher.js"), u = require2("../errors.js"), m = require2("../shared.js"), c = m.nop, f = m.guid, l = require2("../constants.js"), h = l.fsConstants, p = l.FILE_SYSTEM_NAME, d = l.FS_FORMAT, g = l.FS_READY, b = l.FS_PENDING, A = l.FS_ERROR, P = l.FS_NODUPEIDCHECK, v = l.STDIN, y = l.STDOUT, E = l.STDERR, R = require2("./implementation.js");
      function w(e2) {
        return "function" == typeof e2 ? e2 : function(e3) {
          if (e3)
            throw e3;
        };
      }
      __name(w, "w");
      function S(e2) {
        e2 && console.error("Filer error: ", e2);
      }
      __name(S, "S");
      function O(e2) {
        if (!(e2 && e2.protocol && e2.pathname))
          return e2;
        if ("file:" !== e2.protocol)
          throw new u.EINVAL("only file: URLs are supported for paths", e2);
        for (var r2 = e2.pathname, t2 = 0; t2 < r2.length; t2++)
          if ("%" === r2[t2]) {
            var n2 = 32 | r2.codePointAt(t2 + 2);
            if ("2" === r2[t2 + 1] && 102 === n2)
              throw new u.EINVAL("file: URLs must not include encoded / characters", e2);
          }
        return decodeURIComponent(r2);
      }
      __name(O, "O");
      function x(r2) {
        return e.isBuffer(r2) ? r2.toString() : r2;
      }
      __name(x, "x");
      function F(e2, r2) {
        return e2 ? n.isNull(e2) ? new u.EINVAL("Path must be a string without null bytes.", e2) : r2 || n.isAbsolute(e2) ? void 0 : new u.EINVAL("Path must be absolute.", e2) : new u.EINVAL("Path must be a string", e2);
      }
      __name(F, "F");
      function _(e2, r2, t2) {
        var n2 = e2[r2], a2 = F(n2 = x(n2 = O(n2)), t2);
        if (a2)
          throw a2;
        e2[r2] = n2;
      }
      __name(_, "_");
      function q(e2, r2) {
        r2 = r2 || S;
        var m2 = (e2 = e2 || {}).flags || [], l2 = e2.guid ? e2.guid : f, O2 = e2.provider || new a.Default(e2.name || p), x2 = e2.name || O2.name, F2 = m2.includes(d), I = this;
        I.readyState = b, I.name = x2, I.error = null, I.stdin = v, I.stdout = y, I.stderr = E, I.constants = h, I.F_OK = h.F_OK, I.R_OK = h.R_OK, I.W_OK = h.W_OK, I.X_OK = h.X_OK, this.Shell = s.bind(void 0, this);
        var N = [];
        function j(e3) {
          return function(r3) {
            m2.includes(P) ? r3(null, l2()) : (/* @__PURE__ */ __name(function r4(t2) {
              var n2 = l2();
              e3.getObject(n2, function(e4, a2) {
                e4 ? t2(e4) : a2 ? r4(t2) : t2(null, n2);
              });
            }, "r"))(r3);
          };
        }
        __name(j, "j");
        this.queueOrRun = function(e3) {
          var r3;
          return g === I.readyState ? e3.call(I) : A === I.readyState ? r3 = new u.EFILESYSTEMERROR("unknown error") : N.push(e3), r3;
        }, this.watch = function(e3, r3, t2) {
          if (n.isNull(e3))
            throw new Error("Path must be a string without null bytes.");
          "function" == typeof r3 && (t2 = r3, r3 = {}), r3 = r3 || {}, t2 = t2 || c;
          var a2 = new i();
          return a2.start(e3, false, r3.recursive), a2.on("change", t2), a2;
        }, O2.open(function(e3) {
          function t2(e4) {
            function t3(e5) {
              var r3 = O2[e5]();
              return r3.name = x2, r3.flags = m2, r3.changes = [], r3.guid = j(r3), r3.close = function() {
                var e6 = r3.changes;
                !function(e7) {
                  if (e7.length) {
                    var r4 = o.getInstance();
                    e7.forEach(function(e8) {
                      r4.emit(e8.event, e8.path);
                    });
                  }
                }(e6), e6.length = 0;
              }, r3;
            }
            __name(t3, "t");
            I.provider = { openReadWriteContext: function() {
              return t3("getReadWriteContext");
            }, openReadOnlyContext: function() {
              return t3("getReadOnlyContext");
            } }, I.readyState = e4 ? A : g, N.forEach(function(e5) {
              e5.call(this);
            }.bind(I)), N = null, r2(e4, I);
          }
          __name(t2, "t");
          if (e3)
            return t2(e3);
          var n2 = O2.getReadWriteContext();
          n2.guid = j(n2), F2 ? n2.clear(function(e4) {
            if (e4)
              return t2(e4);
            R.ensureRootDirectory(n2, t2);
          }) : R.ensureRootDirectory(n2, t2);
        }), q.prototype.promises = {}, [{ name: "appendFile", promises: true, absPathArgs: [0] }, { name: "access", promises: true, absPathArgs: [0] }, { name: "chown", promises: true, absPathArgs: [0] }, { name: "chmod", promises: true, absPathArgs: [0] }, { name: "close" }, { name: "exists", absPathArgs: [0] }, { name: "fchown" }, { name: "fchmod" }, { name: "fgetxattr" }, { name: "fremovexattr" }, { name: "fsetxattr" }, { name: "fstat" }, { name: "fsync" }, { name: "ftruncate" }, { name: "futimes" }, { name: "getxattr", promises: true, absPathArgs: [0] }, { name: "link", promises: true, absPathArgs: [0, 1] }, { name: "lseek" }, { name: "lstat", promises: true }, { name: "mkdir", promises: true, absPathArgs: [0] }, { name: "mkdtemp", promises: true }, { name: "mknod", promises: true, absPathArgs: [0] }, { name: "open", promises: true, absPathArgs: [0] }, { name: "readdir", promises: true, absPathArgs: [0] }, { name: "read" }, { name: "readFile", promises: true, absPathArgs: [0] }, { name: "readlink", promises: true, absPathArgs: [0] }, { name: "removexattr", promises: true, absPathArgs: [0] }, { name: "rename", promises: true, absPathArgs: [0, 1] }, { name: "rmdir", promises: true, absPathArgs: [0] }, { name: "setxattr", promises: true, absPathArgs: [0] }, { name: "stat", promises: true, absPathArgs: [0] }, { name: "symlink", promises: true, relPathArgs: [0], absPathArgs: [1] }, { name: "truncate", promises: true, absPathArgs: [0] }, { name: "unlink", promises: true, absPathArgs: [0] }, { name: "utimes", promises: true, absPathArgs: [0] }, { name: "writeFile", promises: true, absPathArgs: [0] }, { name: "write" }].forEach(function(e3) {
          var r3 = e3.name, n2 = true === e3.promises;
          q.prototype[r3] = function() {
            var t2 = this, n3 = Array.prototype.slice.call(arguments, 0), a2 = n3.length - 1, s2 = "function" != typeof n3[a2], o2 = w(n3[a2]);
            e3.absPathArgs && e3.absPathArgs.forEach(function(e4) {
              return _(n3, e4, false);
            }), e3.relPathArgs && e3.relPathArgs.forEach(function(e4) {
              return _(n3, e4, true);
            });
            var i2 = t2.queueOrRun(function() {
              var e4 = t2.provider.openReadWriteContext();
              if (A === t2.readyState) {
                var i3 = new u.EFILESYSTEMERROR("filesystem unavailable, operation canceled");
                return o2.call(t2, i3);
              }
              function m3() {
                e4.close(), o2.apply(t2, arguments);
              }
              __name(m3, "m");
              s2 ? n3.push(m3) : n3[a2] = m3;
              var c2 = [e4].concat(n3);
              R[r3].apply(null, c2);
            });
            i2 && o2(i2);
          }, n2 && (q.prototype.promises[r3] = t(q.prototype[r3].bind(I)));
        });
      }
      __name(q, "q");
      q.providers = a, module2.exports = q;
    }, { "es6-promisify": "b1ZG", "../path.js": "UzoP", "../providers/index.js": "AiW7", "../shell/shell.js": "D1Ra", "../../lib/intercom.js": "u7Jv", "../fs-watcher.js": "VLEe", "../errors.js": "p8GN", "../shared.js": "zBMa", "../constants.js": "iJA9", "./implementation.js": "bsBG", "buffer": "dskh" }], "iIhC": [function(require2, module2, exports2) {
      "use strict";
      function e(e2, t2, r2) {
        return { dataPath: void 0, schemaPath: void 0, keyword: "absolutePath", params: { absolutePath: r2 }, message: e2, parentSchema: t2 };
      }
      __name(e, "e");
      function t(t2, r2, a2) {
        return e(t2 ? "The provided value ".concat(JSON.stringify(a2), " is not an absolute path!") : "A relative path is expected. However, the provided value ".concat(JSON.stringify(a2), " is an absolute path!"), r2, a2);
      }
      __name(t, "t");
      function r(r2) {
        return r2.addKeyword("absolutePath", { errors: true, type: "string", compile: function(r3, a2) {
          var o = /* @__PURE__ */ __name(function o2(s) {
            var n = true;
            return s.includes("!") && (o2.errors = [e("The provided value ".concat(JSON.stringify(s), " contains exclamation mark (!) which is not allowed because it's reserved for loader syntax."), a2, s)], n = false), r3 === /^(?:[A-Za-z]:(\\|\/)|\\\\|\/)/.test(s) || (o2.errors = [t(r3, a2, s)], n = false), n;
          }, "o");
          return o.errors = [], o;
        } }), r2;
      }
      __name(r, "r");
      Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
      var a = r;
      exports2.default = a;
    }, {}], "GNtl": [function(require2, module2, exports2) {
      "use strict";
      function t(t2, n2) {
        return a(t2) || o(t2, n2) || r(t2, n2) || e();
      }
      __name(t, "t");
      function e() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      __name(e, "e");
      function r(t2, e2) {
        if (t2) {
          if ("string" == typeof t2)
            return n(t2, e2);
          var r2 = Object.prototype.toString.call(t2).slice(8, -1);
          return "Object" === r2 && t2.constructor && (r2 = t2.constructor.name), "Map" === r2 || "Set" === r2 ? Array.from(r2) : "Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2) ? n(t2, e2) : void 0;
        }
      }
      __name(r, "r");
      function n(t2, e2) {
        (null == e2 || e2 > t2.length) && (e2 = t2.length);
        for (var r2 = 0, n2 = new Array(e2); r2 < e2; r2++)
          n2[r2] = t2[r2];
        return n2;
      }
      __name(n, "n");
      function o(t2, e2) {
        if ("undefined" != typeof Symbol && Symbol.iterator in Object(t2)) {
          var r2 = [], n2 = true, o2 = false, a2 = void 0;
          try {
            for (var i2, u2 = t2[Symbol.iterator](); !(n2 = (i2 = u2.next()).done) && (r2.push(i2.value), !e2 || r2.length !== e2); n2 = true)
              ;
          } catch (f2) {
            o2 = true, a2 = f2;
          } finally {
            try {
              n2 || null == u2.return || u2.return();
            } finally {
              if (o2)
                throw a2;
            }
          }
          return r2;
        }
      }
      __name(o, "o");
      function a(t2) {
        if (Array.isArray(t2))
          return t2;
      }
      __name(a, "a");
      function i(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      __name(i, "i");
      function u(t2, e2) {
        for (var r2 = 0; r2 < e2.length; r2++) {
          var n2 = e2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
        }
      }
      __name(u, "u");
      function f(t2, e2, r2) {
        return e2 && u(t2.prototype, e2), r2 && u(t2, r2), t2;
      }
      __name(f, "f");
      var c = function() {
        function e2() {
          i(this, e2), this._left = [], this._right = [];
        }
        __name(e2, "e");
        return f(e2, [{ key: "left", value: function(t2) {
          var e3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          this._left.push([t2, e3]);
        } }, { key: "right", value: function(t2) {
          var e3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          this._right.push([t2, e3]);
        } }, { key: "format", value: function() {
          var r2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], n2 = t(e2.getRangeValue(this._left, r2), 2), o2 = n2[0], a2 = n2[1], i2 = t(e2.getRangeValue(this._right, !r2), 2), u2 = i2[0], f2 = i2[1];
          if (!Number.isFinite(o2) && !Number.isFinite(u2))
            return "";
          var c2 = a2 ? o2 + 1 : o2;
          return c2 === (f2 ? u2 - 1 : u2) ? "should be ".concat(r2 ? "" : "!", "= ").concat(c2) : Number.isFinite(o2) && !Number.isFinite(u2) ? e2.formatLeft(o2, r2, a2) : !Number.isFinite(o2) && Number.isFinite(u2) ? e2.formatRight(u2, r2, f2) : e2.formatRange(o2, u2, a2, f2, r2);
        } }], [{ key: "getOperator", value: function(t2, e3) {
          return "left" === t2 ? e3 ? ">" : ">=" : e3 ? "<" : "<=";
        } }, { key: "formatRight", value: function(t2, r2, n2) {
          return false === r2 ? e2.formatLeft(t2, !r2, !n2) : "should be ".concat(e2.getOperator("right", n2), " ").concat(t2);
        } }, { key: "formatLeft", value: function(t2, r2, n2) {
          return false === r2 ? e2.formatRight(t2, !r2, !n2) : "should be ".concat(e2.getOperator("left", n2), " ").concat(t2);
        } }, { key: "formatRange", value: function(t2, r2, n2, o2, a2) {
          var i2 = "should be";
          return i2 += " ".concat(e2.getOperator(a2 ? "left" : "right", a2 ? n2 : !n2), " ").concat(t2, " "), i2 += a2 ? "and" : "or", i2 += " ".concat(e2.getOperator(a2 ? "right" : "left", a2 ? o2 : !o2), " ").concat(r2);
        } }, { key: "getRangeValue", value: function(e3, r2) {
          for (var n2 = r2 ? 1 / 0 : -1 / 0, o2 = -1, a2 = r2 ? function(e4) {
            return t(e4, 1)[0] <= n2;
          } : function(e4) {
            return t(e4, 1)[0] >= n2;
          }, i2 = 0; i2 < e3.length; i2++)
            if (a2(e3[i2])) {
              var u2 = t(e3[i2], 1);
              n2 = u2[0], o2 = i2;
            }
          return o2 > -1 ? e3[o2] : [1 / 0, true];
        } }]), e2;
      }();
      module2.exports = c;
    }, {}], "SqDh": [function(require2, module2, exports2) {
      "use strict";
      function t(t2, e2) {
        var n2 = Object.keys(t2);
        if (Object.getOwnPropertySymbols) {
          var r2 = Object.getOwnPropertySymbols(t2);
          e2 && (r2 = r2.filter(function(e3) {
            return Object.getOwnPropertyDescriptor(t2, e3).enumerable;
          })), n2.push.apply(n2, r2);
        }
        return n2;
      }
      __name(t, "t");
      function e(e2) {
        for (var r2 = 1; r2 < arguments.length; r2++) {
          var m = null != arguments[r2] ? arguments[r2] : {};
          r2 % 2 ? t(Object(m), true).forEach(function(t2) {
            n(e2, t2, m[t2]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(m)) : t(Object(m)).forEach(function(t2) {
            Object.defineProperty(e2, t2, Object.getOwnPropertyDescriptor(m, t2));
          });
        }
        return e2;
      }
      __name(e, "e");
      function n(t2, e2, n2) {
        return e2 in t2 ? Object.defineProperty(t2, e2, { value: n2, enumerable: true, configurable: true, writable: true }) : t2[e2] = n2, t2;
      }
      __name(n, "n");
      var r = require2("./Range");
      module2.exports.stringHints = function(t2, n2) {
        var r2 = [], m = "string", i = e({}, t2);
        if (!n2) {
          var o = i.minLength, u = i.formatMinimum, a = i.formatExclusiveMaximum;
          i.minLength = i.maxLength, i.maxLength = o, i.formatMinimum = i.formatMaximum, i.formatMaximum = u, i.formatExclusiveMaximum = !i.formatExclusiveMinimum, i.formatExclusiveMinimum = !a;
        }
        if ("number" == typeof i.minLength)
          if (1 === i.minLength)
            m = "non-empty string";
          else {
            var c = Math.max(i.minLength - 1, 0);
            r2.push("should be longer than ".concat(c, " character").concat(c > 1 ? "s" : ""));
          }
        if ("number" == typeof i.maxLength)
          if (0 === i.maxLength)
            m = "empty string";
          else {
            var f = i.maxLength + 1;
            r2.push("should be shorter than ".concat(f, " character").concat(f > 1 ? "s" : ""));
          }
        return i.pattern && r2.push("should".concat(n2 ? "" : " not", " match pattern ").concat(JSON.stringify(i.pattern))), i.format && r2.push("should".concat(n2 ? "" : " not", " match format ").concat(JSON.stringify(i.format))), i.formatMinimum && r2.push("should be ".concat(i.formatExclusiveMinimum ? ">" : ">=", " ").concat(JSON.stringify(i.formatMinimum))), i.formatMaximum && r2.push("should be ".concat(i.formatExclusiveMaximum ? "<" : "<=", " ").concat(JSON.stringify(i.formatMaximum))), [m].concat(r2);
      }, module2.exports.numberHints = function(t2, e2) {
        var n2 = ["integer" === t2.type ? "integer" : "number"], m = new r();
        "number" == typeof t2.minimum && m.left(t2.minimum), "number" == typeof t2.exclusiveMinimum && m.left(t2.exclusiveMinimum, true), "number" == typeof t2.maximum && m.right(t2.maximum), "number" == typeof t2.exclusiveMaximum && m.right(t2.exclusiveMaximum, true);
        var i = m.format(e2);
        return i && n2.push(i), "number" == typeof t2.multipleOf && n2.push("should".concat(e2 ? "" : " not", " be multiple of ").concat(t2.multipleOf)), n2;
      };
    }, { "./Range": "GNtl" }], "ySUA": [function(require2, module2, exports2) {
      "use strict";
      function t(t2) {
        return n(t2) || r(t2) || i(t2) || e();
      }
      __name(t, "t");
      function e() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      __name(e, "e");
      function n(t2) {
        if (Array.isArray(t2))
          return s(t2);
      }
      __name(n, "n");
      function a(t2) {
        return m(t2) || r(t2) || i(t2) || c();
      }
      __name(a, "a");
      function r(t2) {
        if ("undefined" != typeof Symbol && Symbol.iterator in Object(t2))
          return Array.from(t2);
      }
      __name(r, "r");
      function o(t2, e2) {
        return m(t2) || u(t2, e2) || i(t2, e2) || c();
      }
      __name(o, "o");
      function c() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      __name(c, "c");
      function i(t2, e2) {
        if (t2) {
          if ("string" == typeof t2)
            return s(t2, e2);
          var n2 = Object.prototype.toString.call(t2).slice(8, -1);
          return "Object" === n2 && t2.constructor && (n2 = t2.constructor.name), "Map" === n2 || "Set" === n2 ? Array.from(n2) : "Arguments" === n2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2) ? s(t2, e2) : void 0;
        }
      }
      __name(i, "i");
      function s(t2, e2) {
        (null == e2 || e2 > t2.length) && (e2 = t2.length);
        for (var n2 = 0, a2 = new Array(e2); n2 < e2; n2++)
          a2[n2] = t2[n2];
        return a2;
      }
      __name(s, "s");
      function u(t2, e2) {
        if ("undefined" != typeof Symbol && Symbol.iterator in Object(t2)) {
          var n2 = [], a2 = true, r2 = false, o2 = void 0;
          try {
            for (var c2, i2 = t2[Symbol.iterator](); !(a2 = (c2 = i2.next()).done) && (n2.push(c2.value), !e2 || n2.length !== e2); a2 = true)
              ;
          } catch (s2) {
            r2 = true, o2 = s2;
          } finally {
            try {
              a2 || null == i2.return || i2.return();
            } finally {
              if (r2)
                throw o2;
            }
          }
          return n2;
        }
      }
      __name(u, "u");
      function m(t2) {
        if (Array.isArray(t2))
          return t2;
      }
      __name(m, "m");
      function h(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      __name(h, "h");
      function p(t2, e2) {
        for (var n2 = 0; n2 < e2.length; n2++) {
          var a2 = e2[n2];
          a2.enumerable = a2.enumerable || false, a2.configurable = true, "value" in a2 && (a2.writable = true), Object.defineProperty(t2, a2.key, a2);
        }
      }
      __name(p, "p");
      function l(t2, e2, n2) {
        return e2 && p(t2.prototype, e2), n2 && p(t2, n2), t2;
      }
      __name(l, "l");
      function f(t2, e2) {
        if ("function" != typeof e2 && null !== e2)
          throw new TypeError("Super expression must either be null or a function");
        t2.prototype = Object.create(e2 && e2.prototype, { constructor: { value: t2, writable: true, configurable: true } }), e2 && x(t2, e2);
      }
      __name(f, "f");
      function d(t2) {
        return function() {
          var e2, n2 = O(t2);
          if (S()) {
            var a2 = O(this).constructor;
            e2 = Reflect.construct(n2, arguments, a2);
          } else
            e2 = n2.apply(this, arguments);
          return y(this, e2);
        };
      }
      __name(d, "d");
      function y(t2, e2) {
        return !e2 || "object" !== j(e2) && "function" != typeof e2 ? v(t2) : e2;
      }
      __name(y, "y");
      function v(t2) {
        if (void 0 === t2)
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t2;
      }
      __name(v, "v");
      function g(t2) {
        var e2 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
        return (g = /* @__PURE__ */ __name(function(t3) {
          if (null === t3 || !P(t3))
            return t3;
          if ("function" != typeof t3)
            throw new TypeError("Super expression must either be null or a function");
          if (void 0 !== e2) {
            if (e2.has(t3))
              return e2.get(t3);
            e2.set(t3, n2);
          }
          function n2() {
            return b(t3, arguments, O(this).constructor);
          }
          __name(n2, "n");
          return n2.prototype = Object.create(t3.prototype, { constructor: { value: n2, enumerable: false, writable: true, configurable: true } }), x(n2, t3);
        }, "g"))(t2);
      }
      __name(g, "g");
      function b(t2, e2, n2) {
        return (b = S() ? Reflect.construct : function(t3, e3, n3) {
          var a2 = [null];
          a2.push.apply(a2, e3);
          var r2 = new (Function.bind.apply(t3, a2))();
          return n3 && x(r2, n3.prototype), r2;
        }).apply(null, arguments);
      }
      __name(b, "b");
      function S() {
        if ("undefined" == typeof Reflect || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if ("function" == typeof Proxy)
          return true;
        try {
          return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          })), true;
        } catch (t2) {
          return false;
        }
      }
      __name(S, "S");
      function P(t2) {
        return -1 !== Function.toString.call(t2).indexOf("[native code]");
      }
      __name(P, "P");
      function x(t2, e2) {
        return (x = Object.setPrototypeOf || function(t3, e3) {
          return t3.__proto__ = e3, t3;
        })(t2, e2);
      }
      __name(x, "x");
      function O(t2) {
        return (O = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        })(t2);
      }
      __name(O, "O");
      function j(t2) {
        return (j = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      __name(j, "j");
      Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
      var w = require2("./util/hints"), D = w.stringHints, I = w.numberHints, T = { type: 1, not: 1, oneOf: 1, anyOf: 1, if: 1, enum: 1, const: 1, instanceof: 1, required: 2, pattern: 2, patternRequired: 2, format: 2, formatMinimum: 2, formatMaximum: 2, minimum: 2, exclusiveMinimum: 2, maximum: 2, exclusiveMaximum: 2, multipleOf: 2, uniqueItems: 2, contains: 2, minLength: 2, maxLength: 2, minItems: 2, maxItems: 2, minProperties: 2, maxProperties: 2, dependencies: 2, propertyNames: 2, additionalItems: 2, additionalProperties: 2, absolutePath: 2 };
      function k(t2, e2) {
        var n2 = t2.reduce(function(t3, n3) {
          return Math.max(t3, e2(n3));
        }, 0);
        return t2.filter(function(t3) {
          return e2(t3) === n2;
        });
      }
      __name(k, "k");
      function A(t2) {
        var e2 = t2;
        return e2 = k(e2, function(t3) {
          return t3.dataPath ? t3.dataPath.length : 0;
        }), e2 = k(e2, function(t3) {
          return T[t3.keyword] || 2;
        });
      }
      __name(A, "A");
      function N(t2, e2) {
        for (var n2 = t2.length - 1, a2 = function(e3) {
          return 0 !== t2[n2].schemaPath.indexOf(e3);
        }; n2 > -1 && !e2.every(a2); )
          if ("anyOf" === t2[n2].keyword || "oneOf" === t2[n2].keyword) {
            var r2 = M(t2[n2]), o2 = N(t2.slice(0, n2), r2.concat(t2[n2].schemaPath));
            n2 = o2 - 1;
          } else
            n2 -= 1;
        return n2 + 1;
      }
      __name(N, "N");
      function M(t2) {
        var e2 = t2.schema;
        return Array.isArray(e2) ? e2.map(function(t3) {
          return t3.$ref;
        }).filter(function(t3) {
          return t3;
        }) : [];
      }
      __name(M, "M");
      function E(t2) {
        for (var e2 = [], n2 = t2.length - 1; n2 > 0; ) {
          var a2 = t2[n2];
          if ("anyOf" === a2.keyword || "oneOf" === a2.keyword) {
            var r2 = M(a2), o2 = N(t2.slice(0, n2), r2.concat(a2.schemaPath));
            o2 !== n2 ? (e2.push(Object.assign({}, a2, { children: t2.slice(o2, n2) })), n2 = o2) : e2.push(a2);
          } else
            e2.push(a2);
          n2 -= 1;
        }
        return 0 === n2 && e2.push(t2[n2]), e2.reverse();
      }
      __name(E, "E");
      function q(t2, e2) {
        return t2.replace(/\n(?!$)/g, "\n".concat(e2));
      }
      __name(q, "q");
      function R(t2) {
        return !!t2.not;
      }
      __name(R, "R");
      function J(t2) {
        return R(t2) ? J(t2.not) : t2;
      }
      __name(J, "J");
      function $(t2) {
        var e2 = J(t2);
        return V(e2) || F(e2) || L(e2) || z(e2) || B(e2);
      }
      __name($, "$");
      function _(t2) {
        return "object" === j(t2) && null !== t2;
      }
      __name(_, "_");
      function V(t2) {
        return "number" === t2.type || void 0 !== t2.minimum || void 0 !== t2.exclusiveMinimum || void 0 !== t2.maximum || void 0 !== t2.exclusiveMaximum || void 0 !== t2.multipleOf;
      }
      __name(V, "V");
      function F(t2) {
        return "integer" === t2.type || void 0 !== t2.minimum || void 0 !== t2.exclusiveMinimum || void 0 !== t2.maximum || void 0 !== t2.exclusiveMaximum || void 0 !== t2.multipleOf;
      }
      __name(F, "F");
      function L(t2) {
        return "string" === t2.type || void 0 !== t2.minLength || void 0 !== t2.maxLength || void 0 !== t2.pattern || void 0 !== t2.format || void 0 !== t2.formatMinimum || void 0 !== t2.formatMaximum;
      }
      __name(L, "L");
      function B(t2) {
        return "boolean" === t2.type;
      }
      __name(B, "B");
      function C(t2) {
        return "array" === t2.type || "number" == typeof t2.minItems || "number" == typeof t2.maxItems || void 0 !== t2.uniqueItems || void 0 !== t2.items || void 0 !== t2.additionalItems || void 0 !== t2.contains;
      }
      __name(C, "C");
      function H(t2) {
        return "object" === t2.type || void 0 !== t2.minProperties || void 0 !== t2.maxProperties || void 0 !== t2.required || void 0 !== t2.properties || void 0 !== t2.patternProperties || void 0 !== t2.additionalProperties || void 0 !== t2.dependencies || void 0 !== t2.propertyNames || void 0 !== t2.patternRequired;
      }
      __name(H, "H");
      function z(t2) {
        return "null" === t2.type;
      }
      __name(z, "z");
      function K(t2) {
        return /^[aeiou]/i.test(t2) ? "an" : "a";
      }
      __name(K, "K");
      function U(t2) {
        if (!t2)
          return "";
        if (!t2.type) {
          if (V(t2) || F(t2))
            return " | should be any non-number";
          if (L(t2))
            return " | should be any non-string";
          if (C(t2))
            return " | should be any non-array";
          if (H(t2))
            return " | should be any non-object";
        }
        return "";
      }
      __name(U, "U");
      function G(t2) {
        return t2.length > 0 ? "(".concat(t2.join(", "), ")") : "";
      }
      __name(G, "G");
      function Q(t2, e2) {
        return V(t2) || F(t2) ? I(t2, e2) : L(t2) ? D(t2, e2) : [];
      }
      __name(Q, "Q");
      var W = function(e2) {
        f(r2, g(Error));
        var n2 = d(r2);
        function r2(t2, e3) {
          var a2, c2, i2, s2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
          if (h(this, r2), (a2 = n2.call(this)).name = "ValidationError", a2.errors = t2, a2.schema = e3, e3.title && (!s2.name || !s2.baseDataPath)) {
            var u2 = e3.title.match(/^(.+) (.+)$/);
            if (u2) {
              if (!s2.name)
                c2 = o(u2, 2)[1];
              if (!s2.baseDataPath)
                i2 = o(u2, 3)[2];
            }
          }
          a2.headerName = s2.name || c2 || "Object", a2.baseDataPath = s2.baseDataPath || i2 || "configuration", a2.postFormatter = s2.postFormatter || null;
          var m2 = "Invalid ".concat(a2.baseDataPath, " object. ").concat(a2.headerName, " has been initialized using ").concat(K(a2.baseDataPath), " ").concat(a2.baseDataPath, " object that does not match the API schema.\n");
          return a2.message = "".concat(m2).concat(a2.formatValidationErrors(t2)), Error.captureStackTrace(v(a2), a2.constructor), a2;
        }
        __name(r2, "r");
        return l(r2, [{ key: "getSchemaPart", value: function(t2) {
          for (var e3 = t2.split("/"), n3 = this.schema, a2 = 1; a2 < e3.length; a2++) {
            var r3 = n3[e3[a2]];
            if (!r3)
              break;
            n3 = r3;
          }
          return n3;
        } }, { key: "formatSchema", value: function(e3) {
          var n3 = this, r3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], o2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [], c2 = r3, i2 = /* @__PURE__ */ __name(function(t2, a2) {
            return a2 ? o2.includes(t2) ? "(recursive)" : n3.formatSchema(t2, c2, o2.concat(e3)) : n3.formatSchema(t2, c2, o2);
          }, "i");
          if (R(e3) && !H(e3)) {
            if ($(e3.not))
              return c2 = !r3, i2(e3.not);
            var s2 = !e3.not.not;
            return c2 = !r3, s2 ? (r3 ? "" : "non ") + i2(e3.not) : i2(e3.not);
          }
          if (e3.instanceof) {
            var u2 = e3.instanceof;
            return (Array.isArray(u2) ? u2 : [u2]).map(function(t2) {
              return "Function" === t2 ? "function" : t2;
            }).join(" | ");
          }
          if (e3.enum)
            return e3.enum.map(function(t2) {
              return JSON.stringify(t2);
            }).join(" | ");
          if (void 0 !== e3.const)
            return JSON.stringify(e3.const);
          if (e3.oneOf)
            return e3.oneOf.map(function(t2) {
              return i2(t2, true);
            }).join(" | ");
          if (e3.anyOf)
            return e3.anyOf.map(function(t2) {
              return i2(t2, true);
            }).join(" | ");
          if (e3.allOf)
            return e3.allOf.map(function(t2) {
              return i2(t2, true);
            }).join(" & ");
          if (e3.if) {
            var m2 = e3.if, h2 = e3.then, p2 = e3.else;
            return "".concat(m2 ? "if ".concat(i2(m2)) : "").concat(h2 ? " then ".concat(i2(h2)) : "").concat(p2 ? " else ".concat(i2(p2)) : "");
          }
          if (e3.$ref)
            return i2(this.getSchemaPart(e3.$ref), true);
          if (V(e3) || F(e3)) {
            var l2 = a(Q(e3, r3)), f2 = l2[0], d2 = l2.slice(1), y2 = "".concat(f2).concat(d2.length > 0 ? " ".concat(G(d2)) : "");
            return r3 ? y2 : d2.length > 0 ? "non-".concat(f2, " | ").concat(y2) : "non-".concat(f2);
          }
          if (L(e3)) {
            var v2 = a(Q(e3, r3)), g2 = v2[0], b2 = v2.slice(1), S2 = "".concat(g2).concat(b2.length > 0 ? " ".concat(G(b2)) : "");
            return r3 ? S2 : "string" === S2 ? "non-string" : "non-string | ".concat(S2);
          }
          if (B(e3))
            return "".concat(r3 ? "" : "non-", "boolean");
          if (C(e3)) {
            c2 = true;
            var P2 = [];
            "number" == typeof e3.minItems && P2.push("should not have fewer than ".concat(e3.minItems, " item").concat(e3.minItems > 1 ? "s" : "")), "number" == typeof e3.maxItems && P2.push("should not have more than ".concat(e3.maxItems, " item").concat(e3.maxItems > 1 ? "s" : "")), e3.uniqueItems && P2.push("should not have duplicate items");
            var x2 = void 0 === e3.additionalItems || Boolean(e3.additionalItems), O2 = "";
            return e3.items ? Array.isArray(e3.items) && e3.items.length > 0 ? (O2 = "".concat(e3.items.map(function(t2) {
              return i2(t2);
            }).join(", ")), x2 && e3.additionalItems && _(e3.additionalItems) && Object.keys(e3.additionalItems).length > 0 && P2.push("additional items should be ".concat(i2(e3.additionalItems)))) : O2 = e3.items && Object.keys(e3.items).length > 0 ? "".concat(i2(e3.items)) : "any" : O2 = "any", e3.contains && Object.keys(e3.contains).length > 0 && P2.push("should contains at least one ".concat(this.formatSchema(e3.contains), " item")), "[".concat(O2).concat(x2 ? ", ..." : "", "]").concat(P2.length > 0 ? " (".concat(P2.join(", "), ")") : "");
          }
          if (H(e3)) {
            c2 = true;
            var j2 = [];
            if ("number" == typeof e3.minProperties && j2.push("should not have fewer than ".concat(e3.minProperties, " ").concat(e3.minProperties > 1 ? "properties" : "property")), "number" == typeof e3.maxProperties && j2.push("should not have more than ".concat(e3.maxProperties, " ").concat(e3.minProperties && e3.minProperties > 1 ? "properties" : "property")), e3.patternProperties && Object.keys(e3.patternProperties).length > 0) {
              var w2 = Object.keys(e3.patternProperties);
              j2.push("additional property names should match pattern".concat(w2.length > 1 ? "s" : "", " ").concat(w2.map(function(t2) {
                return JSON.stringify(t2);
              }).join(" | ")));
            }
            var D2 = e3.properties ? Object.keys(e3.properties) : [], I2 = e3.required ? e3.required : [], T2 = t(new Set([].concat(I2).concat(D2))).map(function(t2) {
              var e4 = I2.includes(t2);
              return "".concat(t2).concat(e4 ? "" : "?");
            }).concat(void 0 === e3.additionalProperties || Boolean(e3.additionalProperties) ? e3.additionalProperties && _(e3.additionalProperties) ? ["<key>: ".concat(i2(e3.additionalProperties))] : ["\u2026"] : []).join(", "), k2 = e3.dependencies, A2 = e3.propertyNames, N2 = e3.patternRequired;
            return k2 && Object.keys(k2).forEach(function(t2) {
              var e4 = k2[t2];
              Array.isArray(e4) ? j2.push("should have ".concat(e4.length > 1 ? "properties" : "property", " ").concat(e4.map(function(t3) {
                return "'".concat(t3, "'");
              }).join(", "), " when property '").concat(t2, "' is present")) : j2.push("should be valid according to the schema ".concat(i2(e4), " when property '").concat(t2, "' is present"));
            }), A2 && Object.keys(A2).length > 0 && j2.push("each property name should match format ".concat(JSON.stringify(e3.propertyNames.format))), N2 && N2.length > 0 && j2.push("should have property matching pattern ".concat(N2.map(function(t2) {
              return JSON.stringify(t2);
            }))), "object {".concat(T2 ? " ".concat(T2, " ") : "", "}").concat(j2.length > 0 ? " (".concat(j2.join(", "), ")") : "");
          }
          return z(e3) ? "".concat(r3 ? "" : "non-", "null") : Array.isArray(e3.type) ? "".concat(e3.type.join(" | ")) : JSON.stringify(e3, null, 2);
        } }, { key: "getSchemaPartText", value: function(t2, e3) {
          var n3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], a2 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
          if (!t2)
            return "";
          if (Array.isArray(e3))
            for (var r3 = 0; r3 < e3.length; r3++) {
              var o2 = t2[e3[r3]];
              if (!o2)
                break;
              t2 = o2;
            }
          for (; t2.$ref; )
            t2 = this.getSchemaPart(t2.$ref);
          var c2 = "".concat(this.formatSchema(t2, a2)).concat(n3 ? "." : "");
          return t2.description && (c2 += "\n-> ".concat(t2.description)), t2.link && (c2 += "\n-> Read more at ".concat(t2.link)), c2;
        } }, { key: "getSchemaPartDescription", value: function(t2) {
          if (!t2)
            return "";
          for (; t2.$ref; )
            t2 = this.getSchemaPart(t2.$ref);
          var e3 = "";
          return t2.description && (e3 += "\n-> ".concat(t2.description)), t2.link && (e3 += "\n-> Read more at ".concat(t2.link)), e3;
        } }, { key: "formatValidationError", value: function(t2) {
          var e3 = this, n3 = t2.keyword, r3 = t2.dataPath, o2 = "".concat(this.baseDataPath).concat(r3);
          switch (n3) {
            case "type":
              var c2 = t2.parentSchema;
              switch (t2.params.type) {
                case "number":
                  return "".concat(o2, " should be a ").concat(this.getSchemaPartText(c2, false, true));
                case "integer":
                  return "".concat(o2, " should be an ").concat(this.getSchemaPartText(c2, false, true));
                case "string":
                case "boolean":
                  return "".concat(o2, " should be a ").concat(this.getSchemaPartText(c2, false, true));
                case "array":
                  return "".concat(o2, " should be an array:\n").concat(this.getSchemaPartText(c2));
                case "object":
                  return "".concat(o2, " should be an object:\n").concat(this.getSchemaPartText(c2));
                case "null":
                  return "".concat(o2, " should be a ").concat(this.getSchemaPartText(c2, false, true));
                default:
                  return "".concat(o2, " should be:\n").concat(this.getSchemaPartText(c2));
              }
            case "instanceof":
              var i2 = t2.parentSchema;
              return "".concat(o2, " should be an instance of ").concat(this.getSchemaPartText(i2, false, true));
            case "pattern":
              var s2 = t2.params, u2 = t2.parentSchema, m2 = s2.pattern;
              return "".concat(o2, " should match pattern ").concat(JSON.stringify(m2)).concat(U(u2), ".").concat(this.getSchemaPartDescription(u2));
            case "format":
              var h2 = t2.params, p2 = t2.parentSchema, l2 = h2.format;
              return "".concat(o2, " should match format ").concat(JSON.stringify(l2)).concat(U(p2), ".").concat(this.getSchemaPartDescription(p2));
            case "formatMinimum":
            case "formatMaximum":
              var f2 = t2.params, d2 = t2.parentSchema, y2 = f2.comparison, v2 = f2.limit;
              return "".concat(o2, " should be ").concat(y2, " ").concat(JSON.stringify(v2)).concat(U(d2), ".").concat(this.getSchemaPartDescription(d2));
            case "minimum":
            case "maximum":
            case "exclusiveMinimum":
            case "exclusiveMaximum":
              var g2 = t2.parentSchema, b2 = t2.params, S2 = b2.comparison, P2 = b2.limit, x2 = a(Q(g2, true)).slice(1);
              return 0 === x2.length && x2.push("should be ".concat(S2, " ").concat(P2)), "".concat(o2, " ").concat(x2.join(" ")).concat(U(g2), ".").concat(this.getSchemaPartDescription(g2));
            case "multipleOf":
              var O2 = t2.params, j2 = t2.parentSchema, w2 = O2.multipleOf;
              return "".concat(o2, " should be multiple of ").concat(w2).concat(U(j2), ".").concat(this.getSchemaPartDescription(j2));
            case "patternRequired":
              var D2 = t2.params, I2 = t2.parentSchema, T2 = D2.missingPattern;
              return "".concat(o2, " should have property matching pattern ").concat(JSON.stringify(T2)).concat(U(I2), ".").concat(this.getSchemaPartDescription(I2));
            case "minLength":
              var k2 = t2.params, N2 = t2.parentSchema, M2 = k2.limit;
              if (1 === M2)
                return "".concat(o2, " should be a non-empty string").concat(U(N2), ".").concat(this.getSchemaPartDescription(N2));
              var R2 = M2 - 1;
              return "".concat(o2, " should be longer than ").concat(R2, " character").concat(R2 > 1 ? "s" : "").concat(U(N2), ".").concat(this.getSchemaPartDescription(N2));
            case "minItems":
              var J2 = t2.params, _2 = t2.parentSchema, V2 = J2.limit;
              return 1 === V2 ? "".concat(o2, " should be a non-empty array").concat(U(_2), ".").concat(this.getSchemaPartDescription(_2)) : "".concat(o2, " should not have fewer than ").concat(V2, " items").concat(U(_2), ".").concat(this.getSchemaPartDescription(_2));
            case "minProperties":
              var F2 = t2.params, L2 = t2.parentSchema, B2 = F2.limit;
              return 1 === B2 ? "".concat(o2, " should be a non-empty object").concat(U(L2), ".").concat(this.getSchemaPartDescription(L2)) : "".concat(o2, " should not have fewer than ").concat(B2, " properties").concat(U(L2), ".").concat(this.getSchemaPartDescription(L2));
            case "maxLength":
              var C2 = t2.params, z2 = t2.parentSchema, K2 = C2.limit + 1;
              return "".concat(o2, " should be shorter than ").concat(K2, " character").concat(K2 > 1 ? "s" : "").concat(U(z2), ".").concat(this.getSchemaPartDescription(z2));
            case "maxItems":
              var G2 = t2.params, W2 = t2.parentSchema, X2 = G2.limit;
              return "".concat(o2, " should not have more than ").concat(X2, " items").concat(U(W2), ".").concat(this.getSchemaPartDescription(W2));
            case "maxProperties":
              var Y = t2.params, Z = t2.parentSchema, tt = Y.limit;
              return "".concat(o2, " should not have more than ").concat(tt, " properties").concat(U(Z), ".").concat(this.getSchemaPartDescription(Z));
            case "uniqueItems":
              var et = t2.params, nt = t2.parentSchema, at = et.i;
              return "".concat(o2, " should not contain the item '").concat(t2.data[at], "' twice").concat(U(nt), ".").concat(this.getSchemaPartDescription(nt));
            case "additionalItems":
              var rt = t2.params, ot = t2.parentSchema, ct = rt.limit;
              return "".concat(o2, " should not have more than ").concat(ct, " items").concat(U(ot), ". These items are valid:\n").concat(this.getSchemaPartText(ot));
            case "contains":
              var it = t2.parentSchema;
              return "".concat(o2, " should contains at least one ").concat(this.getSchemaPartText(it, ["contains"]), " item").concat(U(it), ".");
            case "required":
              var st = t2.parentSchema, ut = t2.params.missingProperty.replace(/^\./, ""), mt = st && Boolean(st.properties && st.properties[ut]);
              return "".concat(o2, " misses the property '").concat(ut, "'").concat(U(st), ".").concat(mt ? " Should be:\n".concat(this.getSchemaPartText(st, ["properties", ut])) : this.getSchemaPartDescription(st));
            case "additionalProperties":
              var ht = t2.params, pt = t2.parentSchema, lt = ht.additionalProperty;
              return "".concat(o2, " has an unknown property '").concat(lt, "'").concat(U(pt), ". These properties are valid:\n").concat(this.getSchemaPartText(pt));
            case "dependencies":
              var ft = t2.params, dt = t2.parentSchema, yt = ft.property, vt = ft.deps.split(",").map(function(t3) {
                return "'".concat(t3.trim(), "'");
              }).join(", ");
              return "".concat(o2, " should have properties ").concat(vt, " when property '").concat(yt, "' is present").concat(U(dt), ".").concat(this.getSchemaPartDescription(dt));
            case "propertyNames":
              var gt = t2.params, bt = t2.parentSchema, St = t2.schema, Pt = gt.propertyName;
              return "".concat(o2, " property name '").concat(Pt, "' is invalid").concat(U(bt), ". Property names should be match format ").concat(JSON.stringify(St.format), ".").concat(this.getSchemaPartDescription(bt));
            case "enum":
              var xt = t2.parentSchema;
              return xt && xt.enum && 1 === xt.enum.length ? "".concat(o2, " should be ").concat(this.getSchemaPartText(xt, false, true)) : "".concat(o2, " should be one of these:\n").concat(this.getSchemaPartText(xt));
            case "const":
              var Ot = t2.parentSchema;
              return "".concat(o2, " should be equal to constant ").concat(this.getSchemaPartText(Ot, false, true));
            case "not":
              var jt = H(t2.parentSchema) ? "\n".concat(this.getSchemaPartText(t2.parentSchema)) : "", wt = this.getSchemaPartText(t2.schema, false, false, false);
              if ($(t2.schema))
                return "".concat(o2, " should be any ").concat(wt).concat(jt, ".");
              var Dt = t2.schema, It = t2.parentSchema;
              return "".concat(o2, " should not be ").concat(this.getSchemaPartText(Dt, false, true)).concat(It && H(It) ? "\n".concat(this.getSchemaPartText(It)) : "");
            case "oneOf":
            case "anyOf":
              var Tt = t2.parentSchema, kt = t2.children;
              if (kt && kt.length > 0) {
                if (1 === t2.schema.length) {
                  var At = kt[kt.length - 1], Nt = kt.slice(0, kt.length - 1);
                  return this.formatValidationError(Object.assign({}, At, { children: Nt, parentSchema: Object.assign({}, Tt, At.parentSchema) }));
                }
                var Mt = A(kt);
                return 1 === Mt.length ? this.formatValidationError(Mt[0]) : (Mt = E(Mt), "".concat(o2, " should be one of these:\n").concat(this.getSchemaPartText(Tt), "\nDetails:\n").concat(Mt.map(function(t3) {
                  return " * ".concat(q(e3.formatValidationError(t3), "   "));
                }).join("\n")));
              }
              return "".concat(o2, " should be one of these:\n").concat(this.getSchemaPartText(Tt));
            case "if":
              var Et = t2.params, qt = t2.parentSchema, Rt = Et.failingKeyword;
              return "".concat(o2, ' should match "').concat(Rt, '" schema:\n').concat(this.getSchemaPartText(qt, [Rt]));
            case "absolutePath":
              var Jt = t2.message, $t = t2.parentSchema;
              return "".concat(o2, ": ").concat(Jt).concat(this.getSchemaPartDescription($t));
            default:
              var _t = t2.message, Vt = t2.parentSchema, Ft = JSON.stringify(t2, null, 2);
              return "".concat(o2, " ").concat(_t, " (").concat(Ft, ").\n").concat(this.getSchemaPartText(Vt, false));
          }
        } }, { key: "formatValidationErrors", value: function(t2) {
          var e3 = this;
          return t2.map(function(t3) {
            var n3 = e3.formatValidationError(t3);
            return e3.postFormatter && (n3 = e3.postFormatter(n3, t3)), " - ".concat(q(n3, "   "));
          }).join("\n");
        } }]), r2;
      }(), X = W;
      exports2.default = X;
    }, { "./util/hints": "SqDh" }], "wWOq": [function(require2, module2, exports2) {
      var define2;
      var global2 = arguments[3];
      var e, r = arguments[3];
      !function(r2, t) {
        "object" == typeof exports2 && "undefined" != typeof module2 ? t(exports2) : "function" == typeof e && e.amd ? e(["exports"], t) : t(r2.URI = r2.URI || {});
      }(this, function(e2) {
        "use strict";
        function r2() {
          for (var e3 = arguments.length, r3 = Array(e3), t2 = 0; t2 < e3; t2++)
            r3[t2] = arguments[t2];
          if (r3.length > 1) {
            r3[0] = r3[0].slice(0, -1);
            for (var n2 = r3.length - 1, o2 = 1; o2 < n2; ++o2)
              r3[o2] = r3[o2].slice(1, -1);
            return r3[n2] = r3[n2].slice(1), r3.join("");
          }
          return r3[0];
        }
        __name(r2, "r");
        function t(e3) {
          return "(?:" + e3 + ")";
        }
        __name(t, "t");
        function n(e3) {
          return void 0 === e3 ? "undefined" : null === e3 ? "null" : Object.prototype.toString.call(e3).split(" ").pop().split("]").shift().toLowerCase();
        }
        __name(n, "n");
        function o(e3) {
          return e3.toUpperCase();
        }
        __name(o, "o");
        function a(e3) {
          var n2 = r2("[0-9]", "[A-Fa-f]"), o2 = t(t("%[EFef]" + n2 + "%" + n2 + n2 + "%" + n2 + n2) + "|" + t("%[89A-Fa-f]" + n2 + "%" + n2 + n2) + "|" + t("%" + n2 + n2)), a2 = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", i2 = r2("[\\:\\/\\?\\#\\[\\]\\@]", a2), s2 = e3 ? "[\\uE000-\\uF8FF]" : "[]", u2 = r2("[A-Za-z]", "[0-9]", "[\\-\\.\\_\\~]", e3 ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]"), c2 = t("[A-Za-z]" + r2("[A-Za-z]", "[0-9]", "[\\+\\-\\.]") + "*"), p2 = t(t(o2 + "|" + r2(u2, a2, "[\\:]")) + "*"), h2 = (t(t("25[0-5]") + "|" + t("2[0-4][0-9]") + "|" + t("1[0-9][0-9]") + "|" + t("[1-9][0-9]") + "|[0-9]"), t(t("25[0-5]") + "|" + t("2[0-4][0-9]") + "|" + t("1[0-9][0-9]") + "|" + t("0?[1-9][0-9]") + "|0?0?[0-9]")), f2 = t(h2 + "\\." + h2 + "\\." + h2 + "\\." + h2), l2 = t(n2 + "{1,4}"), v2 = t(t(l2 + "\\:" + l2) + "|" + f2), d2 = t(t(l2 + "\\:") + "{6}" + v2), g2 = t("\\:\\:" + t(l2 + "\\:") + "{5}" + v2), m2 = t(t(l2) + "?\\:\\:" + t(l2 + "\\:") + "{4}" + v2), E2 = t(t(t(l2 + "\\:") + "{0,1}" + l2) + "?\\:\\:" + t(l2 + "\\:") + "{3}" + v2), C2 = t(t(t(l2 + "\\:") + "{0,2}" + l2) + "?\\:\\:" + t(l2 + "\\:") + "{2}" + v2), y2 = t(t(t(l2 + "\\:") + "{0,3}" + l2) + "?\\:\\:" + l2 + "\\:" + v2), S2 = t(t(t(l2 + "\\:") + "{0,4}" + l2) + "?\\:\\:" + v2), A2 = t(t(t(l2 + "\\:") + "{0,5}" + l2) + "?\\:\\:" + l2), D2 = t(t(t(l2 + "\\:") + "{0,6}" + l2) + "?\\:\\:"), w2 = t([d2, g2, m2, E2, C2, y2, S2, A2, D2].join("|")), b2 = t(t(u2 + "|" + o2) + "+"), x2 = (t(w2 + "\\%25" + b2), t(w2 + t("\\%25|\\%(?!" + n2 + "{2})") + b2)), O2 = t("[vV]" + n2 + "+\\." + r2(u2, a2, "[\\:]") + "+"), I2 = t("\\[" + t(x2 + "|" + w2 + "|" + O2) + "\\]"), F2 = t(t(o2 + "|" + r2(u2, a2)) + "*"), N2 = t(I2 + "|" + f2 + "(?!" + F2 + ")|" + F2), R2 = t("[0-9]*"), T2 = t(t(p2 + "@") + "?" + N2 + t("\\:" + R2) + "?"), _2 = t(o2 + "|" + r2(u2, a2, "[\\:\\@]")), P2 = t(_2 + "*"), U2 = t(_2 + "+"), j2 = t(t(o2 + "|" + r2(u2, a2, "[\\@]")) + "+"), q2 = t(t("\\/" + P2) + "*"), H2 = t("\\/" + t(U2 + q2) + "?"), z2 = t(j2 + q2), L2 = t(U2 + q2), $2 = "(?!" + _2 + ")", V2 = (t(q2 + "|" + H2 + "|" + z2 + "|" + L2 + "|" + $2), t(t(_2 + "|" + r2("[\\/\\?]", s2)) + "*")), M2 = t(t(_2 + "|[\\/\\?]") + "*"), Z2 = t(t("\\/\\/" + T2 + q2) + "|" + H2 + "|" + L2 + "|" + $2), k2 = t(c2 + "\\:" + Z2 + t("\\?" + V2) + "?" + t("\\#" + M2) + "?"), G2 = t(t("\\/\\/" + T2 + q2) + "|" + H2 + "|" + z2 + "|" + $2), Q2 = t(G2 + t("\\?" + V2) + "?" + t("\\#" + M2) + "?");
          t(k2 + "|" + Q2), t(c2 + "\\:" + Z2 + t("\\?" + V2) + "?"), t(t("\\/\\/(" + t("(" + p2 + ")@") + "?(" + N2 + ")" + t("\\:(" + R2 + ")") + "?)") + "?(" + q2 + "|" + H2 + "|" + L2 + "|" + $2 + ")"), t("\\?(" + V2 + ")"), t("\\#(" + M2 + ")"), t(t("\\/\\/(" + t("(" + p2 + ")@") + "?(" + N2 + ")" + t("\\:(" + R2 + ")") + "?)") + "?(" + q2 + "|" + H2 + "|" + z2 + "|" + $2 + ")"), t("\\?(" + V2 + ")"), t("\\#(" + M2 + ")"), t(t("\\/\\/(" + t("(" + p2 + ")@") + "?(" + N2 + ")" + t("\\:(" + R2 + ")") + "?)") + "?(" + q2 + "|" + H2 + "|" + L2 + "|" + $2 + ")"), t("\\?(" + V2 + ")"), t("\\#(" + M2 + ")"), t("(" + p2 + ")@"), t("\\:(" + R2 + ")");
          return { NOT_SCHEME: new RegExp(r2("[^]", "[A-Za-z]", "[0-9]", "[\\+\\-\\.]"), "g"), NOT_USERINFO: new RegExp(r2("[^\\%\\:]", u2, a2), "g"), NOT_HOST: new RegExp(r2("[^\\%\\[\\]\\:]", u2, a2), "g"), NOT_PATH: new RegExp(r2("[^\\%\\/\\:\\@]", u2, a2), "g"), NOT_PATH_NOSCHEME: new RegExp(r2("[^\\%\\/\\@]", u2, a2), "g"), NOT_QUERY: new RegExp(r2("[^\\%]", u2, a2, "[\\:\\@\\/\\?]", s2), "g"), NOT_FRAGMENT: new RegExp(r2("[^\\%]", u2, a2, "[\\:\\@\\/\\?]"), "g"), ESCAPE: new RegExp(r2("[^]", u2, a2), "g"), UNRESERVED: new RegExp(u2, "g"), OTHER_CHARS: new RegExp(r2("[^\\%]", u2, i2), "g"), PCT_ENCODED: new RegExp(o2, "g"), IPV4ADDRESS: new RegExp("^(" + f2 + ")$"), IPV6ADDRESS: new RegExp("^\\[?(" + w2 + ")" + t(t("\\%25|\\%(?!" + n2 + "{2})") + "(" + b2 + ")") + "?\\]?$") };
        }
        __name(a, "a");
        var i = a(false), s = a(true), u = function() {
          return function(e3, r3) {
            if (Array.isArray(e3))
              return e3;
            if (Symbol.iterator in Object(e3))
              return function(e4, r4) {
                var t2 = [], n2 = true, o2 = false, a2 = void 0;
                try {
                  for (var i2, s2 = e4[Symbol.iterator](); !(n2 = (i2 = s2.next()).done) && (t2.push(i2.value), !r4 || t2.length !== r4); n2 = true)
                    ;
                } catch (u2) {
                  o2 = true, a2 = u2;
                } finally {
                  try {
                    !n2 && s2.return && s2.return();
                  } finally {
                    if (o2)
                      throw a2;
                  }
                }
                return t2;
              }(e3, r3);
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          };
        }(), c = 2147483647, p = /^xn--/, h = /[^\0-\x7E]/, f = /[\x2E\u3002\uFF0E\uFF61]/g, l = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, v = Math.floor, d = String.fromCharCode;
        function g(e3) {
          throw new RangeError(l[e3]);
        }
        __name(g, "g");
        function m(e3, r3) {
          var t2 = e3.split("@"), n2 = "";
          t2.length > 1 && (n2 = t2[0] + "@", e3 = t2[1]);
          var o2 = function(e4, r4) {
            for (var t3 = [], n3 = e4.length; n3--; )
              t3[n3] = r4(e4[n3]);
            return t3;
          }((e3 = e3.replace(f, ".")).split("."), r3).join(".");
          return n2 + o2;
        }
        __name(m, "m");
        function E(e3) {
          for (var r3 = [], t2 = 0, n2 = e3.length; t2 < n2; ) {
            var o2 = e3.charCodeAt(t2++);
            if (o2 >= 55296 && o2 <= 56319 && t2 < n2) {
              var a2 = e3.charCodeAt(t2++);
              56320 == (64512 & a2) ? r3.push(((1023 & o2) << 10) + (1023 & a2) + 65536) : (r3.push(o2), t2--);
            } else
              r3.push(o2);
          }
          return r3;
        }
        __name(E, "E");
        var C = /* @__PURE__ */ __name(function(e3, r3) {
          return e3 + 22 + 75 * (e3 < 26) - ((0 != r3) << 5);
        }, "C"), y = /* @__PURE__ */ __name(function(e3, r3, t2) {
          var n2 = 0;
          for (e3 = t2 ? v(e3 / 700) : e3 >> 1, e3 += v(e3 / r3); e3 > 455; n2 += 36)
            e3 = v(e3 / 35);
          return v(n2 + 36 * e3 / (e3 + 38));
        }, "y"), S = /* @__PURE__ */ __name(function(e3) {
          var r3, t2 = [], n2 = e3.length, o2 = 0, a2 = 128, i2 = 72, s2 = e3.lastIndexOf("-");
          s2 < 0 && (s2 = 0);
          for (var u2 = 0; u2 < s2; ++u2)
            e3.charCodeAt(u2) >= 128 && g("not-basic"), t2.push(e3.charCodeAt(u2));
          for (var p2 = s2 > 0 ? s2 + 1 : 0; p2 < n2; ) {
            for (var h2 = o2, f2 = 1, l2 = 36; ; l2 += 36) {
              p2 >= n2 && g("invalid-input");
              var d2 = (r3 = e3.charCodeAt(p2++)) - 48 < 10 ? r3 - 22 : r3 - 65 < 26 ? r3 - 65 : r3 - 97 < 26 ? r3 - 97 : 36;
              (d2 >= 36 || d2 > v((c - o2) / f2)) && g("overflow"), o2 += d2 * f2;
              var m2 = l2 <= i2 ? 1 : l2 >= i2 + 26 ? 26 : l2 - i2;
              if (d2 < m2)
                break;
              var E2 = 36 - m2;
              f2 > v(c / E2) && g("overflow"), f2 *= E2;
            }
            var C2 = t2.length + 1;
            i2 = y(o2 - h2, C2, 0 == h2), v(o2 / C2) > c - a2 && g("overflow"), a2 += v(o2 / C2), o2 %= C2, t2.splice(o2++, 0, a2);
          }
          return String.fromCodePoint.apply(String, t2);
        }, "S"), A = /* @__PURE__ */ __name(function(e3) {
          var r3 = [], t2 = (e3 = E(e3)).length, n2 = 128, o2 = 0, a2 = 72, i2 = true, s2 = false, u2 = void 0;
          try {
            for (var p2, h2 = e3[Symbol.iterator](); !(i2 = (p2 = h2.next()).done); i2 = true) {
              var f2 = p2.value;
              f2 < 128 && r3.push(d(f2));
            }
          } catch (L2) {
            s2 = true, u2 = L2;
          } finally {
            try {
              !i2 && h2.return && h2.return();
            } finally {
              if (s2)
                throw u2;
            }
          }
          var l2 = r3.length, m2 = l2;
          for (l2 && r3.push("-"); m2 < t2; ) {
            var S2 = c, A2 = true, D2 = false, w2 = void 0;
            try {
              for (var b2, x2 = e3[Symbol.iterator](); !(A2 = (b2 = x2.next()).done); A2 = true) {
                var O2 = b2.value;
                O2 >= n2 && O2 < S2 && (S2 = O2);
              }
            } catch (L2) {
              D2 = true, w2 = L2;
            } finally {
              try {
                !A2 && x2.return && x2.return();
              } finally {
                if (D2)
                  throw w2;
              }
            }
            var I2 = m2 + 1;
            S2 - n2 > v((c - o2) / I2) && g("overflow"), o2 += (S2 - n2) * I2, n2 = S2;
            var F2 = true, N2 = false, R2 = void 0;
            try {
              for (var T2, _2 = e3[Symbol.iterator](); !(F2 = (T2 = _2.next()).done); F2 = true) {
                var P2 = T2.value;
                if (P2 < n2 && ++o2 > c && g("overflow"), P2 == n2) {
                  for (var U2 = o2, j2 = 36; ; j2 += 36) {
                    var q2 = j2 <= a2 ? 1 : j2 >= a2 + 26 ? 26 : j2 - a2;
                    if (U2 < q2)
                      break;
                    var H2 = U2 - q2, z2 = 36 - q2;
                    r3.push(d(C(q2 + H2 % z2, 0))), U2 = v(H2 / z2);
                  }
                  r3.push(d(C(U2, 0))), a2 = y(o2, I2, m2 == l2), o2 = 0, ++m2;
                }
              }
            } catch (L2) {
              N2 = true, R2 = L2;
            } finally {
              try {
                !F2 && _2.return && _2.return();
              } finally {
                if (N2)
                  throw R2;
              }
            }
            ++o2, ++n2;
          }
          return r3.join("");
        }, "A"), D = { version: "2.1.0", ucs2: { decode: E, encode: function(e3) {
          return String.fromCodePoint.apply(String, function(e4) {
            if (Array.isArray(e4)) {
              for (var r3 = 0, t2 = Array(e4.length); r3 < e4.length; r3++)
                t2[r3] = e4[r3];
              return t2;
            }
            return Array.from(e4);
          }(e3));
        } }, decode: S, encode: A, toASCII: function(e3) {
          return m(e3, function(e4) {
            return h.test(e4) ? "xn--" + A(e4) : e4;
          });
        }, toUnicode: function(e3) {
          return m(e3, function(e4) {
            return p.test(e4) ? S(e4.slice(4).toLowerCase()) : e4;
          });
        } }, w = {};
        function b(e3) {
          var r3 = e3.charCodeAt(0);
          return r3 < 16 ? "%0" + r3.toString(16).toUpperCase() : r3 < 128 ? "%" + r3.toString(16).toUpperCase() : r3 < 2048 ? "%" + (r3 >> 6 | 192).toString(16).toUpperCase() + "%" + (63 & r3 | 128).toString(16).toUpperCase() : "%" + (r3 >> 12 | 224).toString(16).toUpperCase() + "%" + (r3 >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (63 & r3 | 128).toString(16).toUpperCase();
        }
        __name(b, "b");
        function x(e3) {
          for (var r3 = "", t2 = 0, n2 = e3.length; t2 < n2; ) {
            var o2 = parseInt(e3.substr(t2 + 1, 2), 16);
            if (o2 < 128)
              r3 += String.fromCharCode(o2), t2 += 3;
            else if (o2 >= 194 && o2 < 224) {
              if (n2 - t2 >= 6) {
                var a2 = parseInt(e3.substr(t2 + 4, 2), 16);
                r3 += String.fromCharCode((31 & o2) << 6 | 63 & a2);
              } else
                r3 += e3.substr(t2, 6);
              t2 += 6;
            } else if (o2 >= 224) {
              if (n2 - t2 >= 9) {
                var i2 = parseInt(e3.substr(t2 + 4, 2), 16), s2 = parseInt(e3.substr(t2 + 7, 2), 16);
                r3 += String.fromCharCode((15 & o2) << 12 | (63 & i2) << 6 | 63 & s2);
              } else
                r3 += e3.substr(t2, 9);
              t2 += 9;
            } else
              r3 += e3.substr(t2, 3), t2 += 3;
          }
          return r3;
        }
        __name(x, "x");
        function O(e3, r3) {
          function t2(e4) {
            var t3 = x(e4);
            return t3.match(r3.UNRESERVED) ? t3 : e4;
          }
          __name(t2, "t");
          return e3.scheme && (e3.scheme = String(e3.scheme).replace(r3.PCT_ENCODED, t2).toLowerCase().replace(r3.NOT_SCHEME, "")), void 0 !== e3.userinfo && (e3.userinfo = String(e3.userinfo).replace(r3.PCT_ENCODED, t2).replace(r3.NOT_USERINFO, b).replace(r3.PCT_ENCODED, o)), void 0 !== e3.host && (e3.host = String(e3.host).replace(r3.PCT_ENCODED, t2).toLowerCase().replace(r3.NOT_HOST, b).replace(r3.PCT_ENCODED, o)), void 0 !== e3.path && (e3.path = String(e3.path).replace(r3.PCT_ENCODED, t2).replace(e3.scheme ? r3.NOT_PATH : r3.NOT_PATH_NOSCHEME, b).replace(r3.PCT_ENCODED, o)), void 0 !== e3.query && (e3.query = String(e3.query).replace(r3.PCT_ENCODED, t2).replace(r3.NOT_QUERY, b).replace(r3.PCT_ENCODED, o)), void 0 !== e3.fragment && (e3.fragment = String(e3.fragment).replace(r3.PCT_ENCODED, t2).replace(r3.NOT_FRAGMENT, b).replace(r3.PCT_ENCODED, o)), e3;
        }
        __name(O, "O");
        function I(e3) {
          return e3.replace(/^0*(.*)/, "$1") || "0";
        }
        __name(I, "I");
        function F(e3, r3) {
          var t2 = e3.match(r3.IPV4ADDRESS) || [], n2 = u(t2, 2)[1];
          return n2 ? n2.split(".").map(I).join(".") : e3;
        }
        __name(F, "F");
        function N(e3, r3) {
          var t2 = e3.match(r3.IPV6ADDRESS) || [], n2 = u(t2, 3), o2 = n2[1], a2 = n2[2];
          if (o2) {
            for (var i2 = o2.toLowerCase().split("::").reverse(), s2 = u(i2, 2), c2 = s2[0], p2 = s2[1], h2 = p2 ? p2.split(":").map(I) : [], f2 = c2.split(":").map(I), l2 = r3.IPV4ADDRESS.test(f2[f2.length - 1]), v2 = l2 ? 7 : 8, d2 = f2.length - v2, g2 = Array(v2), m2 = 0; m2 < v2; ++m2)
              g2[m2] = h2[m2] || f2[d2 + m2] || "";
            l2 && (g2[v2 - 1] = F(g2[v2 - 1], r3));
            var E2 = g2.reduce(function(e4, r4, t3) {
              if (!r4 || "0" === r4) {
                var n3 = e4[e4.length - 1];
                n3 && n3.index + n3.length === t3 ? n3.length++ : e4.push({ index: t3, length: 1 });
              }
              return e4;
            }, []).sort(function(e4, r4) {
              return r4.length - e4.length;
            })[0], C2 = void 0;
            if (E2 && E2.length > 1) {
              var y2 = g2.slice(0, E2.index), S2 = g2.slice(E2.index + E2.length);
              C2 = y2.join(":") + "::" + S2.join(":");
            } else
              C2 = g2.join(":");
            return a2 && (C2 += "%" + a2), C2;
          }
          return e3;
        }
        __name(N, "N");
        var R = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i, T = void 0 === "".match(/(){0}/)[1];
        function _(e3) {
          var r3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, t2 = {}, n2 = false !== r3.iri ? s : i;
          "suffix" === r3.reference && (e3 = (r3.scheme ? r3.scheme + ":" : "") + "//" + e3);
          var o2 = e3.match(R);
          if (o2) {
            T ? (t2.scheme = o2[1], t2.userinfo = o2[3], t2.host = o2[4], t2.port = parseInt(o2[5], 10), t2.path = o2[6] || "", t2.query = o2[7], t2.fragment = o2[8], isNaN(t2.port) && (t2.port = o2[5])) : (t2.scheme = o2[1] || void 0, t2.userinfo = -1 !== e3.indexOf("@") ? o2[3] : void 0, t2.host = -1 !== e3.indexOf("//") ? o2[4] : void 0, t2.port = parseInt(o2[5], 10), t2.path = o2[6] || "", t2.query = -1 !== e3.indexOf("?") ? o2[7] : void 0, t2.fragment = -1 !== e3.indexOf("#") ? o2[8] : void 0, isNaN(t2.port) && (t2.port = e3.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? o2[4] : void 0)), t2.host && (t2.host = N(F(t2.host, n2), n2)), void 0 !== t2.scheme || void 0 !== t2.userinfo || void 0 !== t2.host || void 0 !== t2.port || t2.path || void 0 !== t2.query ? void 0 === t2.scheme ? t2.reference = "relative" : void 0 === t2.fragment ? t2.reference = "absolute" : t2.reference = "uri" : t2.reference = "same-document", r3.reference && "suffix" !== r3.reference && r3.reference !== t2.reference && (t2.error = t2.error || "URI is not a " + r3.reference + " reference.");
            var a2 = w[(r3.scheme || t2.scheme || "").toLowerCase()];
            if (r3.unicodeSupport || a2 && a2.unicodeSupport)
              O(t2, n2);
            else {
              if (t2.host && (r3.domainHost || a2 && a2.domainHost))
                try {
                  t2.host = D.toASCII(t2.host.replace(n2.PCT_ENCODED, x).toLowerCase());
                } catch (u2) {
                  t2.error = t2.error || "Host's domain name can not be converted to ASCII via punycode: " + u2;
                }
              O(t2, i);
            }
            a2 && a2.parse && a2.parse(t2, r3);
          } else
            t2.error = t2.error || "URI can not be parsed.";
          return t2;
        }
        __name(_, "_");
        var P = /^\.\.?\//, U = /^\/\.(\/|$)/, j = /^\/\.\.(\/|$)/, q = /^\/?(?:.|\n)*?(?=\/|$)/;
        function H(e3) {
          for (var r3 = []; e3.length; )
            if (e3.match(P))
              e3 = e3.replace(P, "");
            else if (e3.match(U))
              e3 = e3.replace(U, "/");
            else if (e3.match(j))
              e3 = e3.replace(j, "/"), r3.pop();
            else if ("." === e3 || ".." === e3)
              e3 = "";
            else {
              var t2 = e3.match(q);
              if (!t2)
                throw new Error("Unexpected dot segment condition");
              var n2 = t2[0];
              e3 = e3.slice(n2.length), r3.push(n2);
            }
          return r3.join("");
        }
        __name(H, "H");
        function z(e3) {
          var r3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, t2 = r3.iri ? s : i, n2 = [], o2 = w[(r3.scheme || e3.scheme || "").toLowerCase()];
          if (o2 && o2.serialize && o2.serialize(e3, r3), e3.host) {
            if (t2.IPV6ADDRESS.test(e3.host))
              ;
            else if (r3.domainHost || o2 && o2.domainHost)
              try {
                e3.host = r3.iri ? D.toUnicode(e3.host) : D.toASCII(e3.host.replace(t2.PCT_ENCODED, x).toLowerCase());
              } catch (c2) {
                e3.error = e3.error || "Host's domain name can not be converted to " + (r3.iri ? "Unicode" : "ASCII") + " via punycode: " + c2;
              }
          }
          O(e3, t2), "suffix" !== r3.reference && e3.scheme && (n2.push(e3.scheme), n2.push(":"));
          var a2 = function(e4, r4) {
            var t3 = false !== r4.iri ? s : i, n3 = [];
            return void 0 !== e4.userinfo && (n3.push(e4.userinfo), n3.push("@")), void 0 !== e4.host && n3.push(N(F(String(e4.host), t3), t3).replace(t3.IPV6ADDRESS, function(e5, r5, t4) {
              return "[" + r5 + (t4 ? "%25" + t4 : "") + "]";
            })), "number" == typeof e4.port && (n3.push(":"), n3.push(e4.port.toString(10))), n3.length ? n3.join("") : void 0;
          }(e3, r3);
          if (void 0 !== a2 && ("suffix" !== r3.reference && n2.push("//"), n2.push(a2), e3.path && "/" !== e3.path.charAt(0) && n2.push("/")), void 0 !== e3.path) {
            var u2 = e3.path;
            r3.absolutePath || o2 && o2.absolutePath || (u2 = H(u2)), void 0 === a2 && (u2 = u2.replace(/^\/\//, "/%2F")), n2.push(u2);
          }
          return void 0 !== e3.query && (n2.push("?"), n2.push(e3.query)), void 0 !== e3.fragment && (n2.push("#"), n2.push(e3.fragment)), n2.join("");
        }
        __name(z, "z");
        function L(e3, r3) {
          var t2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, n2 = {};
          return arguments[3] || (e3 = _(z(e3, t2), t2), r3 = _(z(r3, t2), t2)), !(t2 = t2 || {}).tolerant && r3.scheme ? (n2.scheme = r3.scheme, n2.userinfo = r3.userinfo, n2.host = r3.host, n2.port = r3.port, n2.path = H(r3.path || ""), n2.query = r3.query) : (void 0 !== r3.userinfo || void 0 !== r3.host || void 0 !== r3.port ? (n2.userinfo = r3.userinfo, n2.host = r3.host, n2.port = r3.port, n2.path = H(r3.path || ""), n2.query = r3.query) : (r3.path ? ("/" === r3.path.charAt(0) ? n2.path = H(r3.path) : (void 0 === e3.userinfo && void 0 === e3.host && void 0 === e3.port || e3.path ? e3.path ? n2.path = e3.path.slice(0, e3.path.lastIndexOf("/") + 1) + r3.path : n2.path = r3.path : n2.path = "/" + r3.path, n2.path = H(n2.path)), n2.query = r3.query) : (n2.path = e3.path, void 0 !== r3.query ? n2.query = r3.query : n2.query = e3.query), n2.userinfo = e3.userinfo, n2.host = e3.host, n2.port = e3.port), n2.scheme = e3.scheme), n2.fragment = r3.fragment, n2;
        }
        __name(L, "L");
        function $(e3, r3) {
          return e3 && e3.toString().replace(r3 && r3.iri ? s.PCT_ENCODED : i.PCT_ENCODED, x);
        }
        __name($, "$");
        var V = { scheme: "http", domainHost: true, parse: function(e3, r3) {
          return e3.host || (e3.error = e3.error || "HTTP URIs must have a host."), e3;
        }, serialize: function(e3, r3) {
          return e3.port !== ("https" !== String(e3.scheme).toLowerCase() ? 80 : 443) && "" !== e3.port || (e3.port = void 0), e3.path || (e3.path = "/"), e3;
        } }, M = { scheme: "https", domainHost: V.domainHost, parse: V.parse, serialize: V.serialize }, Z = {}, k = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]", G = "[0-9A-Fa-f]", Q = t(t("%[EFef][0-9A-Fa-f]%" + G + G + "%" + G + G) + "|" + t("%[89A-Fa-f][0-9A-Fa-f]%" + G + G) + "|" + t("%" + G + G)), Y = r2("[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]", '[\\"\\\\]'), B = new RegExp(k, "g"), J = new RegExp(Q, "g"), K = new RegExp(r2("[^]", "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]", "[\\.]", '[\\"]', Y), "g"), W = new RegExp(r2("[^]", k, "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]"), "g"), X = W;
        function ee(e3) {
          var r3 = x(e3);
          return r3.match(B) ? r3 : e3;
        }
        __name(ee, "ee");
        var re = { scheme: "mailto", parse: function(e3, r3) {
          var t2 = e3, n2 = t2.to = t2.path ? t2.path.split(",") : [];
          if (t2.path = void 0, t2.query) {
            for (var o2 = false, a2 = {}, i2 = t2.query.split("&"), s2 = 0, u2 = i2.length; s2 < u2; ++s2) {
              var c2 = i2[s2].split("=");
              switch (c2[0]) {
                case "to":
                  for (var p2 = c2[1].split(","), h2 = 0, f2 = p2.length; h2 < f2; ++h2)
                    n2.push(p2[h2]);
                  break;
                case "subject":
                  t2.subject = $(c2[1], r3);
                  break;
                case "body":
                  t2.body = $(c2[1], r3);
                  break;
                default:
                  o2 = true, a2[$(c2[0], r3)] = $(c2[1], r3);
              }
            }
            o2 && (t2.headers = a2);
          }
          t2.query = void 0;
          for (var l2 = 0, v2 = n2.length; l2 < v2; ++l2) {
            var d2 = n2[l2].split("@");
            if (d2[0] = $(d2[0]), r3.unicodeSupport)
              d2[1] = $(d2[1], r3).toLowerCase();
            else
              try {
                d2[1] = D.toASCII($(d2[1], r3).toLowerCase());
              } catch (g2) {
                t2.error = t2.error || "Email address's domain name can not be converted to ASCII via punycode: " + g2;
              }
            n2[l2] = d2.join("@");
          }
          return t2;
        }, serialize: function(e3, r3) {
          var t2, n2 = e3, a2 = null != (t2 = e3.to) ? t2 instanceof Array ? t2 : "number" != typeof t2.length || t2.split || t2.setInterval || t2.call ? [t2] : Array.prototype.slice.call(t2) : [];
          if (a2) {
            for (var i2 = 0, s2 = a2.length; i2 < s2; ++i2) {
              var u2 = String(a2[i2]), c2 = u2.lastIndexOf("@"), p2 = u2.slice(0, c2).replace(J, ee).replace(J, o).replace(K, b), h2 = u2.slice(c2 + 1);
              try {
                h2 = r3.iri ? D.toUnicode(h2) : D.toASCII($(h2, r3).toLowerCase());
              } catch (d2) {
                n2.error = n2.error || "Email address's domain name can not be converted to " + (r3.iri ? "Unicode" : "ASCII") + " via punycode: " + d2;
              }
              a2[i2] = p2 + "@" + h2;
            }
            n2.path = a2.join(",");
          }
          var f2 = e3.headers = e3.headers || {};
          e3.subject && (f2.subject = e3.subject), e3.body && (f2.body = e3.body);
          var l2 = [];
          for (var v2 in f2)
            f2[v2] !== Z[v2] && l2.push(v2.replace(J, ee).replace(J, o).replace(W, b) + "=" + f2[v2].replace(J, ee).replace(J, o).replace(X, b));
          return l2.length && (n2.query = l2.join("&")), n2;
        } }, te = /^([^\:]+)\:(.*)/, ne = { scheme: "urn", parse: function(e3, r3) {
          var t2 = e3.path && e3.path.match(te), n2 = e3;
          if (t2) {
            var o2 = r3.scheme || n2.scheme || "urn", a2 = t2[1].toLowerCase(), i2 = t2[2], s2 = o2 + ":" + (r3.nid || a2), u2 = w[s2];
            n2.nid = a2, n2.nss = i2, n2.path = void 0, u2 && (n2 = u2.parse(n2, r3));
          } else
            n2.error = n2.error || "URN can not be parsed.";
          return n2;
        }, serialize: function(e3, r3) {
          var t2 = r3.scheme || e3.scheme || "urn", n2 = e3.nid, o2 = t2 + ":" + (r3.nid || n2), a2 = w[o2];
          a2 && (e3 = a2.serialize(e3, r3));
          var i2 = e3, s2 = e3.nss;
          return i2.path = (n2 || r3.nid) + ":" + s2, i2;
        } }, oe = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/, ae = { scheme: "urn:uuid", parse: function(e3, r3) {
          var t2 = e3;
          return t2.uuid = t2.nss, t2.nss = void 0, r3.tolerant || t2.uuid && t2.uuid.match(oe) || (t2.error = t2.error || "UUID is not valid."), t2;
        }, serialize: function(e3, r3) {
          var t2 = e3;
          return t2.nss = (e3.uuid || "").toLowerCase(), t2;
        } };
        w[V.scheme] = V, w[M.scheme] = M, w[re.scheme] = re, w[ne.scheme] = ne, w[ae.scheme] = ae, e2.SCHEMES = w, e2.pctEncChar = b, e2.pctDecChars = x, e2.parse = _, e2.removeDotSegments = H, e2.serialize = z, e2.resolveComponents = L, e2.resolve = function(e3, r3, t2) {
          var n2 = function(e4, r4) {
            var t3 = e4;
            if (r4)
              for (var n3 in r4)
                t3[n3] = r4[n3];
            return t3;
          }({ scheme: "null" }, t2);
          return z(L(_(e3, n2), _(r3, n2), n2, true), n2);
        }, e2.normalize = function(e3, r3) {
          return "string" == typeof e3 ? e3 = z(_(e3, r3), r3) : "object" === n(e3) && (e3 = _(z(e3, r3), r3)), e3;
        }, e2.equal = function(e3, r3, t2) {
          return "string" == typeof e3 ? e3 = z(_(e3, t2), t2) : "object" === n(e3) && (e3 = z(e3, t2)), "string" == typeof r3 ? r3 = z(_(r3, t2), t2) : "object" === n(r3) && (r3 = z(r3, t2)), e3 === r3;
        }, e2.escapeComponent = function(e3, r3) {
          return e3 && e3.toString().replace(r3 && r3.iri ? s.ESCAPE : i.ESCAPE, b);
        }, e2.unescapeComponent = $, Object.defineProperty(e2, "__esModule", { value: true });
      });
    }, {}], "dPQH": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = /* @__PURE__ */ __name(function r(t, e) {
        if (t === e)
          return true;
        if (t && e && "object" == typeof t && "object" == typeof e) {
          if (t.constructor !== e.constructor)
            return false;
          var o, n, u;
          if (Array.isArray(t)) {
            if ((o = t.length) != e.length)
              return false;
            for (n = o; 0 != n--; )
              if (!r(t[n], e[n]))
                return false;
            return true;
          }
          if (t.constructor === RegExp)
            return t.source === e.source && t.flags === e.flags;
          if (t.valueOf !== Object.prototype.valueOf)
            return t.valueOf() === e.valueOf();
          if (t.toString !== Object.prototype.toString)
            return t.toString() === e.toString();
          if ((o = (u = Object.keys(t)).length) !== Object.keys(e).length)
            return false;
          for (n = o; 0 != n--; )
            if (!Object.prototype.hasOwnProperty.call(e, u[n]))
              return false;
          for (n = o; 0 != n--; ) {
            var f = u[n];
            if (!r(t[f], e[f]))
              return false;
          }
          return true;
        }
        return t != t && e != e;
      }, "r");
    }, {}], "rD0p": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = function(r) {
        for (var t, e = 0, o = r.length, c = 0; c < o; )
          e++, (t = r.charCodeAt(c++)) >= 55296 && t <= 56319 && c < o && 56320 == (64512 & (t = r.charCodeAt(c))) && c++;
        return e;
      };
    }, {}], "Q1F7": [function(require2, module2, exports2) {
      "use strict";
      function e(e2, r2) {
        for (var n2 in r2 = r2 || {}, e2)
          r2[n2] = e2[n2];
        return r2;
      }
      __name(e, "e");
      function r(e2, r2, n2, t2) {
        var a2 = t2 ? " !== " : " === ", o2 = t2 ? " || " : " && ", u2 = t2 ? "!" : "", c2 = t2 ? "" : "!";
        switch (e2) {
          case "null":
            return r2 + a2 + "null";
          case "array":
            return u2 + "Array.isArray(" + r2 + ")";
          case "object":
            return "(" + u2 + r2 + o2 + "typeof " + r2 + a2 + '"object"' + o2 + c2 + "Array.isArray(" + r2 + "))";
          case "integer":
            return "(typeof " + r2 + a2 + '"number"' + o2 + c2 + "(" + r2 + " % 1)" + o2 + r2 + a2 + r2 + (n2 ? o2 + u2 + "isFinite(" + r2 + ")" : "") + ")";
          case "number":
            return "(typeof " + r2 + a2 + '"' + e2 + '"' + (n2 ? o2 + u2 + "isFinite(" + r2 + ")" : "") + ")";
          default:
            return "typeof " + r2 + a2 + '"' + e2 + '"';
        }
      }
      __name(r, "r");
      function n(e2, n2, t2) {
        switch (e2.length) {
          case 1:
            return r(e2[0], n2, t2, true);
          default:
            var a2 = "", u2 = o(e2);
            for (var c2 in u2.array && u2.object && (a2 = u2.null ? "(" : "(!" + n2 + " || ", a2 += "typeof " + n2 + ' !== "object")', delete u2.null, delete u2.array, delete u2.object), u2.number && delete u2.integer, u2)
              a2 += (a2 ? " && " : "") + r(c2, n2, t2, true);
            return a2;
        }
      }
      __name(n, "n");
      module2.exports = { copy: e, checkDataType: r, checkDataTypes: n, coerceToTypes: a, toHash: o, getProperty: i, escapeQuotes: l, equal: require2("fast-deep-equal"), ucs2length: require2("./ucs2length"), varOccurences: f, varReplace: s, schemaHasRules: p, schemaHasRulesExcept: g, schemaUnknownRules: y, toQuotedString: h, getPathExpr: v, getPath: d, getData: w, unescapeFragment: E, unescapeJsonPointer: A, escapeFragment: R, escapeJsonPointer: x };
      var t = o(["string", "number", "integer", "boolean", "null"]);
      function a(e2, r2) {
        if (Array.isArray(r2)) {
          for (var n2 = [], a2 = 0; a2 < r2.length; a2++) {
            var o2 = r2[a2];
            t[o2] ? n2[n2.length] = o2 : "array" === e2 && "array" === o2 && (n2[n2.length] = o2);
          }
          if (n2.length)
            return n2;
        } else {
          if (t[r2])
            return [r2];
          if ("array" === e2 && "array" === r2)
            return ["array"];
        }
      }
      __name(a, "a");
      function o(e2) {
        for (var r2 = {}, n2 = 0; n2 < e2.length; n2++)
          r2[e2[n2]] = true;
        return r2;
      }
      __name(o, "o");
      var u = /^[a-z$_][a-z$_0-9]*$/i, c = /'|\\/g;
      function i(e2) {
        return "number" == typeof e2 ? "[" + e2 + "]" : u.test(e2) ? "." + e2 : "['" + l(e2) + "']";
      }
      __name(i, "i");
      function l(e2) {
        return e2.replace(c, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t");
      }
      __name(l, "l");
      function f(e2, r2) {
        r2 += "[^0-9]";
        var n2 = e2.match(new RegExp(r2, "g"));
        return n2 ? n2.length : 0;
      }
      __name(f, "f");
      function s(e2, r2, n2) {
        return r2 += "([^0-9])", n2 = n2.replace(/\$/g, "$$$$"), e2.replace(new RegExp(r2, "g"), n2 + "$1");
      }
      __name(s, "s");
      function p(e2, r2) {
        if ("boolean" == typeof e2)
          return !e2;
        for (var n2 in e2)
          if (r2[n2])
            return true;
      }
      __name(p, "p");
      function g(e2, r2, n2) {
        if ("boolean" == typeof e2)
          return !e2 && "not" != n2;
        for (var t2 in e2)
          if (t2 != n2 && r2[t2])
            return true;
      }
      __name(g, "g");
      function y(e2, r2) {
        if ("boolean" != typeof e2) {
          for (var n2 in e2)
            if (!r2[n2])
              return n2;
        }
      }
      __name(y, "y");
      function h(e2) {
        return "'" + l(e2) + "'";
      }
      __name(h, "h");
      function v(e2, r2, n2, t2) {
        return $(e2, n2 ? "'/' + " + r2 + (t2 ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : t2 ? "'[' + " + r2 + " + ']'" : "'[\\'' + " + r2 + " + '\\']'");
      }
      __name(v, "v");
      function d(e2, r2, n2) {
        return $(e2, h(n2 ? "/" + x(r2) : i(r2)));
      }
      __name(d, "d");
      var m = /^\/(?:[^~]|~0|~1)*$/, b = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
      function w(e2, r2, n2) {
        var t2, a2, o2, u2;
        if ("" === e2)
          return "rootData";
        if ("/" == e2[0]) {
          if (!m.test(e2))
            throw new Error("Invalid JSON-pointer: " + e2);
          a2 = e2, o2 = "rootData";
        } else {
          if (!(u2 = e2.match(b)))
            throw new Error("Invalid JSON-pointer: " + e2);
          if (t2 = +u2[1], "#" == (a2 = u2[2])) {
            if (t2 >= r2)
              throw new Error("Cannot access property/index " + t2 + " levels up, current level is " + r2);
            return n2[r2 - t2];
          }
          if (t2 > r2)
            throw new Error("Cannot access data " + t2 + " levels up, current level is " + r2);
          if (o2 = "data" + (r2 - t2 || ""), !a2)
            return o2;
        }
        for (var c2 = o2, l2 = a2.split("/"), f2 = 0; f2 < l2.length; f2++) {
          var s2 = l2[f2];
          s2 && (c2 += " && " + (o2 += i(A(s2))));
        }
        return c2;
      }
      __name(w, "w");
      function $(e2, r2) {
        return '""' == e2 ? r2 : (e2 + " + " + r2).replace(/([^\\])' \+ '/g, "$1");
      }
      __name($, "$");
      function E(e2) {
        return A(decodeURIComponent(e2));
      }
      __name(E, "E");
      function R(e2) {
        return encodeURIComponent(x(e2));
      }
      __name(R, "R");
      function x(e2) {
        return e2.replace(/~/g, "~0").replace(/\//g, "~1");
      }
      __name(x, "x");
      function A(e2) {
        return e2.replace(/~1/g, "/").replace(/~0/g, "~");
      }
      __name(A, "A");
    }, { "fast-deep-equal": "dPQH", "./ucs2length": "rD0p" }], "HHLG": [function(require2, module2, exports2) {
      "use strict";
      var t = require2("./util");
      function e(e2) {
        t.copy(e2, this);
      }
      __name(e, "e");
      module2.exports = e;
    }, { "./util": "Q1F7" }], "uMRE": [function(require2, module2, exports2) {
      "use strict";
      var e = module2.exports = function(e2, i2, t) {
        "function" == typeof i2 && (t = i2, i2 = {}), r(i2, "function" == typeof (t = i2.cb || t) ? t : t.pre || function() {
        }, t.post || function() {
        }, e2, "", e2);
      };
      function r(t, n, o, s, a, m, p, f, u, y) {
        if (s && "object" == typeof s && !Array.isArray(s)) {
          for (var c in n(s, a, m, p, f, u, y), s) {
            var d = s[c];
            if (Array.isArray(d)) {
              if (c in e.arrayKeywords)
                for (var l = 0; l < d.length; l++)
                  r(t, n, o, d[l], a + "/" + c + "/" + l, m, a, c, s, l);
            } else if (c in e.propsKeywords) {
              if (d && "object" == typeof d)
                for (var w in d)
                  r(t, n, o, d[w], a + "/" + c + "/" + i(w), m, a, c, s, w);
            } else
              (c in e.keywords || t.allKeys && !(c in e.skipKeywords)) && r(t, n, o, d, a + "/" + c, m, a, c, s);
          }
          o(s, a, m, p, f, u, y);
        }
      }
      __name(r, "r");
      function i(e2) {
        return e2.replace(/~/g, "~0").replace(/\//g, "~1");
      }
      __name(i, "i");
      e.keywords = { additionalItems: true, items: true, contains: true, additionalProperties: true, propertyNames: true, not: true }, e.arrayKeywords = { items: true, allOf: true, anyOf: true, oneOf: true }, e.propsKeywords = { definitions: true, properties: true, patternProperties: true, dependencies: true }, e.skipKeywords = { default: true, enum: true, const: true, required: true, maximum: true, minimum: true, exclusiveMaximum: true, exclusiveMinimum: true, multipleOf: true, maxLength: true, minLength: true, pattern: true, format: true, maxItems: true, minItems: true, uniqueItems: true, maxProperties: true, minProperties: true };
    }, {}], "w10T": [function(require2, module2, exports2) {
      "use strict";
      var e = require2("uri-js"), r = require2("fast-deep-equal"), t = require2("./util"), i = require2("./schema_obj"), s = require2("json-schema-traverse");
      function a(e2, r2, t2) {
        var s2 = this._refs[t2];
        if ("string" == typeof s2) {
          if (!this._refs[s2])
            return a.call(this, e2, r2, s2);
          s2 = this._refs[s2];
        }
        if ((s2 = s2 || this._schemas[t2]) instanceof i)
          return u(s2.schema, this._opts.inlineRefs) ? s2.schema : s2.validate || this._compile(s2);
        var o2, f2, c2, h2 = n.call(this, r2, t2);
        return h2 && (o2 = h2.schema, r2 = h2.root, c2 = h2.baseId), o2 instanceof i ? f2 = o2.validate || e2.call(this, o2.schema, r2, void 0, c2) : void 0 !== o2 && (f2 = u(o2, this._opts.inlineRefs) ? o2 : e2.call(this, o2, r2, void 0, c2)), f2;
      }
      __name(a, "a");
      function n(r2, t2) {
        var s2 = e.parse(t2), a2 = d(s2), n2 = v(this._getId(r2.schema));
        if (0 === Object.keys(r2.schema).length || a2 !== n2) {
          var f2 = g(a2), h2 = this._refs[f2];
          if ("string" == typeof h2)
            return o.call(this, r2, h2, s2);
          if (h2 instanceof i)
            h2.validate || this._compile(h2), r2 = h2;
          else {
            if (!((h2 = this._schemas[f2]) instanceof i))
              return;
            if (h2.validate || this._compile(h2), f2 == g(t2))
              return { schema: h2, root: r2, baseId: n2 };
            r2 = h2;
          }
          if (!r2.schema)
            return;
          n2 = v(this._getId(r2.schema));
        }
        return c.call(this, s2, n2, r2.schema, r2);
      }
      __name(n, "n");
      function o(e2, r2, t2) {
        var i2 = n.call(this, e2, r2);
        if (i2) {
          var s2 = i2.schema, a2 = i2.baseId;
          e2 = i2.root;
          var o2 = this._getId(s2);
          return o2 && (a2 = _(a2, o2)), c.call(this, t2, a2, s2, e2);
        }
      }
      __name(o, "o");
      module2.exports = a, a.normalizeId = g, a.fullPath = v, a.url = _, a.ids = y, a.inlineRef = u, a.schema = n;
      var f = t.toHash(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
      function c(e2, r2, i2, s2) {
        if (e2.fragment = e2.fragment || "", "/" == e2.fragment.slice(0, 1)) {
          for (var a2 = e2.fragment.split("/"), o2 = 1; o2 < a2.length; o2++) {
            var c2 = a2[o2];
            if (c2) {
              if (void 0 === (i2 = i2[c2 = t.unescapeFragment(c2)]))
                break;
              var h2;
              if (!f[c2] && ((h2 = this._getId(i2)) && (r2 = _(r2, h2)), i2.$ref)) {
                var u2 = _(r2, i2.$ref), l2 = n.call(this, s2, u2);
                l2 && (i2 = l2.schema, s2 = l2.root, r2 = l2.baseId);
              }
            }
          }
          return void 0 !== i2 && i2 !== s2.schema ? { schema: i2, root: s2, baseId: r2 } : void 0;
        }
      }
      __name(c, "c");
      var h = t.toHash(["type", "format", "pattern", "maxLength", "minLength", "maxProperties", "minProperties", "maxItems", "minItems", "maximum", "minimum", "uniqueItems", "multipleOf", "required", "enum"]);
      function u(e2, r2) {
        return false !== r2 && (void 0 === r2 || true === r2 ? l(e2) : r2 ? m(e2) <= r2 : void 0);
      }
      __name(u, "u");
      function l(e2) {
        var r2;
        if (Array.isArray(e2)) {
          for (var t2 = 0; t2 < e2.length; t2++)
            if ("object" == typeof (r2 = e2[t2]) && !l(r2))
              return false;
        } else
          for (var i2 in e2) {
            if ("$ref" == i2)
              return false;
            if ("object" == typeof (r2 = e2[i2]) && !l(r2))
              return false;
          }
        return true;
      }
      __name(l, "l");
      function m(e2) {
        var r2, t2 = 0;
        if (Array.isArray(e2)) {
          for (var i2 = 0; i2 < e2.length; i2++)
            if ("object" == typeof (r2 = e2[i2]) && (t2 += m(r2)), t2 == 1 / 0)
              return 1 / 0;
        } else
          for (var s2 in e2) {
            if ("$ref" == s2)
              return 1 / 0;
            if (h[s2])
              t2++;
            else if ("object" == typeof (r2 = e2[s2]) && (t2 += m(r2) + 1), t2 == 1 / 0)
              return 1 / 0;
          }
        return t2;
      }
      __name(m, "m");
      function v(r2, t2) {
        return false !== t2 && (r2 = g(r2)), d(e.parse(r2));
      }
      __name(v, "v");
      function d(r2) {
        return e.serialize(r2).split("#")[0] + "#";
      }
      __name(d, "d");
      var p = /#\/?$/;
      function g(e2) {
        return e2 ? e2.replace(p, "") : "";
      }
      __name(g, "g");
      function _(r2, t2) {
        return t2 = g(t2), e.resolve(r2, t2);
      }
      __name(_, "_");
      function y(i2) {
        var a2 = g(this._getId(i2)), n2 = { "": a2 }, o2 = { "": v(a2, false) }, f2 = {}, c2 = this;
        return s(i2, { allKeys: true }, function(i3, s2, a3, h2, u2, l2, m2) {
          if ("" !== s2) {
            var v2 = c2._getId(i3), d2 = n2[h2], p2 = o2[h2] + "/" + u2;
            if (void 0 !== m2 && (p2 += "/" + ("number" == typeof m2 ? m2 : t.escapeFragment(m2))), "string" == typeof v2) {
              v2 = d2 = g(d2 ? e.resolve(d2, v2) : v2);
              var _2 = c2._refs[v2];
              if ("string" == typeof _2 && (_2 = c2._refs[_2]), _2 && _2.schema) {
                if (!r(i3, _2.schema))
                  throw new Error('id "' + v2 + '" resolves to more than one schema');
              } else if (v2 != g(p2))
                if ("#" == v2[0]) {
                  if (f2[v2] && !r(i3, f2[v2]))
                    throw new Error('id "' + v2 + '" resolves to more than one schema');
                  f2[v2] = i3;
                } else
                  c2._refs[v2] = p2;
            }
            n2[s2] = d2, o2[s2] = p2;
          }
        }), f2;
      }
      __name(y, "y");
    }, { "uri-js": "wWOq", "fast-deep-equal": "dPQH", "./util": "Q1F7", "./schema_obj": "HHLG", "json-schema-traverse": "uMRE" }], "OtNE": [function(require2, module2, exports2) {
      "use strict";
      var e = require2("./resolve");
      function t(e2) {
        this.message = "validation failed", this.errors = e2, this.ajv = this.validation = true;
      }
      __name(t, "t");
      function i(t2, s2, r) {
        this.message = r || i.message(t2, s2), this.missingRef = e.url(t2, s2), this.missingSchema = e.normalizeId(e.fullPath(this.missingRef));
      }
      __name(i, "i");
      function s(e2) {
        return e2.prototype = Object.create(Error.prototype), e2.prototype.constructor = e2, e2;
      }
      __name(s, "s");
      module2.exports = { Validation: s(t), MissingRef: s(i) }, i.message = function(e2, t2) {
        return "can't resolve reference " + t2 + " from id " + e2;
      };
    }, { "./resolve": "w10T" }], "Xb3N": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = function(r, t) {
        t || (t = {}), "function" == typeof t && (t = { cmp: t });
        var e, n = "boolean" == typeof t.cycles && t.cycles, i = t.cmp && (e = t.cmp, function(r2) {
          return function(t2, n2) {
            var i2 = { key: t2, value: r2[t2] }, u2 = { key: n2, value: r2[n2] };
            return e(i2, u2);
          };
        }), u = [];
        return (/* @__PURE__ */ __name(function r2(t2) {
          if (t2 && t2.toJSON && "function" == typeof t2.toJSON && (t2 = t2.toJSON()), void 0 !== t2) {
            if ("number" == typeof t2)
              return isFinite(t2) ? "" + t2 : "null";
            if ("object" != typeof t2)
              return JSON.stringify(t2);
            var e2, o;
            if (Array.isArray(t2)) {
              for (o = "[", e2 = 0; e2 < t2.length; e2++)
                e2 && (o += ","), o += r2(t2[e2]) || "null";
              return o + "]";
            }
            if (null === t2)
              return "null";
            if (-1 !== u.indexOf(t2)) {
              if (n)
                return JSON.stringify("__cycle__");
              throw new TypeError("Converting circular structure to JSON");
            }
            var f = u.push(t2) - 1, c = Object.keys(t2).sort(i && i(t2));
            for (o = "", e2 = 0; e2 < c.length; e2++) {
              var l = c[e2], y = r2(t2[l]);
              y && (o && (o += ","), o += JSON.stringify(l) + ":" + y);
            }
            return u.splice(f, 1), "{" + o + "}";
          }
        }, "r"))(r);
      };
    }, {}], "yhC1": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = function(e, r, a) {
        var t = "", s = true === e.schema.$async, o = e.util.schemaHasRulesExcept(e.schema, e.RULES.all, "$ref"), l = e.self._getId(e.schema);
        if (e.opts.strictKeywords) {
          var i = e.util.schemaUnknownRules(e.schema, e.RULES.keywords);
          if (i) {
            var n = "unknown keyword: " + i;
            if ("log" !== e.opts.strictKeywords)
              throw new Error(n);
            e.logger.warn(n);
          }
        }
        if (e.isTop && (t += " var validate = ", s && (e.async = true, t += "async "), t += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ", l && (e.opts.sourceCode || e.opts.processCode) && (t += " /*# sourceURL=" + l + " */ ")), "boolean" == typeof e.schema || !o && !e.schema.$ref) {
          var c = e.level, f = e.dataLevel, h = e.schema["false schema"], u = e.schemaPath + e.util.getProperty("false schema"), p = e.errSchemaPath + "/false schema", d = !e.opts.allErrors, m = "data" + (f || ""), v = "valid" + c;
          if (false === e.schema) {
            e.isTop ? d = true : t += " var " + v + " = false; ", (W = W || []).push(t), t = "", false !== e.createErrors ? (t += " { keyword: 'false schema' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(p) + " , params: {} ", false !== e.opts.messages && (t += " , message: 'boolean schema is false' "), e.opts.verbose && (t += " , schema: false , parentSchema: validate.schema" + e.schemaPath + " , data: " + m + " "), t += " } ") : t += " {} ";
            var y = t;
            t = W.pop(), !e.compositeRule && d ? e.async ? t += " throw new ValidationError([" + y + "]); " : t += " validate.errors = [" + y + "]; return false; " : t += " var err = " + y + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          } else
            e.isTop ? t += s ? " return data; " : " validate.errors = null; return true; " : t += " var " + v + " = true; ";
          return e.isTop && (t += " }; return validate; "), t;
        }
        if (e.isTop) {
          var g = e.isTop;
          c = e.level = 0, f = e.dataLevel = 0, m = "data";
          if (e.rootId = e.resolve.fullPath(e.self._getId(e.root.schema)), e.baseId = e.baseId || e.rootId, delete e.isTop, e.dataPathArr = [""], void 0 !== e.schema.default && e.opts.useDefaults && e.opts.strictDefaults) {
            var w = "default is ignored in the schema root";
            if ("log" !== e.opts.strictDefaults)
              throw new Error(w);
            e.logger.warn(w);
          }
          t += " var vErrors = null; ", t += " var errors = 0;     ", t += " if (rootData === undefined) rootData = data; ";
        } else {
          c = e.level, m = "data" + ((f = e.dataLevel) || "");
          if (l && (e.baseId = e.resolve.url(e.baseId, l)), s && !e.async)
            throw new Error("async schema in sync schema");
          t += " var errs_" + c + " = errors;";
        }
        v = "valid" + c, d = !e.opts.allErrors;
        var E = "", P = "", b = e.schema.type, D = Array.isArray(b);
        if (b && e.opts.nullable && true === e.schema.nullable && (D ? -1 == b.indexOf("null") && (b = b.concat("null")) : "null" != b && (b = [b, "null"], D = true)), D && 1 == b.length && (b = b[0], D = false), e.schema.$ref && o) {
          if ("fail" == e.opts.extendRefs)
            throw new Error('$ref: validation keywords used in schema at path "' + e.errSchemaPath + '" (see option extendRefs)');
          true !== e.opts.extendRefs && (o = false, e.logger.warn('$ref: keywords ignored in schema at path "' + e.errSchemaPath + '"'));
        }
        if (e.schema.$comment && e.opts.$comment && (t += " " + e.RULES.all.$comment.code(e, "$comment")), b) {
          if (e.opts.coerceTypes)
            var S = e.util.coerceToTypes(e.opts.coerceTypes, b);
          var R = e.RULES.types[b];
          if (S || D || true === R || R && !X(R)) {
            u = e.schemaPath + ".type", p = e.errSchemaPath + "/type", u = e.schemaPath + ".type", p = e.errSchemaPath + "/type";
            var T = D ? "checkDataTypes" : "checkDataType";
            if (t += " if (" + e.util[T](b, m, e.opts.strictNumbers, true) + ") { ", S) {
              var k = "dataType" + c, $ = "coerced" + c;
              t += " var " + k + " = typeof " + m + "; var " + $ + " = undefined; ", "array" == e.opts.coerceTypes && (t += " if (" + k + " == 'object' && Array.isArray(" + m + ") && " + m + ".length == 1) { " + m + " = " + m + "[0]; " + k + " = typeof " + m + "; if (" + e.util.checkDataType(e.schema.type, m, e.opts.strictNumbers) + ") " + $ + " = " + m + "; } "), t += " if (" + $ + " !== undefined) ; ";
              var L = S;
              if (L)
                for (var j, A = -1, I = L.length - 1; A < I; )
                  "string" == (j = L[A += 1]) ? t += " else if (" + k + " == 'number' || " + k + " == 'boolean') " + $ + " = '' + " + m + "; else if (" + m + " === null) " + $ + " = ''; " : "number" == j || "integer" == j ? (t += " else if (" + k + " == 'boolean' || " + m + " === null || (" + k + " == 'string' && " + m + " && " + m + " == +" + m + " ", "integer" == j && (t += " && !(" + m + " % 1)"), t += ")) " + $ + " = +" + m + "; ") : "boolean" == j ? t += " else if (" + m + " === 'false' || " + m + " === 0 || " + m + " === null) " + $ + " = false; else if (" + m + " === 'true' || " + m + " === 1) " + $ + " = true; " : "null" == j ? t += " else if (" + m + " === '' || " + m + " === 0 || " + m + " === false) " + $ + " = null; " : "array" == e.opts.coerceTypes && "array" == j && (t += " else if (" + k + " == 'string' || " + k + " == 'number' || " + k + " == 'boolean' || " + m + " == null) " + $ + " = [" + m + "]; ");
              t += " else {   ", (W = W || []).push(t), t = "", false !== e.createErrors ? (t += " { keyword: 'type' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(p) + " , params: { type: '", t += D ? "" + b.join(",") : "" + b, t += "' } ", false !== e.opts.messages && (t += " , message: 'should be ", t += D ? "" + b.join(",") : "" + b, t += "' "), e.opts.verbose && (t += " , schema: validate.schema" + u + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + m + " "), t += " } ") : t += " {} ";
              y = t;
              t = W.pop(), !e.compositeRule && d ? e.async ? t += " throw new ValidationError([" + y + "]); " : t += " validate.errors = [" + y + "]; return false; " : t += " var err = " + y + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", t += " } if (" + $ + " !== undefined) {  ";
              var U = f ? "data" + (f - 1 || "") : "parentData";
              t += " " + m + " = " + $ + "; ", f || (t += "if (" + U + " !== undefined)"), t += " " + U + "[" + (f ? e.dataPathArr[f] : "parentDataProperty") + "] = " + $ + "; } ";
            } else {
              (W = W || []).push(t), t = "", false !== e.createErrors ? (t += " { keyword: 'type' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(p) + " , params: { type: '", t += D ? "" + b.join(",") : "" + b, t += "' } ", false !== e.opts.messages && (t += " , message: 'should be ", t += D ? "" + b.join(",") : "" + b, t += "' "), e.opts.verbose && (t += " , schema: validate.schema" + u + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + m + " "), t += " } ") : t += " {} ";
              y = t;
              t = W.pop(), !e.compositeRule && d ? e.async ? t += " throw new ValidationError([" + y + "]); " : t += " validate.errors = [" + y + "]; return false; " : t += " var err = " + y + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            t += " } ";
          }
        }
        if (e.schema.$ref && !o)
          t += " " + e.RULES.all.$ref.code(e, "$ref") + " ", d && (t += " } if (errors === ", t += g ? "0" : "errs_" + c, t += ") { ", P += "}");
        else {
          var x = e.RULES;
          if (x) {
            for (var _ = -1, N = x.length - 1; _ < N; )
              if (X(R = x[_ += 1])) {
                if (R.type && (t += " if (" + e.util.checkDataType(R.type, m, e.opts.strictNumbers) + ") { "), e.opts.useDefaults) {
                  if ("object" == R.type && e.schema.properties) {
                    h = e.schema.properties;
                    var V = Object.keys(h);
                    if (V)
                      for (var O, Q = -1, C = V.length - 1; Q < C; ) {
                        if (void 0 !== (H = h[O = V[Q += 1]]).default) {
                          var J = m + e.util.getProperty(O);
                          if (e.compositeRule) {
                            if (e.opts.strictDefaults) {
                              w = "default is ignored for: " + J;
                              if ("log" !== e.opts.strictDefaults)
                                throw new Error(w);
                              e.logger.warn(w);
                            }
                          } else
                            t += " if (" + J + " === undefined ", "empty" == e.opts.useDefaults && (t += " || " + J + " === null || " + J + " === '' "), t += " ) " + J + " = ", "shared" == e.opts.useDefaults ? t += " " + e.useDefault(H.default) + " " : t += " " + JSON.stringify(H.default) + " ", t += "; ";
                        }
                      }
                  } else if ("array" == R.type && Array.isArray(e.schema.items)) {
                    var K = e.schema.items;
                    if (K) {
                      A = -1;
                      for (var H, q = K.length - 1; A < q; )
                        if (void 0 !== (H = K[A += 1]).default) {
                          J = m + "[" + A + "]";
                          if (e.compositeRule) {
                            if (e.opts.strictDefaults) {
                              w = "default is ignored for: " + J;
                              if ("log" !== e.opts.strictDefaults)
                                throw new Error(w);
                              e.logger.warn(w);
                            }
                          } else
                            t += " if (" + J + " === undefined ", "empty" == e.opts.useDefaults && (t += " || " + J + " === null || " + J + " === '' "), t += " ) " + J + " = ", "shared" == e.opts.useDefaults ? t += " " + e.useDefault(H.default) + " " : t += " " + JSON.stringify(H.default) + " ", t += "; ";
                        }
                    }
                  }
                }
                var z = R.rules;
                if (z) {
                  for (var B, F = -1, G = z.length - 1; F < G; )
                    if (Y(B = z[F += 1])) {
                      var M = B.code(e, B.keyword, R.type);
                      M && (t += " " + M + " ", d && (E += "}"));
                    }
                }
                if (d && (t += " " + E + " ", E = ""), R.type && (t += " } ", b && b === R.type && !S)) {
                  t += " else { ";
                  var W;
                  u = e.schemaPath + ".type", p = e.errSchemaPath + "/type";
                  (W = W || []).push(t), t = "", false !== e.createErrors ? (t += " { keyword: 'type' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(p) + " , params: { type: '", t += D ? "" + b.join(",") : "" + b, t += "' } ", false !== e.opts.messages && (t += " , message: 'should be ", t += D ? "" + b.join(",") : "" + b, t += "' "), e.opts.verbose && (t += " , schema: validate.schema" + u + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + m + " "), t += " } ") : t += " {} ";
                  y = t;
                  t = W.pop(), !e.compositeRule && d ? e.async ? t += " throw new ValidationError([" + y + "]); " : t += " validate.errors = [" + y + "]; return false; " : t += " var err = " + y + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", t += " } ";
                }
                d && (t += " if (errors === ", t += g ? "0" : "errs_" + c, t += ") { ", P += "}");
              }
          }
        }
        function X(e2) {
          for (var r2 = e2.rules, a2 = 0; a2 < r2.length; a2++)
            if (Y(r2[a2]))
              return true;
        }
        __name(X, "X");
        function Y(r2) {
          return void 0 !== e.schema[r2.keyword] || r2.implements && function(r3) {
            for (var a2 = r3.implements, t2 = 0; t2 < a2.length; t2++)
              if (void 0 !== e.schema[a2[t2]])
                return true;
          }(r2);
        }
        __name(Y, "Y");
        return d && (t += " " + P + " "), g ? (s ? (t += " if (errors === 0) return data;           ", t += " else throw new ValidationError(vErrors); ") : (t += " validate.errors = vErrors; ", t += " return errors === 0;       "), t += " }; return validate;") : t += " var " + v + " = errors === errs_" + c + ";", t;
      };
    }, {}], "qdYs": [function(require2, module2, exports2) {
      "use strict";
      var e = require2("./resolve"), r = require2("./util"), t = require2("./error_classes"), i = require2("fast-json-stable-stringify"), o = require2("../dotjs/validate"), a = r.ucs2length, n = require2("fast-deep-equal"), s = t.Validation;
      function l(f2, g, y, w) {
        var R = this, V = this._opts, S = [void 0], _ = {}, b = [], E = {}, q = [], j = {}, x = [];
        g = g || { schema: f2, refVal: S, refs: _ };
        var $ = c.call(this, f2, g, w), k = this._compilations[$.index];
        if ($.compiling)
          return k.callValidate = /* @__PURE__ */ __name(function e2() {
            var r2 = k.validate;
            var t2 = r2.apply(this, arguments);
            e2.errors = r2.errors;
            return t2;
          }, "e");
        var C = this._formats, P = this.RULES;
        try {
          var I = U(f2, g, y, w);
          k.validate = I;
          var L = k.callValidate;
          return L && (L.schema = I.schema, L.errors = null, L.refs = I.refs, L.refVal = I.refVal, L.root = I.root, L.$async = I.$async, V.sourceCode && (L.source = I.source)), I;
        } finally {
          u.call(this, f2, g, w);
        }
        function U(i2, c2, u2, f3) {
          var y2 = !c2 || c2 && c2.schema == i2;
          if (c2.schema != g.schema)
            return l.call(R, i2, c2, u2, f3);
          var w2, E2 = true === i2.$async, j2 = o({ isTop: true, schema: i2, isRoot: y2, baseId: f3, root: c2, schemaPath: "", errSchemaPath: "#", errorPath: '""', MissingRefError: t.MissingRef, RULES: P, validate: o, util: r, resolve: e, resolveRef: M, usePattern: T, useDefault: D, useCustomRule: F, opts: V, formats: C, logger: R.logger, self: R });
          j2 = p(S, h) + p(b, d) + p(q, v) + p(x, m) + j2, V.processCode && (j2 = V.processCode(j2, i2));
          try {
            w2 = new Function("self", "RULES", "formats", "root", "refVal", "defaults", "customRules", "equal", "ucs2length", "ValidationError", j2)(R, P, C, g, S, q, x, n, a, s), S[0] = w2;
          } catch ($2) {
            throw R.logger.error("Error compiling schema, function code:", j2), $2;
          }
          return w2.schema = i2, w2.errors = null, w2.refs = _, w2.refVal = S, w2.root = y2 ? w2 : c2, E2 && (w2.$async = true), true === V.sourceCode && (w2.source = { code: j2, patterns: b, defaults: q }), w2;
        }
        __name(U, "U");
        function M(r2, t2, i2) {
          t2 = e.url(r2, t2);
          var o2, a2, n2 = _[t2];
          if (void 0 !== n2)
            return Q(o2 = S[n2], a2 = "refVal[" + n2 + "]");
          if (!i2 && g.refs) {
            var s2 = g.refs[t2];
            if (void 0 !== s2)
              return Q(o2 = g.refVal[s2], a2 = O(t2, o2));
          }
          a2 = O(t2);
          var c2 = e.call(R, U, g, t2);
          if (void 0 === c2) {
            var u2 = y && y[t2];
            u2 && (c2 = e.inlineRef(u2, V.inlineRefs) ? u2 : l.call(R, u2, g, y, r2));
          }
          if (void 0 !== c2)
            return function(e2, r3) {
              var t3 = _[e2];
              S[t3] = r3;
            }(t2, c2), Q(c2, a2);
          !function(e2) {
            delete _[e2];
          }(t2);
        }
        __name(M, "M");
        function O(e2, r2) {
          var t2 = S.length;
          return S[t2] = r2, _[e2] = t2, "refVal" + t2;
        }
        __name(O, "O");
        function Q(e2, r2) {
          return "object" == typeof e2 || "boolean" == typeof e2 ? { code: r2, schema: e2, inline: true } : { code: r2, $async: e2 && !!e2.$async };
        }
        __name(Q, "Q");
        function T(e2) {
          var r2 = E[e2];
          return void 0 === r2 && (r2 = E[e2] = b.length, b[r2] = e2), "pattern" + r2;
        }
        __name(T, "T");
        function D(e2) {
          switch (typeof e2) {
            case "boolean":
            case "number":
              return "" + e2;
            case "string":
              return r.toQuotedString(e2);
            case "object":
              if (null === e2)
                return "null";
              var t2 = i(e2), o2 = j[t2];
              return void 0 === o2 && (o2 = j[t2] = q.length, q[o2] = e2), "default" + o2;
          }
        }
        __name(D, "D");
        function F(e2, r2, t2, i2) {
          if (false !== R._opts.validateSchema) {
            var o2 = e2.definition.dependencies;
            if (o2 && !o2.every(function(e3) {
              return Object.prototype.hasOwnProperty.call(t2, e3);
            }))
              throw new Error("parent schema must have all required keywords: " + o2.join(","));
            var a2 = e2.definition.validateSchema;
            if (a2) {
              if (!a2(r2)) {
                var n2 = "keyword schema is invalid: " + R.errorsText(a2.errors);
                if ("log" != R._opts.validateSchema)
                  throw new Error(n2);
                R.logger.error(n2);
              }
            }
          }
          var s2, l2 = e2.definition.compile, c2 = e2.definition.inline, u2 = e2.definition.macro;
          if (l2)
            s2 = l2.call(R, r2, t2, i2);
          else if (u2)
            s2 = u2.call(R, r2, t2, i2), false !== V.validateSchema && R.validateSchema(s2, true);
          else if (c2)
            s2 = c2.call(R, i2, e2.keyword, r2, t2);
          else if (!(s2 = e2.definition.validate))
            return;
          if (void 0 === s2)
            throw new Error('custom keyword "' + e2.keyword + '"failed to compile');
          var f3 = x.length;
          return x[f3] = s2, { code: "customRule" + f3, validate: s2 };
        }
        __name(F, "F");
      }
      __name(l, "l");
      function c(e2, r2, t2) {
        var i2 = f.call(this, e2, r2, t2);
        return i2 >= 0 ? { index: i2, compiling: true } : (i2 = this._compilations.length, this._compilations[i2] = { schema: e2, root: r2, baseId: t2 }, { index: i2, compiling: false });
      }
      __name(c, "c");
      function u(e2, r2, t2) {
        var i2 = f.call(this, e2, r2, t2);
        i2 >= 0 && this._compilations.splice(i2, 1);
      }
      __name(u, "u");
      function f(e2, r2, t2) {
        for (var i2 = 0; i2 < this._compilations.length; i2++) {
          var o2 = this._compilations[i2];
          if (o2.schema == e2 && o2.root == r2 && o2.baseId == t2)
            return i2;
        }
        return -1;
      }
      __name(f, "f");
      function d(e2, t2) {
        return "var pattern" + e2 + " = new RegExp(" + r.toQuotedString(t2[e2]) + ");";
      }
      __name(d, "d");
      function v(e2) {
        return "var default" + e2 + " = defaults[" + e2 + "];";
      }
      __name(v, "v");
      function h(e2, r2) {
        return void 0 === r2[e2] ? "" : "var refVal" + e2 + " = refVal[" + e2 + "];";
      }
      __name(h, "h");
      function m(e2) {
        return "var customRule" + e2 + " = customRules[" + e2 + "];";
      }
      __name(m, "m");
      function p(e2, r2) {
        if (!e2.length)
          return "";
        for (var t2 = "", i2 = 0; i2 < e2.length; i2++)
          t2 += r2(i2, e2);
        return t2;
      }
      __name(p, "p");
      module2.exports = l;
    }, { "./resolve": "w10T", "./util": "Q1F7", "./error_classes": "OtNE", "fast-json-stable-stringify": "Xb3N", "../dotjs/validate": "yhC1", "fast-deep-equal": "dPQH" }], "fXCy": [function(require2, module2, exports2) {
      "use strict";
      var t = module2.exports = function() {
        this._cache = {};
      };
      t.prototype.put = function(t2, e) {
        this._cache[t2] = e;
      }, t.prototype.get = function(t2) {
        return this._cache[t2];
      }, t.prototype.del = function(t2) {
        delete this._cache[t2];
      }, t.prototype.clear = function() {
        this._cache = {};
      };
    }, {}], "dfAH": [function(require2, module2, exports2) {
      "use strict";
      var d = require2("./util"), a = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, u = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], F = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i, f = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i, D = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, t = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, r = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i, e = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i, i = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i, z = /^(?:\/(?:[^~/]|~0|~1)*)*$/, $ = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i, n = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
      function s(a2) {
        return a2 = "full" == a2 ? "full" : "fast", d.copy(s[a2]);
      }
      __name(s, "s");
      function x(d2) {
        return d2 % 4 == 0 && (d2 % 100 != 0 || d2 % 400 == 0);
      }
      __name(x, "x");
      function _(d2) {
        var F2 = d2.match(a);
        if (!F2)
          return false;
        var f2 = +F2[1], D2 = +F2[2], t2 = +F2[3];
        return D2 >= 1 && D2 <= 12 && t2 >= 1 && t2 <= (2 == D2 && x(f2) ? 29 : u[D2]);
      }
      __name(_, "_");
      function o(d2, a2) {
        var u2 = d2.match(F);
        if (!u2)
          return false;
        var f2 = u2[1], D2 = u2[2], t2 = u2[3], r2 = u2[5];
        return (f2 <= 23 && D2 <= 59 && t2 <= 59 || 23 == f2 && 59 == D2 && 60 == t2) && (!a2 || r2);
      }
      __name(o, "o");
      module2.exports = s, s.fast = { date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/, time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i, "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i, "uri-template": r, url: e, email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i, hostname: f, ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/, ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i, regex: v, uuid: i, "json-pointer": z, "json-pointer-uri-fragment": $, "relative-json-pointer": n }, s.full = { date: _, time: o, "date-time": B, uri: l, "uri-reference": t, "uri-template": r, url: e, email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i, hostname: f, ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/, ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i, regex: v, uuid: i, "json-pointer": z, "json-pointer-uri-fragment": $, "relative-json-pointer": n };
      var E = /t|\s/i;
      function B(d2) {
        var a2 = d2.split(E);
        return 2 == a2.length && _(a2[0]) && o(a2[1], true);
      }
      __name(B, "B");
      var C = /\/|:/;
      function l(d2) {
        return C.test(d2) && D.test(d2);
      }
      __name(l, "l");
      var p = /[^\\]\\Z/;
      function v(d2) {
        if (p.test(d2))
          return false;
        try {
          return new RegExp(d2), true;
        } catch (a2) {
          return false;
        }
      }
      __name(v, "v");
    }, { "./util": "Q1F7" }], "a2na": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = function(r, e, a) {
        var s, t, o = " ", i = r.level, l = r.dataLevel, c = r.schema[e], n = r.errSchemaPath + "/" + e, h = !r.opts.allErrors, v = "data" + (l || ""), f = "valid" + i;
        if ("#" == c || "#/" == c)
          r.isRoot ? (s = r.async, t = "validate") : (s = true === r.root.schema.$async, t = "root.refVal[0]");
        else {
          var d = r.resolveRef(r.baseId, c, r.isRoot);
          if (void 0 === d) {
            var p = r.MissingRefError.message(r.baseId, c);
            if ("fail" == r.opts.missingRefs) {
              r.logger.error(p), (g = g || []).push(o), o = "", false !== r.createErrors ? (o += " { keyword: '$ref' , dataPath: (dataPath || '') + " + r.errorPath + " , schemaPath: " + r.util.toQuotedString(n) + " , params: { ref: '" + r.util.escapeQuotes(c) + "' } ", false !== r.opts.messages && (o += " , message: 'can\\'t resolve reference " + r.util.escapeQuotes(c) + "' "), r.opts.verbose && (o += " , schema: " + r.util.toQuotedString(c) + " , parentSchema: validate.schema" + r.schemaPath + " , data: " + v + " "), o += " } ") : o += " {} ";
              var m = o;
              o = g.pop(), !r.compositeRule && h ? r.async ? o += " throw new ValidationError([" + m + "]); " : o += " validate.errors = [" + m + "]; return false; " : o += " var err = " + m + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", h && (o += " if (false) { ");
            } else {
              if ("ignore" != r.opts.missingRefs)
                throw new r.MissingRefError(r.baseId, c, p);
              r.logger.warn(p), h && (o += " if (true) { ");
            }
          } else if (d.inline) {
            var u = r.util.copy(r);
            u.level++;
            var E = "valid" + u.level;
            u.schema = d.schema, u.schemaPath = "", u.errSchemaPath = c, o += " " + r.validate(u).replace(/validate\.schema/g, d.code) + " ", h && (o += " if (" + E + ") { ");
          } else
            s = true === d.$async || r.async && false !== d.$async, t = d.code;
        }
        if (t) {
          var g;
          (g = g || []).push(o), o = "", r.opts.passContext ? o += " " + t + ".call(this, " : o += " " + t + "( ", o += " " + v + ", (dataPath || '')", '""' != r.errorPath && (o += " + " + r.errorPath);
          var y = o += " , " + (l ? "data" + (l - 1 || "") : "parentData") + " , " + (l ? r.dataPathArr[l] : "parentDataProperty") + ", rootData)  ";
          if (o = g.pop(), s) {
            if (!r.async)
              throw new Error("async schema referenced by sync schema");
            h && (o += " var " + f + "; "), o += " try { await " + y + "; ", h && (o += " " + f + " = true; "), o += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ", h && (o += " " + f + " = false; "), o += " } ", h && (o += " if (" + f + ") { ");
          } else
            o += " if (!" + y + ") { if (vErrors === null) vErrors = " + t + ".errors; else vErrors = vErrors.concat(" + t + ".errors); errors = vErrors.length; } ", h && (o += " else { ");
        }
        return o;
      };
    }, {}], "hRgn": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = function(e, t, a) {
        var r = " ", s = e.schema[t], l = e.schemaPath + e.util.getProperty(t), c = e.errSchemaPath + "/" + t, h = !e.opts.allErrors, i = e.util.copy(e), o = "";
        i.level++;
        var u = "valid" + i.level, m = i.baseId, v = true, d = s;
        if (d)
          for (var f, p = -1, n = d.length - 1; p < n; )
            f = d[p += 1], (e.opts.strictKeywords ? "object" == typeof f && Object.keys(f).length > 0 || false === f : e.util.schemaHasRules(f, e.RULES.all)) && (v = false, i.schema = f, i.schemaPath = l + "[" + p + "]", i.errSchemaPath = c + "/" + p, r += "  " + e.validate(i) + " ", i.baseId = m, h && (r += " if (" + u + ") { ", o += "}"));
        return h && (r += v ? " if (true) { " : " " + o.slice(0, -1) + " "), r;
      };
    }, {}], "lo6J": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = function(e, r, a) {
        var s = " ", t = e.level, o = e.dataLevel, l = e.schema[r], i = e.schemaPath + e.util.getProperty(r), c = e.errSchemaPath + "/" + r, h = !e.opts.allErrors, v = "data" + (o || ""), m = "valid" + t, u = "errs__" + t, n = e.util.copy(e), d = "";
        n.level++;
        var p = "valid" + n.level;
        if (l.every(function(r2) {
          return e.opts.strictKeywords ? "object" == typeof r2 && Object.keys(r2).length > 0 || false === r2 : e.util.schemaHasRules(r2, e.RULES.all);
        })) {
          var f = n.baseId;
          s += " var " + u + " = errors; var " + m + " = false;  ";
          var E = e.compositeRule;
          e.compositeRule = n.compositeRule = true;
          var y = l;
          if (y)
            for (var P, R = -1, g = y.length - 1; R < g; )
              P = y[R += 1], n.schema = P, n.schemaPath = i + "[" + R + "]", n.errSchemaPath = c + "/" + R, s += "  " + e.validate(n) + " ", n.baseId = f, s += " " + m + " = " + m + " || " + p + "; if (!" + m + ") { ", d += "}";
          e.compositeRule = n.compositeRule = E, s += " " + d + " if (!" + m + ") {   var err =   ", false !== e.createErrors ? (s += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: {} ", false !== e.opts.messages && (s += " , message: 'should match some schema in anyOf' "), e.opts.verbose && (s += " , schema: validate.schema" + i + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + v + " "), s += " } ") : s += " {} ", s += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e.compositeRule && h && (e.async ? s += " throw new ValidationError(vErrors); " : s += " validate.errors = vErrors; return false; "), s += " } else {  errors = " + u + "; if (vErrors !== null) { if (" + u + ") vErrors.length = " + u + "; else vErrors = null; } ", e.opts.allErrors && (s += " } ");
        } else
          h && (s += " if (true) { ");
        return s;
      };
    }, {}], "Kkzr": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = function(t, o, e) {
        var r = " ", s = t.schema[o], n = t.errSchemaPath + "/" + o, c = (t.opts.allErrors, t.util.toQuotedString(s));
        return true === t.opts.$comment ? r += " console.log(" + c + ");" : "function" == typeof t.opts.$comment && (r += " self._opts.$comment(" + c + ", " + t.util.toQuotedString(n) + ", validate.root.schema);"), r;
      };
    }, {}], "U4sD": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = function(a, e, r) {
        var t = " ", s = a.level, o = a.dataLevel, l = a.schema[e], h = a.schemaPath + a.util.getProperty(e), c = a.errSchemaPath + "/" + e, d = !a.opts.allErrors, m = "data" + (o || ""), v = "valid" + s, u = a.opts.$data && l && l.$data;
        u && (t += " var schema" + s + " = " + a.util.getData(l.$data, o, a.dataPathArr) + "; "), u || (t += " var schema" + s + " = validate.schema" + h + ";"), t += "var " + v + " = equal(" + m + ", schema" + s + "); if (!" + v + ") {   ";
        var i = i || [];
        i.push(t), t = "", false !== a.createErrors ? (t += " { keyword: 'const' , dataPath: (dataPath || '') + " + a.errorPath + " , schemaPath: " + a.util.toQuotedString(c) + " , params: { allowedValue: schema" + s + " } ", false !== a.opts.messages && (t += " , message: 'should be equal to constant' "), a.opts.verbose && (t += " , schema: validate.schema" + h + " , parentSchema: validate.schema" + a.schemaPath + " , data: " + m + " "), t += " } ") : t += " {} ";
        var n = t;
        return t = i.pop(), !a.compositeRule && d ? a.async ? t += " throw new ValidationError([" + n + "]); " : t += " validate.errors = [" + n + "]; return false; " : t += " var err = " + n + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", t += " }", d && (t += " else { "), t;
      };
    }, {}], "EypH": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = function(e, r, a) {
        var t = " ", s = e.level, l = e.dataLevel, o = e.schema[r], i = e.schemaPath + e.util.getProperty(r), v = e.errSchemaPath + "/" + r, h = !e.opts.allErrors, c = "data" + (l || ""), u = "valid" + s, d = "errs__" + s, m = e.util.copy(e);
        m.level++;
        var p = "valid" + m.level, n = "i" + s, P = m.dataLevel = e.dataLevel + 1, f = "data" + P, E = e.baseId, g = e.opts.strictKeywords ? "object" == typeof o && Object.keys(o).length > 0 || false === o : e.util.schemaHasRules(o, e.RULES.all);
        if (t += "var " + d + " = errors;var " + u + ";", g) {
          var R = e.compositeRule;
          e.compositeRule = m.compositeRule = true, m.schema = o, m.schemaPath = i, m.errSchemaPath = v, t += " var " + p + " = false; for (var " + n + " = 0; " + n + " < " + c + ".length; " + n + "++) { ", m.errorPath = e.util.getPathExpr(e.errorPath, n, e.opts.jsonPointers, true);
          var y = c + "[" + n + "]";
          m.dataPathArr[P] = n;
          var b = e.validate(m);
          m.baseId = E, e.util.varOccurences(b, f) < 2 ? t += " " + e.util.varReplace(b, f, y) + " " : t += " var " + f + " = " + y + "; " + b + " ", t += " if (" + p + ") break; }  ", e.compositeRule = m.compositeRule = R, t += "  if (!" + p + ") {";
        } else
          t += " if (" + c + ".length == 0) {";
        var S = S || [];
        S.push(t), t = "", false !== e.createErrors ? (t += " { keyword: 'contains' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(v) + " , params: {} ", false !== e.opts.messages && (t += " , message: 'should contain a valid item' "), e.opts.verbose && (t += " , schema: validate.schema" + i + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "), t += " } ") : t += " {} ";
        var w = t;
        return t = S.pop(), !e.compositeRule && h ? e.async ? t += " throw new ValidationError([" + w + "]); " : t += " validate.errors = [" + w + "]; return false; " : t += " var err = " + w + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", t += " } else { ", g && (t += "  errors = " + d + "; if (vErrors !== null) { if (" + d + ") vErrors.length = " + d + "; else vErrors = null; } "), e.opts.allErrors && (t += " } "), t;
      };
    }, {}], "Cpp7": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = function(e, r, t) {
        var a = " ", s = e.level, o = e.dataLevel, p = e.schema[r], i = e.schemaPath + e.util.getProperty(r), l = e.errSchemaPath + "/" + r, u = !e.opts.allErrors, n = "data" + (o || ""), h = "errs__" + s, c = e.util.copy(e), d = "";
        c.level++;
        var v = "valid" + c.level, P = {}, m = {}, y = e.opts.ownProperties;
        for (j in p)
          if ("__proto__" != j) {
            var g = p[j], f = Array.isArray(g) ? m : P;
            f[j] = g;
          }
        a += "var " + h + " = errors;";
        var Q = e.errorPath;
        for (var j in a += "var missing" + s + ";", m)
          if ((f = m[j]).length) {
            if (a += " if ( " + n + e.util.getProperty(j) + " !== undefined ", y && (a += " && Object.prototype.hasOwnProperty.call(" + n + ", '" + e.util.escapeQuotes(j) + "') "), u) {
              a += " && ( ";
              var w = f;
              if (w)
                for (var E = -1, b = w.length - 1; E < b; ) {
                  x = w[E += 1], E && (a += " || "), a += " ( ( " + (I = n + (D = e.util.getProperty(x))) + " === undefined ", y && (a += " || ! Object.prototype.hasOwnProperty.call(" + n + ", '" + e.util.escapeQuotes(x) + "') "), a += ") && (missing" + s + " = " + e.util.toQuotedString(e.opts.jsonPointers ? x : D) + ") ) ";
                }
              a += ")) {  ";
              var O = "missing" + s, S = "' + " + O + " + '";
              e.opts._errorDataPathProperty && (e.errorPath = e.opts.jsonPointers ? e.util.getPathExpr(Q, O, true) : Q + " + " + O);
              var _ = _ || [];
              _.push(a), a = "", false !== e.createErrors ? (a += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(l) + " , params: { property: '" + e.util.escapeQuotes(j) + "', missingProperty: '" + S + "', depsCount: " + f.length + ", deps: '" + e.util.escapeQuotes(1 == f.length ? f[0] : f.join(", ")) + "' } ", false !== e.opts.messages && (a += " , message: 'should have ", 1 == f.length ? a += "property " + e.util.escapeQuotes(f[0]) : a += "properties " + e.util.escapeQuotes(f.join(", ")), a += " when property " + e.util.escapeQuotes(j) + " is present' "), e.opts.verbose && (a += " , schema: validate.schema" + i + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + n + " "), a += " } ") : a += " {} ";
              var k = a;
              a = _.pop(), !e.compositeRule && u ? e.async ? a += " throw new ValidationError([" + k + "]); " : a += " validate.errors = [" + k + "]; return false; " : a += " var err = " + k + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            } else {
              a += " ) { ";
              var R = f;
              if (R)
                for (var x, A = -1, C = R.length - 1; A < C; ) {
                  x = R[A += 1];
                  var D = e.util.getProperty(x), I = (S = e.util.escapeQuotes(x), n + D);
                  e.opts._errorDataPathProperty && (e.errorPath = e.util.getPath(Q, x, e.opts.jsonPointers)), a += " if ( " + I + " === undefined ", y && (a += " || ! Object.prototype.hasOwnProperty.call(" + n + ", '" + e.util.escapeQuotes(x) + "') "), a += ") {  var err =   ", false !== e.createErrors ? (a += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(l) + " , params: { property: '" + e.util.escapeQuotes(j) + "', missingProperty: '" + S + "', depsCount: " + f.length + ", deps: '" + e.util.escapeQuotes(1 == f.length ? f[0] : f.join(", ")) + "' } ", false !== e.opts.messages && (a += " , message: 'should have ", 1 == f.length ? a += "property " + e.util.escapeQuotes(f[0]) : a += "properties " + e.util.escapeQuotes(f.join(", ")), a += " when property " + e.util.escapeQuotes(j) + " is present' "), e.opts.verbose && (a += " , schema: validate.schema" + i + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + n + " "), a += " } ") : a += " {} ", a += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
                }
            }
            a += " }   ", u && (d += "}", a += " else { ");
          }
        e.errorPath = Q;
        var L = c.baseId;
        for (var j in P) {
          g = P[j];
          (e.opts.strictKeywords ? "object" == typeof g && Object.keys(g).length > 0 || false === g : e.util.schemaHasRules(g, e.RULES.all)) && (a += " " + v + " = true; if ( " + n + e.util.getProperty(j) + " !== undefined ", y && (a += " && Object.prototype.hasOwnProperty.call(" + n + ", '" + e.util.escapeQuotes(j) + "') "), a += ") { ", c.schema = g, c.schemaPath = i + e.util.getProperty(j), c.errSchemaPath = l + "/" + e.util.escapeFragment(j), a += "  " + e.validate(c) + " ", c.baseId = L, a += " }  ", u && (a += " if (" + v + ") { ", d += "}"));
        }
        return u && (a += "   " + d + " if (" + h + " == errors) {"), a;
      };
    }, {}], "fqDY": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = function(a, e, r) {
        var t = " ", s = a.level, l = a.dataLevel, o = a.schema[e], h = a.schemaPath + a.util.getProperty(e), d = a.errSchemaPath + "/" + e, i = !a.opts.allErrors, u = "data" + (l || ""), m = "valid" + s, v = a.opts.$data && o && o.$data;
        v && (t += " var schema" + s + " = " + a.util.getData(o.$data, l, a.dataPathArr) + "; ");
        var c = "i" + s, n = "schema" + s;
        v || (t += " var " + n + " = validate.schema" + h + ";"), t += "var " + m + ";", v && (t += " if (schema" + s + " === undefined) " + m + " = true; else if (!Array.isArray(schema" + s + ")) " + m + " = false; else {"), t += m + " = false;for (var " + c + "=0; " + c + "<" + n + ".length; " + c + "++) if (equal(" + u + ", " + n + "[" + c + "])) { " + m + " = true; break; }", v && (t += "  }  "), t += " if (!" + m + ") {   ";
        var p = p || [];
        p.push(t), t = "", false !== a.createErrors ? (t += " { keyword: 'enum' , dataPath: (dataPath || '') + " + a.errorPath + " , schemaPath: " + a.util.toQuotedString(d) + " , params: { allowedValues: schema" + s + " } ", false !== a.opts.messages && (t += " , message: 'should be equal to one of the allowed values' "), a.opts.verbose && (t += " , schema: validate.schema" + h + " , parentSchema: validate.schema" + a.schemaPath + " , data: " + u + " "), t += " } ") : t += " {} ";
        var f = t;
        return t = p.pop(), !a.compositeRule && i ? a.async ? t += " throw new ValidationError([" + f + "]); " : t += " validate.errors = [" + f + "]; return false; " : t += " var err = " + f + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", t += " }", i && (t += " else { "), t;
      };
    }, {}], "avoW": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = function(a, t, r) {
        var e = " ", o = a.level, s = a.dataLevel, i = a.schema[t], n = a.schemaPath + a.util.getProperty(t), f = a.errSchemaPath + "/" + t, c = !a.opts.allErrors, u = "data" + (s || "");
        if (false === a.opts.format)
          return c && (e += " if (true) { "), e;
        var m, h = a.opts.$data && i && i.$data;
        h ? (e += " var schema" + o + " = " + a.util.getData(i.$data, s, a.dataPathArr) + "; ", m = "schema" + o) : m = i;
        var l = a.opts.unknownFormats, d = Array.isArray(l);
        if (h) {
          e += " var " + (p = "format" + o) + " = formats[" + m + "]; var " + (v = "isObject" + o) + " = typeof " + p + " == 'object' && !(" + p + " instanceof RegExp) && " + p + ".validate; var " + (y = "formatType" + o) + " = " + v + " && " + p + ".type || 'string'; if (" + v + ") { ", a.async && (e += " var async" + o + " = " + p + ".async; "), e += " " + p + " = " + p + ".validate; } if (  ", h && (e += " (" + m + " !== undefined && typeof " + m + " != 'string') || "), e += " (", "ignore" != l && (e += " (" + m + " && !" + p + " ", d && (e += " && self._opts.unknownFormats.indexOf(" + m + ") == -1 "), e += ") || "), e += " (" + p + " && " + y + " == '" + r + "' && !(typeof " + p + " == 'function' ? ", a.async ? e += " (async" + o + " ? await " + p + "(" + u + ") : " + p + "(" + u + ")) " : e += " " + p + "(" + u + ") ", e += " : " + p + ".test(" + u + "))))) {";
        } else {
          var p;
          if (!(p = a.formats[i])) {
            if ("ignore" == l)
              return a.logger.warn('unknown format "' + i + '" ignored in schema at path "' + a.errSchemaPath + '"'), c && (e += " if (true) { "), e;
            if (d && l.indexOf(i) >= 0)
              return c && (e += " if (true) { "), e;
            throw new Error('unknown format "' + i + '" is used in schema at path "' + a.errSchemaPath + '"');
          }
          var v, y = (v = "object" == typeof p && !(p instanceof RegExp) && p.validate) && p.type || "string";
          if (v) {
            var g = true === p.async;
            p = p.validate;
          }
          if (y != r)
            return c && (e += " if (true) { "), e;
          if (g) {
            if (!a.async)
              throw new Error("async format in sync schema");
            e += " if (!(await " + (w = "formats" + a.util.getProperty(i) + ".validate") + "(" + u + "))) { ";
          } else {
            e += " if (! ";
            var w = "formats" + a.util.getProperty(i);
            v && (w += ".validate"), e += "function" == typeof p ? " " + w + "(" + u + ") " : " " + w + ".test(" + u + ") ", e += ") { ";
          }
        }
        var P = P || [];
        P.push(e), e = "", false !== a.createErrors ? (e += " { keyword: 'format' , dataPath: (dataPath || '') + " + a.errorPath + " , schemaPath: " + a.util.toQuotedString(f) + " , params: { format:  ", e += h ? "" + m : "" + a.util.toQuotedString(i), e += "  } ", false !== a.opts.messages && (e += ` , message: 'should match format "`, e += h ? "' + " + m + " + '" : "" + a.util.escapeQuotes(i), e += `"' `), a.opts.verbose && (e += " , schema:  ", e += h ? "validate.schema" + n : "" + a.util.toQuotedString(i), e += "         , parentSchema: validate.schema" + a.schemaPath + " , data: " + u + " "), e += " } ") : e += " {} ";
        var E = e;
        return e = P.pop(), !a.compositeRule && c ? a.async ? e += " throw new ValidationError([" + E + "]); " : e += " validate.errors = [" + E + "]; return false; " : e += " var err = " + E + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", e += " } ", c && (e += " else { "), e;
      };
    }, {}], "JHQ3": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = function(e, r, a) {
        var s = " ", t = e.level, l = e.dataLevel, h = e.schema[r], o = e.schemaPath + e.util.getProperty(r), c = e.errSchemaPath + "/" + r, i = !e.opts.allErrors, m = "data" + (l || ""), v = "valid" + t, u = "errs__" + t, d = e.util.copy(e);
        d.level++;
        var n = "valid" + d.level, p = e.schema.then, P = e.schema.else, f = void 0 !== p && (e.opts.strictKeywords ? "object" == typeof p && Object.keys(p).length > 0 || false === p : e.util.schemaHasRules(p, e.RULES.all)), E = void 0 !== P && (e.opts.strictKeywords ? "object" == typeof P && Object.keys(P).length > 0 || false === P : e.util.schemaHasRules(P, e.RULES.all)), y = d.baseId;
        if (f || E) {
          var R;
          d.createErrors = false, d.schema = h, d.schemaPath = o, d.errSchemaPath = c, s += " var " + u + " = errors; var " + v + " = true;  ";
          var S = e.compositeRule;
          e.compositeRule = d.compositeRule = true, s += "  " + e.validate(d) + " ", d.baseId = y, d.createErrors = true, s += "  errors = " + u + "; if (vErrors !== null) { if (" + u + ") vErrors.length = " + u + "; else vErrors = null; }  ", e.compositeRule = d.compositeRule = S, f ? (s += " if (" + n + ") {  ", d.schema = e.schema.then, d.schemaPath = e.schemaPath + ".then", d.errSchemaPath = e.errSchemaPath + "/then", s += "  " + e.validate(d) + " ", d.baseId = y, s += " " + v + " = " + n + "; ", f && E ? s += " var " + (R = "ifClause" + t) + " = 'then'; " : R = "'then'", s += " } ", E && (s += " else { ")) : s += " if (!" + n + ") { ", E && (d.schema = e.schema.else, d.schemaPath = e.schemaPath + ".else", d.errSchemaPath = e.errSchemaPath + "/else", s += "  " + e.validate(d) + " ", d.baseId = y, s += " " + v + " = " + n + "; ", f && E ? s += " var " + (R = "ifClause" + t) + " = 'else'; " : R = "'else'", s += " } "), s += " if (!" + v + ") {   var err =   ", false !== e.createErrors ? (s += " { keyword: 'if' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { failingKeyword: " + R + " } ", false !== e.opts.messages && (s += ` , message: 'should match "' + ` + R + ` + '" schema' `), e.opts.verbose && (s += " , schema: validate.schema" + o + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + m + " "), s += " } ") : s += " {} ", s += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e.compositeRule && i && (e.async ? s += " throw new ValidationError(vErrors); " : s += " validate.errors = vErrors; return false; "), s += " }   ", i && (s += " else { ");
        } else
          i && (s += " if (true) { ");
        return s;
      };
    }, {}], "aiPb": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = function(e, a, r) {
        var t = " ", s = e.level, l = e.dataLevel, h = e.schema[a], o = e.schemaPath + e.util.getProperty(a), i = e.errSchemaPath + "/" + a, c = !e.opts.allErrors, v = "data" + (l || ""), d = "valid" + s, n = "errs__" + s, m = e.util.copy(e), u = "";
        m.level++;
        var P = "valid" + m.level, p = "i" + s, f = m.dataLevel = e.dataLevel + 1, g = "data" + f, y = e.baseId;
        if (t += "var " + n + " = errors;var " + d + ";", Array.isArray(h)) {
          var b = e.schema.additionalItems;
          if (false === b) {
            t += " " + d + " = " + v + ".length <= " + h.length + "; ";
            var E = i;
            i = e.errSchemaPath + "/additionalItems", t += "  if (!" + d + ") {   ";
            var S = S || [];
            S.push(t), t = "", false !== e.createErrors ? (t += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(i) + " , params: { limit: " + h.length + " } ", false !== e.opts.messages && (t += " , message: 'should NOT have more than " + h.length + " items' "), e.opts.verbose && (t += " , schema: false , parentSchema: validate.schema" + e.schemaPath + " , data: " + v + " "), t += " } ") : t += " {} ";
            var j = t;
            t = S.pop(), !e.compositeRule && c ? e.async ? t += " throw new ValidationError([" + j + "]); " : t += " validate.errors = [" + j + "]; return false; " : t += " var err = " + j + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", t += " } ", i = E, c && (u += "}", t += " else { ");
          }
          var R = h;
          if (R) {
            for (var I, O = -1, k = R.length - 1; O < k; )
              if (I = R[O += 1], e.opts.strictKeywords ? "object" == typeof I && Object.keys(I).length > 0 || false === I : e.util.schemaHasRules(I, e.RULES.all)) {
                t += " " + P + " = true; if (" + v + ".length > " + O + ") { ";
                var w = v + "[" + O + "]";
                m.schema = I, m.schemaPath = o + "[" + O + "]", m.errSchemaPath = i + "/" + O, m.errorPath = e.util.getPathExpr(e.errorPath, O, e.opts.jsonPointers, true), m.dataPathArr[f] = O;
                var L = e.validate(m);
                m.baseId = y, e.util.varOccurences(L, g) < 2 ? t += " " + e.util.varReplace(L, g, w) + " " : t += " var " + g + " = " + w + "; " + L + " ", t += " }  ", c && (t += " if (" + P + ") { ", u += "}");
              }
          }
          if ("object" == typeof b && (e.opts.strictKeywords ? "object" == typeof b && Object.keys(b).length > 0 || false === b : e.util.schemaHasRules(b, e.RULES.all))) {
            m.schema = b, m.schemaPath = e.schemaPath + ".additionalItems", m.errSchemaPath = e.errSchemaPath + "/additionalItems", t += " " + P + " = true; if (" + v + ".length > " + h.length + ") {  for (var " + p + " = " + h.length + "; " + p + " < " + v + ".length; " + p + "++) { ", m.errorPath = e.util.getPathExpr(e.errorPath, p, e.opts.jsonPointers, true);
            w = v + "[" + p + "]";
            m.dataPathArr[f] = p;
            L = e.validate(m);
            m.baseId = y, e.util.varOccurences(L, g) < 2 ? t += " " + e.util.varReplace(L, g, w) + " " : t += " var " + g + " = " + w + "; " + L + " ", c && (t += " if (!" + P + ") break; "), t += " } }  ", c && (t += " if (" + P + ") { ", u += "}");
          }
        } else if (e.opts.strictKeywords ? "object" == typeof h && Object.keys(h).length > 0 || false === h : e.util.schemaHasRules(h, e.RULES.all)) {
          m.schema = h, m.schemaPath = o, m.errSchemaPath = i, t += "  for (var " + p + " = 0; " + p + " < " + v + ".length; " + p + "++) { ", m.errorPath = e.util.getPathExpr(e.errorPath, p, e.opts.jsonPointers, true);
          w = v + "[" + p + "]";
          m.dataPathArr[f] = p;
          L = e.validate(m);
          m.baseId = y, e.util.varOccurences(L, g) < 2 ? t += " " + e.util.varReplace(L, g, w) + " " : t += " var " + g + " = " + w + "; " + L + " ", c && (t += " if (!" + P + ") break; "), t += " }";
        }
        return c && (t += " " + u + " if (" + n + " == errors) {"), t;
      };
    }, {}], "UJAl": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = function(e, r, a) {
        var t, s = " ", o = e.level, i = e.dataLevel, m = e.schema[r], h = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, l = !e.opts.allErrors, d = "data" + (i || ""), n = e.opts.$data && m && m.$data;
        n ? (s += " var schema" + o + " = " + e.util.getData(m.$data, i, e.dataPathArr) + "; ", t = "schema" + o) : t = m;
        var c = "maximum" == r, v = c ? "exclusiveMaximum" : "exclusiveMinimum", p = e.schema[v], f = e.opts.$data && p && p.$data, b = c ? "<" : ">", P = c ? ">" : "<", E = void 0;
        if (!n && "number" != typeof m && void 0 !== m)
          throw new Error(r + " must be number");
        if (!f && void 0 !== p && "number" != typeof p && "boolean" != typeof p)
          throw new Error(v + " must be number or boolean");
        if (f) {
          var y = e.util.getData(p.$data, i, e.dataPathArr), x = "exclusive" + o, w = "exclType" + o, g = "exclIsNumber" + o, S = "' + " + (k = "op" + o) + " + '";
          s += " var schemaExcl" + o + " = " + y + "; ", s += " var " + x + "; var " + w + " = typeof " + (y = "schemaExcl" + o) + "; if (" + w + " != 'boolean' && " + w + " != 'undefined' && " + w + " != 'number') { ";
          var $;
          E = v;
          ($ = $ || []).push(s), s = "", false !== e.createErrors ? (s += " { keyword: '" + (E || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: {} ", false !== e.opts.messages && (s += " , message: '" + v + " should be boolean' "), e.opts.verbose && (s += " , schema: validate.schema" + h + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), s += " } ") : s += " {} ";
          var M = s;
          s = $.pop(), !e.compositeRule && l ? e.async ? s += " throw new ValidationError([" + M + "]); " : s += " validate.errors = [" + M + "]; return false; " : s += " var err = " + M + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", s += " } else if ( ", n && (s += " (" + t + " !== undefined && typeof " + t + " != 'number') || "), s += " " + w + " == 'number' ? ( (" + x + " = " + t + " === undefined || " + y + " " + b + "= " + t + ") ? " + d + " " + P + "= " + y + " : " + d + " " + P + " " + t + " ) : ( (" + x + " = " + y + " === true) ? " + d + " " + P + "= " + t + " : " + d + " " + P + " " + t + " ) || " + d + " !== " + d + ") { var op" + o + " = " + x + " ? '" + b + "' : '" + b + "='; ", void 0 === m && (E = v, u = e.errSchemaPath + "/" + v, t = y, n = f);
        } else {
          S = b;
          if ((g = "number" == typeof p) && n) {
            var k = "'" + S + "'";
            s += " if ( ", n && (s += " (" + t + " !== undefined && typeof " + t + " != 'number') || "), s += " ( " + t + " === undefined || " + p + " " + b + "= " + t + " ? " + d + " " + P + "= " + p + " : " + d + " " + P + " " + t + " ) || " + d + " !== " + d + ") { ";
          } else {
            g && void 0 === m ? (x = true, E = v, u = e.errSchemaPath + "/" + v, t = p, P += "=") : (g && (t = Math[c ? "min" : "max"](p, m)), p === (!g || t) ? (x = true, E = v, u = e.errSchemaPath + "/" + v, P += "=") : (x = false, S += "="));
            k = "'" + S + "'";
            s += " if ( ", n && (s += " (" + t + " !== undefined && typeof " + t + " != 'number') || "), s += " " + d + " " + P + " " + t + " || " + d + " !== " + d + ") { ";
          }
        }
        E = E || r, ($ = $ || []).push(s), s = "", false !== e.createErrors ? (s += " { keyword: '" + (E || "_limit") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { comparison: " + k + ", limit: " + t + ", exclusive: " + x + " } ", false !== e.opts.messages && (s += " , message: 'should be " + S + " ", s += n ? "' + " + t : t + "'"), e.opts.verbose && (s += " , schema:  ", s += n ? "validate.schema" + h : "" + m, s += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), s += " } ") : s += " {} ";
        M = s;
        return s = $.pop(), !e.compositeRule && l ? e.async ? s += " throw new ValidationError([" + M + "]); " : s += " validate.errors = [" + M + "]; return false; " : s += " var err = " + M + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", s += " } ", l && (s += " else { "), s;
      };
    }, {}], "W8ih": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = function(e, r, a) {
        var t, s = " ", o = e.level, m = e.dataLevel, h = e.schema[r], l = e.schemaPath + e.util.getProperty(r), i = e.errSchemaPath + "/" + r, d = !e.opts.allErrors, u = "data" + (m || ""), n = e.opts.$data && h && h.$data;
        if (n ? (s += " var schema" + o + " = " + e.util.getData(h.$data, m, e.dataPathArr) + "; ", t = "schema" + o) : t = h, !n && "number" != typeof h)
          throw new Error(r + " must be number");
        s += "if ( ", n && (s += " (" + t + " !== undefined && typeof " + t + " != 'number') || "), s += " " + u + ".length " + ("maxItems" == r ? ">" : "<") + " " + t + ") { ";
        var c = r, p = p || [];
        p.push(s), s = "", false !== e.createErrors ? (s += " { keyword: '" + (c || "_limitItems") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(i) + " , params: { limit: " + t + " } ", false !== e.opts.messages && (s += " , message: 'should NOT have ", s += "maxItems" == r ? "more" : "fewer", s += " than ", s += n ? "' + " + t + " + '" : "" + h, s += " items' "), e.opts.verbose && (s += " , schema:  ", s += n ? "validate.schema" + l : "" + h, s += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), s += " } ") : s += " {} ";
        var v = s;
        return s = p.pop(), !e.compositeRule && d ? e.async ? s += " throw new ValidationError([" + v + "]); " : s += " validate.errors = [" + v + "]; return false; " : s += " var err = " + v + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", s += "} ", d && (s += " else { "), s;
      };
    }, {}], "fZGX": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = function(e, r, a) {
        var t, s = " ", o = e.level, h = e.dataLevel, l = e.schema[r], m = e.schemaPath + e.util.getProperty(r), n = e.errSchemaPath + "/" + r, i = !e.opts.allErrors, u = "data" + (h || ""), c = e.opts.$data && l && l.$data;
        if (c ? (s += " var schema" + o + " = " + e.util.getData(l.$data, h, e.dataPathArr) + "; ", t = "schema" + o) : t = l, !c && "number" != typeof l)
          throw new Error(r + " must be number");
        var d = "maxLength" == r ? ">" : "<";
        s += "if ( ", c && (s += " (" + t + " !== undefined && typeof " + t + " != 'number') || "), false === e.opts.unicode ? s += " " + u + ".length " : s += " ucs2length(" + u + ") ", s += " " + d + " " + t + ") { ";
        var p = r, v = v || [];
        v.push(s), s = "", false !== e.createErrors ? (s += " { keyword: '" + (p || "_limitLength") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(n) + " , params: { limit: " + t + " } ", false !== e.opts.messages && (s += " , message: 'should NOT be ", s += "maxLength" == r ? "longer" : "shorter", s += " than ", s += c ? "' + " + t + " + '" : "" + l, s += " characters' "), e.opts.verbose && (s += " , schema:  ", s += c ? "validate.schema" + m : "" + l, s += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), s += " } ") : s += " {} ";
        var g = s;
        return s = v.pop(), !e.compositeRule && i ? e.async ? s += " throw new ValidationError([" + g + "]); " : s += " validate.errors = [" + g + "]; return false; " : s += " var err = " + g + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", s += "} ", i && (s += " else { "), s;
      };
    }, {}], "JAEr": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = function(e, r, a) {
        var t, s = " ", o = e.level, h = e.dataLevel, m = e.schema[r], i = e.schemaPath + e.util.getProperty(r), l = e.errSchemaPath + "/" + r, p = !e.opts.allErrors, d = "data" + (h || ""), u = e.opts.$data && m && m.$data;
        if (u ? (s += " var schema" + o + " = " + e.util.getData(m.$data, h, e.dataPathArr) + "; ", t = "schema" + o) : t = m, !u && "number" != typeof m)
          throw new Error(r + " must be number");
        s += "if ( ", u && (s += " (" + t + " !== undefined && typeof " + t + " != 'number') || "), s += " Object.keys(" + d + ").length " + ("maxProperties" == r ? ">" : "<") + " " + t + ") { ";
        var n = r, c = c || [];
        c.push(s), s = "", false !== e.createErrors ? (s += " { keyword: '" + (n || "_limitProperties") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(l) + " , params: { limit: " + t + " } ", false !== e.opts.messages && (s += " , message: 'should NOT have ", s += "maxProperties" == r ? "more" : "fewer", s += " than ", s += u ? "' + " + t + " + '" : "" + m, s += " properties' "), e.opts.verbose && (s += " , schema:  ", s += u ? "validate.schema" + i : "" + m, s += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), s += " } ") : s += " {} ";
        var v = s;
        return s = c.pop(), !e.compositeRule && p ? e.async ? s += " throw new ValidationError([" + v + "]); " : s += " validate.errors = [" + v + "]; return false; " : s += " var err = " + v + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", s += "} ", p && (s += " else { "), s;
      };
    }, {}], "oNPH": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = function(e, r, a) {
        var t, s = " ", i = e.level, o = e.dataLevel, l = e.schema[r], d = e.schemaPath + e.util.getProperty(r), h = e.errSchemaPath + "/" + r, n = !e.opts.allErrors, m = "data" + (o || ""), u = e.opts.$data && l && l.$data;
        if (u ? (s += " var schema" + i + " = " + e.util.getData(l.$data, o, e.dataPathArr) + "; ", t = "schema" + i) : t = l, !u && "number" != typeof l)
          throw new Error(r + " must be number");
        s += "var division" + i + ";if (", u && (s += " " + t + " !== undefined && ( typeof " + t + " != 'number' || "), s += " (division" + i + " = " + m + " / " + t + ", ", e.opts.multipleOfPrecision ? s += " Math.abs(Math.round(division" + i + ") - division" + i + ") > 1e-" + e.opts.multipleOfPrecision + " " : s += " division" + i + " !== parseInt(division" + i + ") ", s += " ) ", u && (s += "  )  "), s += " ) {   ";
        var p = p || [];
        p.push(s), s = "", false !== e.createErrors ? (s += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(h) + " , params: { multipleOf: " + t + " } ", false !== e.opts.messages && (s += " , message: 'should be multiple of ", s += u ? "' + " + t : t + "'"), e.opts.verbose && (s += " , schema:  ", s += u ? "validate.schema" + d : "" + l, s += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + m + " "), s += " } ") : s += " {} ";
        var v = s;
        return s = p.pop(), !e.compositeRule && n ? e.async ? s += " throw new ValidationError([" + v + "]); " : s += " validate.errors = [" + v + "]; return false; " : s += " var err = " + v + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", s += "} ", n && (s += " else { "), s;
      };
    }, {}], "mmjm": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = function(r, e, a) {
        var s = " ", t = r.level, o = r.dataLevel, l = r.schema[e], h = r.schemaPath + r.util.getProperty(e), c = r.errSchemaPath + "/" + e, i = !r.opts.allErrors, m = "data" + (o || ""), v = "errs__" + t, p = r.util.copy(r);
        p.level++;
        var u = "valid" + p.level;
        if (r.opts.strictKeywords ? "object" == typeof l && Object.keys(l).length > 0 || false === l : r.util.schemaHasRules(l, r.RULES.all)) {
          p.schema = l, p.schemaPath = h, p.errSchemaPath = c, s += " var " + v + " = errors;  ";
          var d, E = r.compositeRule;
          r.compositeRule = p.compositeRule = true, p.createErrors = false, p.opts.allErrors && (d = p.opts.allErrors, p.opts.allErrors = false), s += " " + r.validate(p) + " ", p.createErrors = true, d && (p.opts.allErrors = d), r.compositeRule = p.compositeRule = E, s += " if (" + u + ") {   ";
          var n = n || [];
          n.push(s), s = "", false !== r.createErrors ? (s += " { keyword: 'not' , dataPath: (dataPath || '') + " + r.errorPath + " , schemaPath: " + r.util.toQuotedString(c) + " , params: {} ", false !== r.opts.messages && (s += " , message: 'should NOT be valid' "), r.opts.verbose && (s += " , schema: validate.schema" + h + " , parentSchema: validate.schema" + r.schemaPath + " , data: " + m + " "), s += " } ") : s += " {} ";
          var P = s;
          s = n.pop(), !r.compositeRule && i ? r.async ? s += " throw new ValidationError([" + P + "]); " : s += " validate.errors = [" + P + "]; return false; " : s += " var err = " + P + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", s += " } else {  errors = " + v + "; if (vErrors !== null) { if (" + v + ") vErrors.length = " + v + "; else vErrors = null; } ", r.opts.allErrors && (s += " } ");
        } else
          s += "  var err =   ", false !== r.createErrors ? (s += " { keyword: 'not' , dataPath: (dataPath || '') + " + r.errorPath + " , schemaPath: " + r.util.toQuotedString(c) + " , params: {} ", false !== r.opts.messages && (s += " , message: 'should NOT be valid' "), r.opts.verbose && (s += " , schema: validate.schema" + h + " , parentSchema: validate.schema" + r.schemaPath + " , data: " + m + " "), s += " } ") : s += " {} ", s += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", i && (s += " if (false) { ");
        return s;
      };
    }, {}], "SSWF": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = function(e, r, a) {
        var s = " ", t = e.level, l = e.dataLevel, o = e.schema[r], i = e.schemaPath + e.util.getProperty(r), c = e.errSchemaPath + "/" + r, h = !e.opts.allErrors, v = "data" + (l || ""), m = "valid" + t, u = "errs__" + t, n = e.util.copy(e), p = "";
        n.level++;
        var d = "valid" + n.level, f = n.baseId, E = "prevValid" + t, P = "passingSchemas" + t;
        s += "var " + u + " = errors , " + E + " = false , " + m + " = false , " + P + " = null; ";
        var g = e.compositeRule;
        e.compositeRule = n.compositeRule = true;
        var y = o;
        if (y)
          for (var R, S = -1, b = y.length - 1; S < b; )
            R = y[S += 1], (e.opts.strictKeywords ? "object" == typeof R && Object.keys(R).length > 0 || false === R : e.util.schemaHasRules(R, e.RULES.all)) ? (n.schema = R, n.schemaPath = i + "[" + S + "]", n.errSchemaPath = c + "/" + S, s += "  " + e.validate(n) + " ", n.baseId = f) : s += " var " + d + " = true; ", S && (s += " if (" + d + " && " + E + ") { " + m + " = false; " + P + " = [" + P + ", " + S + "]; } else { ", p += "}"), s += " if (" + d + ") { " + m + " = " + E + " = true; " + P + " = " + S + "; }";
        return e.compositeRule = n.compositeRule = g, s += p + "if (!" + m + ") {   var err =   ", false !== e.createErrors ? (s += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { passingSchemas: " + P + " } ", false !== e.opts.messages && (s += " , message: 'should match exactly one schema in oneOf' "), e.opts.verbose && (s += " , schema: validate.schema" + i + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + v + " "), s += " } ") : s += " {} ", s += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e.compositeRule && h && (e.async ? s += " throw new ValidationError(vErrors); " : s += " validate.errors = vErrors; return false; "), s += "} else {  errors = " + u + "; if (vErrors !== null) { if (" + u + ") vErrors.length = " + u + "; else vErrors = null; }", e.opts.allErrors && (s += " } "), s;
      };
    }, {}], "mGZS": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = function(e, t, a) {
        var r, s = " ", o = e.level, h = e.dataLevel, l = e.schema[t], u = e.schemaPath + e.util.getProperty(t), d = e.errSchemaPath + "/" + t, i = !e.opts.allErrors, n = "data" + (h || ""), p = e.opts.$data && l && l.$data;
        p ? (s += " var schema" + o + " = " + e.util.getData(l.$data, h, e.dataPathArr) + "; ", r = "schema" + o) : r = l, s += "if ( ", p && (s += " (" + r + " !== undefined && typeof " + r + " != 'string') || "), s += " !" + (p ? "(new RegExp(" + r + "))" : e.usePattern(l)) + ".test(" + n + ") ) {   ";
        var c = c || [];
        c.push(s), s = "", false !== e.createErrors ? (s += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: { pattern:  ", s += p ? "" + r : "" + e.util.toQuotedString(l), s += "  } ", false !== e.opts.messages && (s += ` , message: 'should match pattern "`, s += p ? "' + " + r + " + '" : "" + e.util.escapeQuotes(l), s += `"' `), e.opts.verbose && (s += " , schema:  ", s += p ? "validate.schema" + u : "" + e.util.toQuotedString(l), s += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + n + " "), s += " } ") : s += " {} ";
        var m = s;
        return s = c.pop(), !e.compositeRule && i ? e.async ? s += " throw new ValidationError([" + m + "]); " : s += " validate.errors = [" + m + "]; return false; " : s += " var err = " + m + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", s += "} ", i && (s += " else { "), s;
      };
    }, {}], "jFnx": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = function(e, r, t) {
        var a = " ", o = e.level, s = e.dataLevel, i = e.schema[r], l = e.schemaPath + e.util.getProperty(r), h = e.errSchemaPath + "/" + r, p = !e.opts.allErrors, d = "data" + (s || ""), n = "errs__" + o, c = e.util.copy(e), P = "";
        c.level++;
        var u = "valid" + c.level, v = "key" + o, f = "idx" + o, m = c.dataLevel = e.dataLevel + 1, g = "data" + m, y = "dataProperties" + o, b = Object.keys(i || {}).filter(x), j = e.schema.patternProperties || {}, O = Object.keys(j).filter(x), S = e.schema.additionalProperties, E = b.length || O.length, R = false === S, k = "object" == typeof S && Object.keys(S).length, w = e.opts.removeAdditional, _ = R || k || w, Q = e.opts.ownProperties, A = e.baseId, D = e.schema.required;
        if (D && (!e.opts.$data || !D.$data) && D.length < e.opts.loopRequired)
          var q = e.util.toHash(D);
        function x(e2) {
          return "__proto__" !== e2;
        }
        __name(x, "x");
        if (a += "var " + n + " = errors;var " + u + " = true;", Q && (a += " var " + y + " = undefined;"), _) {
          if (a += Q ? " " + y + " = " + y + " || Object.keys(" + d + "); for (var " + f + "=0; " + f + "<" + y + ".length; " + f + "++) { var " + v + " = " + y + "[" + f + "]; " : " for (var " + v + " in " + d + ") { ", E) {
            if (a += " var isAdditional" + o + " = !(false ", b.length)
              if (b.length > 8)
                a += " || validate.schema" + l + ".hasOwnProperty(" + v + ") ";
              else {
                var I = b;
                if (I)
                  for (var L = -1, H = I.length - 1; L < H; )
                    M = I[L += 1], a += " || " + v + " == " + e.util.toQuotedString(M) + " ";
              }
            if (O.length) {
              var F = O;
              if (F)
                for (var K = -1, U = F.length - 1; K < U; )
                  se = F[K += 1], a += " || " + e.usePattern(se) + ".test(" + v + ") ";
            }
            a += " ); if (isAdditional" + o + ") { ";
          }
          if ("all" == w)
            a += " delete " + d + "[" + v + "]; ";
          else {
            var V = e.errorPath, $ = "' + " + v + " + '";
            if (e.opts._errorDataPathProperty && (e.errorPath = e.util.getPathExpr(e.errorPath, v, e.opts.jsonPointers)), R)
              if (w)
                a += " delete " + d + "[" + v + "]; ";
              else {
                a += " " + u + " = false; ";
                var N = h;
                h = e.errSchemaPath + "/additionalProperties", (te = te || []).push(a), a = "", false !== e.createErrors ? (a += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(h) + " , params: { additionalProperty: '" + $ + "' } ", false !== e.opts.messages && (a += " , message: '", e.opts._errorDataPathProperty ? a += "is an invalid additional property" : a += "should NOT have additional properties", a += "' "), e.opts.verbose && (a += " , schema: false , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), a += " } ") : a += " {} ";
                var T = a;
                a = te.pop(), !e.compositeRule && p ? e.async ? a += " throw new ValidationError([" + T + "]); " : a += " validate.errors = [" + T + "]; return false; " : a += " var err = " + T + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", h = N, p && (a += " break; ");
              }
            else if (k)
              if ("failing" == w) {
                a += " var " + n + " = errors;  ";
                var z = e.compositeRule;
                e.compositeRule = c.compositeRule = true, c.schema = S, c.schemaPath = e.schemaPath + ".additionalProperties", c.errSchemaPath = e.errSchemaPath + "/additionalProperties", c.errorPath = e.opts._errorDataPathProperty ? e.errorPath : e.util.getPathExpr(e.errorPath, v, e.opts.jsonPointers);
                var B = d + "[" + v + "]";
                c.dataPathArr[m] = v;
                var C = e.validate(c);
                c.baseId = A, e.util.varOccurences(C, g) < 2 ? a += " " + e.util.varReplace(C, g, B) + " " : a += " var " + g + " = " + B + "; " + C + " ", a += " if (!" + u + ") { errors = " + n + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + d + "[" + v + "]; }  ", e.compositeRule = c.compositeRule = z;
              } else {
                c.schema = S, c.schemaPath = e.schemaPath + ".additionalProperties", c.errSchemaPath = e.errSchemaPath + "/additionalProperties", c.errorPath = e.opts._errorDataPathProperty ? e.errorPath : e.util.getPathExpr(e.errorPath, v, e.opts.jsonPointers);
                B = d + "[" + v + "]";
                c.dataPathArr[m] = v;
                C = e.validate(c);
                c.baseId = A, e.util.varOccurences(C, g) < 2 ? a += " " + e.util.varReplace(C, g, B) + " " : a += " var " + g + " = " + B + "; " + C + " ", p && (a += " if (!" + u + ") break; ");
              }
            e.errorPath = V;
          }
          E && (a += " } "), a += " }  ", p && (a += " if (" + u + ") { ", P += "}");
        }
        var G = e.opts.useDefaults && !e.compositeRule;
        if (b.length) {
          var J = b;
          if (J)
            for (var M, W = -1, X = J.length - 1; W < X; ) {
              var Y = i[M = J[W += 1]];
              if (e.opts.strictKeywords ? "object" == typeof Y && Object.keys(Y).length > 0 || false === Y : e.util.schemaHasRules(Y, e.RULES.all)) {
                var Z = e.util.getProperty(M), ee = (B = d + Z, G && void 0 !== Y.default);
                c.schema = Y, c.schemaPath = l + Z, c.errSchemaPath = h + "/" + e.util.escapeFragment(M), c.errorPath = e.util.getPath(e.errorPath, M, e.opts.jsonPointers), c.dataPathArr[m] = e.util.toQuotedString(M);
                C = e.validate(c);
                if (c.baseId = A, e.util.varOccurences(C, g) < 2) {
                  C = e.util.varReplace(C, g, B);
                  var re = B;
                } else {
                  re = g;
                  a += " var " + g + " = " + B + "; ";
                }
                if (ee)
                  a += " " + C + " ";
                else {
                  if (q && q[M]) {
                    a += " if ( " + re + " === undefined ", Q && (a += " || ! Object.prototype.hasOwnProperty.call(" + d + ", '" + e.util.escapeQuotes(M) + "') "), a += ") { " + u + " = false; ";
                    V = e.errorPath, N = h;
                    var te, ae = e.util.escapeQuotes(M);
                    e.opts._errorDataPathProperty && (e.errorPath = e.util.getPath(V, M, e.opts.jsonPointers)), h = e.errSchemaPath + "/required", (te = te || []).push(a), a = "", false !== e.createErrors ? (a += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(h) + " , params: { missingProperty: '" + ae + "' } ", false !== e.opts.messages && (a += " , message: '", e.opts._errorDataPathProperty ? a += "is a required property" : a += "should have required property \\'" + ae + "\\'", a += "' "), e.opts.verbose && (a += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), a += " } ") : a += " {} ";
                    T = a;
                    a = te.pop(), !e.compositeRule && p ? e.async ? a += " throw new ValidationError([" + T + "]); " : a += " validate.errors = [" + T + "]; return false; " : a += " var err = " + T + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", h = N, e.errorPath = V, a += " } else { ";
                  } else
                    p ? (a += " if ( " + re + " === undefined ", Q && (a += " || ! Object.prototype.hasOwnProperty.call(" + d + ", '" + e.util.escapeQuotes(M) + "') "), a += ") { " + u + " = true; } else { ") : (a += " if (" + re + " !== undefined ", Q && (a += " &&   Object.prototype.hasOwnProperty.call(" + d + ", '" + e.util.escapeQuotes(M) + "') "), a += " ) { ");
                  a += " " + C + " } ";
                }
              }
              p && (a += " if (" + u + ") { ", P += "}");
            }
        }
        if (O.length) {
          var oe = O;
          if (oe)
            for (var se, ie = -1, le = oe.length - 1; ie < le; ) {
              Y = j[se = oe[ie += 1]];
              if (e.opts.strictKeywords ? "object" == typeof Y && Object.keys(Y).length > 0 || false === Y : e.util.schemaHasRules(Y, e.RULES.all)) {
                c.schema = Y, c.schemaPath = e.schemaPath + ".patternProperties" + e.util.getProperty(se), c.errSchemaPath = e.errSchemaPath + "/patternProperties/" + e.util.escapeFragment(se), a += Q ? " " + y + " = " + y + " || Object.keys(" + d + "); for (var " + f + "=0; " + f + "<" + y + ".length; " + f + "++) { var " + v + " = " + y + "[" + f + "]; " : " for (var " + v + " in " + d + ") { ", a += " if (" + e.usePattern(se) + ".test(" + v + ")) { ", c.errorPath = e.util.getPathExpr(e.errorPath, v, e.opts.jsonPointers);
                B = d + "[" + v + "]";
                c.dataPathArr[m] = v;
                C = e.validate(c);
                c.baseId = A, e.util.varOccurences(C, g) < 2 ? a += " " + e.util.varReplace(C, g, B) + " " : a += " var " + g + " = " + B + "; " + C + " ", p && (a += " if (!" + u + ") break; "), a += " } ", p && (a += " else " + u + " = true; "), a += " }  ", p && (a += " if (" + u + ") { ", P += "}");
              }
            }
        }
        return p && (a += " " + P + " if (" + n + " == errors) {"), a;
      };
    }, {}], "XxjR": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = function(r, e, a) {
        var t = " ", s = r.level, o = r.dataLevel, l = r.schema[e], i = r.schemaPath + r.util.getProperty(e), v = r.errSchemaPath + "/" + e, c = !r.opts.allErrors, p = "data" + (o || ""), m = "errs__" + s, h = r.util.copy(r);
        h.level++;
        var d = "valid" + h.level;
        if (t += "var " + m + " = errors;", r.opts.strictKeywords ? "object" == typeof l && Object.keys(l).length > 0 || false === l : r.util.schemaHasRules(l, r.RULES.all)) {
          h.schema = l, h.schemaPath = i, h.errSchemaPath = v;
          var u = "key" + s, n = "idx" + s, y = "i" + s, E = "' + " + u + " + '", P = "data" + (h.dataLevel = r.dataLevel + 1), f = "dataProperties" + s, R = r.opts.ownProperties, b = r.baseId;
          R && (t += " var " + f + " = undefined; "), t += R ? " " + f + " = " + f + " || Object.keys(" + p + "); for (var " + n + "=0; " + n + "<" + f + ".length; " + n + "++) { var " + u + " = " + f + "[" + n + "]; " : " for (var " + u + " in " + p + ") { ", t += " var startErrs" + s + " = errors; ";
          var g = u, k = r.compositeRule;
          r.compositeRule = h.compositeRule = true;
          var w = r.validate(h);
          h.baseId = b, r.util.varOccurences(w, P) < 2 ? t += " " + r.util.varReplace(w, P, g) + " " : t += " var " + P + " = " + g + "; " + w + " ", r.compositeRule = h.compositeRule = k, t += " if (!" + d + ") { for (var " + y + "=startErrs" + s + "; " + y + "<errors; " + y + "++) { vErrors[" + y + "].propertyName = " + u + "; }   var err =   ", false !== r.createErrors ? (t += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + r.errorPath + " , schemaPath: " + r.util.toQuotedString(v) + " , params: { propertyName: '" + E + "' } ", false !== r.opts.messages && (t += " , message: 'property name \\'" + E + "\\' is invalid' "), r.opts.verbose && (t += " , schema: validate.schema" + i + " , parentSchema: validate.schema" + r.schemaPath + " , data: " + p + " "), t += " } ") : t += " {} ", t += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !r.compositeRule && c && (r.async ? t += " throw new ValidationError(vErrors); " : t += " validate.errors = vErrors; return false; "), c && (t += " break; "), t += " } }";
        }
        return c && (t += "  if (" + m + " == errors) {"), t;
      };
    }, {}], "Dht1": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = function(r, e, a) {
        var t = " ", s = r.level, o = r.dataLevel, i = r.schema[e], h = r.schemaPath + r.util.getProperty(e), p = r.errSchemaPath + "/" + e, l = !r.opts.allErrors, d = "data" + (o || ""), u = "valid" + s, P = r.opts.$data && i && i.$data;
        P && (t += " var schema" + s + " = " + r.util.getData(i.$data, o, r.dataPathArr) + "; ");
        var n = "schema" + s;
        if (!P)
          if (i.length < r.opts.loopRequired && r.schema.properties && Object.keys(r.schema.properties).length) {
            var c = [], m = i;
            if (m)
              for (var v, y = -1, g = m.length - 1; y < g; ) {
                v = m[y += 1];
                var f = r.schema.properties[v];
                f && (r.opts.strictKeywords ? "object" == typeof f && Object.keys(f).length > 0 || false === f : r.util.schemaHasRules(f, r.RULES.all)) || (c[c.length] = v);
              }
          } else
            c = i;
        if (P || c.length) {
          var E = r.errorPath, q = P || c.length >= r.opts.loopRequired, w = r.opts.ownProperties;
          if (l)
            if (t += " var missing" + s + "; ", q) {
              P || (t += " var " + n + " = validate.schema" + h + "; ");
              var b = "' + " + (_ = "schema" + s + "[" + (D = "i" + s) + "]") + " + '";
              r.opts._errorDataPathProperty && (r.errorPath = r.util.getPathExpr(E, _, r.opts.jsonPointers)), t += " var " + u + " = true; ", P && (t += " if (schema" + s + " === undefined) " + u + " = true; else if (!Array.isArray(schema" + s + ")) " + u + " = false; else {"), t += " for (var " + D + " = 0; " + D + " < " + n + ".length; " + D + "++) { " + u + " = " + d + "[" + n + "[" + D + "]] !== undefined ", w && (t += " &&   Object.prototype.hasOwnProperty.call(" + d + ", " + n + "[" + D + "]) "), t += "; if (!" + u + ") break; } ", P && (t += "  }  "), t += "  if (!" + u + ") {   ", (Q = Q || []).push(t), t = "", false !== r.createErrors ? (t += " { keyword: 'required' , dataPath: (dataPath || '') + " + r.errorPath + " , schemaPath: " + r.util.toQuotedString(p) + " , params: { missingProperty: '" + b + "' } ", false !== r.opts.messages && (t += " , message: '", r.opts._errorDataPathProperty ? t += "is a required property" : t += "should have required property \\'" + b + "\\'", t += "' "), r.opts.verbose && (t += " , schema: validate.schema" + h + " , parentSchema: validate.schema" + r.schemaPath + " , data: " + d + " "), t += " } ") : t += " {} ";
              var S = t;
              t = Q.pop(), !r.compositeRule && l ? r.async ? t += " throw new ValidationError([" + S + "]); " : t += " validate.errors = [" + S + "]; return false; " : t += " var err = " + S + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", t += " } else { ";
            } else {
              t += " if ( ";
              var j = c;
              if (j)
                for (var D = -1, O = j.length - 1; D < O; ) {
                  R = j[D += 1], D && (t += " || "), t += " ( ( " + (L = d + ($ = r.util.getProperty(R))) + " === undefined ", w && (t += " || ! Object.prototype.hasOwnProperty.call(" + d + ", '" + r.util.escapeQuotes(R) + "') "), t += ") && (missing" + s + " = " + r.util.toQuotedString(r.opts.jsonPointers ? R : $) + ") ) ";
                }
              t += ") {  ";
              var Q;
              b = "' + " + (_ = "missing" + s) + " + '";
              r.opts._errorDataPathProperty && (r.errorPath = r.opts.jsonPointers ? r.util.getPathExpr(E, _, true) : E + " + " + _), (Q = Q || []).push(t), t = "", false !== r.createErrors ? (t += " { keyword: 'required' , dataPath: (dataPath || '') + " + r.errorPath + " , schemaPath: " + r.util.toQuotedString(p) + " , params: { missingProperty: '" + b + "' } ", false !== r.opts.messages && (t += " , message: '", r.opts._errorDataPathProperty ? t += "is a required property" : t += "should have required property \\'" + b + "\\'", t += "' "), r.opts.verbose && (t += " , schema: validate.schema" + h + " , parentSchema: validate.schema" + r.schemaPath + " , data: " + d + " "), t += " } ") : t += " {} ";
              S = t;
              t = Q.pop(), !r.compositeRule && l ? r.async ? t += " throw new ValidationError([" + S + "]); " : t += " validate.errors = [" + S + "]; return false; " : t += " var err = " + S + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", t += " } else { ";
            }
          else if (q) {
            P || (t += " var " + n + " = validate.schema" + h + "; ");
            var _;
            b = "' + " + (_ = "schema" + s + "[" + (D = "i" + s) + "]") + " + '";
            r.opts._errorDataPathProperty && (r.errorPath = r.util.getPathExpr(E, _, r.opts.jsonPointers)), P && (t += " if (" + n + " && !Array.isArray(" + n + ")) {  var err =   ", false !== r.createErrors ? (t += " { keyword: 'required' , dataPath: (dataPath || '') + " + r.errorPath + " , schemaPath: " + r.util.toQuotedString(p) + " , params: { missingProperty: '" + b + "' } ", false !== r.opts.messages && (t += " , message: '", r.opts._errorDataPathProperty ? t += "is a required property" : t += "should have required property \\'" + b + "\\'", t += "' "), r.opts.verbose && (t += " , schema: validate.schema" + h + " , parentSchema: validate.schema" + r.schemaPath + " , data: " + d + " "), t += " } ") : t += " {} ", t += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + n + " !== undefined) { "), t += " for (var " + D + " = 0; " + D + " < " + n + ".length; " + D + "++) { if (" + d + "[" + n + "[" + D + "]] === undefined ", w && (t += " || ! Object.prototype.hasOwnProperty.call(" + d + ", " + n + "[" + D + "]) "), t += ") {  var err =   ", false !== r.createErrors ? (t += " { keyword: 'required' , dataPath: (dataPath || '') + " + r.errorPath + " , schemaPath: " + r.util.toQuotedString(p) + " , params: { missingProperty: '" + b + "' } ", false !== r.opts.messages && (t += " , message: '", r.opts._errorDataPathProperty ? t += "is a required property" : t += "should have required property \\'" + b + "\\'", t += "' "), r.opts.verbose && (t += " , schema: validate.schema" + h + " , parentSchema: validate.schema" + r.schemaPath + " , data: " + d + " "), t += " } ") : t += " {} ", t += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ", P && (t += "  }  ");
          } else {
            var k = c;
            if (k)
              for (var R, A = -1, x = k.length - 1; A < x; ) {
                R = k[A += 1];
                var $ = r.util.getProperty(R), L = (b = r.util.escapeQuotes(R), d + $);
                r.opts._errorDataPathProperty && (r.errorPath = r.util.getPath(E, R, r.opts.jsonPointers)), t += " if ( " + L + " === undefined ", w && (t += " || ! Object.prototype.hasOwnProperty.call(" + d + ", '" + r.util.escapeQuotes(R) + "') "), t += ") {  var err =   ", false !== r.createErrors ? (t += " { keyword: 'required' , dataPath: (dataPath || '') + " + r.errorPath + " , schemaPath: " + r.util.toQuotedString(p) + " , params: { missingProperty: '" + b + "' } ", false !== r.opts.messages && (t += " , message: '", r.opts._errorDataPathProperty ? t += "is a required property" : t += "should have required property \\'" + b + "\\'", t += "' "), r.opts.verbose && (t += " , schema: validate.schema" + h + " , parentSchema: validate.schema" + r.schemaPath + " , data: " + d + " "), t += " } ") : t += " {} ", t += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
              }
          }
          r.errorPath = E;
        } else
          l && (t += " if (true) {");
        return t;
      };
    }, {}], "mmFQ": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = function(e, a, r) {
        var t, i = " ", s = e.level, o = e.dataLevel, m = e.schema[a], l = e.schemaPath + e.util.getProperty(a), c = e.errSchemaPath + "/" + a, u = !e.opts.allErrors, d = "data" + (o || ""), h = "valid" + s, n = e.opts.$data && m && m.$data;
        if (n ? (i += " var schema" + s + " = " + e.util.getData(m.$data, o, e.dataPathArr) + "; ", t = "schema" + s) : t = m, (m || n) && false !== e.opts.uniqueItems) {
          n && (i += " var " + h + "; if (" + t + " === false || " + t + " === undefined) " + h + " = true; else if (typeof " + t + " != 'boolean') " + h + " = false; else { "), i += " var i = " + d + ".length , " + h + " = true , j; if (i > 1) { ";
          var f = e.schema.items && e.schema.items.type, v = Array.isArray(f);
          if (!f || "object" == f || "array" == f || v && (f.indexOf("object") >= 0 || f.indexOf("array") >= 0))
            i += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + d + "[i], " + d + "[j])) { " + h + " = false; break outer; } } } ";
          else {
            i += " var itemIndices = {}, item; for (;i--;) { var item = " + d + "[i]; ";
            var p = "checkDataType" + (v ? "s" : "");
            i += " if (" + e.util[p](f, "item", e.opts.strictNumbers, true) + ") continue; ", v && (i += ` if (typeof item == 'string') item = '"' + item; `), i += " if (typeof itemIndices[item] == 'number') { " + h + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ";
          }
          i += " } ", n && (i += "  }  "), i += " if (!" + h + ") {   ";
          var y = y || [];
          y.push(i), i = "", false !== e.createErrors ? (i += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { i: i, j: j } ", false !== e.opts.messages && (i += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' "), e.opts.verbose && (i += " , schema:  ", i += n ? "validate.schema" + l : "" + m, i += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), i += " } ") : i += " {} ";
          var j = i;
          i = y.pop(), !e.compositeRule && u ? e.async ? i += " throw new ValidationError([" + j + "]); " : i += " validate.errors = [" + j + "]; return false; " : i += " var err = " + j + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", i += " } ", u && (i += " else { ");
        } else
          u && (i += " if (true) { ");
        return i;
      };
    }, {}], "Czyc": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = { $ref: require2("./ref"), allOf: require2("./allOf"), anyOf: require2("./anyOf"), $comment: require2("./comment"), const: require2("./const"), contains: require2("./contains"), dependencies: require2("./dependencies"), enum: require2("./enum"), format: require2("./format"), if: require2("./if"), items: require2("./items"), maximum: require2("./_limit"), minimum: require2("./_limit"), maxItems: require2("./_limitItems"), minItems: require2("./_limitItems"), maxLength: require2("./_limitLength"), minLength: require2("./_limitLength"), maxProperties: require2("./_limitProperties"), minProperties: require2("./_limitProperties"), multipleOf: require2("./multipleOf"), not: require2("./not"), oneOf: require2("./oneOf"), pattern: require2("./pattern"), properties: require2("./properties"), propertyNames: require2("./propertyNames"), required: require2("./required"), uniqueItems: require2("./uniqueItems"), validate: require2("./validate") };
    }, { "./ref": "a2na", "./allOf": "hRgn", "./anyOf": "lo6J", "./comment": "Kkzr", "./const": "U4sD", "./contains": "EypH", "./dependencies": "Cpp7", "./enum": "fqDY", "./format": "avoW", "./if": "JHQ3", "./items": "aiPb", "./_limit": "UJAl", "./_limitItems": "W8ih", "./_limitLength": "fZGX", "./_limitProperties": "JAEr", "./multipleOf": "oNPH", "./not": "mmjm", "./oneOf": "SSWF", "./pattern": "mGZS", "./properties": "jFnx", "./propertyNames": "XxjR", "./required": "Dht1", "./uniqueItems": "mmFQ", "./validate": "yhC1" }], "vBP0": [function(require2, module2, exports2) {
      "use strict";
      var e = require2("../dotjs"), t = require2("./util").toHash;
      module2.exports = function() {
        var n = [{ type: "number", rules: [{ maximum: ["exclusiveMaximum"] }, { minimum: ["exclusiveMinimum"] }, "multipleOf", "format"] }, { type: "string", rules: ["maxLength", "minLength", "pattern", "format"] }, { type: "array", rules: ["maxItems", "minItems", "items", "contains", "uniqueItems"] }, { type: "object", rules: ["maxProperties", "minProperties", "required", "dependencies", "propertyNames", { properties: ["additionalProperties", "patternProperties"] }] }, { rules: ["$ref", "const", "enum", "not", "anyOf", "oneOf", "allOf", "if"] }], r = ["type", "$comment"];
        return n.all = t(r), n.types = t(["number", "integer", "string", "array", "object", "boolean", "null"]), n.forEach(function(t2) {
          t2.rules = t2.rules.map(function(t3) {
            var i;
            if ("object" == typeof t3) {
              var o = Object.keys(t3)[0];
              i = t3[o], t3 = o, i.forEach(function(e2) {
                r.push(e2), n.all[e2] = true;
              });
            }
            return r.push(t3), n.all[t3] = { keyword: t3, code: e[t3], implements: i };
          }), n.all.$comment = { keyword: "$comment", code: e.$comment }, t2.type && (n.types[t2.type] = t2);
        }), n.keywords = t(r.concat(["$schema", "$id", "id", "$data", "$async", "title", "description", "default", "definitions", "examples", "readOnly", "writeOnly", "contentMediaType", "contentEncoding", "additionalItems", "then", "else"])), n.custom = {}, n;
      };
    }, { "../dotjs": "Czyc", "./util": "Q1F7" }], "BunE": [function(require2, module2, exports2) {
      "use strict";
      var e = ["multipleOf", "maximum", "exclusiveMaximum", "minimum", "exclusiveMinimum", "maxLength", "minLength", "pattern", "additionalItems", "maxItems", "minItems", "uniqueItems", "maxProperties", "minProperties", "required", "additionalProperties", "enum", "format", "const"];
      module2.exports = function(t, i) {
        for (var r = 0; r < i.length; r++) {
          t = JSON.parse(JSON.stringify(t));
          var m, a = i[r].split("/"), n = t;
          for (m = 1; m < a.length; m++)
            n = n[a[m]];
          for (m = 0; m < e.length; m++) {
            var s = e[m], o = n[s];
            o && (n[s] = { anyOf: [o, { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }] });
          }
        }
        return t;
      };
    }, {}], "mNRF": [function(require2, module2, exports2) {
      "use strict";
      var n = require2("./error_classes").MissingRef;
      function e(t, r, o) {
        var i = this;
        if ("function" != typeof this._opts.loadSchema)
          throw new Error("options.loadSchema should be a function");
        "function" == typeof r && (o = r, r = void 0);
        var a = c(t).then(function() {
          var e2 = i._addSchema(t, void 0, r);
          return e2.validate || (/* @__PURE__ */ __name(function e3(t2) {
            try {
              return i._compile(t2);
            } catch (a2) {
              if (a2 instanceof n)
                return (/* @__PURE__ */ __name(function o3(e4) {
                  var o4 = e4.missingSchema;
                  if (h(o4))
                    throw new Error("Schema " + o4 + " is loaded but " + e4.missingRef + " cannot be resolved");
                  var a3 = i._loadingSchemas[o4];
                  a3 || (a3 = i._loadingSchemas[o4] = i._opts.loadSchema(o4)).then(s, s);
                  return a3.then(function(n2) {
                    if (!h(o4))
                      return c(n2).then(function() {
                        h(o4) || i.addSchema(n2, o4, void 0, r);
                      });
                  }).then(function() {
                    return (/* @__PURE__ */ __name(function t3(o5) {
                      try {
                        return i._compile(o5);
                      } catch (e5) {
                        if (e5 instanceof n)
                          return a4(e5);
                        throw e5;
                      }
                      function a4(n2) {
                        var e5 = n2.missingSchema;
                        if (h2(e5))
                          throw new Error("Schema " + e5 + " is loaded but " + n2.missingRef + " cannot be resolved");
                        var a5 = i._loadingSchemas[e5];
                        return a5 || (a5 = i._loadingSchemas[e5] = i._opts.loadSchema(e5)).then(s2, s2), a5.then(function(n3) {
                          if (!h2(e5))
                            return c(n3).then(function() {
                              h2(e5) || i.addSchema(n3, e5, void 0, r);
                            });
                        }).then(function() {
                          return t3(o5);
                        });
                        function s2() {
                          delete i._loadingSchemas[e5];
                        }
                        __name(s2, "s");
                        function h2(n3) {
                          return i._refs[n3] || i._schemas[n3];
                        }
                        __name(h2, "h");
                      }
                      __name(a4, "a");
                    }, "t"))(t2);
                  });
                  function s() {
                    delete i._loadingSchemas[o4];
                  }
                  __name(s, "s");
                  function h(n2) {
                    return i._refs[n2] || i._schemas[n2];
                  }
                  __name(h, "h");
                }, "o"))(a2);
              throw a2;
            }
            function o2(n2) {
              var o3 = n2.missingSchema;
              if (h(o3))
                throw new Error("Schema " + o3 + " is loaded but " + n2.missingRef + " cannot be resolved");
              var a2 = i._loadingSchemas[o3];
              return a2 || (a2 = i._loadingSchemas[o3] = i._opts.loadSchema(o3)).then(s, s), a2.then(function(n3) {
                if (!h(o3))
                  return c(n3).then(function() {
                    h(o3) || i.addSchema(n3, o3, void 0, r);
                  });
              }).then(function() {
                return e3(t2);
              });
              function s() {
                delete i._loadingSchemas[o3];
              }
              __name(s, "s");
              function h(n3) {
                return i._refs[n3] || i._schemas[n3];
              }
              __name(h, "h");
            }
            __name(o2, "o");
          }, "e"))(e2);
        });
        return o && a.then(function(n2) {
          o(null, n2);
        }, o), a;
        function c(n2) {
          var t2 = n2.$schema;
          return t2 && !i.getSchema(t2) ? e.call(i, { $ref: t2 }, true) : Promise.resolve();
        }
        __name(c, "c");
      }
      __name(e, "e");
      module2.exports = e;
    }, { "./error_classes": "OtNE" }], "Mzku": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = function(a, r, e) {
        var t, s, o = " ", i = a.level, h = a.dataLevel, d = a.schema[r], l = a.schemaPath + a.util.getProperty(r), v = a.errSchemaPath + "/" + r, c = !a.opts.allErrors, n = "data" + (h || ""), m = "valid" + i, u = "errs__" + i, p = a.opts.$data && d && d.$data;
        p ? (o += " var schema" + i + " = " + a.util.getData(d.$data, h, a.dataPathArr) + "; ", s = "schema" + i) : s = d;
        var f, P, y, E, w, k = "definition" + i, g = this.definition, R = "";
        if (p && g.$data) {
          w = "keywordValidate" + i;
          var S = g.validateSchema;
          o += " var " + k + " = RULES.custom['" + r + "'].definition; var " + w + " = " + k + ".validate;";
        } else {
          if (!(E = a.useCustomRule(this, d, a.schema, a)))
            return;
          s = "validate.schema" + l, w = E.code, f = g.compile, P = g.inline, y = g.macro;
        }
        var b = w + ".errors", $ = "i" + i, A = "ruleErr" + i, D = g.async;
        if (D && !a.async)
          throw new Error("async keyword in sync schema");
        if (P || y || (o += b + " = null;"), o += "var " + u + " = errors;var " + m + ";", p && g.$data && (R += "}", o += " if (" + s + " === undefined) { " + m + " = true; } else { ", S && (R += "}", o += " " + m + " = " + k + ".validateSchema(" + s + "); if (" + m + ") { ")), P)
          g.statements ? o += " " + E.validate + " " : o += " " + m + " = " + E.validate + "; ";
        else if (y) {
          var V = a.util.copy(a);
          R = "";
          V.level++;
          var x = "valid" + V.level;
          V.schema = E.validate, V.schemaPath = "";
          var C = a.compositeRule;
          a.compositeRule = V.compositeRule = true;
          var L = a.validate(V).replace(/validate\.schema/g, w);
          a.compositeRule = V.compositeRule = C, o += " " + L;
        } else {
          (j = j || []).push(o), o = "", o += "  " + w + ".call( ", a.opts.passContext ? o += "this" : o += "self", f || false === g.schema ? o += " , " + n + " " : o += " , " + s + " , " + n + " , validate.schema" + a.schemaPath + " ", o += " , (dataPath || '')", '""' != a.errorPath && (o += " + " + a.errorPath);
          var Q = h ? "data" + (h - 1 || "") : "parentData", _ = h ? a.dataPathArr[h] : "parentDataProperty", U = o += " , " + Q + " , " + _ + " , rootData )  ";
          o = j.pop(), false === g.errors ? (o += " " + m + " = ", D && (o += "await "), o += U + "; ") : o += D ? " var " + (b = "customErrors" + i) + " = null; try { " + m + " = await " + U + "; } catch (e) { " + m + " = false; if (e instanceof ValidationError) " + b + " = e.errors; else throw e; } " : " " + b + " = null; " + m + " = " + U + "; ";
        }
        if (g.modifying && (o += " if (" + Q + ") " + n + " = " + Q + "[" + _ + "];"), o += "" + R, g.valid)
          c && (o += " if (true) { ");
        else {
          var j;
          o += " if ( ", void 0 === g.valid ? (o += " !", o += y ? "" + x : "" + m) : o += " " + !g.valid + " ", o += ") { ", t = this.keyword, (j = j || []).push(o), o = "", (j = j || []).push(o), o = "", false !== a.createErrors ? (o += " { keyword: '" + (t || "custom") + "' , dataPath: (dataPath || '') + " + a.errorPath + " , schemaPath: " + a.util.toQuotedString(v) + " , params: { keyword: '" + this.keyword + "' } ", false !== a.opts.messages && (o += ` , message: 'should pass "` + this.keyword + `" keyword validation' `), a.opts.verbose && (o += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + a.schemaPath + " , data: " + n + " "), o += " } ") : o += " {} ";
          var q = o;
          o = j.pop(), !a.compositeRule && c ? a.async ? o += " throw new ValidationError([" + q + "]); " : o += " validate.errors = [" + q + "]; return false; " : o += " var err = " + q + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          var z = o;
          o = j.pop(), P ? g.errors ? "full" != g.errors && (o += "  for (var " + $ + "=" + u + "; " + $ + "<errors; " + $ + "++) { var " + A + " = vErrors[" + $ + "]; if (" + A + ".dataPath === undefined) " + A + ".dataPath = (dataPath || '') + " + a.errorPath + "; if (" + A + ".schemaPath === undefined) { " + A + '.schemaPath = "' + v + '"; } ', a.opts.verbose && (o += " " + A + ".schema = " + s + "; " + A + ".data = " + n + "; "), o += " } ") : false === g.errors ? o += " " + z + " " : (o += " if (" + u + " == errors) { " + z + " } else {  for (var " + $ + "=" + u + "; " + $ + "<errors; " + $ + "++) { var " + A + " = vErrors[" + $ + "]; if (" + A + ".dataPath === undefined) " + A + ".dataPath = (dataPath || '') + " + a.errorPath + "; if (" + A + ".schemaPath === undefined) { " + A + '.schemaPath = "' + v + '"; } ', a.opts.verbose && (o += " " + A + ".schema = " + s + "; " + A + ".data = " + n + "; "), o += " } } ") : y ? (o += "   var err =   ", false !== a.createErrors ? (o += " { keyword: '" + (t || "custom") + "' , dataPath: (dataPath || '') + " + a.errorPath + " , schemaPath: " + a.util.toQuotedString(v) + " , params: { keyword: '" + this.keyword + "' } ", false !== a.opts.messages && (o += ` , message: 'should pass "` + this.keyword + `" keyword validation' `), a.opts.verbose && (o += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + a.schemaPath + " , data: " + n + " "), o += " } ") : o += " {} ", o += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !a.compositeRule && c && (a.async ? o += " throw new ValidationError(vErrors); " : o += " validate.errors = vErrors; return false; ")) : false === g.errors ? o += " " + z + " " : (o += " if (Array.isArray(" + b + ")) { if (vErrors === null) vErrors = " + b + "; else vErrors = vErrors.concat(" + b + "); errors = vErrors.length;  for (var " + $ + "=" + u + "; " + $ + "<errors; " + $ + "++) { var " + A + " = vErrors[" + $ + "]; if (" + A + ".dataPath === undefined) " + A + ".dataPath = (dataPath || '') + " + a.errorPath + ";  " + A + '.schemaPath = "' + v + '";  ', a.opts.verbose && (o += " " + A + ".schema = " + s + "; " + A + ".data = " + n + "; "), o += " } } else { " + z + " } "), o += " } ", c && (o += " else { ");
        }
        return o;
      };
    }, {}], "ve7q": [function(require2, module2, exports2) {
      module2.exports = { $schema: "http://json-schema.org/draft-07/schema#", $id: "http://json-schema.org/draft-07/schema#", title: "Core schema meta-schema", definitions: { schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } }, nonNegativeInteger: { type: "integer", minimum: 0 }, nonNegativeIntegerDefault0: { allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }] }, simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, uniqueItems: true, default: [] } }, type: ["object", "boolean"], properties: { $id: { type: "string", format: "uri-reference" }, $schema: { type: "string", format: "uri" }, $ref: { type: "string", format: "uri-reference" }, $comment: { type: "string" }, title: { type: "string" }, description: { type: "string" }, default: true, readOnly: { type: "boolean", default: false }, examples: { type: "array", items: true }, multipleOf: { type: "number", exclusiveMinimum: 0 }, maximum: { type: "number" }, exclusiveMaximum: { type: "number" }, minimum: { type: "number" }, exclusiveMinimum: { type: "number" }, maxLength: { $ref: "#/definitions/nonNegativeInteger" }, minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, pattern: { type: "string", format: "regex" }, additionalItems: { $ref: "#" }, items: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }], default: true }, maxItems: { $ref: "#/definitions/nonNegativeInteger" }, minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, uniqueItems: { type: "boolean", default: false }, contains: { $ref: "#" }, maxProperties: { $ref: "#/definitions/nonNegativeInteger" }, minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, required: { $ref: "#/definitions/stringArray" }, additionalProperties: { $ref: "#" }, definitions: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, properties: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $ref: "#" }, propertyNames: { format: "regex" }, default: {} }, dependencies: { type: "object", additionalProperties: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }] } }, propertyNames: { $ref: "#" }, const: true, enum: { type: "array", items: true, minItems: 1, uniqueItems: true }, type: { anyOf: [{ $ref: "#/definitions/simpleTypes" }, { type: "array", items: { $ref: "#/definitions/simpleTypes" }, minItems: 1, uniqueItems: true }] }, format: { type: "string" }, contentMediaType: { type: "string" }, contentEncoding: { type: "string" }, if: { $ref: "#" }, then: { $ref: "#" }, else: { $ref: "#" }, allOf: { $ref: "#/definitions/schemaArray" }, anyOf: { $ref: "#/definitions/schemaArray" }, oneOf: { $ref: "#/definitions/schemaArray" }, not: { $ref: "#" } }, default: true };
    }, {}], "GIYw": [function(require2, module2, exports2) {
      "use strict";
      var e = require2("./refs/json-schema-draft-07.json");
      module2.exports = { $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js", definitions: { simpleTypes: e.definitions.simpleTypes }, type: "object", dependencies: { schema: ["validate"], $data: ["validate"], statements: ["inline"], valid: { not: { required: ["macro"] } } }, properties: { type: e.properties.type, schema: { type: "boolean" }, statements: { type: "boolean" }, dependencies: { type: "array", items: { type: "string" } }, metaSchema: { type: "object" }, modifying: { type: "boolean" }, valid: { type: "boolean" }, $data: { type: "boolean" }, async: { type: "boolean" }, errors: { anyOf: [{ type: "boolean" }, { const: "full" }] } } };
    }, { "./refs/json-schema-draft-07.json": "ve7q" }], "UVv5": [function(require2, module2, exports2) {
      "use strict";
      var e = /^[a-z_$][a-z0-9_$-]*$/i, r = require2("./dotjs/custom"), t = require2("./definition_schema");
      function i(t2, i2) {
        var o2 = this.RULES;
        if (o2.keywords[t2])
          throw new Error("Keyword " + t2 + " is already defined");
        if (!e.test(t2))
          throw new Error("Keyword " + t2 + " is not a valid identifier");
        if (i2) {
          this.validateKeyword(i2, true);
          var a2 = i2.type;
          if (Array.isArray(a2))
            for (var s2 = 0; s2 < a2.length; s2++)
              d(t2, a2[s2], i2);
          else
            d(t2, a2, i2);
          var n = i2.metaSchema;
          n && (i2.$data && this._opts.$data && (n = { anyOf: [n, { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }] }), i2.validateSchema = this.compile(n, true));
        }
        function d(e2, t3, i3) {
          for (var a3, s3 = 0; s3 < o2.length; s3++) {
            var n2 = o2[s3];
            if (n2.type == t3) {
              a3 = n2;
              break;
            }
          }
          a3 || (a3 = { type: t3, rules: [] }, o2.push(a3));
          var d2 = { keyword: e2, definition: i3, custom: true, code: r, implements: i3.implements };
          a3.rules.push(d2), o2.custom[e2] = d2;
        }
        __name(d, "d");
        return o2.keywords[t2] = o2.all[t2] = true, this;
      }
      __name(i, "i");
      function o(e2) {
        var r2 = this.RULES.custom[e2];
        return r2 ? r2.definition : this.RULES.keywords[e2] || false;
      }
      __name(o, "o");
      function a(e2) {
        var r2 = this.RULES;
        delete r2.keywords[e2], delete r2.all[e2], delete r2.custom[e2];
        for (var t2 = 0; t2 < r2.length; t2++)
          for (var i2 = r2[t2].rules, o2 = 0; o2 < i2.length; o2++)
            if (i2[o2].keyword == e2) {
              i2.splice(o2, 1);
              break;
            }
        return this;
      }
      __name(a, "a");
      function s(e2, r2) {
        s.errors = null;
        var i2 = this._validateKeyword = this._validateKeyword || this.compile(t, true);
        if (i2(e2))
          return true;
        if (s.errors = i2.errors, r2)
          throw new Error("custom keyword definition is invalid: " + this.errorsText(i2.errors));
        return false;
      }
      __name(s, "s");
      module2.exports = { add: i, get: o, remove: a, validate: s };
    }, { "./dotjs/custom": "Mzku", "./definition_schema": "GIYw" }], "xbmT": [function(require2, module2, exports2) {
      module2.exports = { $schema: "http://json-schema.org/draft-07/schema#", $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", description: "Meta-schema for $data reference (JSON Schema extension proposal)", type: "object", required: ["$data"], properties: { $data: { type: "string", anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }] } }, additionalProperties: false };
    }, {}], "hi5j": [function(require2, module2, exports2) {
      "use strict";
      var e = require2("./compile"), t = require2("./compile/resolve"), r = require2("./cache"), a = require2("./compile/schema_obj"), i = require2("fast-json-stable-stringify"), s = require2("./compile/formats"), o = require2("./compile/rules"), h = require2("./data"), n = require2("./compile/util");
      module2.exports = p, p.prototype.validate = u, p.prototype.compile = v, p.prototype.addSchema = _, p.prototype.addMetaSchema = g, p.prototype.validateSchema = y, p.prototype.getSchema = S, p.prototype.removeSchema = q, p.prototype.addFormat = x, p.prototype.errorsText = k, p.prototype._addSchema = E, p.prototype._compile = I, p.prototype.compileAsync = require2("./compile/async");
      var c = require2("./keyword");
      p.prototype.addKeyword = c.add, p.prototype.getKeyword = c.get, p.prototype.removeKeyword = c.remove, p.prototype.validateKeyword = c.validate;
      var d = require2("./compile/error_classes");
      p.ValidationError = d.Validation, p.MissingRefError = d.MissingRef, p.$dataMetaSchema = h;
      var l = "http://json-schema.org/draft-07/schema", m = ["removeAdditional", "useDefaults", "coerceTypes", "strictDefaults"], f = ["/properties"];
      function p(e2) {
        if (!(this instanceof p))
          return new p(e2);
        e2 = this._opts = n.copy(e2) || {}, O(this), this._schemas = {}, this._refs = {}, this._fragments = {}, this._formats = s(e2.format), this._cache = e2.cache || new r(), this._loadingSchemas = {}, this._compilations = [], this.RULES = o(), this._getId = M(e2), e2.loopRequired = e2.loopRequired || 1 / 0, "property" == e2.errorDataPath && (e2._errorDataPathProperty = true), void 0 === e2.serialize && (e2.serialize = i), this._metaOpts = F(this), e2.formats && D(this), e2.keywords && P(this), A(this), "object" == typeof e2.meta && this.addMetaSchema(e2.meta), e2.nullable && this.addKeyword("nullable", { metaSchema: { type: "boolean" } }), V(this);
      }
      __name(p, "p");
      function u(e2, t2) {
        var r2;
        if ("string" == typeof e2) {
          if (!(r2 = this.getSchema(e2)))
            throw new Error('no schema with key or ref "' + e2 + '"');
        } else {
          var a2 = this._addSchema(e2);
          r2 = a2.validate || this._compile(a2);
        }
        var i2 = r2(t2);
        return true !== r2.$async && (this.errors = r2.errors), i2;
      }
      __name(u, "u");
      function v(e2, t2) {
        var r2 = this._addSchema(e2, void 0, t2);
        return r2.validate || this._compile(r2);
      }
      __name(v, "v");
      function _(e2, r2, a2, i2) {
        if (Array.isArray(e2)) {
          for (var s2 = 0; s2 < e2.length; s2++)
            this.addSchema(e2[s2], void 0, a2, i2);
          return this;
        }
        var o2 = this._getId(e2);
        if (void 0 !== o2 && "string" != typeof o2)
          throw new Error("schema id must be string");
        return T(this, r2 = t.normalizeId(r2 || o2)), this._schemas[r2] = this._addSchema(e2, a2, i2, true), this;
      }
      __name(_, "_");
      function g(e2, t2, r2) {
        return this.addSchema(e2, t2, r2, true), this;
      }
      __name(g, "g");
      function y(e2, t2) {
        var r2 = e2.$schema;
        if (void 0 !== r2 && "string" != typeof r2)
          throw new Error("$schema must be a string");
        if (!(r2 = r2 || this._opts.defaultMeta || w(this)))
          return this.logger.warn("meta-schema not available"), this.errors = null, true;
        var a2 = this.validate(r2, e2);
        if (!a2 && t2) {
          var i2 = "schema is invalid: " + this.errorsText();
          if ("log" != this._opts.validateSchema)
            throw new Error(i2);
          this.logger.error(i2);
        }
        return a2;
      }
      __name(y, "y");
      function w(e2) {
        var t2 = e2._opts.meta;
        return e2._opts.defaultMeta = "object" == typeof t2 ? e2._getId(t2) || t2 : e2.getSchema(l) ? l : void 0, e2._opts.defaultMeta;
      }
      __name(w, "w");
      function S(e2) {
        var t2 = $(this, e2);
        switch (typeof t2) {
          case "object":
            return t2.validate || this._compile(t2);
          case "string":
            return this.getSchema(t2);
          case "undefined":
            return b(this, e2);
        }
      }
      __name(S, "S");
      function b(r2, i2) {
        var s2 = t.schema.call(r2, { schema: {} }, i2);
        if (s2) {
          var o2 = s2.schema, h2 = s2.root, n2 = s2.baseId, c2 = e.call(r2, o2, h2, void 0, n2);
          return r2._fragments[i2] = new a({ ref: i2, fragment: true, schema: o2, root: h2, baseId: n2, validate: c2 }), c2;
        }
      }
      __name(b, "b");
      function $(e2, r2) {
        return r2 = t.normalizeId(r2), e2._schemas[r2] || e2._refs[r2] || e2._fragments[r2];
      }
      __name($, "$");
      function q(e2) {
        if (e2 instanceof RegExp)
          return j(this, this._schemas, e2), j(this, this._refs, e2), this;
        switch (typeof e2) {
          case "undefined":
            return j(this, this._schemas), j(this, this._refs), this._cache.clear(), this;
          case "string":
            var r2 = $(this, e2);
            return r2 && this._cache.del(r2.cacheKey), delete this._schemas[e2], delete this._refs[e2], this;
          case "object":
            var a2 = this._opts.serialize, i2 = a2 ? a2(e2) : e2;
            this._cache.del(i2);
            var s2 = this._getId(e2);
            s2 && (s2 = t.normalizeId(s2), delete this._schemas[s2], delete this._refs[s2]);
        }
        return this;
      }
      __name(q, "q");
      function j(e2, t2, r2) {
        for (var a2 in t2) {
          var i2 = t2[a2];
          i2.meta || r2 && !r2.test(a2) || (e2._cache.del(i2.cacheKey), delete t2[a2]);
        }
      }
      __name(j, "j");
      function E(e2, r2, i2, s2) {
        if ("object" != typeof e2 && "boolean" != typeof e2)
          throw new Error("schema should be object or boolean");
        var o2 = this._opts.serialize, h2 = o2 ? o2(e2) : e2, n2 = this._cache.get(h2);
        if (n2)
          return n2;
        s2 = s2 || false !== this._opts.addUsedSchema;
        var c2 = t.normalizeId(this._getId(e2));
        c2 && s2 && T(this, c2);
        var d2, l2 = false !== this._opts.validateSchema && !r2;
        l2 && !(d2 = c2 && c2 == t.normalizeId(e2.$schema)) && this.validateSchema(e2, true);
        var m2 = t.ids.call(this, e2), f2 = new a({ id: c2, schema: e2, localRefs: m2, cacheKey: h2, meta: i2 });
        return "#" != c2[0] && s2 && (this._refs[c2] = f2), this._cache.put(h2, f2), l2 && d2 && this.validateSchema(e2, true), f2;
      }
      __name(E, "E");
      function I(t2, r2) {
        if (t2.compiling)
          return t2.validate = s2, s2.schema = t2.schema, s2.errors = null, s2.root = r2 || s2, true === t2.schema.$async && (s2.$async = true), s2;
        var a2, i2;
        t2.compiling = true, t2.meta && (a2 = this._opts, this._opts = this._metaOpts);
        try {
          i2 = e.call(this, t2.schema, r2, t2.localRefs);
        } catch (o2) {
          throw delete t2.validate, o2;
        } finally {
          t2.compiling = false, t2.meta && (this._opts = a2);
        }
        return t2.validate = i2, t2.refs = i2.refs, t2.refVal = i2.refVal, t2.root = i2.root, i2;
        function s2() {
          var e2 = t2.validate, r3 = e2.apply(this, arguments);
          return s2.errors = e2.errors, r3;
        }
        __name(s2, "s");
      }
      __name(I, "I");
      function M(e2) {
        switch (e2.schemaId) {
          case "auto":
            return R;
          case "id":
            return z;
          default:
            return K;
        }
      }
      __name(M, "M");
      function z(e2) {
        return e2.$id && this.logger.warn("schema $id ignored", e2.$id), e2.id;
      }
      __name(z, "z");
      function K(e2) {
        return e2.id && this.logger.warn("schema id ignored", e2.id), e2.$id;
      }
      __name(K, "K");
      function R(e2) {
        if (e2.$id && e2.id && e2.$id != e2.id)
          throw new Error("schema $id is different from id");
        return e2.$id || e2.id;
      }
      __name(R, "R");
      function k(e2, t2) {
        if (!(e2 = e2 || this.errors))
          return "No errors";
        for (var r2 = void 0 === (t2 = t2 || {}).separator ? ", " : t2.separator, a2 = void 0 === t2.dataVar ? "data" : t2.dataVar, i2 = "", s2 = 0; s2 < e2.length; s2++) {
          var o2 = e2[s2];
          o2 && (i2 += a2 + o2.dataPath + " " + o2.message + r2);
        }
        return i2.slice(0, -r2.length);
      }
      __name(k, "k");
      function x(e2, t2) {
        return "string" == typeof t2 && (t2 = new RegExp(t2)), this._formats[e2] = t2, this;
      }
      __name(x, "x");
      function A(e2) {
        var t2;
        if (e2._opts.$data && (t2 = require2("./refs/data.json"), e2.addMetaSchema(t2, t2.$id, true)), false !== e2._opts.meta) {
          var r2 = require2("./refs/json-schema-draft-07.json");
          e2._opts.$data && (r2 = h(r2, f)), e2.addMetaSchema(r2, l, true), e2._refs["http://json-schema.org/schema"] = l;
        }
      }
      __name(A, "A");
      function V(e2) {
        var t2 = e2._opts.schemas;
        if (t2)
          if (Array.isArray(t2))
            e2.addSchema(t2);
          else
            for (var r2 in t2)
              e2.addSchema(t2[r2], r2);
      }
      __name(V, "V");
      function D(e2) {
        for (var t2 in e2._opts.formats) {
          var r2 = e2._opts.formats[t2];
          e2.addFormat(t2, r2);
        }
      }
      __name(D, "D");
      function P(e2) {
        for (var t2 in e2._opts.keywords) {
          var r2 = e2._opts.keywords[t2];
          e2.addKeyword(t2, r2);
        }
      }
      __name(P, "P");
      function T(e2, t2) {
        if (e2._schemas[t2] || e2._refs[t2])
          throw new Error('schema with key or id "' + t2 + '" already exists');
      }
      __name(T, "T");
      function F(e2) {
        for (var t2 = n.copy(e2._opts), r2 = 0; r2 < m.length; r2++)
          delete t2[m[r2]];
        return t2;
      }
      __name(F, "F");
      function O(e2) {
        var t2 = e2._opts.logger;
        if (false === t2)
          e2.logger = { log: U, warn: U, error: U };
        else {
          if (void 0 === t2 && (t2 = console), !("object" == typeof t2 && t2.log && t2.warn && t2.error))
            throw new Error("logger must implement log, warn and error methods");
          e2.logger = t2;
        }
      }
      __name(O, "O");
      function U() {
      }
      __name(U, "U");
    }, { "./compile": "qdYs", "./compile/resolve": "w10T", "./cache": "fXCy", "./compile/schema_obj": "HHLG", "fast-json-stable-stringify": "Xb3N", "./compile/formats": "dfAH", "./compile/rules": "vBP0", "./data": "BunE", "./compile/util": "Q1F7", "./compile/async": "mNRF", "./keyword": "UVv5", "./compile/error_classes": "OtNE", "./refs/data.json": "xbmT", "./refs/json-schema-draft-07.json": "ve7q" }], "dhP9": [function(require2, module2, exports2) {
      var Buffer2 = require2("buffer").Buffer;
      var r = require2("buffer").Buffer, e = { Object, Array, Function, Number, String, Date, RegExp };
      module2.exports = /* @__PURE__ */ __name(function n(t) {
        return void 0 !== r && (e.Buffer = r), "undefined" != typeof Promise && (e.Promise = Promise), n.definition = { compile: function(r2) {
          if ("string" == typeof r2) {
            var e2 = i(r2);
            return function(r3) {
              return r3 instanceof e2;
            };
          }
          var n2 = r2.map(i);
          return function(r3) {
            for (var e3 = 0; e3 < n2.length; e3++)
              if (r3 instanceof n2[e3])
                return true;
            return false;
          };
        }, CONSTRUCTORS: e, metaSchema: { anyOf: [{ type: "string" }, { type: "array", items: { type: "string" } }] } }, t.addKeyword("instanceof", n.definition), t;
        function i(r2) {
          var n2 = e[r2];
          if (n2)
            return n2;
          throw new Error('invalid "instanceof" keyword value ' + r2);
        }
        __name(i, "i");
      }, "n");
    }, { "buffer": "dskh" }], "uBCt": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = /* @__PURE__ */ __name(function e(n) {
        return e.definition = { type: "number", macro: function(e2, n2) {
          var r = e2[0], i = e2[1], o = n2.exclusiveRange;
          return function(e3, n3, r2) {
            if (void 0 !== r2 && "boolean" != typeof r2)
              throw new Error("Invalid schema for exclusiveRange keyword, should be boolean");
            if (e3 > n3 || r2 && e3 == n3)
              throw new Error("There are no numbers in range");
          }(r, i, o), true === o ? { exclusiveMinimum: r, exclusiveMaximum: i } : { minimum: r, maximum: i };
        }, metaSchema: { type: "array", minItems: 2, maxItems: 2, items: { type: "number" } } }, n.addKeyword("range", e.definition), n.addKeyword("exclusiveRange"), n;
      }, "e");
    }, {}], "AtCq": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = /* @__PURE__ */ __name(function e(t) {
        return e.definition = { type: "string", inline: function(e2, t2, r) {
          return function() {
            try {
              if ("object" == typeof r)
                return new RegExp(r.pattern, r.flags);
              var e3 = r.match(/^\/(.*)\/([gimuy]*)$/);
              if (e3)
                return new RegExp(e3[1], e3[2]);
              throw new Error("cannot parse string into RegExp");
            } catch (t3) {
              throw console.error("regular expression", r, "is invalid"), t3;
            }
          }() + ".test(data" + (e2.dataLevel || "") + ")";
        }, metaSchema: { type: ["string", "object"], properties: { pattern: { type: "string" }, flags: { type: "string" } }, required: ["pattern"], additionalProperties: false } }, t.addKeyword("regexp", e.definition), t;
      }, "e");
    }, {}], "yoml": [function(require2, module2, exports2) {
      "use strict";
      var e = ["undefined", "string", "number", "object", "function", "boolean", "symbol"];
      module2.exports = /* @__PURE__ */ __name(function t(n) {
        return t.definition = { inline: function(e2, t2, n2) {
          var i = "data" + (e2.dataLevel || "");
          return "string" == typeof n2 ? "typeof " + i + ' == "' + n2 + '"' : (n2 = "validate.schema" + e2.schemaPath + "." + t2) + ".indexOf(typeof " + i + ") >= 0";
        }, metaSchema: { anyOf: [{ type: "string", enum: e }, { type: "array", items: { type: "string", enum: e } }] } }, n.addKeyword("typeof", t.definition), n;
      }, "t");
    }, {}], "FbE8": [function(require2, module2, exports2) {
      "use strict";
      var t = {}, n = { timestamp: function() {
        return Date.now();
      }, datetime: function() {
        return new Date().toISOString();
      }, date: function() {
        return new Date().toISOString().slice(0, 10);
      }, time: function() {
        return new Date().toISOString().slice(11);
      }, random: function() {
        return Math.random();
      }, randomint: function(t2) {
        var n2 = t2 && t2.max || 2;
        return function() {
          return Math.floor(Math.random() * n2);
        };
      }, seq: function(n2) {
        var r = n2 && n2.name || "";
        return t[r] = t[r] || 0, function() {
          return t[r]++;
        };
      } };
      module2.exports = /* @__PURE__ */ __name(function t2(r) {
        return t2.definition = { compile: function(t3, n2, r2) {
          var i = {};
          for (var o in t3) {
            var u = t3[o], a = e("string" == typeof u ? u : u.func);
            i[o] = a.length ? a(u.args) : a;
          }
          return r2.opts.useDefaults && !r2.compositeRule ? function(n3) {
            for (var e2 in t3)
              void 0 !== n3[e2] && ("empty" != r2.opts.useDefaults || null !== n3[e2] && "" !== n3[e2]) || (n3[e2] = i[e2]());
            return true;
          } : function() {
            return true;
          };
        }, DEFAULTS: n, metaSchema: { type: "object", additionalProperties: { type: ["string", "object"], additionalProperties: false, required: ["func", "args"], properties: { func: { type: "string" }, args: { type: "object" } } } } }, r.addKeyword("dynamicDefaults", t2.definition), r;
        function e(t3) {
          var r2 = n[t3];
          if (r2)
            return r2;
          throw new Error('invalid "dynamicDefaults" keyword property value: ' + t3);
        }
        __name(e, "e");
      }, "t");
    }, {}], "CJDR": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = /* @__PURE__ */ __name(function e(r) {
        return e.definition = { type: "object", macro: function(e2, r2) {
          if (!e2)
            return true;
          var t = Object.keys(r2.properties);
          return 0 == t.length || { required: t };
        }, metaSchema: { type: "boolean" }, dependencies: ["properties"] }, r.addKeyword("allRequired", e.definition), r;
      }, "e");
    }, {}], "n1DR": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = /* @__PURE__ */ __name(function e(t) {
        return e.definition = { type: "object", macro: function(e2) {
          return 0 == e2.length || (1 == e2.length ? { required: e2 } : { anyOf: e2.map(function(e3) {
            return { required: [e3] };
          }) });
        }, metaSchema: { type: "array", items: { type: "string" } } }, t.addKeyword("anyRequired", e.definition), t;
      }, "e");
    }, {}], "XrCF": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = /* @__PURE__ */ __name(function e(t) {
        return e.definition = { type: "object", macro: function(e2) {
          return 0 == e2.length || (1 == e2.length ? { required: e2 } : { oneOf: e2.map(function(e3) {
            return { required: [e3] };
          }) });
        }, metaSchema: { type: "array", items: { type: "string" } } }, t.addKeyword("oneRequired", e.definition), t;
      }, "e");
    }, {}], "MFGI": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = /* @__PURE__ */ __name(function e(t) {
        return e.definition = { type: "object", macro: function(e2) {
          return 0 == e2.length || (1 == e2.length ? { not: { required: e2 } } : { not: { anyOf: e2.map(function(e3) {
            return { required: [e3] };
          }) } });
        }, metaSchema: { type: "array", items: { type: "string" } } }, t.addKeyword("prohibited", e.definition), t;
      }, "e");
    }, {}], "m7Ap": [function(require2, module2, exports2) {
      "use strict";
      var e = ["number", "integer", "string", "boolean", "null"];
      function r(r2, t) {
        return r2.map(function(r3) {
          var n = t.items && t.items.properties, i = n && n[r3] && n[r3].type;
          return Array.isArray(i) ? i.indexOf("object") < 0 && i.indexOf("array") < 0 : e.indexOf(i) >= 0;
        });
      }
      __name(r, "r");
      module2.exports = /* @__PURE__ */ __name(function e2(t) {
        return e2.definition = { type: "array", compile: function(e3, t2, n) {
          var i = n.util.equal, o = r(e3, t2);
          return function(r2) {
            if (r2.length > 1)
              for (var t3 = 0; t3 < e3.length; t3++) {
                var n2, f = e3[t3];
                if (o[t3]) {
                  var a = {};
                  for (n2 = r2.length; n2--; )
                    if (r2[n2] && "object" == typeof r2[n2]) {
                      var u = r2[n2][f];
                      if (!u || "object" != typeof u) {
                        if ("string" == typeof u && (u = '"' + u), a[u])
                          return false;
                        a[u] = true;
                      }
                    }
                } else
                  for (n2 = r2.length; n2--; )
                    if (r2[n2] && "object" == typeof r2[n2]) {
                      for (var p = n2; p--; )
                        if (r2[p] && "object" == typeof r2[p] && i(r2[n2][f], r2[p][f]))
                          return false;
                    }
              }
            return true;
          };
        }, metaSchema: { type: "array", items: { type: "string" } } }, t.addKeyword("uniqueItemProperties", e2.definition), t;
      }, "e");
    }, {}], "R4Fp": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = { metaSchemaRef: t };
      var e = "http://json-schema.org/draft-07/schema";
      function t(t2) {
        var a = t2._opts.defaultMeta;
        return "string" == typeof a ? { $ref: a } : t2.getSchema(e) ? { $ref: e } : (console.warn("meta schema not defined"), {});
      }
      __name(t, "t");
    }, {}], "kIuQ": [function(require2, module2, exports2) {
      "use strict";
      var e = require2("./_util");
      function r(e2, r2) {
        for (var i = e2.split("/"), o = {}, n = o, a = 1; a < i.length; a++) {
          var p = i[a], s = a == i.length - 1;
          p = t(p);
          var u = n.properties = {}, f = void 0;
          if (/[0-9]+/.test(p)) {
            var c = +p;
            for (f = n.items = []; c--; )
              f.push({});
          }
          n = s ? r2 : {}, u[p] = n, f && f.push(n);
        }
        return o;
      }
      __name(r, "r");
      function t(e2) {
        return e2.replace(/~1/g, "/").replace(/~0/g, "~");
      }
      __name(t, "t");
      module2.exports = /* @__PURE__ */ __name(function t2(i) {
        return t2.definition = { type: "object", macro: function(e2) {
          var t3 = [];
          for (var i2 in e2)
            t3.push(r(i2, e2[i2]));
          return { allOf: t3 };
        }, metaSchema: { type: "object", propertyNames: { type: "string", format: "json-pointer" }, additionalProperties: e.metaSchemaRef(i) } }, i.addKeyword("deepProperties", t2.definition), i;
      }, "t");
    }, { "./_util": "R4Fp" }], "KB8y": [function(require2, module2, exports2) {
      "use strict";
      function e(e2, t2) {
        var r2 = "data" + (t2 || "");
        if (!e2)
          return r2;
        for (var n2 = r2, o = e2.split("/"), u = 1; u < o.length; u++) {
          n2 += " && " + (r2 += i(a(o[u])));
        }
        return n2;
      }
      __name(e, "e");
      module2.exports = /* @__PURE__ */ __name(function t2(r2) {
        return t2.definition = { type: "object", inline: function(t3, r3, n2) {
          for (var i2 = "", a2 = 0; a2 < n2.length; a2++)
            a2 && (i2 += " && "), i2 += "(" + e(n2[a2], t3.dataLevel) + " !== undefined)";
          return i2;
        }, metaSchema: { type: "array", items: { type: "string", format: "json-pointer" } } }, r2.addKeyword("deepRequired", t2.definition), r2;
      }, "t");
      var t = /^[a-z$_][a-z$_0-9]*$/i, r = /^[0-9]+$/, n = /'|\\/g;
      function i(e2) {
        return r.test(e2) ? "[" + e2 + "]" : t.test(e2) ? "." + e2 : "['" + e2.replace(n, "\\$&") + "']";
      }
      __name(i, "i");
      function a(e2) {
        return e2.replace(/~1/g, "/").replace(/~0/g, "~");
      }
      __name(a, "a");
    }, {}], "KeB4": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = function(e, a, r) {
        var t = " ", s = e.level, o = e.dataLevel, i = e.schema[a], l = e.schemaPath + e.util.getProperty(a), u = e.errSchemaPath + "/" + a, d = !e.opts.allErrors, m = "data" + (o || ""), f = "valid" + s;
        if (t += "var " + f + " = undefined;", false === e.opts.format)
          return t += " " + f + " = true; ";
        var n = e.schema.format, h = e.opts.$data && n.$data, c = "";
        if (h) {
          t += " var " + (v = "format" + s) + " = formats[" + e.util.getData(n.$data, o, e.dataPathArr) + "] , " + (p = "compare" + s) + " = " + v + " && " + v + ".compare;";
        } else {
          var v;
          if (!(v = e.formats[n]) || !v.compare)
            return t += "  " + f + " = true; ";
          var p = "formats" + e.util.getProperty(n) + ".compare";
        }
        var g, P = "formatMaximum" == a, E = "formatExclusive" + (P ? "Maximum" : "Minimum"), x = e.schema[E], y = e.opts.$data && x && x.$data, S = P ? "<" : ">", $ = "result" + s, Q = e.opts.$data && i && i.$data;
        if (Q ? (t += " var schema" + s + " = " + e.util.getData(i.$data, o, e.dataPathArr) + "; ", g = "schema" + s) : g = i, y) {
          var b = e.util.getData(x.$data, o, e.dataPathArr), w = "exclusive" + s, A = "' + " + (M = "op" + s) + " + '";
          t += " var schemaExcl" + s + " = " + b + "; ", t += " if (typeof " + (b = "schemaExcl" + s) + " != 'boolean' && " + b + " !== undefined) { " + f + " = false; ";
          var D = E;
          (k = k || []).push(t), t = "", false !== e.createErrors ? (t += " { keyword: '" + (D || "_formatExclusiveLimit") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: {} ", false !== e.opts.messages && (t += " , message: '" + E + " should be boolean' "), e.opts.verbose && (t += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + m + " "), t += " } ") : t += " {} ";
          var L = t;
          t = k.pop(), !e.compositeRule && d ? e.async ? t += " throw new ValidationError([" + L + "]); " : t += " validate.errors = [" + L + "]; return false; " : t += " var err = " + L + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", t += " }  ", d && (c += "}", t += " else { "), Q && (t += " if (" + g + " === undefined) " + f + " = true; else if (typeof " + g + " != 'string') " + f + " = false; else { ", c += "}"), h && (t += " if (!" + p + ") " + f + " = true; else { ", c += "}"), t += " var " + $ + " = " + p + "(" + m + ",  ", t += Q ? "" + g : "" + e.util.toQuotedString(i), t += " ); if (" + $ + " === undefined) " + f + " = false; var " + w + " = " + b + " === true; if (" + f + " === undefined) { " + f + " = " + w + " ? " + $ + " " + S + " 0 : " + $ + " " + S + "= 0; } if (!" + f + ") var op" + s + " = " + w + " ? '" + S + "' : '" + S + "=';";
        } else {
          A = S;
          (w = true === x) || (A += "=");
          var M = "'" + A + "'";
          Q && (t += " if (" + g + " === undefined) " + f + " = true; else if (typeof " + g + " != 'string') " + f + " = false; else { ", c += "}"), h && (t += " if (!" + p + ") " + f + " = true; else { ", c += "}"), t += " var " + $ + " = " + p + "(" + m + ",  ", t += Q ? "" + g : "" + e.util.toQuotedString(i), t += " ); if (" + $ + " === undefined) " + f + " = false; if (" + f + " === undefined) " + f + " = " + $ + " " + S, w || (t += "="), t += " 0;";
        }
        t += c + "if (!" + f + ") { ";
        var k;
        D = a;
        (k = k || []).push(t), t = "", false !== e.createErrors ? (t += " { keyword: '" + (D || "_formatLimit") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { comparison: " + M + ", limit:  ", t += Q ? "" + g : "" + e.util.toQuotedString(i), t += " , exclusive: " + w + " } ", false !== e.opts.messages && (t += " , message: 'should be " + A + ' "', t += Q ? "' + " + g + " + '" : "" + e.util.escapeQuotes(i), t += `"' `), e.opts.verbose && (t += " , schema:  ", t += Q ? "validate.schema" + l : "" + e.util.toQuotedString(i), t += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + m + " "), t += " } ") : t += " {} ";
        L = t;
        return t = k.pop(), !e.compositeRule && d ? e.async ? t += " throw new ValidationError([" + L + "]); " : t += " validate.errors = [" + L + "]; return false; " : t += " var err = " + L + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", t += "}";
      };
    }, {}], "mYD7": [function(require2, module2, exports2) {
      "use strict";
      var t = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d:\d\d)?$/i, e = /t|\s/i, i = { date: n, time: o, "date-time": d }, r = { type: "object", required: ["$data"], properties: { $data: { type: "string", anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }] } }, additionalProperties: false };
      function a(t2) {
        var e2 = t2._formats;
        for (var r2 in i) {
          var a2 = e2[r2];
          ("object" != typeof a2 || a2 instanceof RegExp || !a2.validate) && (a2 = e2[r2] = { validate: a2 }), a2.compare || (a2.compare = i[r2]);
        }
      }
      __name(a, "a");
      function n(t2, e2) {
        if (t2 && e2)
          return t2 > e2 ? 1 : t2 < e2 ? -1 : t2 === e2 ? 0 : void 0;
      }
      __name(n, "n");
      function o(e2, i2) {
        if (e2 && i2 && (e2 = e2.match(t), i2 = i2.match(t), e2 && i2))
          return (e2 = e2[1] + e2[2] + e2[3] + (e2[4] || "")) > (i2 = i2[1] + i2[2] + i2[3] + (i2[4] || "")) ? 1 : e2 < i2 ? -1 : e2 === i2 ? 0 : void 0;
      }
      __name(o, "o");
      function d(t2, i2) {
        if (t2 && i2) {
          t2 = t2.split(e), i2 = i2.split(e);
          var r2 = n(t2[0], i2[0]);
          if (void 0 !== r2)
            return r2 || o(t2[1], i2[1]);
        }
      }
      __name(d, "d");
      module2.exports = function(t2) {
        var e2 = "format" + t2;
        return /* @__PURE__ */ __name(function i2(n2) {
          return i2.definition = { type: "string", inline: require2("./dotjs/_formatLimit"), statements: true, errors: "full", dependencies: ["format"], metaSchema: { anyOf: [{ type: "string" }, r] } }, n2.addKeyword(e2, i2.definition), n2.addKeyword("formatExclusive" + t2, { dependencies: ["format" + t2], metaSchema: { anyOf: [{ type: "boolean" }, r] } }), a(n2), n2;
        }, "i");
      };
    }, { "./dotjs/_formatLimit": "KeB4" }], "J927": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = require2("./_formatLimit")("Minimum");
    }, { "./_formatLimit": "mYD7" }], "dgLz": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = require2("./_formatLimit")("Maximum");
    }, { "./_formatLimit": "mYD7" }], "OTUE": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = function(e, r, a) {
        var t = " ", s = e.level, o = e.dataLevel, h = e.schema[r], i = e.schemaPath + e.util.getProperty(r), l = e.errSchemaPath + "/" + r, v = !e.opts.allErrors, n = "data" + (o || ""), d = "valid" + s, p = "key" + s, c = "idx" + s, u = "patternMatched" + s, m = "dataProperties" + s, P = "", f = e.opts.ownProperties;
        t += "var " + d + " = true;", f && (t += " var " + m + " = undefined;");
        var g = h;
        if (g)
          for (var y, E = -1, k = g.length - 1; E < k; ) {
            y = g[E += 1], t += " var " + u + " = false;  ", t += f ? " " + m + " = " + m + " || Object.keys(" + n + "); for (var " + c + "=0; " + c + "<" + m + ".length; " + c + "++) { var " + p + " = " + m + "[" + c + "]; " : " for (var " + p + " in " + n + ") { ", t += " " + u + " = " + e.usePattern(y) + ".test(" + p + "); if (" + u + ") break; } ";
            var b = e.util.escapeQuotes(y);
            t += " if (!" + u + ") { " + d + " = false;  var err =   ", false !== e.createErrors ? (t += " { keyword: 'patternRequired' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(l) + " , params: { missingPattern: '" + b + "' } ", false !== e.opts.messages && (t += " , message: 'should have property matching pattern \\'" + b + "\\'' "), e.opts.verbose && (t += " , schema: validate.schema" + i + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + n + " "), t += " } ") : t += " {} ", t += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; }   ", v && (P += "}", t += " else { ");
          }
        return t += "" + P;
      };
    }, {}], "u2zM": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = /* @__PURE__ */ __name(function e(t) {
        return e.definition = { type: "object", inline: require2("./dotjs/patternRequired"), statements: true, errors: "full", metaSchema: { type: "array", items: { type: "string", format: "regex" }, uniqueItems: true } }, t.addKeyword("patternRequired", e.definition), t;
      }, "e");
    }, { "./dotjs/patternRequired": "OTUE" }], "mlCb": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = function(e, r, a) {
        var s = " ", t = e.level, o = e.dataLevel, h = e.schema[r], l = e.schemaPath + e.util.getProperty(r), i = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, v = "data" + (o || ""), n = "valid" + t, d = "errs__" + t, m = e.util.copy(e), p = "";
        m.level++;
        var u, f = "valid" + m.level, P = "ifPassed" + e.level, E = m.baseId;
        s += "var " + P + ";";
        var w = h;
        if (w)
          for (var y, b = -1, g = w.length - 1; b < g; ) {
            if (y = w[b += 1], b && !u && (s += " if (!" + P + ") { ", p += "}"), y.if && (e.opts.strictKeywords ? "object" == typeof y.if && Object.keys(y.if).length > 0 : e.util.schemaHasRules(y.if, e.RULES.all))) {
              s += " var " + d + " = errors;   ";
              var R = e.compositeRule;
              if (e.compositeRule = m.compositeRule = true, m.createErrors = false, m.schema = y.if, m.schemaPath = l + "[" + b + "].if", m.errSchemaPath = i + "/" + b + "/if", s += "  " + e.validate(m) + " ", m.baseId = E, m.createErrors = true, e.compositeRule = m.compositeRule = R, s += " " + P + " = " + f + "; if (" + P + ") {  ", "boolean" == typeof y.then) {
                if (false === y.then) {
                  (I = I || []).push(s), s = "", false !== e.createErrors ? (s += " { keyword: 'switch' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(i) + " , params: { caseIndex: " + b + " } ", false !== e.opts.messages && (s += ` , message: 'should pass "switch" keyword validation' `), e.opts.verbose && (s += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + v + " "), s += " } ") : s += " {} ";
                  var S = s;
                  s = I.pop(), !e.compositeRule && c ? e.async ? s += " throw new ValidationError([" + S + "]); " : s += " validate.errors = [" + S + "]; return false; " : s += " var err = " + S + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                }
                s += " var " + f + " = " + y.then + "; ";
              } else
                m.schema = y.then, m.schemaPath = l + "[" + b + "].then", m.errSchemaPath = i + "/" + b + "/then", s += "  " + e.validate(m) + " ", m.baseId = E;
              s += "  } else {  errors = " + d + "; if (vErrors !== null) { if (" + d + ") vErrors.length = " + d + "; else vErrors = null; } } ";
            } else if (s += " " + P + " = true;  ", "boolean" == typeof y.then) {
              if (false === y.then) {
                var I;
                (I = I || []).push(s), s = "", false !== e.createErrors ? (s += " { keyword: 'switch' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(i) + " , params: { caseIndex: " + b + " } ", false !== e.opts.messages && (s += ` , message: 'should pass "switch" keyword validation' `), e.opts.verbose && (s += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + v + " "), s += " } ") : s += " {} ";
                S = s;
                s = I.pop(), !e.compositeRule && c ? e.async ? s += " throw new ValidationError([" + S + "]); " : s += " validate.errors = [" + S + "]; return false; " : s += " var err = " + S + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
              s += " var " + f + " = " + y.then + "; ";
            } else
              m.schema = y.then, m.schemaPath = l + "[" + b + "].then", m.errSchemaPath = i + "/" + b + "/then", s += "  " + e.validate(m) + " ", m.baseId = E;
            u = y.continue;
          }
        return s += p + "var " + n + " = " + f + ";";
      };
    }, {}], "KC2b": [function(require2, module2, exports2) {
      "use strict";
      var e = require2("./_util");
      module2.exports = /* @__PURE__ */ __name(function i(t) {
        if (!t.RULES.keywords.switch || !t.RULES.keywords.if) {
          var r = e.metaSchemaRef(t);
          return i.definition = { inline: require2("./dotjs/switch"), statements: true, errors: "full", metaSchema: { type: "array", items: { required: ["then"], properties: { if: r, then: { anyOf: [{ type: "boolean" }, r] }, continue: { type: "boolean" } }, additionalProperties: false, dependencies: { continue: ["if"] } } } }, t.addKeyword("switch", i.definition), t;
        }
      }, "i");
    }, { "./_util": "R4Fp", "./dotjs/switch": "mlCb" }], "mwue": [function(require2, module2, exports2) {
      "use strict";
      var e = require2("./_util");
      module2.exports = /* @__PURE__ */ __name(function r(t) {
        if (!t._opts.$data)
          return console.warn("keyword select requires $data option"), t;
        var a = e.metaSchemaRef(t), n = [];
        return r.definition = { validate: /* @__PURE__ */ __name(function e2(r2, t2, a2) {
          if (void 0 === a2.selectCases)
            throw new Error('keyword "selectCases" is absent');
          var n2 = o(a2, false), i2 = n2.cases[r2];
          if (void 0 === i2 && (i2 = n2.default), "boolean" == typeof i2)
            return i2;
          var s = i2(t2);
          return s || (e2.errors = i2.errors), s;
        }, "e"), $data: true, metaSchema: { type: ["string", "number", "boolean", "null"] } }, t.addKeyword("select", r.definition), t.addKeyword("selectCases", { compile: function(e2, r2) {
          var t2 = o(r2);
          for (var a2 in e2)
            t2.cases[a2] = i(e2[a2]);
          return function() {
            return true;
          };
        }, valid: true, metaSchema: { type: "object", additionalProperties: a } }), t.addKeyword("selectDefault", { compile: function(e2, r2) {
          return o(r2).default = i(e2), function() {
            return true;
          };
        }, valid: true, metaSchema: a }), t;
        function o(e2, r2) {
          var t2;
          return n.some(function(r3) {
            if (r3.parentSchema === e2)
              return t2 = r3, true;
          }), t2 || false === r2 || (t2 = { parentSchema: e2, cases: {}, default: true }, n.push(t2)), t2;
        }
        __name(o, "o");
        function i(e2) {
          return "boolean" == typeof e2 ? e2 : t.compile(e2);
        }
        __name(i, "i");
      }, "r");
    }, { "./_util": "R4Fp" }], "selR": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = /* @__PURE__ */ __name(function e(r) {
        var n = { trimLeft: function(e2) {
          return e2.replace(/^[\s]+/, "");
        }, trimRight: function(e2) {
          return e2.replace(/[\s]+$/, "");
        }, trim: function(e2) {
          return e2.trim();
        }, toLowerCase: function(e2) {
          return e2.toLowerCase();
        }, toUpperCase: function(e2) {
          return e2.toUpperCase();
        }, toEnumCase: function(e2, r2) {
          return r2.hash[t(e2)] || e2;
        } };
        return e.definition = { type: "string", errors: false, modifying: true, valid: true, compile: function(e2, r2) {
          var i;
          if (-1 !== e2.indexOf("toEnumCase")) {
            if (i = { hash: {} }, !r2.enum)
              throw new Error('Missing enum. To use `transform:["toEnumCase"]`, `enum:[...]` is required.');
            for (var o = r2.enum.length; o--; o) {
              var u = r2.enum[o];
              if ("string" == typeof u) {
                var s = t(u);
                if (i.hash[s])
                  throw new Error('Invalid enum uniqueness. To use `transform:["toEnumCase"]`, all values must be unique when case insensitive.');
                i.hash[s] = u;
              }
            }
          }
          return function(r3, t2, o2, u2) {
            if (o2) {
              for (var s2 = 0, a = e2.length; s2 < a; s2++)
                r3 = n[e2[s2]](r3, i);
              o2[u2] = r3;
            }
          };
        }, metaSchema: { type: "array", items: { type: "string", enum: ["trimLeft", "trimRight", "trim", "toLowerCase", "toUpperCase", "toEnumCase"] } } }, r.addKeyword("transform", e.definition), r;
        function t(e2) {
          return e2.toLowerCase();
        }
        __name(t, "t");
      }, "e");
    }, {}], "KP4Q": [function(require2, module2, exports2) {
      "use strict";
      module2.exports = { instanceof: require2("./instanceof"), range: require2("./range"), regexp: require2("./regexp"), typeof: require2("./typeof"), dynamicDefaults: require2("./dynamicDefaults"), allRequired: require2("./allRequired"), anyRequired: require2("./anyRequired"), oneRequired: require2("./oneRequired"), prohibited: require2("./prohibited"), uniqueItemProperties: require2("./uniqueItemProperties"), deepProperties: require2("./deepProperties"), deepRequired: require2("./deepRequired"), formatMinimum: require2("./formatMinimum"), formatMaximum: require2("./formatMaximum"), patternRequired: require2("./patternRequired"), switch: require2("./switch"), select: require2("./select"), transform: require2("./transform") };
    }, { "./instanceof": "dhP9", "./range": "uBCt", "./regexp": "AtCq", "./typeof": "yoml", "./dynamicDefaults": "FbE8", "./allRequired": "CJDR", "./anyRequired": "n1DR", "./oneRequired": "XrCF", "./prohibited": "MFGI", "./uniqueItemProperties": "m7Ap", "./deepProperties": "kIuQ", "./deepRequired": "KB8y", "./formatMinimum": "J927", "./formatMaximum": "dgLz", "./patternRequired": "u2zM", "./switch": "KC2b", "./select": "mwue", "./transform": "selR" }], "n1A8": [function(require2, module2, exports2) {
      "use strict";
      var r = require2("./keywords");
      function e(e2, t) {
        if (Array.isArray(t)) {
          for (var o = 0; o < t.length; o++)
            n(t[o])(e2);
          return e2;
        }
        if (t)
          return n(t)(e2), e2;
        for (t in r)
          n(t)(e2);
        return e2;
      }
      __name(e, "e");
      function n(e2) {
        var n2 = r[e2];
        if (!n2)
          throw new Error("Unknown keyword " + e2);
        return n2;
      }
      __name(n, "n");
      module2.exports = e, e.get = n;
    }, { "./keywords": "KP4Q" }], "STvH": [function(require2, module2, exports2) {
      "use strict";
      function r(r2) {
        if ("undefined" == typeof Symbol || null == r2[Symbol.iterator]) {
          if (Array.isArray(r2) || (r2 = n(r2))) {
            var t2 = 0, e2 = /* @__PURE__ */ __name(function() {
            }, "e");
            return { s: e2, n: function() {
              return t2 >= r2.length ? { done: true } : { done: false, value: r2[t2++] };
            }, e: function(r3) {
              throw r3;
            }, f: e2 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var o2, a2, i2 = true, u2 = false;
        return { s: function() {
          o2 = r2[Symbol.iterator]();
        }, n: function() {
          var r3 = o2.next();
          return i2 = r3.done, r3;
        }, e: function(r3) {
          u2 = true, a2 = r3;
        }, f: function() {
          try {
            i2 || null == o2.return || o2.return();
          } finally {
            if (u2)
              throw a2;
          }
        } };
      }
      __name(r, "r");
      function t(r2) {
        return a(r2) || o(r2) || n(r2) || e();
      }
      __name(t, "t");
      function e() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      __name(e, "e");
      function n(r2, t2) {
        if (r2) {
          if ("string" == typeof r2)
            return i(r2, t2);
          var e2 = Object.prototype.toString.call(r2).slice(8, -1);
          return "Object" === e2 && r2.constructor && (e2 = r2.constructor.name), "Map" === e2 || "Set" === e2 ? Array.from(e2) : "Arguments" === e2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e2) ? i(r2, t2) : void 0;
        }
      }
      __name(n, "n");
      function o(r2) {
        if ("undefined" != typeof Symbol && Symbol.iterator in Object(r2))
          return Array.from(r2);
      }
      __name(o, "o");
      function a(r2) {
        if (Array.isArray(r2))
          return i(r2);
      }
      __name(a, "a");
      function i(r2, t2) {
        (null == t2 || t2 > r2.length) && (t2 = r2.length);
        for (var e2 = 0, n2 = new Array(t2); e2 < t2; e2++)
          n2[e2] = r2[e2];
        return n2;
      }
      __name(i, "i");
      Object.defineProperty(exports2, "__esModule", { value: true }), exports2.validate = y, Object.defineProperty(exports2, "ValidationError", { enumerable: true, get: function() {
        return c.default;
      } });
      var u = f(require2("./keywords/absolutePath")), c = f(require2("./ValidationError"));
      function f(r2) {
        return r2 && r2.__esModule ? r2 : { default: r2 };
      }
      __name(f, "f");
      var l = require2("ajv"), d = require2("ajv-keywords"), s = new l({ allErrors: true, verbose: true, $data: true });
      function y(r2, e2, n2) {
        var o2 = [];
        if (Array.isArray(e2) ? ((o2 = Array.from(e2, function(t2) {
          return h(r2, t2);
        })).forEach(function(r3, t2) {
          r3.forEach(/* @__PURE__ */ __name(function r4(e3) {
            e3.dataPath = "[".concat(t2, "]").concat(e3.dataPath), e3.children && e3.children.forEach(r4);
          }, "r"));
        }), o2 = o2.reduce(function(r3, e3) {
          return r3.push.apply(r3, t(e3)), r3;
        }, [])) : o2 = h(r2, e2), o2.length > 0)
          throw new c.default(o2, r2, n2);
      }
      __name(y, "y");
      function h(r2, t2) {
        var e2 = s.compile(r2);
        return e2(t2) ? [] : e2.errors ? m(e2.errors) : [];
      }
      __name(h, "h");
      function m(t2) {
        var e2, n2 = [], o2 = r(t2);
        try {
          var a2 = /* @__PURE__ */ __name(function() {
            var r2 = e2.value, t3 = r2.dataPath, o3 = [];
            n2 = n2.filter(function(r3) {
              return !r3.dataPath.includes(t3) || (r3.children && (o3 = o3.concat(r3.children.slice(0))), r3.children = void 0, o3.push(r3), false);
            }), o3.length && (r2.children = o3), n2.push(r2);
          }, "a");
          for (o2.s(); !(e2 = o2.n()).done; )
            a2();
        } catch (i2) {
          o2.e(i2);
        } finally {
          o2.f();
        }
        return n2;
      }
      __name(m, "m");
      d(s, ["instanceof", "formatMinimum", "formatMaximum", "patternRequired"]), (0, u.default)(s);
    }, { "./keywords/absolutePath": "iIhC", "./ValidationError": "ySUA", "ajv": "hi5j", "ajv-keywords": "n1A8" }], "pA46": [function(require2, module2, exports2) {
      "use strict";
      var a = require2("./validate"), r = a.validate, i = a.ValidationError;
      module2.exports = { validate: r, ValidationError: i };
    }, { "./validate": "STvH" }], "t7hQ": [function(require2, module2, exports2) {
      function r(r2, n2) {
        return i(r2) || o(r2, n2) || e(r2, n2) || t();
      }
      __name(r, "r");
      function t() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      __name(t, "t");
      function e(r2, t2) {
        if (r2) {
          if ("string" == typeof r2)
            return n(r2, t2);
          var e2 = Object.prototype.toString.call(r2).slice(8, -1);
          return "Object" === e2 && r2.constructor && (e2 = r2.constructor.name), "Map" === e2 || "Set" === e2 ? Array.from(e2) : "Arguments" === e2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e2) ? n(r2, t2) : void 0;
        }
      }
      __name(e, "e");
      function n(r2, t2) {
        (null == t2 || t2 > r2.length) && (t2 = r2.length);
        for (var e2 = 0, n2 = new Array(t2); e2 < t2; e2++)
          n2[e2] = r2[e2];
        return n2;
      }
      __name(n, "n");
      function o(r2, t2) {
        if ("undefined" != typeof Symbol && Symbol.iterator in Object(r2)) {
          var e2 = [], n2 = true, o2 = false, i2 = void 0;
          try {
            for (var a2, u2 = r2[Symbol.iterator](); !(n2 = (a2 = u2.next()).done) && (e2.push(a2.value), !t2 || e2.length !== t2); n2 = true)
              ;
          } catch (l2) {
            o2 = true, i2 = l2;
          } finally {
            try {
              n2 || null == u2.return || u2.return();
            } finally {
              if (o2)
                throw i2;
            }
          }
          return e2;
        }
      }
      __name(o, "o");
      function i(r2) {
        if (Array.isArray(r2))
          return r2;
      }
      __name(i, "i");
      var a = require2("schema-utils"), u = a.validate;
      function l(r2, t2) {
        u(t2, r2);
      }
      __name(l, "l");
      function c(t2, e2) {
        for (var n2 = {}, o2 = 0, i2 = Object.entries(e2); o2 < i2.length; o2++) {
          var a2 = r(i2[o2], 2), u2 = a2[0], l2 = a2[1];
          n2[u2] = t2[u2], void 0 === n2[u2] && (n2[u2] = l2.default), l2.process && (n2[u2] = l2.process(n2[u2]));
        }
        return n2;
      }
      __name(c, "c");
      module2.exports = { validateOptions: l, processOptions: c };
    }, { "schema-utils": "pA46" }], "uYXM": [function(require2, module2, exports2) {
      module2.exports = { type: "object", properties: { filerDir: { type: "string" }, shimsDir: { type: "string" }, shimFs: { type: "boolean" }, shimPath: { type: "boolean" }, fsProvider: { type: "string" }, fsProviderDir: { type: "string" } } };
    }, {}], "qUtu": [function(require2, module2, exports2) {
      var process2 = require2("process");
      var e = require2("process"), r = require2("path"), s = "<rootDir>", o = e.cwd();
      module2.exports = { filerDir: { process: function(e2) {
        return e2 ? r.resolve(e2.replace(s, o)) : r.join(o, "node_modules", "filer");
      } }, shimsDir: { process: function(e2) {
        return e2 ? r.resolve(e2.replace(s, o)) : r.join(o, "node_modules", "filer", "shims");
      } }, fsProviderDir: { process: function(e2) {
        return e2 ? r.resolve(e2.replace(s, o)) : r.join(o, "node_modules", "filer", "shims", "providers");
      } }, shimFs: { default: true }, shimPath: { default: true }, fsProvider: { default: "default" } };
    }, { "path": "UUq2", "process": "pBGv" }], "Ge14": [function(require2, module2, exports2) {
      function e(e2, r2) {
        if (!(e2 instanceof r2))
          throw new TypeError("Cannot call a class as a function");
      }
      __name(e, "e");
      function r(e2, r2) {
        for (var i2 = 0; i2 < r2.length; i2++) {
          var o2 = r2[i2];
          o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, o2.key, o2);
        }
      }
      __name(r, "r");
      function i(e2, i2, o2) {
        return i2 && r(e2.prototype, i2), o2 && r(e2, o2), e2;
      }
      __name(i, "i");
      var o = require2("path"), s = require2("./utils"), t = "filer-webpack-plugin", n = require2("./schema"), a = require2("./processors");
      module2.exports = function() {
        function r2() {
          var i2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          e(this, r2), s.validateOptions(i2, n), this.options = s.processOptions(i2, a);
        }
        __name(r2, "r");
        return i(r2, [{ key: "apply", value: function(e2) {
          var r3 = this;
          e2.hooks.normalModuleFactory.tap(t, function(e3) {
            e3.hooks.resolve.tap(t, function(e4) {
              if ("fsProvider" === e4.request && e4.context === r3.options.shimsDir)
                return r3.resolveFsProvider(e4);
              if (!e4.context.startsWith(r3.options.filerDir))
                switch (e4.request) {
                  case "fs":
                    if (!r3.options.shimFs)
                      return;
                    return r3.applyFsShim(e4);
                  case "path":
                    if (!r3.options.shimPath)
                      return;
                    return r3.applyPathShim(e4);
                  default:
                    return;
                }
            });
          });
        } }, { key: "resolveFsProvider", value: function(e2) {
          switch (this.options.fsProvider) {
            case "default":
              e2.request = o.join(this.options.fsProviderDir, "default.js");
              break;
            case "indexeddb":
              e2.request = o.join(this.options.fsProviderDir, "indexeddb.js");
              break;
            case "memory":
              e2.request = o.join(this.options.fsProviderDir, "memory.js");
              break;
            case "custom":
              e2.request = o.join(this.options.fsProviderDir, "custom.js");
              break;
            default:
              throw new Error(["Invalid option for fsProvider.", "fsProvider must be one of 'default', 'indexeddb', 'memory' or 'custom'.", "If using a custom fsProvider, you must also provide the fsProviderDir option."].join(" "));
          }
        } }, { key: "applyFsShim", value: function(e2) {
          e2.request = o.join(this.options.shimsDir, "fs.js");
        } }, { key: "applyPathShim", value: function(e2) {
          e2.request = o.join(this.options.shimsDir, "path.js");
        } }]), r2;
      }();
    }, { "path": "UUq2", "./utils": "t7hQ", "./schema": "uYXM", "./processors": "qUtu" }], "Focm": [function(require2, module2, exports2) {
      var Buffer2 = require2("buffer").Buffer;
      var e = require2("buffer").Buffer, r = null, l = null;
      module2.exports = l = { FileSystem: require2("./filesystem/interface.js"), Buffer: e, Path: require2("./path.js"), path: require2("./path.js"), Errors: require2("./errors.js"), Shell: require2("./shell/shell.js"), FilerWebpackPlugin: require2("./webpack-plugin") }, Object.defineProperty(l, "fs", { enumerable: true, get: function() {
        return r || (r = new l.FileSystem()), r;
      } });
    }, { "./filesystem/interface.js": "GMi4", "./path.js": "UzoP", "./errors.js": "p8GN", "./shell/shell.js": "D1Ra", "./webpack-plugin": "Ge14", "buffer": "dskh" }] }, {}, ["Focm"], "Filer");
  }
});

// node_modules/web-ifc/web-ifc-api.js
var __defProp2 = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = /* @__PURE__ */ __name((obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value, "__defNormalProp");
var __spreadValues = /* @__PURE__ */ __name((a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp2.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
}, "__spreadValues");
var __require2 = /* @__PURE__ */ __name((x) => {
  if (typeof __require !== "undefined")
    return __require(x);
  throw new Error('Dynamic require of "' + x + '" is not supported');
}, "__require");
var __commonJS2 = /* @__PURE__ */ __name((cb, mod) => /* @__PURE__ */ __name(function __require22() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
}, "__require2"), "__commonJS");
var __async = /* @__PURE__ */ __name((__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = /* @__PURE__ */ __name((value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }, "fulfilled");
    var rejected = /* @__PURE__ */ __name((value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }, "rejected");
    var step = /* @__PURE__ */ __name((x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected), "step");
    step((generator = generator.apply(__this, __arguments)).next());
  });
}, "__async");
var require_crypto = __commonJS2({
  "(disabled):crypto"() {
  }
});
var require_web_ifc_mt = __commonJS2({
  "dist/web-ifc-mt.js"(exports, module) {
    var WebIFCWasm2 = function() {
      var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
      if (typeof __filename !== "undefined")
        _scriptDir = _scriptDir || __filename;
      return function(WebIFCWasm3) {
        WebIFCWasm3 = WebIFCWasm3 || {};
        function GROWABLE_HEAP_I8() {
          if (wasmMemory.buffer != buffer) {
            updateGlobalBufferAndViews(wasmMemory.buffer);
          }
          return HEAP8;
        }
        __name(GROWABLE_HEAP_I8, "GROWABLE_HEAP_I8");
        function GROWABLE_HEAP_U8() {
          if (wasmMemory.buffer != buffer) {
            updateGlobalBufferAndViews(wasmMemory.buffer);
          }
          return HEAPU8;
        }
        __name(GROWABLE_HEAP_U8, "GROWABLE_HEAP_U8");
        function GROWABLE_HEAP_I16() {
          if (wasmMemory.buffer != buffer) {
            updateGlobalBufferAndViews(wasmMemory.buffer);
          }
          return HEAP16;
        }
        __name(GROWABLE_HEAP_I16, "GROWABLE_HEAP_I16");
        function GROWABLE_HEAP_U16() {
          if (wasmMemory.buffer != buffer) {
            updateGlobalBufferAndViews(wasmMemory.buffer);
          }
          return HEAPU16;
        }
        __name(GROWABLE_HEAP_U16, "GROWABLE_HEAP_U16");
        function GROWABLE_HEAP_I32() {
          if (wasmMemory.buffer != buffer) {
            updateGlobalBufferAndViews(wasmMemory.buffer);
          }
          return HEAP32;
        }
        __name(GROWABLE_HEAP_I32, "GROWABLE_HEAP_I32");
        function GROWABLE_HEAP_U32() {
          if (wasmMemory.buffer != buffer) {
            updateGlobalBufferAndViews(wasmMemory.buffer);
          }
          return HEAPU32;
        }
        __name(GROWABLE_HEAP_U32, "GROWABLE_HEAP_U32");
        function GROWABLE_HEAP_F32() {
          if (wasmMemory.buffer != buffer) {
            updateGlobalBufferAndViews(wasmMemory.buffer);
          }
          return HEAPF32;
        }
        __name(GROWABLE_HEAP_F32, "GROWABLE_HEAP_F32");
        function GROWABLE_HEAP_F64() {
          if (wasmMemory.buffer != buffer) {
            updateGlobalBufferAndViews(wasmMemory.buffer);
          }
          return HEAPF64;
        }
        __name(GROWABLE_HEAP_F64, "GROWABLE_HEAP_F64");
        var Module = typeof WebIFCWasm3 !== "undefined" ? WebIFCWasm3 : {};
        var readyPromiseResolve, readyPromiseReject;
        Module["ready"] = new Promise(function(resolve, reject) {
          readyPromiseResolve = resolve;
          readyPromiseReject = reject;
        });
        var moduleOverrides = {};
        var key;
        for (key in Module) {
          if (Module.hasOwnProperty(key)) {
            moduleOverrides[key] = Module[key];
          }
        }
        var arguments_ = [];
        var thisProgram = "./this.program";
        var quit_ = /* @__PURE__ */ __name(function(status, toThrow) {
          throw toThrow;
        }, "quit_");
        var ENVIRONMENT_IS_WEB = typeof window === "object";
        var ENVIRONMENT_IS_WORKER = typeof importScripts === "function";
        var ENVIRONMENT_IS_NODE = typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node === "string";
        var ENVIRONMENT_IS_PTHREAD = Module["ENVIRONMENT_IS_PTHREAD"] || false;
        var scriptDirectory = "";
        function locateFile(path) {
          if (Module["locateFile"]) {
            return Module["locateFile"](path, scriptDirectory);
          }
          return scriptDirectory + path;
        }
        __name(locateFile, "locateFile");
        var read_, readAsync, readBinary, setWindowTitle;
        var nodeFS;
        var nodePath;
        if (ENVIRONMENT_IS_NODE) {
          if (ENVIRONMENT_IS_WORKER) {
            scriptDirectory = __require2("path").dirname(scriptDirectory) + "/";
          } else {
            scriptDirectory = __dirname + "/";
          }
          read_ = /* @__PURE__ */ __name(function shell_read(filename, binary) {
            if (!nodeFS)
              nodeFS = __require2("fs");
            if (!nodePath)
              nodePath = __require2("path");
            filename = nodePath["normalize"](filename);
            return nodeFS["readFileSync"](filename, binary ? null : "utf8");
          }, "shell_read");
          readBinary = /* @__PURE__ */ __name(function readBinary2(filename) {
            var ret = read_(filename, true);
            if (!ret.buffer) {
              ret = new Uint8Array(ret);
            }
            assert(ret.buffer);
            return ret;
          }, "readBinary2");
          readAsync = /* @__PURE__ */ __name(function readAsync2(filename, onload, onerror) {
            if (!nodeFS)
              nodeFS = __require2("fs");
            if (!nodePath)
              nodePath = __require2("path");
            filename = nodePath["normalize"](filename);
            nodeFS["readFile"](filename, function(err2, data) {
              if (err2)
                onerror(err2);
              else
                onload(data.buffer);
            });
          }, "readAsync2");
          if (process["argv"].length > 1) {
            thisProgram = process["argv"][1].replace(/\\/g, "/");
          }
          arguments_ = process["argv"].slice(2);
          process["on"]("uncaughtException", function(ex) {
            if (!(ex instanceof ExitStatus)) {
              throw ex;
            }
          });
          process["on"]("unhandledRejection", abort);
          quit_ = /* @__PURE__ */ __name(function(status, toThrow) {
            if (keepRuntimeAlive()) {
              process["exitCode"] = status;
              throw toThrow;
            }
            process["exit"](status);
          }, "quit_");
          Module["inspect"] = function() {
            return "[Emscripten Module object]";
          };
          var nodeWorkerThreads;
          try {
            nodeWorkerThreads = __require2("worker_threads");
          } catch (e) {
            console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?');
            throw e;
          }
          global.Worker = nodeWorkerThreads.Worker;
        } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
          if (ENVIRONMENT_IS_WORKER) {
            scriptDirectory = self.location.href;
          } else if (typeof document !== "undefined" && document.currentScript) {
            scriptDirectory = document.currentScript.src;
          }
          if (_scriptDir) {
            scriptDirectory = _scriptDir;
          }
          if (scriptDirectory.indexOf("blob:") !== 0) {
            scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1);
          } else {
            scriptDirectory = "";
          }
          if (ENVIRONMENT_IS_NODE) {
            read_ = /* @__PURE__ */ __name(function shell_read(filename, binary) {
              if (!nodeFS)
                nodeFS = __require2("fs");
              if (!nodePath)
                nodePath = __require2("path");
              filename = nodePath["normalize"](filename);
              return nodeFS["readFileSync"](filename, binary ? null : "utf8");
            }, "shell_read");
            readBinary = /* @__PURE__ */ __name(function readBinary2(filename) {
              var ret = read_(filename, true);
              if (!ret.buffer) {
                ret = new Uint8Array(ret);
              }
              assert(ret.buffer);
              return ret;
            }, "readBinary2");
            readAsync = /* @__PURE__ */ __name(function readAsync2(filename, onload, onerror) {
              if (!nodeFS)
                nodeFS = __require2("fs");
              if (!nodePath)
                nodePath = __require2("path");
              filename = nodePath["normalize"](filename);
              nodeFS["readFile"](filename, function(err2, data) {
                if (err2)
                  onerror(err2);
                else
                  onload(data.buffer);
              });
            }, "readAsync2");
          } else {
            read_ = /* @__PURE__ */ __name(function(url) {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, false);
              xhr.send(null);
              return xhr.responseText;
            }, "read_");
            if (ENVIRONMENT_IS_WORKER) {
              readBinary = /* @__PURE__ */ __name(function(url) {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url, false);
                xhr.responseType = "arraybuffer";
                xhr.send(null);
                return new Uint8Array(xhr.response);
              }, "readBinary");
            }
            readAsync = /* @__PURE__ */ __name(function(url, onload, onerror) {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, true);
              xhr.responseType = "arraybuffer";
              xhr.onload = function() {
                if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                  onload(xhr.response);
                  return;
                }
                onerror();
              };
              xhr.onerror = onerror;
              xhr.send(null);
            }, "readAsync");
          }
          setWindowTitle = /* @__PURE__ */ __name(function(title) {
            document.title = title;
          }, "setWindowTitle");
        } else {
        }
        if (ENVIRONMENT_IS_NODE) {
          if (typeof performance === "undefined") {
            global.performance = __require2("perf_hooks").performance;
          }
        }
        var out = Module["print"] || console.log.bind(console);
        var err = Module["printErr"] || console.warn.bind(console);
        for (key in moduleOverrides) {
          if (moduleOverrides.hasOwnProperty(key)) {
            Module[key] = moduleOverrides[key];
          }
        }
        moduleOverrides = null;
        if (Module["arguments"])
          arguments_ = Module["arguments"];
        if (Module["thisProgram"])
          thisProgram = Module["thisProgram"];
        if (Module["quit"])
          quit_ = Module["quit"];
        var STACK_ALIGN = 16;
        function alignMemory(size, factor) {
          if (!factor)
            factor = STACK_ALIGN;
          return Math.ceil(size / factor) * factor;
        }
        __name(alignMemory, "alignMemory");
        function warnOnce(text) {
          if (!warnOnce.shown)
            warnOnce.shown = {};
          if (!warnOnce.shown[text]) {
            warnOnce.shown[text] = 1;
            err(text);
          }
        }
        __name(warnOnce, "warnOnce");
        var tempRet0 = 0;
        var setTempRet0 = /* @__PURE__ */ __name(function(value) {
          tempRet0 = value;
        }, "setTempRet0");
        var getTempRet0 = /* @__PURE__ */ __name(function() {
          return tempRet0;
        }, "getTempRet0");
        var Atomics_load = Atomics.load;
        var Atomics_store = Atomics.store;
        var Atomics_compareExchange = Atomics.compareExchange;
        var wasmBinary;
        if (Module["wasmBinary"])
          wasmBinary = Module["wasmBinary"];
        var noExitRuntime = Module["noExitRuntime"] || true;
        if (typeof WebAssembly !== "object") {
          abort("no native wasm support detected");
        }
        var wasmMemory;
        var wasmModule;
        var ABORT = false;
        var EXITSTATUS;
        function assert(condition, text) {
          if (!condition) {
            abort("Assertion failed: " + text);
          }
        }
        __name(assert, "assert");
        function TextDecoderWrapper(encoding) {
          var textDecoder = new TextDecoder(encoding);
          this.decode = function(data) {
            if (data.buffer instanceof SharedArrayBuffer) {
              data = new Uint8Array(data);
            }
            return textDecoder.decode.call(textDecoder, data);
          };
        }
        __name(TextDecoderWrapper, "TextDecoderWrapper");
        var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoderWrapper("utf8") : void 0;
        function UTF8ArrayToString(heap, idx, maxBytesToRead) {
          idx >>>= 0;
          var endIdx = idx + maxBytesToRead;
          var endPtr = idx;
          while (heap[endPtr >>> 0] && !(endPtr >= endIdx))
            ++endPtr;
          if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
            return UTF8Decoder.decode(heap.subarray(idx >>> 0, endPtr >>> 0));
          } else {
            var str = "";
            while (idx < endPtr) {
              var u0 = heap[idx++ >>> 0];
              if (!(u0 & 128)) {
                str += String.fromCharCode(u0);
                continue;
              }
              var u1 = heap[idx++ >>> 0] & 63;
              if ((u0 & 224) == 192) {
                str += String.fromCharCode((u0 & 31) << 6 | u1);
                continue;
              }
              var u2 = heap[idx++ >>> 0] & 63;
              if ((u0 & 240) == 224) {
                u0 = (u0 & 15) << 12 | u1 << 6 | u2;
              } else {
                u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++ >>> 0] & 63;
              }
              if (u0 < 65536) {
                str += String.fromCharCode(u0);
              } else {
                var ch = u0 - 65536;
                str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
              }
            }
          }
          return str;
        }
        __name(UTF8ArrayToString, "UTF8ArrayToString");
        function UTF8ToString(ptr, maxBytesToRead) {
          ptr >>>= 0;
          return ptr ? UTF8ArrayToString(GROWABLE_HEAP_U8(), ptr, maxBytesToRead) : "";
        }
        __name(UTF8ToString, "UTF8ToString");
        function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
          outIdx >>>= 0;
          if (!(maxBytesToWrite > 0))
            return 0;
          var startIdx = outIdx;
          var endIdx = outIdx + maxBytesToWrite - 1;
          for (var i = 0; i < str.length; ++i) {
            var u = str.charCodeAt(i);
            if (u >= 55296 && u <= 57343) {
              var u1 = str.charCodeAt(++i);
              u = 65536 + ((u & 1023) << 10) | u1 & 1023;
            }
            if (u <= 127) {
              if (outIdx >= endIdx)
                break;
              heap[outIdx++ >>> 0] = u;
            } else if (u <= 2047) {
              if (outIdx + 1 >= endIdx)
                break;
              heap[outIdx++ >>> 0] = 192 | u >> 6;
              heap[outIdx++ >>> 0] = 128 | u & 63;
            } else if (u <= 65535) {
              if (outIdx + 2 >= endIdx)
                break;
              heap[outIdx++ >>> 0] = 224 | u >> 12;
              heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
              heap[outIdx++ >>> 0] = 128 | u & 63;
            } else {
              if (outIdx + 3 >= endIdx)
                break;
              heap[outIdx++ >>> 0] = 240 | u >> 18;
              heap[outIdx++ >>> 0] = 128 | u >> 12 & 63;
              heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
              heap[outIdx++ >>> 0] = 128 | u & 63;
            }
          }
          heap[outIdx >>> 0] = 0;
          return outIdx - startIdx;
        }
        __name(stringToUTF8Array, "stringToUTF8Array");
        function stringToUTF8(str, outPtr, maxBytesToWrite) {
          return stringToUTF8Array(str, GROWABLE_HEAP_U8(), outPtr, maxBytesToWrite);
        }
        __name(stringToUTF8, "stringToUTF8");
        function lengthBytesUTF8(str) {
          var len = 0;
          for (var i = 0; i < str.length; ++i) {
            var u = str.charCodeAt(i);
            if (u >= 55296 && u <= 57343)
              u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
            if (u <= 127)
              ++len;
            else if (u <= 2047)
              len += 2;
            else if (u <= 65535)
              len += 3;
            else
              len += 4;
          }
          return len;
        }
        __name(lengthBytesUTF8, "lengthBytesUTF8");
        var UTF16Decoder = typeof TextDecoder !== "undefined" ? new TextDecoderWrapper("utf-16le") : void 0;
        function UTF16ToString(ptr, maxBytesToRead) {
          var endPtr = ptr;
          var idx = endPtr >> 1;
          var maxIdx = idx + maxBytesToRead / 2;
          while (!(idx >= maxIdx) && GROWABLE_HEAP_U16()[idx >>> 0])
            ++idx;
          endPtr = idx << 1;
          if (endPtr - ptr > 32 && UTF16Decoder) {
            return UTF16Decoder.decode(GROWABLE_HEAP_U8().subarray(ptr >>> 0, endPtr >>> 0));
          } else {
            var str = "";
            for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {
              var codeUnit = GROWABLE_HEAP_I16()[ptr + i * 2 >>> 1];
              if (codeUnit == 0)
                break;
              str += String.fromCharCode(codeUnit);
            }
            return str;
          }
        }
        __name(UTF16ToString, "UTF16ToString");
        function stringToUTF16(str, outPtr, maxBytesToWrite) {
          if (maxBytesToWrite === void 0) {
            maxBytesToWrite = 2147483647;
          }
          if (maxBytesToWrite < 2)
            return 0;
          maxBytesToWrite -= 2;
          var startPtr = outPtr;
          var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
          for (var i = 0; i < numCharsToWrite; ++i) {
            var codeUnit = str.charCodeAt(i);
            GROWABLE_HEAP_I16()[outPtr >>> 1] = codeUnit;
            outPtr += 2;
          }
          GROWABLE_HEAP_I16()[outPtr >>> 1] = 0;
          return outPtr - startPtr;
        }
        __name(stringToUTF16, "stringToUTF16");
        function lengthBytesUTF16(str) {
          return str.length * 2;
        }
        __name(lengthBytesUTF16, "lengthBytesUTF16");
        function UTF32ToString(ptr, maxBytesToRead) {
          var i = 0;
          var str = "";
          while (!(i >= maxBytesToRead / 4)) {
            var utf32 = GROWABLE_HEAP_I32()[ptr + i * 4 >>> 2];
            if (utf32 == 0)
              break;
            ++i;
            if (utf32 >= 65536) {
              var ch = utf32 - 65536;
              str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
            } else {
              str += String.fromCharCode(utf32);
            }
          }
          return str;
        }
        __name(UTF32ToString, "UTF32ToString");
        function stringToUTF32(str, outPtr, maxBytesToWrite) {
          outPtr >>>= 0;
          if (maxBytesToWrite === void 0) {
            maxBytesToWrite = 2147483647;
          }
          if (maxBytesToWrite < 4)
            return 0;
          var startPtr = outPtr;
          var endPtr = startPtr + maxBytesToWrite - 4;
          for (var i = 0; i < str.length; ++i) {
            var codeUnit = str.charCodeAt(i);
            if (codeUnit >= 55296 && codeUnit <= 57343) {
              var trailSurrogate = str.charCodeAt(++i);
              codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;
            }
            GROWABLE_HEAP_I32()[outPtr >>> 2] = codeUnit;
            outPtr += 4;
            if (outPtr + 4 > endPtr)
              break;
          }
          GROWABLE_HEAP_I32()[outPtr >>> 2] = 0;
          return outPtr - startPtr;
        }
        __name(stringToUTF32, "stringToUTF32");
        function lengthBytesUTF32(str) {
          var len = 0;
          for (var i = 0; i < str.length; ++i) {
            var codeUnit = str.charCodeAt(i);
            if (codeUnit >= 55296 && codeUnit <= 57343)
              ++i;
            len += 4;
          }
          return len;
        }
        __name(lengthBytesUTF32, "lengthBytesUTF32");
        function writeArrayToMemory(array, buffer2) {
          GROWABLE_HEAP_I8().set(array, buffer2 >>> 0);
        }
        __name(writeArrayToMemory, "writeArrayToMemory");
        function writeAsciiToMemory(str, buffer2, dontAddNull) {
          for (var i = 0; i < str.length; ++i) {
            GROWABLE_HEAP_I8()[buffer2++ >>> 0] = str.charCodeAt(i);
          }
          if (!dontAddNull)
            GROWABLE_HEAP_I8()[buffer2 >>> 0] = 0;
        }
        __name(writeAsciiToMemory, "writeAsciiToMemory");
        function alignUp(x, multiple) {
          if (x % multiple > 0) {
            x += multiple - x % multiple;
          }
          return x;
        }
        __name(alignUp, "alignUp");
        var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
        if (ENVIRONMENT_IS_PTHREAD) {
          buffer = Module["buffer"];
        }
        function updateGlobalBufferAndViews(buf) {
          buffer = buf;
          Module["HEAP8"] = HEAP8 = new Int8Array(buf);
          Module["HEAP16"] = HEAP16 = new Int16Array(buf);
          Module["HEAP32"] = HEAP32 = new Int32Array(buf);
          Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
          Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
          Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
          Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
          Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
        }
        __name(updateGlobalBufferAndViews, "updateGlobalBufferAndViews");
        var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;
        if (ENVIRONMENT_IS_PTHREAD) {
          wasmMemory = Module["wasmMemory"];
          buffer = Module["buffer"];
        } else {
          if (Module["wasmMemory"]) {
            wasmMemory = Module["wasmMemory"];
          } else {
            wasmMemory = new WebAssembly.Memory({ "initial": INITIAL_MEMORY / 65536, "maximum": 4294967296 / 65536, "shared": true });
            if (!(wasmMemory.buffer instanceof SharedArrayBuffer)) {
              err("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag");
              if (ENVIRONMENT_IS_NODE) {
                console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)");
              }
              throw Error("bad memory");
            }
          }
        }
        if (wasmMemory) {
          buffer = wasmMemory.buffer;
        }
        INITIAL_MEMORY = buffer.byteLength;
        updateGlobalBufferAndViews(buffer);
        var wasmTable;
        var __ATPRERUN__ = [];
        var __ATINIT__ = [];
        var __ATMAIN__ = [];
        var __ATEXIT__ = [];
        var __ATPOSTRUN__ = [];
        var runtimeInitialized = false;
        var runtimeExited = false;
        var runtimeKeepaliveCounter = 0;
        function keepRuntimeAlive() {
          return noExitRuntime || runtimeKeepaliveCounter > 0;
        }
        __name(keepRuntimeAlive, "keepRuntimeAlive");
        function preRun() {
          if (ENVIRONMENT_IS_PTHREAD)
            return;
          if (Module["preRun"]) {
            if (typeof Module["preRun"] == "function")
              Module["preRun"] = [Module["preRun"]];
            while (Module["preRun"].length) {
              addOnPreRun(Module["preRun"].shift());
            }
          }
          callRuntimeCallbacks(__ATPRERUN__);
        }
        __name(preRun, "preRun");
        function initRuntime() {
          runtimeInitialized = true;
          if (ENVIRONMENT_IS_PTHREAD)
            return;
          if (!Module["noFSInit"] && !FS.init.initialized)
            FS.init();
          FS.ignorePermissions = false;
          TTY.init();
          callRuntimeCallbacks(__ATINIT__);
        }
        __name(initRuntime, "initRuntime");
        function preMain() {
          if (ENVIRONMENT_IS_PTHREAD)
            return;
          callRuntimeCallbacks(__ATMAIN__);
        }
        __name(preMain, "preMain");
        function exitRuntime() {
          if (ENVIRONMENT_IS_PTHREAD)
            return;
          runtimeExited = true;
        }
        __name(exitRuntime, "exitRuntime");
        function postRun() {
          if (ENVIRONMENT_IS_PTHREAD)
            return;
          if (Module["postRun"]) {
            if (typeof Module["postRun"] == "function")
              Module["postRun"] = [Module["postRun"]];
            while (Module["postRun"].length) {
              addOnPostRun(Module["postRun"].shift());
            }
          }
          callRuntimeCallbacks(__ATPOSTRUN__);
        }
        __name(postRun, "postRun");
        function addOnPreRun(cb) {
          __ATPRERUN__.unshift(cb);
        }
        __name(addOnPreRun, "addOnPreRun");
        function addOnInit(cb) {
          __ATINIT__.unshift(cb);
        }
        __name(addOnInit, "addOnInit");
        function addOnPostRun(cb) {
          __ATPOSTRUN__.unshift(cb);
        }
        __name(addOnPostRun, "addOnPostRun");
        var runDependencies = 0;
        var runDependencyWatcher = null;
        var dependenciesFulfilled = null;
        function getUniqueRunDependency(id) {
          return id;
        }
        __name(getUniqueRunDependency, "getUniqueRunDependency");
        function addRunDependency(id) {
          runDependencies++;
          if (Module["monitorRunDependencies"]) {
            Module["monitorRunDependencies"](runDependencies);
          }
        }
        __name(addRunDependency, "addRunDependency");
        function removeRunDependency(id) {
          runDependencies--;
          if (Module["monitorRunDependencies"]) {
            Module["monitorRunDependencies"](runDependencies);
          }
          if (runDependencies == 0) {
            if (runDependencyWatcher !== null) {
              clearInterval(runDependencyWatcher);
              runDependencyWatcher = null;
            }
            if (dependenciesFulfilled) {
              var callback = dependenciesFulfilled;
              dependenciesFulfilled = null;
              callback();
            }
          }
        }
        __name(removeRunDependency, "removeRunDependency");
        Module["preloadedImages"] = {};
        Module["preloadedAudios"] = {};
        function abort(what) {
          if (Module["onAbort"]) {
            Module["onAbort"](what);
          }
          if (ENVIRONMENT_IS_PTHREAD)
            console.error("Pthread aborting at " + new Error().stack);
          what += "";
          err(what);
          ABORT = true;
          EXITSTATUS = 1;
          what = "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
          var e = new WebAssembly.RuntimeError(what);
          readyPromiseReject(e);
          throw e;
        }
        __name(abort, "abort");
        var dataURIPrefix = "data:application/octet-stream;base64,";
        function isDataURI(filename) {
          return filename.startsWith(dataURIPrefix);
        }
        __name(isDataURI, "isDataURI");
        function isFileURI(filename) {
          return filename.startsWith("file://");
        }
        __name(isFileURI, "isFileURI");
        var wasmBinaryFile;
        wasmBinaryFile = "web-ifc-mt.wasm";
        if (!isDataURI(wasmBinaryFile)) {
          wasmBinaryFile = locateFile(wasmBinaryFile);
        }
        function getBinary(file) {
          try {
            if (file == wasmBinaryFile && wasmBinary) {
              return new Uint8Array(wasmBinary);
            }
            if (readBinary) {
              return readBinary(file);
            } else {
              throw "both async and sync fetching of the wasm failed";
            }
          } catch (err2) {
            abort(err2);
          }
        }
        __name(getBinary, "getBinary");
        function getBinaryPromise() {
          if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
            if (typeof fetch === "function" && !isFileURI(wasmBinaryFile)) {
              return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
                if (!response["ok"]) {
                  throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
                }
                return response["arrayBuffer"]();
              }).catch(function() {
                return getBinary(wasmBinaryFile);
              });
            } else {
              if (readAsync) {
                return new Promise(function(resolve, reject) {
                  readAsync(wasmBinaryFile, function(response) {
                    resolve(new Uint8Array(response));
                  }, reject);
                });
              }
            }
          }
          return Promise.resolve().then(function() {
            return getBinary(wasmBinaryFile);
          });
        }
        __name(getBinaryPromise, "getBinaryPromise");
        function createWasm() {
          var info = { "a": asmLibraryArg };
          function receiveInstance(instance, module2) {
            var exports3 = instance.exports;
            Module["asm"] = exports3;
            wasmTable = Module["asm"]["db"];
            addOnInit(Module["asm"]["ab"]);
            PThread.tlsInitFunctions.push(Module["asm"]["fb"]);
            wasmModule = module2;
            if (!ENVIRONMENT_IS_PTHREAD) {
              var numWorkersToLoad = PThread.unusedWorkers.length;
              PThread.unusedWorkers.forEach(function(w) {
                PThread.loadWasmModuleToWorker(w, function() {
                  if (!--numWorkersToLoad)
                    removeRunDependency("wasm-instantiate");
                });
              });
            }
          }
          __name(receiveInstance, "receiveInstance");
          if (!ENVIRONMENT_IS_PTHREAD) {
            addRunDependency("wasm-instantiate");
          }
          function receiveInstantiationResult(result) {
            receiveInstance(result["instance"], result["module"]);
          }
          __name(receiveInstantiationResult, "receiveInstantiationResult");
          function instantiateArrayBuffer(receiver) {
            return getBinaryPromise().then(function(binary) {
              var result = WebAssembly.instantiate(binary, info);
              return result;
            }).then(receiver, function(reason) {
              err("failed to asynchronously prepare wasm: " + reason);
              abort(reason);
            });
          }
          __name(instantiateArrayBuffer, "instantiateArrayBuffer");
          function instantiateAsync() {
            if (!wasmBinary && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch === "function") {
              return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
                var result = WebAssembly.instantiateStreaming(response, info);
                return result.then(receiveInstantiationResult, function(reason) {
                  err("wasm streaming compile failed: " + reason);
                  err("falling back to ArrayBuffer instantiation");
                  return instantiateArrayBuffer(receiveInstantiationResult);
                });
              });
            } else {
              return instantiateArrayBuffer(receiveInstantiationResult);
            }
          }
          __name(instantiateAsync, "instantiateAsync");
          if (Module["instantiateWasm"]) {
            try {
              var exports2 = Module["instantiateWasm"](info, receiveInstance);
              return exports2;
            } catch (e) {
              err("Module.instantiateWasm callback failed with error: " + e);
              return false;
            }
          }
          instantiateAsync().catch(readyPromiseReject);
          return {};
        }
        __name(createWasm, "createWasm");
        var tempDouble;
        var tempI64;
        var ASM_CONSTS = { 56684: function() {
          throw "Canceled!";
        }, 56702: function($0, $1) {
          setTimeout(function() {
            __emscripten_do_dispatch_to_thread($0, $1);
          }, 0);
        } };
        function initPthreadsJS() {
          PThread.initRuntime();
        }
        __name(initPthreadsJS, "initPthreadsJS");
        function callRuntimeCallbacks(callbacks) {
          while (callbacks.length > 0) {
            var callback = callbacks.shift();
            if (typeof callback == "function") {
              callback(Module);
              continue;
            }
            var func = callback.func;
            if (typeof func === "number") {
              if (callback.arg === void 0) {
                wasmTable.get(func)();
              } else {
                wasmTable.get(func)(callback.arg);
              }
            } else {
              func(callback.arg === void 0 ? null : callback.arg);
            }
          }
        }
        __name(callRuntimeCallbacks, "callRuntimeCallbacks");
        function _emscripten_futex_wake(addr, count) {
          if (addr <= 0 || addr > GROWABLE_HEAP_I8().length || addr & true || count < 0)
            return -28;
          if (count == 0)
            return 0;
          if (count >= 2147483647)
            count = Infinity;
          var mainThreadWaitAddress = Atomics.load(GROWABLE_HEAP_I32(), __emscripten_main_thread_futex >> 2);
          var mainThreadWoken = 0;
          if (mainThreadWaitAddress == addr) {
            var loadedAddr = Atomics.compareExchange(GROWABLE_HEAP_I32(), __emscripten_main_thread_futex >> 2, mainThreadWaitAddress, 0);
            if (loadedAddr == mainThreadWaitAddress) {
              --count;
              mainThreadWoken = 1;
              if (count <= 0)
                return 1;
            }
          }
          var ret = Atomics.notify(GROWABLE_HEAP_I32(), addr >> 2, count);
          if (ret >= 0)
            return ret + mainThreadWoken;
          throw "Atomics.notify returned an unexpected value " + ret;
        }
        __name(_emscripten_futex_wake, "_emscripten_futex_wake");
        Module["_emscripten_futex_wake"] = _emscripten_futex_wake;
        function killThread(pthread_ptr) {
          if (ENVIRONMENT_IS_PTHREAD)
            throw "Internal Error! killThread() can only ever be called from main application thread!";
          if (!pthread_ptr)
            throw "Internal Error! Null pthread_ptr in killThread!";
          GROWABLE_HEAP_I32()[pthread_ptr + 12 >>> 2] = 0;
          var pthread = PThread.pthreads[pthread_ptr];
          pthread.worker.terminate();
          PThread.freeThreadData(pthread);
          PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(pthread.worker), 1);
          pthread.worker.pthread = void 0;
        }
        __name(killThread, "killThread");
        function cancelThread(pthread_ptr) {
          if (ENVIRONMENT_IS_PTHREAD)
            throw "Internal Error! cancelThread() can only ever be called from main application thread!";
          if (!pthread_ptr)
            throw "Internal Error! Null pthread_ptr in cancelThread!";
          var pthread = PThread.pthreads[pthread_ptr];
          pthread.worker.postMessage({ "cmd": "cancel" });
        }
        __name(cancelThread, "cancelThread");
        function cleanupThread(pthread_ptr) {
          if (ENVIRONMENT_IS_PTHREAD)
            throw "Internal Error! cleanupThread() can only ever be called from main application thread!";
          if (!pthread_ptr)
            throw "Internal Error! Null pthread_ptr in cleanupThread!";
          var pthread = PThread.pthreads[pthread_ptr];
          if (pthread) {
            GROWABLE_HEAP_I32()[pthread_ptr + 12 >>> 2] = 0;
            var worker = pthread.worker;
            PThread.returnWorkerToPool(worker);
          }
        }
        __name(cleanupThread, "cleanupThread");
        var PThread = { unusedWorkers: [], runningWorkers: [], tlsInitFunctions: [], initMainThreadBlock: function() {
          var pthreadPoolSize = navigator.hardwareConcurrency;
          for (var i = 0; i < pthreadPoolSize; ++i) {
            PThread.allocateUnusedWorker();
          }
        }, initRuntime: function() {
          var tb = _malloc(228);
          for (var i = 0; i < 228 / 4; ++i)
            GROWABLE_HEAP_U32()[tb / 4 + i >>> 0] = 0;
          GROWABLE_HEAP_I32()[tb + 12 >>> 2] = tb;
          var headPtr = tb + 152;
          GROWABLE_HEAP_I32()[headPtr >>> 2] = headPtr;
          var tlsMemory = _malloc(512);
          for (var i = 0; i < 128; ++i)
            GROWABLE_HEAP_U32()[tlsMemory / 4 + i >>> 0] = 0;
          Atomics.store(GROWABLE_HEAP_U32(), tb + 100 >> 2, tlsMemory);
          Atomics.store(GROWABLE_HEAP_U32(), tb + 40 >> 2, tb);
          __emscripten_thread_init(tb, !ENVIRONMENT_IS_WORKER, 1);
          _emscripten_register_main_browser_thread_id(tb);
        }, initWorker: function() {
        }, pthreads: {}, threadExitHandlers: [], runExitHandlers: function() {
          while (PThread.threadExitHandlers.length > 0) {
            PThread.threadExitHandlers.pop()();
          }
          ___pthread_tsd_run_dtors();
        }, runExitHandlersAndDeinitThread: function(tb, exitCode) {
          Atomics.store(GROWABLE_HEAP_U32(), tb + 56 >> 2, 1);
          Atomics.store(GROWABLE_HEAP_U32(), tb + 60 >> 2, 0);
          PThread.runExitHandlers();
          Atomics.store(GROWABLE_HEAP_U32(), tb + 4 >> 2, exitCode);
          Atomics.store(GROWABLE_HEAP_U32(), tb + 0 >> 2, 1);
          _emscripten_futex_wake(tb + 0, 2147483647);
          __emscripten_thread_init(0, 0, 0);
        }, setExitStatus: function(status) {
          EXITSTATUS = status;
        }, threadExit: function(exitCode) {
          var tb = _pthread_self();
          if (tb) {
            PThread.runExitHandlersAndDeinitThread(tb, exitCode);
            if (ENVIRONMENT_IS_PTHREAD) {
              postMessage({ "cmd": "exit" });
            }
          }
        }, threadCancel: function() {
          PThread.runExitHandlersAndDeinitThread(_pthread_self(), -1);
          postMessage({ "cmd": "cancelDone" });
        }, terminateAllThreads: function() {
          for (var t in PThread.pthreads) {
            var pthread = PThread.pthreads[t];
            if (pthread && pthread.worker) {
              PThread.returnWorkerToPool(pthread.worker);
            }
          }
          PThread.pthreads = {};
          for (var i = 0; i < PThread.unusedWorkers.length; ++i) {
            var worker = PThread.unusedWorkers[i];
            worker.terminate();
          }
          PThread.unusedWorkers = [];
          for (var i = 0; i < PThread.runningWorkers.length; ++i) {
            var worker = PThread.runningWorkers[i];
            var pthread = worker.pthread;
            PThread.freeThreadData(pthread);
            worker.terminate();
          }
          PThread.runningWorkers = [];
        }, freeThreadData: function(pthread) {
          if (!pthread)
            return;
          if (pthread.threadInfoStruct) {
            var tlsMemory = GROWABLE_HEAP_I32()[pthread.threadInfoStruct + 100 >>> 2];
            GROWABLE_HEAP_I32()[pthread.threadInfoStruct + 100 >>> 2] = 0;
            _free(tlsMemory);
            _free(pthread.threadInfoStruct);
          }
          pthread.threadInfoStruct = 0;
          if (pthread.allocatedOwnStack && pthread.stackBase)
            _free(pthread.stackBase);
          pthread.stackBase = 0;
          if (pthread.worker)
            pthread.worker.pthread = null;
        }, returnWorkerToPool: function(worker) {
          PThread.runWithoutMainThreadQueuedCalls(function() {
            delete PThread.pthreads[worker.pthread.threadInfoStruct];
            PThread.unusedWorkers.push(worker);
            PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(worker), 1);
            PThread.freeThreadData(worker.pthread);
            worker.pthread = void 0;
          });
        }, runWithoutMainThreadQueuedCalls: function(func) {
          GROWABLE_HEAP_I32()[__emscripten_allow_main_runtime_queued_calls >>> 2] = 0;
          try {
            func();
          } finally {
            GROWABLE_HEAP_I32()[__emscripten_allow_main_runtime_queued_calls >>> 2] = 1;
          }
        }, receiveObjectTransfer: function(data) {
        }, threadInit: function() {
          for (var i in PThread.tlsInitFunctions) {
            PThread.tlsInitFunctions[i]();
          }
        }, loadWasmModuleToWorker: function(worker, onFinishedLoading) {
          worker.onmessage = function(e) {
            var d = e["data"];
            var cmd = d["cmd"];
            if (worker.pthread)
              PThread.currentProxiedOperationCallerThread = worker.pthread.threadInfoStruct;
            if (d["targetThread"] && d["targetThread"] != _pthread_self()) {
              var thread = PThread.pthreads[d.targetThread];
              if (thread) {
                thread.worker.postMessage(e.data, d["transferList"]);
              } else {
                console.error('Internal error! Worker sent a message "' + cmd + '" to target pthread ' + d["targetThread"] + ", but that thread no longer exists!");
              }
              PThread.currentProxiedOperationCallerThread = void 0;
              return;
            }
            if (cmd === "processQueuedMainThreadWork") {
              _emscripten_main_thread_process_queued_calls();
            } else if (cmd === "spawnThread") {
              spawnThread(e.data);
            } else if (cmd === "cleanupThread") {
              cleanupThread(d["thread"]);
            } else if (cmd === "killThread") {
              killThread(d["thread"]);
            } else if (cmd === "cancelThread") {
              cancelThread(d["thread"]);
            } else if (cmd === "loaded") {
              worker.loaded = true;
              if (onFinishedLoading)
                onFinishedLoading(worker);
              if (worker.runPthread) {
                worker.runPthread();
                delete worker.runPthread;
              }
            } else if (cmd === "print") {
              out("Thread " + d["threadId"] + ": " + d["text"]);
            } else if (cmd === "printErr") {
              err("Thread " + d["threadId"] + ": " + d["text"]);
            } else if (cmd === "alert") {
              alert("Thread " + d["threadId"] + ": " + d["text"]);
            } else if (cmd === "exit") {
              var detached = worker.pthread && Atomics.load(GROWABLE_HEAP_U32(), worker.pthread.threadInfoStruct + 64 >> 2);
              if (detached) {
                PThread.returnWorkerToPool(worker);
              }
            } else if (cmd === "exitProcess") {
              try {
                exit(d["returnCode"]);
              } catch (e2) {
                if (e2 instanceof ExitStatus)
                  return;
                throw e2;
              }
            } else if (cmd === "cancelDone") {
              PThread.returnWorkerToPool(worker);
            } else if (cmd === "objectTransfer") {
              PThread.receiveObjectTransfer(e.data);
            } else if (e.data.target === "setimmediate") {
              worker.postMessage(e.data);
            } else {
              err("worker sent an unknown command " + cmd);
            }
            PThread.currentProxiedOperationCallerThread = void 0;
          };
          worker.onerror = function(e) {
            err("pthread sent an error! " + e.filename + ":" + e.lineno + ": " + e.message);
          };
          if (ENVIRONMENT_IS_NODE) {
            worker.on("message", function(data) {
              worker.onmessage({ data });
            });
            worker.on("error", function(data) {
              worker.onerror(data);
            });
            worker.on("exit", function(data) {
            });
          }
          worker.postMessage({ "cmd": "load", "urlOrBlob": Module["mainScriptUrlOrBlob"] || _scriptDir, "wasmMemory": wasmMemory, "wasmModule": wasmModule });
        }, allocateUnusedWorker: function() {
          var pthreadMainJs = locateFile("web-ifc-mt.worker.js");
          PThread.unusedWorkers.push(new Worker(pthreadMainJs));
        }, getNewWorker: function() {
          if (PThread.unusedWorkers.length == 0) {
            PThread.allocateUnusedWorker();
            PThread.loadWasmModuleToWorker(PThread.unusedWorkers[0]);
          }
          return PThread.unusedWorkers.pop();
        }, busySpinWait: function(msecs) {
          var t = performance.now() + msecs;
          while (performance.now() < t) {
          }
        } };
        function establishStackSpace(stackTop, stackMax) {
          _emscripten_stack_set_limits(stackTop, stackMax);
          stackRestore(stackTop);
        }
        __name(establishStackSpace, "establishStackSpace");
        Module["establishStackSpace"] = establishStackSpace;
        function invokeEntryPoint(ptr, arg) {
          return wasmTable.get(ptr)(arg);
        }
        __name(invokeEntryPoint, "invokeEntryPoint");
        Module["invokeEntryPoint"] = invokeEntryPoint;
        function ___assert_fail(condition, filename, line, func) {
          abort("Assertion failed: " + UTF8ToString(condition) + ", at: " + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
        }
        __name(___assert_fail, "___assert_fail");
        var _emscripten_get_now;
        if (ENVIRONMENT_IS_NODE) {
          _emscripten_get_now = /* @__PURE__ */ __name(function() {
            var t = process["hrtime"]();
            return t[0] * 1e3 + t[1] / 1e6;
          }, "_emscripten_get_now");
        } else if (ENVIRONMENT_IS_PTHREAD) {
          _emscripten_get_now = /* @__PURE__ */ __name(function() {
            return performance.now() - Module["__performance_now_clock_drift"];
          }, "_emscripten_get_now");
        } else
          _emscripten_get_now = /* @__PURE__ */ __name(function() {
            return performance.now();
          }, "_emscripten_get_now");
        var _emscripten_get_now_is_monotonic = true;
        function setErrNo(value) {
          GROWABLE_HEAP_I32()[___errno_location() >>> 2] = value;
          return value;
        }
        __name(setErrNo, "setErrNo");
        function _clock_gettime(clk_id, tp) {
          var now;
          if (clk_id === 0) {
            now = Date.now();
          } else if ((clk_id === 1 || clk_id === 4) && _emscripten_get_now_is_monotonic) {
            now = _emscripten_get_now();
          } else {
            setErrNo(28);
            return -1;
          }
          GROWABLE_HEAP_I32()[tp >>> 2] = now / 1e3 | 0;
          GROWABLE_HEAP_I32()[tp + 4 >>> 2] = now % 1e3 * 1e3 * 1e3 | 0;
          return 0;
        }
        __name(_clock_gettime, "_clock_gettime");
        function ___cxa_allocate_exception(size) {
          return _malloc(size + 16) + 16;
        }
        __name(___cxa_allocate_exception, "___cxa_allocate_exception");
        function _atexit(func, arg) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(1, 1, func, arg);
        }
        __name(_atexit, "_atexit");
        function ExceptionInfo(excPtr) {
          this.excPtr = excPtr;
          this.ptr = excPtr - 16;
          this.set_type = function(type) {
            GROWABLE_HEAP_I32()[this.ptr + 4 >>> 2] = type;
          };
          this.get_type = function() {
            return GROWABLE_HEAP_I32()[this.ptr + 4 >>> 2];
          };
          this.set_destructor = function(destructor) {
            GROWABLE_HEAP_I32()[this.ptr + 8 >>> 2] = destructor;
          };
          this.get_destructor = function() {
            return GROWABLE_HEAP_I32()[this.ptr + 8 >>> 2];
          };
          this.set_refcount = function(refcount) {
            GROWABLE_HEAP_I32()[this.ptr >>> 2] = refcount;
          };
          this.set_caught = function(caught) {
            caught = caught ? 1 : 0;
            GROWABLE_HEAP_I8()[this.ptr + 12 >>> 0] = caught;
          };
          this.get_caught = function() {
            return GROWABLE_HEAP_I8()[this.ptr + 12 >>> 0] != 0;
          };
          this.set_rethrown = function(rethrown) {
            rethrown = rethrown ? 1 : 0;
            GROWABLE_HEAP_I8()[this.ptr + 13 >>> 0] = rethrown;
          };
          this.get_rethrown = function() {
            return GROWABLE_HEAP_I8()[this.ptr + 13 >>> 0] != 0;
          };
          this.init = function(type, destructor) {
            this.set_type(type);
            this.set_destructor(destructor);
            this.set_refcount(0);
            this.set_caught(false);
            this.set_rethrown(false);
          };
          this.add_ref = function() {
            Atomics.add(GROWABLE_HEAP_I32(), this.ptr + 0 >> 2, 1);
          };
          this.release_ref = function() {
            var prev = Atomics.sub(GROWABLE_HEAP_I32(), this.ptr + 0 >> 2, 1);
            return prev === 1;
          };
        }
        __name(ExceptionInfo, "ExceptionInfo");
        function CatchInfo(ptr) {
          this.free = function() {
            _free(this.ptr);
            this.ptr = 0;
          };
          this.set_base_ptr = function(basePtr) {
            GROWABLE_HEAP_I32()[this.ptr >>> 2] = basePtr;
          };
          this.get_base_ptr = function() {
            return GROWABLE_HEAP_I32()[this.ptr >>> 2];
          };
          this.set_adjusted_ptr = function(adjustedPtr) {
            GROWABLE_HEAP_I32()[this.ptr + 4 >>> 2] = adjustedPtr;
          };
          this.get_adjusted_ptr_addr = function() {
            return this.ptr + 4;
          };
          this.get_adjusted_ptr = function() {
            return GROWABLE_HEAP_I32()[this.ptr + 4 >>> 2];
          };
          this.get_exception_ptr = function() {
            var isPointer = ___cxa_is_pointer_type(this.get_exception_info().get_type());
            if (isPointer) {
              return GROWABLE_HEAP_I32()[this.get_base_ptr() >>> 2];
            }
            var adjusted = this.get_adjusted_ptr();
            if (adjusted !== 0)
              return adjusted;
            return this.get_base_ptr();
          };
          this.get_exception_info = function() {
            return new ExceptionInfo(this.get_base_ptr());
          };
          if (ptr === void 0) {
            this.ptr = _malloc(8);
            this.set_adjusted_ptr(0);
          } else {
            this.ptr = ptr;
          }
        }
        __name(CatchInfo, "CatchInfo");
        var exceptionCaught = [];
        function exception_addRef(info) {
          info.add_ref();
        }
        __name(exception_addRef, "exception_addRef");
        var uncaughtExceptionCount = 0;
        function ___cxa_begin_catch(ptr) {
          var catchInfo = new CatchInfo(ptr);
          var info = catchInfo.get_exception_info();
          if (!info.get_caught()) {
            info.set_caught(true);
            uncaughtExceptionCount--;
          }
          info.set_rethrown(false);
          exceptionCaught.push(catchInfo);
          exception_addRef(info);
          return catchInfo.get_exception_ptr();
        }
        __name(___cxa_begin_catch, "___cxa_begin_catch");
        var exceptionLast = 0;
        function ___cxa_free_exception(ptr) {
          return _free(new ExceptionInfo(ptr).ptr);
        }
        __name(___cxa_free_exception, "___cxa_free_exception");
        function exception_decRef(info) {
          if (info.release_ref() && !info.get_rethrown()) {
            var destructor = info.get_destructor();
            if (destructor) {
              wasmTable.get(destructor)(info.excPtr);
            }
            ___cxa_free_exception(info.excPtr);
          }
        }
        __name(exception_decRef, "exception_decRef");
        function ___cxa_end_catch() {
          _setThrew(0);
          var catchInfo = exceptionCaught.pop();
          exception_decRef(catchInfo.get_exception_info());
          catchInfo.free();
          exceptionLast = 0;
        }
        __name(___cxa_end_catch, "___cxa_end_catch");
        function ___resumeException(catchInfoPtr) {
          var catchInfo = new CatchInfo(catchInfoPtr);
          var ptr = catchInfo.get_base_ptr();
          if (!exceptionLast) {
            exceptionLast = ptr;
          }
          catchInfo.free();
          throw ptr;
        }
        __name(___resumeException, "___resumeException");
        function ___cxa_find_matching_catch_2() {
          var thrown = exceptionLast;
          if (!thrown) {
            setTempRet0(0);
            return 0 | 0;
          }
          var info = new ExceptionInfo(thrown);
          var thrownType = info.get_type();
          var catchInfo = new CatchInfo();
          catchInfo.set_base_ptr(thrown);
          catchInfo.set_adjusted_ptr(thrown);
          if (!thrownType) {
            setTempRet0(0);
            return catchInfo.ptr | 0;
          }
          var typeArray = Array.prototype.slice.call(arguments);
          for (var i = 0; i < typeArray.length; i++) {
            var caughtType = typeArray[i];
            if (caughtType === 0 || caughtType === thrownType) {
              break;
            }
            if (___cxa_can_catch(caughtType, thrownType, catchInfo.get_adjusted_ptr_addr())) {
              setTempRet0(caughtType);
              return catchInfo.ptr | 0;
            }
          }
          setTempRet0(thrownType);
          return catchInfo.ptr | 0;
        }
        __name(___cxa_find_matching_catch_2, "___cxa_find_matching_catch_2");
        function ___cxa_find_matching_catch_3() {
          var thrown = exceptionLast;
          if (!thrown) {
            setTempRet0(0);
            return 0 | 0;
          }
          var info = new ExceptionInfo(thrown);
          var thrownType = info.get_type();
          var catchInfo = new CatchInfo();
          catchInfo.set_base_ptr(thrown);
          catchInfo.set_adjusted_ptr(thrown);
          if (!thrownType) {
            setTempRet0(0);
            return catchInfo.ptr | 0;
          }
          var typeArray = Array.prototype.slice.call(arguments);
          for (var i = 0; i < typeArray.length; i++) {
            var caughtType = typeArray[i];
            if (caughtType === 0 || caughtType === thrownType) {
              break;
            }
            if (___cxa_can_catch(caughtType, thrownType, catchInfo.get_adjusted_ptr_addr())) {
              setTempRet0(caughtType);
              return catchInfo.ptr | 0;
            }
          }
          setTempRet0(thrownType);
          return catchInfo.ptr | 0;
        }
        __name(___cxa_find_matching_catch_3, "___cxa_find_matching_catch_3");
        function ___cxa_rethrow() {
          var catchInfo = exceptionCaught.pop();
          if (!catchInfo) {
            abort("no exception to throw");
          }
          var info = catchInfo.get_exception_info();
          var ptr = catchInfo.get_base_ptr();
          if (!info.get_rethrown()) {
            exceptionCaught.push(catchInfo);
            info.set_rethrown(true);
            info.set_caught(false);
            uncaughtExceptionCount++;
          } else {
            catchInfo.free();
          }
          exceptionLast = ptr;
          throw ptr;
        }
        __name(___cxa_rethrow, "___cxa_rethrow");
        function ___cxa_thread_atexit(routine, arg) {
          PThread.threadExitHandlers.push(function() {
            wasmTable.get(routine)(arg);
          });
        }
        __name(___cxa_thread_atexit, "___cxa_thread_atexit");
        function ___cxa_throw(ptr, type, destructor) {
          var info = new ExceptionInfo(ptr);
          info.init(type, destructor);
          exceptionLast = ptr;
          uncaughtExceptionCount++;
          throw ptr;
        }
        __name(___cxa_throw, "___cxa_throw");
        function ___cxa_uncaught_exceptions() {
          return uncaughtExceptionCount;
        }
        __name(___cxa_uncaught_exceptions, "___cxa_uncaught_exceptions");
        var PATH = { splitPath: function(filename) {
          var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
          return splitPathRe.exec(filename).slice(1);
        }, normalizeArray: function(parts, allowAboveRoot) {
          var up = 0;
          for (var i = parts.length - 1; i >= 0; i--) {
            var last = parts[i];
            if (last === ".") {
              parts.splice(i, 1);
            } else if (last === "..") {
              parts.splice(i, 1);
              up++;
            } else if (up) {
              parts.splice(i, 1);
              up--;
            }
          }
          if (allowAboveRoot) {
            for (; up; up--) {
              parts.unshift("..");
            }
          }
          return parts;
        }, normalize: function(path) {
          var isAbsolute = path.charAt(0) === "/", trailingSlash = path.substr(-1) === "/";
          path = PATH.normalizeArray(path.split("/").filter(function(p) {
            return !!p;
          }), !isAbsolute).join("/");
          if (!path && !isAbsolute) {
            path = ".";
          }
          if (path && trailingSlash) {
            path += "/";
          }
          return (isAbsolute ? "/" : "") + path;
        }, dirname: function(path) {
          var result = PATH.splitPath(path), root2 = result[0], dir = result[1];
          if (!root2 && !dir) {
            return ".";
          }
          if (dir) {
            dir = dir.substr(0, dir.length - 1);
          }
          return root2 + dir;
        }, basename: function(path) {
          if (path === "/")
            return "/";
          path = PATH.normalize(path);
          path = path.replace(/\/$/, "");
          var lastSlash = path.lastIndexOf("/");
          if (lastSlash === -1)
            return path;
          return path.substr(lastSlash + 1);
        }, extname: function(path) {
          return PATH.splitPath(path)[3];
        }, join: function() {
          var paths = Array.prototype.slice.call(arguments, 0);
          return PATH.normalize(paths.join("/"));
        }, join2: function(l, r) {
          return PATH.normalize(l + "/" + r);
        } };
        function getRandomDevice() {
          if (typeof crypto === "object" && typeof crypto["getRandomValues"] === "function") {
            var randomBuffer = new Uint8Array(1);
            return function() {
              crypto.getRandomValues(randomBuffer);
              return randomBuffer[0];
            };
          } else if (ENVIRONMENT_IS_NODE) {
            try {
              var crypto_module = require_crypto();
              return function() {
                return crypto_module["randomBytes"](1)[0];
              };
            } catch (e) {
            }
          }
          return function() {
            abort("randomDevice");
          };
        }
        __name(getRandomDevice, "getRandomDevice");
        var PATH_FS = { resolve: function() {
          var resolvedPath = "", resolvedAbsolute = false;
          for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            var path = i >= 0 ? arguments[i] : FS.cwd();
            if (typeof path !== "string") {
              throw new TypeError("Arguments to path.resolve must be strings");
            } else if (!path) {
              return "";
            }
            resolvedPath = path + "/" + resolvedPath;
            resolvedAbsolute = path.charAt(0) === "/";
          }
          resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter(function(p) {
            return !!p;
          }), !resolvedAbsolute).join("/");
          return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
        }, relative: function(from, to) {
          from = PATH_FS.resolve(from).substr(1);
          to = PATH_FS.resolve(to).substr(1);
          function trim(arr) {
            var start = 0;
            for (; start < arr.length; start++) {
              if (arr[start] !== "")
                break;
            }
            var end = arr.length - 1;
            for (; end >= 0; end--) {
              if (arr[end] !== "")
                break;
            }
            if (start > end)
              return [];
            return arr.slice(start, end - start + 1);
          }
          __name(trim, "trim");
          var fromParts = trim(from.split("/"));
          var toParts = trim(to.split("/"));
          var length = Math.min(fromParts.length, toParts.length);
          var samePartsLength = length;
          for (var i = 0; i < length; i++) {
            if (fromParts[i] !== toParts[i]) {
              samePartsLength = i;
              break;
            }
          }
          var outputParts = [];
          for (var i = samePartsLength; i < fromParts.length; i++) {
            outputParts.push("..");
          }
          outputParts = outputParts.concat(toParts.slice(samePartsLength));
          return outputParts.join("/");
        } };
        var TTY = { ttys: [], init: function() {
        }, shutdown: function() {
        }, register: function(dev, ops) {
          TTY.ttys[dev] = { input: [], output: [], ops };
          FS.registerDevice(dev, TTY.stream_ops);
        }, stream_ops: { open: function(stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(43);
          }
          stream.tty = tty;
          stream.seekable = false;
        }, close: function(stream) {
          stream.tty.ops.flush(stream.tty);
        }, flush: function(stream) {
          stream.tty.ops.flush(stream.tty);
        }, read: function(stream, buffer2, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer2[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        }, write: function(stream, buffer2, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i = 0; i < length; i++) {
              stream.tty.ops.put_char(stream.tty, buffer2[offset + i]);
            }
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        } }, default_tty_ops: { get_char: function(tty) {
          if (!tty.input.length) {
            var result = null;
            if (ENVIRONMENT_IS_NODE) {
              var BUFSIZE = 256;
              var buf = Buffer.alloc(BUFSIZE);
              var bytesRead = 0;
              try {
                bytesRead = nodeFS.readSync(process.stdin.fd, buf, 0, BUFSIZE, null);
              } catch (e) {
                if (e.toString().includes("EOF"))
                  bytesRead = 0;
                else
                  throw e;
              }
              if (bytesRead > 0) {
                result = buf.slice(0, bytesRead).toString("utf-8");
              } else {
                result = null;
              }
            } else if (typeof window != "undefined" && typeof window.prompt == "function") {
              result = window.prompt("Input: ");
              if (result !== null) {
                result += "\n";
              }
            } else if (typeof readline == "function") {
              result = readline();
              if (result !== null) {
                result += "\n";
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        }, put_char: function(tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0)
              tty.output.push(val);
          }
        }, flush: function(tty) {
          if (tty.output && tty.output.length > 0) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        } }, default_tty1_ops: { put_char: function(tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0)
              tty.output.push(val);
          }
        }, flush: function(tty) {
          if (tty.output && tty.output.length > 0) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        } } };
        function zeroMemory(address, size) {
          GROWABLE_HEAP_U8().fill(0, address, address + size);
        }
        __name(zeroMemory, "zeroMemory");
        function mmapAlloc(size) {
          size = alignMemory(size, 65536);
          var ptr = _memalign(65536, size);
          if (!ptr)
            return 0;
          zeroMemory(ptr, size);
          return ptr;
        }
        __name(mmapAlloc, "mmapAlloc");
        var MEMFS = { ops_table: null, mount: function(mount) {
          return MEMFS.createNode(null, "/", 16384 | 511, 0);
        }, createNode: function(parent, name2, mode, dev) {
          if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
            throw new FS.ErrnoError(63);
          }
          if (!MEMFS.ops_table) {
            MEMFS.ops_table = { dir: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, lookup: MEMFS.node_ops.lookup, mknod: MEMFS.node_ops.mknod, rename: MEMFS.node_ops.rename, unlink: MEMFS.node_ops.unlink, rmdir: MEMFS.node_ops.rmdir, readdir: MEMFS.node_ops.readdir, symlink: MEMFS.node_ops.symlink }, stream: { llseek: MEMFS.stream_ops.llseek } }, file: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: { llseek: MEMFS.stream_ops.llseek, read: MEMFS.stream_ops.read, write: MEMFS.stream_ops.write, allocate: MEMFS.stream_ops.allocate, mmap: MEMFS.stream_ops.mmap, msync: MEMFS.stream_ops.msync } }, link: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, readlink: MEMFS.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: FS.chrdev_stream_ops } };
          }
          var node = FS.createNode(parent, name2, mode, dev);
          if (FS.isDir(node.mode)) {
            node.node_ops = MEMFS.ops_table.dir.node;
            node.stream_ops = MEMFS.ops_table.dir.stream;
            node.contents = {};
          } else if (FS.isFile(node.mode)) {
            node.node_ops = MEMFS.ops_table.file.node;
            node.stream_ops = MEMFS.ops_table.file.stream;
            node.usedBytes = 0;
            node.contents = null;
          } else if (FS.isLink(node.mode)) {
            node.node_ops = MEMFS.ops_table.link.node;
            node.stream_ops = MEMFS.ops_table.link.stream;
          } else if (FS.isChrdev(node.mode)) {
            node.node_ops = MEMFS.ops_table.chrdev.node;
            node.stream_ops = MEMFS.ops_table.chrdev.stream;
          }
          node.timestamp = Date.now();
          if (parent) {
            parent.contents[name2] = node;
            parent.timestamp = node.timestamp;
          }
          return node;
        }, getFileDataAsTypedArray: function(node) {
          if (!node.contents)
            return new Uint8Array(0);
          if (node.contents.subarray)
            return node.contents.subarray(0, node.usedBytes);
          return new Uint8Array(node.contents);
        }, expandFileStorage: function(node, newCapacity) {
          newCapacity >>>= 0;
          var prevCapacity = node.contents ? node.contents.length : 0;
          if (prevCapacity >= newCapacity)
            return;
          var CAPACITY_DOUBLING_MAX = 1024 * 1024;
          newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
          if (prevCapacity != 0)
            newCapacity = Math.max(newCapacity, 256);
          var oldContents = node.contents;
          node.contents = new Uint8Array(newCapacity);
          if (node.usedBytes > 0)
            node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
        }, resizeFileStorage: function(node, newSize) {
          newSize >>>= 0;
          if (node.usedBytes == newSize)
            return;
          if (newSize == 0) {
            node.contents = null;
            node.usedBytes = 0;
          } else {
            var oldContents = node.contents;
            node.contents = new Uint8Array(newSize);
            if (oldContents) {
              node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
            }
            node.usedBytes = newSize;
          }
        }, node_ops: { getattr: function(node) {
          var attr = {};
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        }, setattr: function(node, attr) {
          if (attr.mode !== void 0) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== void 0) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        }, lookup: function(parent, name2) {
          throw FS.genericErrors[44];
        }, mknod: function(parent, name2, mode, dev) {
          return MEMFS.createNode(parent, name2, mode, dev);
        }, rename: function(old_node, new_dir, new_name) {
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
          }
          delete old_node.parent.contents[old_node.name];
          old_node.parent.timestamp = Date.now();
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          new_dir.timestamp = old_node.parent.timestamp;
          old_node.parent = new_dir;
        }, unlink: function(parent, name2) {
          delete parent.contents[name2];
          parent.timestamp = Date.now();
        }, rmdir: function(parent, name2) {
          var node = FS.lookupNode(parent, name2);
          for (var i in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name2];
          parent.timestamp = Date.now();
        }, readdir: function(node) {
          var entries = [".", ".."];
          for (var key2 in node.contents) {
            if (!node.contents.hasOwnProperty(key2)) {
              continue;
            }
            entries.push(key2);
          }
          return entries;
        }, symlink: function(parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
          node.link = oldpath;
          return node;
        }, readlink: function(node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        } }, stream_ops: { read: function(stream, buffer2, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes)
            return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          if (size > 8 && contents.subarray) {
            buffer2.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++)
              buffer2[offset + i] = contents[position + i];
          }
          return size;
        }, write: function(stream, buffer2, offset, length, position, canOwn) {
          if (buffer2.buffer === GROWABLE_HEAP_I8().buffer) {
            canOwn = false;
          }
          if (!length)
            return 0;
          var node = stream.node;
          node.timestamp = Date.now();
          if (buffer2.subarray && (!node.contents || node.contents.subarray)) {
            if (canOwn) {
              node.contents = buffer2.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) {
              node.contents = buffer2.slice(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) {
              node.contents.set(buffer2.subarray(offset, offset + length), position);
              return length;
            }
          }
          MEMFS.expandFileStorage(node, position + length);
          if (node.contents.subarray && buffer2.subarray) {
            node.contents.set(buffer2.subarray(offset, offset + length), position);
          } else {
            for (var i = 0; i < length; i++) {
              node.contents[position + i] = buffer2[offset + i];
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        }, llseek: function(stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        }, allocate: function(stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
        }, mmap: function(stream, address, length, position, prot, flags) {
          if (address !== 0) {
            throw new FS.ErrnoError(28);
          }
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          if (!(flags & 2) && contents.buffer === buffer) {
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length);
              }
            }
            allocated = true;
            ptr = mmapAlloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            ptr >>>= 0;
            GROWABLE_HEAP_I8().set(contents, ptr >>> 0);
          }
          return { ptr, allocated };
        }, msync: function(stream, buffer2, offset, length, mmapFlags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          if (mmapFlags & 2) {
            return 0;
          }
          var bytesWritten = MEMFS.stream_ops.write(stream, buffer2, 0, length, offset, false);
          return 0;
        } } };
        function asyncLoad(url, onload, onerror, noRunDep) {
          var dep = !noRunDep ? getUniqueRunDependency("al " + url) : "";
          readAsync(url, function(arrayBuffer) {
            assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
            onload(new Uint8Array(arrayBuffer));
            if (dep)
              removeRunDependency(dep);
          }, function(event) {
            if (onerror) {
              onerror();
            } else {
              throw 'Loading data file "' + url + '" failed.';
            }
          });
          if (dep)
            addRunDependency(dep);
        }
        __name(asyncLoad, "asyncLoad");
        var FS = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: false, ignorePermissions: true, trackingDelegate: {}, tracking: { openFlags: { READ: 1, WRITE: 2 } }, ErrnoError: null, genericErrors: {}, filesystems: null, syncFSRequests: 0, lookupPath: function(path, opts) {
          path = PATH_FS.resolve(FS.cwd(), path);
          opts = opts || {};
          if (!path)
            return { path: "", node: null };
          var defaults = { follow_mount: true, recurse_count: 0 };
          for (var key2 in defaults) {
            if (opts[key2] === void 0) {
              opts[key2] = defaults[key2];
            }
          }
          if (opts.recurse_count > 8) {
            throw new FS.ErrnoError(32);
          }
          var parts = PATH.normalizeArray(path.split("/").filter(function(p) {
            return !!p;
          }), false);
          var current = FS.root;
          var current_path = "/";
          for (var i = 0; i < parts.length; i++) {
            var islast = i === parts.length - 1;
            if (islast && opts.parent) {
              break;
            }
            current = FS.lookupNode(current, parts[i]);
            current_path = PATH.join2(current_path, parts[i]);
            if (FS.isMountpoint(current)) {
              if (!islast || islast && opts.follow_mount) {
                current = current.mounted.root;
              }
            }
            if (!islast || opts.follow) {
              var count = 0;
              while (FS.isLink(current.mode)) {
                var link = FS.readlink(current_path);
                current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
                var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count });
                current = lookup.node;
                if (count++ > 40) {
                  throw new FS.ErrnoError(32);
                }
              }
            }
          }
          return { path: current_path, node: current };
        }, getPath: function(node) {
          var path;
          while (true) {
            if (FS.isRoot(node)) {
              var mount = node.mount.mountpoint;
              if (!path)
                return mount;
              return mount[mount.length - 1] !== "/" ? mount + "/" + path : mount + path;
            }
            path = path ? node.name + "/" + path : node.name;
            node = node.parent;
          }
        }, hashName: function(parentid, name2) {
          var hash = 0;
          for (var i = 0; i < name2.length; i++) {
            hash = (hash << 5) - hash + name2.charCodeAt(i) | 0;
          }
          return (parentid + hash >>> 0) % FS.nameTable.length;
        }, hashAddNode: function(node) {
          var hash = FS.hashName(node.parent.id, node.name);
          node.name_next = FS.nameTable[hash];
          FS.nameTable[hash] = node;
        }, hashRemoveNode: function(node) {
          var hash = FS.hashName(node.parent.id, node.name);
          if (FS.nameTable[hash] === node) {
            FS.nameTable[hash] = node.name_next;
          } else {
            var current = FS.nameTable[hash];
            while (current) {
              if (current.name_next === node) {
                current.name_next = node.name_next;
                break;
              }
              current = current.name_next;
            }
          }
        }, lookupNode: function(parent, name2) {
          var errCode = FS.mayLookup(parent);
          if (errCode) {
            throw new FS.ErrnoError(errCode, parent);
          }
          var hash = FS.hashName(parent.id, name2);
          for (var node = FS.nameTable[hash]; node; node = node.name_next) {
            var nodeName = node.name;
            if (node.parent.id === parent.id && nodeName === name2) {
              return node;
            }
          }
          return FS.lookup(parent, name2);
        }, createNode: function(parent, name2, mode, rdev) {
          var node = new FS.FSNode(parent, name2, mode, rdev);
          FS.hashAddNode(node);
          return node;
        }, destroyNode: function(node) {
          FS.hashRemoveNode(node);
        }, isRoot: function(node) {
          return node === node.parent;
        }, isMountpoint: function(node) {
          return !!node.mounted;
        }, isFile: function(mode) {
          return (mode & 61440) === 32768;
        }, isDir: function(mode) {
          return (mode & 61440) === 16384;
        }, isLink: function(mode) {
          return (mode & 61440) === 40960;
        }, isChrdev: function(mode) {
          return (mode & 61440) === 8192;
        }, isBlkdev: function(mode) {
          return (mode & 61440) === 24576;
        }, isFIFO: function(mode) {
          return (mode & 61440) === 4096;
        }, isSocket: function(mode) {
          return (mode & 49152) === 49152;
        }, flagModes: { "r": 0, "r+": 2, "w": 577, "w+": 578, "a": 1089, "a+": 1090 }, modeStringToFlags: function(str) {
          var flags = FS.flagModes[str];
          if (typeof flags === "undefined") {
            throw new Error("Unknown file open mode: " + str);
          }
          return flags;
        }, flagsToPermissionString: function(flag) {
          var perms = ["r", "w", "rw"][flag & 3];
          if (flag & 512) {
            perms += "w";
          }
          return perms;
        }, nodePermissions: function(node, perms) {
          if (FS.ignorePermissions) {
            return 0;
          }
          if (perms.includes("r") && !(node.mode & 292)) {
            return 2;
          } else if (perms.includes("w") && !(node.mode & 146)) {
            return 2;
          } else if (perms.includes("x") && !(node.mode & 73)) {
            return 2;
          }
          return 0;
        }, mayLookup: function(dir) {
          var errCode = FS.nodePermissions(dir, "x");
          if (errCode)
            return errCode;
          if (!dir.node_ops.lookup)
            return 2;
          return 0;
        }, mayCreate: function(dir, name2) {
          try {
            var node = FS.lookupNode(dir, name2);
            return 20;
          } catch (e) {
          }
          return FS.nodePermissions(dir, "wx");
        }, mayDelete: function(dir, name2, isdir) {
          var node;
          try {
            node = FS.lookupNode(dir, name2);
          } catch (e) {
            return e.errno;
          }
          var errCode = FS.nodePermissions(dir, "wx");
          if (errCode) {
            return errCode;
          }
          if (isdir) {
            if (!FS.isDir(node.mode)) {
              return 54;
            }
            if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
              return 10;
            }
          } else {
            if (FS.isDir(node.mode)) {
              return 31;
            }
          }
          return 0;
        }, mayOpen: function(node, flags) {
          if (!node) {
            return 44;
          }
          if (FS.isLink(node.mode)) {
            return 32;
          } else if (FS.isDir(node.mode)) {
            if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
              return 31;
            }
          }
          return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
        }, MAX_OPEN_FDS: 4096, nextfd: function(fd_start, fd_end) {
          fd_start = fd_start || 0;
          fd_end = fd_end || FS.MAX_OPEN_FDS;
          for (var fd = fd_start; fd <= fd_end; fd++) {
            if (!FS.streams[fd]) {
              return fd;
            }
          }
          throw new FS.ErrnoError(33);
        }, getStream: function(fd) {
          return FS.streams[fd];
        }, createStream: function(stream, fd_start, fd_end) {
          if (!FS.FSStream) {
            FS.FSStream = function() {
            };
            FS.FSStream.prototype = { object: { get: function() {
              return this.node;
            }, set: function(val) {
              this.node = val;
            } }, isRead: { get: function() {
              return (this.flags & 2097155) !== 1;
            } }, isWrite: { get: function() {
              return (this.flags & 2097155) !== 0;
            } }, isAppend: { get: function() {
              return this.flags & 1024;
            } } };
          }
          var newStream = new FS.FSStream();
          for (var p in stream) {
            newStream[p] = stream[p];
          }
          stream = newStream;
          var fd = FS.nextfd(fd_start, fd_end);
          stream.fd = fd;
          FS.streams[fd] = stream;
          return stream;
        }, closeStream: function(fd) {
          FS.streams[fd] = null;
        }, chrdev_stream_ops: { open: function(stream) {
          var device = FS.getDevice(stream.node.rdev);
          stream.stream_ops = device.stream_ops;
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        }, llseek: function() {
          throw new FS.ErrnoError(70);
        } }, major: function(dev) {
          return dev >> 8;
        }, minor: function(dev) {
          return dev & 255;
        }, makedev: function(ma, mi) {
          return ma << 8 | mi;
        }, registerDevice: function(dev, ops) {
          FS.devices[dev] = { stream_ops: ops };
        }, getDevice: function(dev) {
          return FS.devices[dev];
        }, getMounts: function(mount) {
          var mounts = [];
          var check = [mount];
          while (check.length) {
            var m = check.pop();
            mounts.push(m);
            check.push.apply(check, m.mounts);
          }
          return mounts;
        }, syncfs: function(populate, callback) {
          if (typeof populate === "function") {
            callback = populate;
            populate = false;
          }
          FS.syncFSRequests++;
          if (FS.syncFSRequests > 1) {
            err("warning: " + FS.syncFSRequests + " FS.syncfs operations in flight at once, probably just doing extra work");
          }
          var mounts = FS.getMounts(FS.root.mount);
          var completed = 0;
          function doCallback(errCode) {
            FS.syncFSRequests--;
            return callback(errCode);
          }
          __name(doCallback, "doCallback");
          function done(errCode) {
            if (errCode) {
              if (!done.errored) {
                done.errored = true;
                return doCallback(errCode);
              }
              return;
            }
            if (++completed >= mounts.length) {
              doCallback(null);
            }
          }
          __name(done, "done");
          mounts.forEach(function(mount) {
            if (!mount.type.syncfs) {
              return done(null);
            }
            mount.type.syncfs(mount, populate, done);
          });
        }, mount: function(type, opts, mountpoint) {
          var root2 = mountpoint === "/";
          var pseudo = !mountpoint;
          var node;
          if (root2 && FS.root) {
            throw new FS.ErrnoError(10);
          } else if (!root2 && !pseudo) {
            var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
            mountpoint = lookup.path;
            node = lookup.node;
            if (FS.isMountpoint(node)) {
              throw new FS.ErrnoError(10);
            }
            if (!FS.isDir(node.mode)) {
              throw new FS.ErrnoError(54);
            }
          }
          var mount = { type, opts, mountpoint, mounts: [] };
          var mountRoot = type.mount(mount);
          mountRoot.mount = mount;
          mount.root = mountRoot;
          if (root2) {
            FS.root = mountRoot;
          } else if (node) {
            node.mounted = mount;
            if (node.mount) {
              node.mount.mounts.push(mount);
            }
          }
          return mountRoot;
        }, unmount: function(mountpoint) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
          if (!FS.isMountpoint(lookup.node)) {
            throw new FS.ErrnoError(28);
          }
          var node = lookup.node;
          var mount = node.mounted;
          var mounts = FS.getMounts(mount);
          Object.keys(FS.nameTable).forEach(function(hash) {
            var current = FS.nameTable[hash];
            while (current) {
              var next = current.name_next;
              if (mounts.includes(current.mount)) {
                FS.destroyNode(current);
              }
              current = next;
            }
          });
          node.mounted = null;
          var idx = node.mount.mounts.indexOf(mount);
          node.mount.mounts.splice(idx, 1);
        }, lookup: function(parent, name2) {
          return parent.node_ops.lookup(parent, name2);
        }, mknod: function(path, mode, dev) {
          var lookup = FS.lookupPath(path, { parent: true });
          var parent = lookup.node;
          var name2 = PATH.basename(path);
          if (!name2 || name2 === "." || name2 === "..") {
            throw new FS.ErrnoError(28);
          }
          var errCode = FS.mayCreate(parent, name2);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!parent.node_ops.mknod) {
            throw new FS.ErrnoError(63);
          }
          return parent.node_ops.mknod(parent, name2, mode, dev);
        }, create: function(path, mode) {
          mode = mode !== void 0 ? mode : 438;
          mode &= 4095;
          mode |= 32768;
          return FS.mknod(path, mode, 0);
        }, mkdir: function(path, mode) {
          mode = mode !== void 0 ? mode : 511;
          mode &= 511 | 512;
          mode |= 16384;
          return FS.mknod(path, mode, 0);
        }, mkdirTree: function(path, mode) {
          var dirs = path.split("/");
          var d = "";
          for (var i = 0; i < dirs.length; ++i) {
            if (!dirs[i])
              continue;
            d += "/" + dirs[i];
            try {
              FS.mkdir(d, mode);
            } catch (e) {
              if (e.errno != 20)
                throw e;
            }
          }
        }, mkdev: function(path, mode, dev) {
          if (typeof dev === "undefined") {
            dev = mode;
            mode = 438;
          }
          mode |= 8192;
          return FS.mknod(path, mode, dev);
        }, symlink: function(oldpath, newpath) {
          if (!PATH_FS.resolve(oldpath)) {
            throw new FS.ErrnoError(44);
          }
          var lookup = FS.lookupPath(newpath, { parent: true });
          var parent = lookup.node;
          if (!parent) {
            throw new FS.ErrnoError(44);
          }
          var newname = PATH.basename(newpath);
          var errCode = FS.mayCreate(parent, newname);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!parent.node_ops.symlink) {
            throw new FS.ErrnoError(63);
          }
          return parent.node_ops.symlink(parent, newname, oldpath);
        }, rename: function(old_path, new_path) {
          var old_dirname = PATH.dirname(old_path);
          var new_dirname = PATH.dirname(new_path);
          var old_name = PATH.basename(old_path);
          var new_name = PATH.basename(new_path);
          var lookup, old_dir, new_dir;
          lookup = FS.lookupPath(old_path, { parent: true });
          old_dir = lookup.node;
          lookup = FS.lookupPath(new_path, { parent: true });
          new_dir = lookup.node;
          if (!old_dir || !new_dir)
            throw new FS.ErrnoError(44);
          if (old_dir.mount !== new_dir.mount) {
            throw new FS.ErrnoError(75);
          }
          var old_node = FS.lookupNode(old_dir, old_name);
          var relative = PATH_FS.relative(old_path, new_dirname);
          if (relative.charAt(0) !== ".") {
            throw new FS.ErrnoError(28);
          }
          relative = PATH_FS.relative(new_path, old_dirname);
          if (relative.charAt(0) !== ".") {
            throw new FS.ErrnoError(55);
          }
          var new_node;
          try {
            new_node = FS.lookupNode(new_dir, new_name);
          } catch (e) {
          }
          if (old_node === new_node) {
            return;
          }
          var isdir = FS.isDir(old_node.mode);
          var errCode = FS.mayDelete(old_dir, old_name, isdir);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!old_dir.node_ops.rename) {
            throw new FS.ErrnoError(63);
          }
          if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
            throw new FS.ErrnoError(10);
          }
          if (new_dir !== old_dir) {
            errCode = FS.nodePermissions(old_dir, "w");
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
          }
          try {
            if (FS.trackingDelegate["willMovePath"]) {
              FS.trackingDelegate["willMovePath"](old_path, new_path);
            }
          } catch (e) {
            err("FS.trackingDelegate['willMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
          }
          FS.hashRemoveNode(old_node);
          try {
            old_dir.node_ops.rename(old_node, new_dir, new_name);
          } catch (e) {
            throw e;
          } finally {
            FS.hashAddNode(old_node);
          }
          try {
            if (FS.trackingDelegate["onMovePath"])
              FS.trackingDelegate["onMovePath"](old_path, new_path);
          } catch (e) {
            err("FS.trackingDelegate['onMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
          }
        }, rmdir: function(path) {
          var lookup = FS.lookupPath(path, { parent: true });
          var parent = lookup.node;
          var name2 = PATH.basename(path);
          var node = FS.lookupNode(parent, name2);
          var errCode = FS.mayDelete(parent, name2, true);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!parent.node_ops.rmdir) {
            throw new FS.ErrnoError(63);
          }
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
          try {
            if (FS.trackingDelegate["willDeletePath"]) {
              FS.trackingDelegate["willDeletePath"](path);
            }
          } catch (e) {
            err("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
          }
          parent.node_ops.rmdir(parent, name2);
          FS.destroyNode(node);
          try {
            if (FS.trackingDelegate["onDeletePath"])
              FS.trackingDelegate["onDeletePath"](path);
          } catch (e) {
            err("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
          }
        }, readdir: function(path) {
          var lookup = FS.lookupPath(path, { follow: true });
          var node = lookup.node;
          if (!node.node_ops.readdir) {
            throw new FS.ErrnoError(54);
          }
          return node.node_ops.readdir(node);
        }, unlink: function(path) {
          var lookup = FS.lookupPath(path, { parent: true });
          var parent = lookup.node;
          var name2 = PATH.basename(path);
          var node = FS.lookupNode(parent, name2);
          var errCode = FS.mayDelete(parent, name2, false);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!parent.node_ops.unlink) {
            throw new FS.ErrnoError(63);
          }
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
          try {
            if (FS.trackingDelegate["willDeletePath"]) {
              FS.trackingDelegate["willDeletePath"](path);
            }
          } catch (e) {
            err("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
          }
          parent.node_ops.unlink(parent, name2);
          FS.destroyNode(node);
          try {
            if (FS.trackingDelegate["onDeletePath"])
              FS.trackingDelegate["onDeletePath"](path);
          } catch (e) {
            err("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
          }
        }, readlink: function(path) {
          var lookup = FS.lookupPath(path);
          var link = lookup.node;
          if (!link) {
            throw new FS.ErrnoError(44);
          }
          if (!link.node_ops.readlink) {
            throw new FS.ErrnoError(28);
          }
          return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
        }, stat: function(path, dontFollow) {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          var node = lookup.node;
          if (!node) {
            throw new FS.ErrnoError(44);
          }
          if (!node.node_ops.getattr) {
            throw new FS.ErrnoError(63);
          }
          return node.node_ops.getattr(node);
        }, lstat: function(path) {
          return FS.stat(path, true);
        }, chmod: function(path, mode, dontFollow) {
          var node;
          if (typeof path === "string") {
            var lookup = FS.lookupPath(path, { follow: !dontFollow });
            node = lookup.node;
          } else {
            node = path;
          }
          if (!node.node_ops.setattr) {
            throw new FS.ErrnoError(63);
          }
          node.node_ops.setattr(node, { mode: mode & 4095 | node.mode & ~4095, timestamp: Date.now() });
        }, lchmod: function(path, mode) {
          FS.chmod(path, mode, true);
        }, fchmod: function(fd, mode) {
          var stream = FS.getStream(fd);
          if (!stream) {
            throw new FS.ErrnoError(8);
          }
          FS.chmod(stream.node, mode);
        }, chown: function(path, uid, gid, dontFollow) {
          var node;
          if (typeof path === "string") {
            var lookup = FS.lookupPath(path, { follow: !dontFollow });
            node = lookup.node;
          } else {
            node = path;
          }
          if (!node.node_ops.setattr) {
            throw new FS.ErrnoError(63);
          }
          node.node_ops.setattr(node, { timestamp: Date.now() });
        }, lchown: function(path, uid, gid) {
          FS.chown(path, uid, gid, true);
        }, fchown: function(fd, uid, gid) {
          var stream = FS.getStream(fd);
          if (!stream) {
            throw new FS.ErrnoError(8);
          }
          FS.chown(stream.node, uid, gid);
        }, truncate: function(path, len) {
          if (len < 0) {
            throw new FS.ErrnoError(28);
          }
          var node;
          if (typeof path === "string") {
            var lookup = FS.lookupPath(path, { follow: true });
            node = lookup.node;
          } else {
            node = path;
          }
          if (!node.node_ops.setattr) {
            throw new FS.ErrnoError(63);
          }
          if (FS.isDir(node.mode)) {
            throw new FS.ErrnoError(31);
          }
          if (!FS.isFile(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          var errCode = FS.nodePermissions(node, "w");
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          node.node_ops.setattr(node, { size: len, timestamp: Date.now() });
        }, ftruncate: function(fd, len) {
          var stream = FS.getStream(fd);
          if (!stream) {
            throw new FS.ErrnoError(8);
          }
          if ((stream.flags & 2097155) === 0) {
            throw new FS.ErrnoError(28);
          }
          FS.truncate(stream.node, len);
        }, utime: function(path, atime, mtime) {
          var lookup = FS.lookupPath(path, { follow: true });
          var node = lookup.node;
          node.node_ops.setattr(node, { timestamp: Math.max(atime, mtime) });
        }, open: function(path, flags, mode, fd_start, fd_end) {
          if (path === "") {
            throw new FS.ErrnoError(44);
          }
          flags = typeof flags === "string" ? FS.modeStringToFlags(flags) : flags;
          mode = typeof mode === "undefined" ? 438 : mode;
          if (flags & 64) {
            mode = mode & 4095 | 32768;
          } else {
            mode = 0;
          }
          var node;
          if (typeof path === "object") {
            node = path;
          } else {
            path = PATH.normalize(path);
            try {
              var lookup = FS.lookupPath(path, { follow: !(flags & 131072) });
              node = lookup.node;
            } catch (e) {
            }
          }
          var created = false;
          if (flags & 64) {
            if (node) {
              if (flags & 128) {
                throw new FS.ErrnoError(20);
              }
            } else {
              node = FS.mknod(path, mode, 0);
              created = true;
            }
          }
          if (!node) {
            throw new FS.ErrnoError(44);
          }
          if (FS.isChrdev(node.mode)) {
            flags &= ~512;
          }
          if (flags & 65536 && !FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
          if (!created) {
            var errCode = FS.mayOpen(node, flags);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
          }
          if (flags & 512) {
            FS.truncate(node, 0);
          }
          flags &= ~(128 | 512 | 131072);
          var stream = FS.createStream({ node, path: FS.getPath(node), flags, seekable: true, position: 0, stream_ops: node.stream_ops, ungotten: [], error: false }, fd_start, fd_end);
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
          if (Module["logReadFiles"] && !(flags & 1)) {
            if (!FS.readFiles)
              FS.readFiles = {};
            if (!(path in FS.readFiles)) {
              FS.readFiles[path] = 1;
              err("FS.trackingDelegate error on read file: " + path);
            }
          }
          try {
            if (FS.trackingDelegate["onOpenFile"]) {
              var trackingFlags = 0;
              if ((flags & 2097155) !== 1) {
                trackingFlags |= FS.tracking.openFlags.READ;
              }
              if ((flags & 2097155) !== 0) {
                trackingFlags |= FS.tracking.openFlags.WRITE;
              }
              FS.trackingDelegate["onOpenFile"](path, trackingFlags);
            }
          } catch (e) {
            err("FS.trackingDelegate['onOpenFile']('" + path + "', flags) threw an exception: " + e.message);
          }
          return stream;
        }, close: function(stream) {
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if (stream.getdents)
            stream.getdents = null;
          try {
            if (stream.stream_ops.close) {
              stream.stream_ops.close(stream);
            }
          } catch (e) {
            throw e;
          } finally {
            FS.closeStream(stream.fd);
          }
          stream.fd = null;
        }, isClosed: function(stream) {
          return stream.fd === null;
        }, llseek: function(stream, offset, whence) {
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if (!stream.seekable || !stream.stream_ops.llseek) {
            throw new FS.ErrnoError(70);
          }
          if (whence != 0 && whence != 1 && whence != 2) {
            throw new FS.ErrnoError(28);
          }
          stream.position = stream.stream_ops.llseek(stream, offset, whence);
          stream.ungotten = [];
          return stream.position;
        }, read: function(stream, buffer2, offset, length, position) {
          offset >>>= 0;
          if (length < 0 || position < 0) {
            throw new FS.ErrnoError(28);
          }
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if ((stream.flags & 2097155) === 1) {
            throw new FS.ErrnoError(8);
          }
          if (FS.isDir(stream.node.mode)) {
            throw new FS.ErrnoError(31);
          }
          if (!stream.stream_ops.read) {
            throw new FS.ErrnoError(28);
          }
          var seeking = typeof position !== "undefined";
          if (!seeking) {
            position = stream.position;
          } else if (!stream.seekable) {
            throw new FS.ErrnoError(70);
          }
          var bytesRead = stream.stream_ops.read(stream, buffer2, offset, length, position);
          if (!seeking)
            stream.position += bytesRead;
          return bytesRead;
        }, write: function(stream, buffer2, offset, length, position, canOwn) {
          offset >>>= 0;
          if (length < 0 || position < 0) {
            throw new FS.ErrnoError(28);
          }
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if ((stream.flags & 2097155) === 0) {
            throw new FS.ErrnoError(8);
          }
          if (FS.isDir(stream.node.mode)) {
            throw new FS.ErrnoError(31);
          }
          if (!stream.stream_ops.write) {
            throw new FS.ErrnoError(28);
          }
          if (stream.seekable && stream.flags & 1024) {
            FS.llseek(stream, 0, 2);
          }
          var seeking = typeof position !== "undefined";
          if (!seeking) {
            position = stream.position;
          } else if (!stream.seekable) {
            throw new FS.ErrnoError(70);
          }
          var bytesWritten = stream.stream_ops.write(stream, buffer2, offset, length, position, canOwn);
          if (!seeking)
            stream.position += bytesWritten;
          try {
            if (stream.path && FS.trackingDelegate["onWriteToFile"])
              FS.trackingDelegate["onWriteToFile"](stream.path);
          } catch (e) {
            err("FS.trackingDelegate['onWriteToFile']('" + stream.path + "') threw an exception: " + e.message);
          }
          return bytesWritten;
        }, allocate: function(stream, offset, length) {
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if (offset < 0 || length <= 0) {
            throw new FS.ErrnoError(28);
          }
          if ((stream.flags & 2097155) === 0) {
            throw new FS.ErrnoError(8);
          }
          if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          if (!stream.stream_ops.allocate) {
            throw new FS.ErrnoError(138);
          }
          stream.stream_ops.allocate(stream, offset, length);
        }, mmap: function(stream, address, length, position, prot, flags) {
          address >>>= 0;
          if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
            throw new FS.ErrnoError(2);
          }
          if ((stream.flags & 2097155) === 1) {
            throw new FS.ErrnoError(2);
          }
          if (!stream.stream_ops.mmap) {
            throw new FS.ErrnoError(43);
          }
          return stream.stream_ops.mmap(stream, address, length, position, prot, flags);
        }, msync: function(stream, buffer2, offset, length, mmapFlags) {
          offset >>>= 0;
          if (!stream || !stream.stream_ops.msync) {
            return 0;
          }
          return stream.stream_ops.msync(stream, buffer2, offset, length, mmapFlags);
        }, munmap: function(stream) {
          return 0;
        }, ioctl: function(stream, cmd, arg) {
          if (!stream.stream_ops.ioctl) {
            throw new FS.ErrnoError(59);
          }
          return stream.stream_ops.ioctl(stream, cmd, arg);
        }, readFile: function(path, opts) {
          opts = opts || {};
          opts.flags = opts.flags || 0;
          opts.encoding = opts.encoding || "binary";
          if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
            throw new Error('Invalid encoding type "' + opts.encoding + '"');
          }
          var ret;
          var stream = FS.open(path, opts.flags);
          var stat = FS.stat(path);
          var length = stat.size;
          var buf = new Uint8Array(length);
          FS.read(stream, buf, 0, length, 0);
          if (opts.encoding === "utf8") {
            ret = UTF8ArrayToString(buf, 0);
          } else if (opts.encoding === "binary") {
            ret = buf;
          }
          FS.close(stream);
          return ret;
        }, writeFile: function(path, data, opts) {
          opts = opts || {};
          opts.flags = opts.flags || 577;
          var stream = FS.open(path, opts.flags, opts.mode);
          if (typeof data === "string") {
            var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
            var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
            FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
          } else if (ArrayBuffer.isView(data)) {
            FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
          } else {
            throw new Error("Unsupported data type");
          }
          FS.close(stream);
        }, cwd: function() {
          return FS.currentPath;
        }, chdir: function(path) {
          var lookup = FS.lookupPath(path, { follow: true });
          if (lookup.node === null) {
            throw new FS.ErrnoError(44);
          }
          if (!FS.isDir(lookup.node.mode)) {
            throw new FS.ErrnoError(54);
          }
          var errCode = FS.nodePermissions(lookup.node, "x");
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          FS.currentPath = lookup.path;
        }, createDefaultDirectories: function() {
          FS.mkdir("/tmp");
          FS.mkdir("/home");
          FS.mkdir("/home/web_user");
        }, createDefaultDevices: function() {
          FS.mkdir("/dev");
          FS.registerDevice(FS.makedev(1, 3), { read: function() {
            return 0;
          }, write: function(stream, buffer2, offset, length, pos) {
            return length;
          } });
          FS.mkdev("/dev/null", FS.makedev(1, 3));
          TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
          TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
          FS.mkdev("/dev/tty", FS.makedev(5, 0));
          FS.mkdev("/dev/tty1", FS.makedev(6, 0));
          var random_device = getRandomDevice();
          FS.createDevice("/dev", "random", random_device);
          FS.createDevice("/dev", "urandom", random_device);
          FS.mkdir("/dev/shm");
          FS.mkdir("/dev/shm/tmp");
        }, createSpecialDirectories: function() {
          FS.mkdir("/proc");
          var proc_self = FS.mkdir("/proc/self");
          FS.mkdir("/proc/self/fd");
          FS.mount({ mount: function() {
            var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
            node.node_ops = { lookup: function(parent, name2) {
              var fd = +name2;
              var stream = FS.getStream(fd);
              if (!stream)
                throw new FS.ErrnoError(8);
              var ret = { parent: null, mount: { mountpoint: "fake" }, node_ops: { readlink: function() {
                return stream.path;
              } } };
              ret.parent = ret;
              return ret;
            } };
            return node;
          } }, {}, "/proc/self/fd");
        }, createStandardStreams: function() {
          if (Module["stdin"]) {
            FS.createDevice("/dev", "stdin", Module["stdin"]);
          } else {
            FS.symlink("/dev/tty", "/dev/stdin");
          }
          if (Module["stdout"]) {
            FS.createDevice("/dev", "stdout", null, Module["stdout"]);
          } else {
            FS.symlink("/dev/tty", "/dev/stdout");
          }
          if (Module["stderr"]) {
            FS.createDevice("/dev", "stderr", null, Module["stderr"]);
          } else {
            FS.symlink("/dev/tty1", "/dev/stderr");
          }
          var stdin = FS.open("/dev/stdin", 0);
          var stdout = FS.open("/dev/stdout", 1);
          var stderr = FS.open("/dev/stderr", 1);
        }, ensureErrnoError: function() {
          if (FS.ErrnoError)
            return;
          FS.ErrnoError = /* @__PURE__ */ __name(function ErrnoError(errno, node) {
            this.node = node;
            this.setErrno = function(errno2) {
              this.errno = errno2;
            };
            this.setErrno(errno);
            this.message = "FS error";
          }, "ErrnoError");
          FS.ErrnoError.prototype = new Error();
          FS.ErrnoError.prototype.constructor = FS.ErrnoError;
          [44].forEach(function(code) {
            FS.genericErrors[code] = new FS.ErrnoError(code);
            FS.genericErrors[code].stack = "<generic error, no stack>";
          });
        }, staticInit: function() {
          FS.ensureErrnoError();
          FS.nameTable = new Array(4096);
          FS.mount(MEMFS, {}, "/");
          FS.createDefaultDirectories();
          FS.createDefaultDevices();
          FS.createSpecialDirectories();
          FS.filesystems = { "MEMFS": MEMFS };
        }, init: function(input, output, error) {
          FS.init.initialized = true;
          FS.ensureErrnoError();
          Module["stdin"] = input || Module["stdin"];
          Module["stdout"] = output || Module["stdout"];
          Module["stderr"] = error || Module["stderr"];
          FS.createStandardStreams();
        }, quit: function() {
          FS.init.initialized = false;
          var fflush = Module["_fflush"];
          if (fflush)
            fflush(0);
          for (var i = 0; i < FS.streams.length; i++) {
            var stream = FS.streams[i];
            if (!stream) {
              continue;
            }
            FS.close(stream);
          }
        }, getMode: function(canRead, canWrite) {
          var mode = 0;
          if (canRead)
            mode |= 292 | 73;
          if (canWrite)
            mode |= 146;
          return mode;
        }, findObject: function(path, dontResolveLastLink) {
          var ret = FS.analyzePath(path, dontResolveLastLink);
          if (ret.exists) {
            return ret.object;
          } else {
            return null;
          }
        }, analyzePath: function(path, dontResolveLastLink) {
          try {
            var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
            path = lookup.path;
          } catch (e) {
          }
          var ret = { isRoot: false, exists: false, error: 0, name: null, path: null, object: null, parentExists: false, parentPath: null, parentObject: null };
          try {
            var lookup = FS.lookupPath(path, { parent: true });
            ret.parentExists = true;
            ret.parentPath = lookup.path;
            ret.parentObject = lookup.node;
            ret.name = PATH.basename(path);
            lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
            ret.exists = true;
            ret.path = lookup.path;
            ret.object = lookup.node;
            ret.name = lookup.node.name;
            ret.isRoot = lookup.path === "/";
          } catch (e) {
            ret.error = e.errno;
          }
          return ret;
        }, createPath: function(parent, path, canRead, canWrite) {
          parent = typeof parent === "string" ? parent : FS.getPath(parent);
          var parts = path.split("/").reverse();
          while (parts.length) {
            var part = parts.pop();
            if (!part)
              continue;
            var current = PATH.join2(parent, part);
            try {
              FS.mkdir(current);
            } catch (e) {
            }
            parent = current;
          }
          return current;
        }, createFile: function(parent, name2, properties, canRead, canWrite) {
          var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name2);
          var mode = FS.getMode(canRead, canWrite);
          return FS.create(path, mode);
        }, createDataFile: function(parent, name2, data, canRead, canWrite, canOwn) {
          var path = name2 ? PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name2) : parent;
          var mode = FS.getMode(canRead, canWrite);
          var node = FS.create(path, mode);
          if (data) {
            if (typeof data === "string") {
              var arr = new Array(data.length);
              for (var i = 0, len = data.length; i < len; ++i)
                arr[i] = data.charCodeAt(i);
              data = arr;
            }
            FS.chmod(node, mode | 146);
            var stream = FS.open(node, 577);
            FS.write(stream, data, 0, data.length, 0, canOwn);
            FS.close(stream);
            FS.chmod(node, mode);
          }
          return node;
        }, createDevice: function(parent, name2, input, output) {
          var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name2);
          var mode = FS.getMode(!!input, !!output);
          if (!FS.createDevice.major)
            FS.createDevice.major = 64;
          var dev = FS.makedev(FS.createDevice.major++, 0);
          FS.registerDevice(dev, { open: function(stream) {
            stream.seekable = false;
          }, close: function(stream) {
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          }, read: function(stream, buffer2, offset, length, pos) {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === void 0 && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === void 0)
                break;
              bytesRead++;
              buffer2[offset + i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          }, write: function(stream, buffer2, offset, length, pos) {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer2[offset + i]);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          } });
          return FS.mkdev(path, mode, dev);
        }, forceLoadFile: function(obj) {
          if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
            return true;
          if (typeof XMLHttpRequest !== "undefined") {
            throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
          } else if (read_) {
            try {
              obj.contents = intArrayFromString(read_(obj.url), true);
              obj.usedBytes = obj.contents.length;
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          } else {
            throw new Error("Cannot load without read() or XMLHttpRequest.");
          }
        }, createLazyFile: function(parent, name2, url, canRead, canWrite) {
          function LazyUint8Array() {
            this.lengthKnown = false;
            this.chunks = [];
          }
          __name(LazyUint8Array, "LazyUint8Array");
          LazyUint8Array.prototype.get = /* @__PURE__ */ __name(function LazyUint8Array_get(idx) {
            if (idx > this.length - 1 || idx < 0) {
              return void 0;
            }
            var chunkOffset = idx % this.chunkSize;
            var chunkNum = idx / this.chunkSize | 0;
            return this.getter(chunkNum)[chunkOffset];
          }, "LazyUint8Array_get");
          LazyUint8Array.prototype.setDataGetter = /* @__PURE__ */ __name(function LazyUint8Array_setDataGetter(getter) {
            this.getter = getter;
          }, "LazyUint8Array_setDataGetter");
          LazyUint8Array.prototype.cacheLength = /* @__PURE__ */ __name(function LazyUint8Array_cacheLength() {
            var xhr = new XMLHttpRequest();
            xhr.open("HEAD", url, false);
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
              throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            var datalength = Number(xhr.getResponseHeader("Content-length"));
            var header;
            var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
            var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
            var chunkSize = 1024 * 1024;
            if (!hasByteServing)
              chunkSize = datalength;
            var doXHR = /* @__PURE__ */ __name(function(from, to) {
              if (from > to)
                throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
              if (to > datalength - 1)
                throw new Error("only " + datalength + " bytes available! programmer error!");
              var xhr2 = new XMLHttpRequest();
              xhr2.open("GET", url, false);
              if (datalength !== chunkSize)
                xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
              if (typeof Uint8Array != "undefined")
                xhr2.responseType = "arraybuffer";
              if (xhr2.overrideMimeType) {
                xhr2.overrideMimeType("text/plain; charset=x-user-defined");
              }
              xhr2.send(null);
              if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
                throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
              if (xhr2.response !== void 0) {
                return new Uint8Array(xhr2.response || []);
              } else {
                return intArrayFromString(xhr2.responseText || "", true);
              }
            }, "doXHR");
            var lazyArray2 = this;
            lazyArray2.setDataGetter(function(chunkNum) {
              var start = chunkNum * chunkSize;
              var end = (chunkNum + 1) * chunkSize - 1;
              end = Math.min(end, datalength - 1);
              if (typeof lazyArray2.chunks[chunkNum] === "undefined") {
                lazyArray2.chunks[chunkNum] = doXHR(start, end);
              }
              if (typeof lazyArray2.chunks[chunkNum] === "undefined")
                throw new Error("doXHR failed!");
              return lazyArray2.chunks[chunkNum];
            });
            if (usesGzip || !datalength) {
              chunkSize = datalength = 1;
              datalength = this.getter(0).length;
              chunkSize = datalength;
              out("LazyFiles on gzip forces download of the whole file when length is accessed");
            }
            this._length = datalength;
            this._chunkSize = chunkSize;
            this.lengthKnown = true;
          }, "LazyUint8Array_cacheLength");
          if (typeof XMLHttpRequest !== "undefined") {
            if (!ENVIRONMENT_IS_WORKER)
              throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
            var lazyArray = new LazyUint8Array();
            Object.defineProperties(lazyArray, { length: { get: function() {
              if (!this.lengthKnown) {
                this.cacheLength();
              }
              return this._length;
            } }, chunkSize: { get: function() {
              if (!this.lengthKnown) {
                this.cacheLength();
              }
              return this._chunkSize;
            } } });
            var properties = { isDevice: false, contents: lazyArray };
          } else {
            var properties = { isDevice: false, url };
          }
          var node = FS.createFile(parent, name2, properties, canRead, canWrite);
          if (properties.contents) {
            node.contents = properties.contents;
          } else if (properties.url) {
            node.contents = null;
            node.url = properties.url;
          }
          Object.defineProperties(node, { usedBytes: { get: function() {
            return this.contents.length;
          } } });
          var stream_ops = {};
          var keys = Object.keys(node.stream_ops);
          keys.forEach(function(key2) {
            var fn = node.stream_ops[key2];
            stream_ops[key2] = /* @__PURE__ */ __name(function forceLoadLazyFile() {
              FS.forceLoadFile(node);
              return fn.apply(null, arguments);
            }, "forceLoadLazyFile");
          });
          stream_ops.read = /* @__PURE__ */ __name(function stream_ops_read(stream, buffer2, offset, length, position) {
            FS.forceLoadFile(node);
            var contents = stream.node.contents;
            if (position >= contents.length)
              return 0;
            var size = Math.min(contents.length - position, length);
            if (contents.slice) {
              for (var i = 0; i < size; i++) {
                buffer2[offset + i] = contents[position + i];
              }
            } else {
              for (var i = 0; i < size; i++) {
                buffer2[offset + i] = contents.get(position + i);
              }
            }
            return size;
          }, "stream_ops_read");
          node.stream_ops = stream_ops;
          return node;
        }, createPreloadedFile: function(parent, name2, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
          Browser.init();
          var fullname = name2 ? PATH_FS.resolve(PATH.join2(parent, name2)) : parent;
          var dep = getUniqueRunDependency("cp " + fullname);
          function processData(byteArray) {
            function finish(byteArray2) {
              if (preFinish)
                preFinish();
              if (!dontCreateFile) {
                FS.createDataFile(parent, name2, byteArray2, canRead, canWrite, canOwn);
              }
              if (onload)
                onload();
              removeRunDependency(dep);
            }
            __name(finish, "finish");
            var handled = false;
            Module["preloadPlugins"].forEach(function(plugin) {
              if (handled)
                return;
              if (plugin["canHandle"](fullname)) {
                plugin["handle"](byteArray, fullname, finish, function() {
                  if (onerror)
                    onerror();
                  removeRunDependency(dep);
                });
                handled = true;
              }
            });
            if (!handled)
              finish(byteArray);
          }
          __name(processData, "processData");
          addRunDependency(dep);
          if (typeof url == "string") {
            asyncLoad(url, function(byteArray) {
              processData(byteArray);
            }, onerror);
          } else {
            processData(url);
          }
        }, indexedDB: function() {
          return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
        }, DB_NAME: function() {
          return "EM_FS_" + window.location.pathname;
        }, DB_VERSION: 20, DB_STORE_NAME: "FILE_DATA", saveFilesToDB: function(paths, onload, onerror) {
          onload = onload || function() {
          };
          onerror = onerror || function() {
          };
          var indexedDB = FS.indexedDB();
          try {
            var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
          } catch (e) {
            return onerror(e);
          }
          openRequest.onupgradeneeded = /* @__PURE__ */ __name(function openRequest_onupgradeneeded() {
            out("creating db");
            var db = openRequest.result;
            db.createObjectStore(FS.DB_STORE_NAME);
          }, "openRequest_onupgradeneeded");
          openRequest.onsuccess = /* @__PURE__ */ __name(function openRequest_onsuccess() {
            var db = openRequest.result;
            var transaction = db.transaction([FS.DB_STORE_NAME], "readwrite");
            var files = transaction.objectStore(FS.DB_STORE_NAME);
            var ok = 0, fail = 0, total = paths.length;
            function finish() {
              if (fail == 0)
                onload();
              else
                onerror();
            }
            __name(finish, "finish");
            paths.forEach(function(path) {
              var putRequest = files.put(FS.analyzePath(path).object.contents, path);
              putRequest.onsuccess = /* @__PURE__ */ __name(function putRequest_onsuccess() {
                ok++;
                if (ok + fail == total)
                  finish();
              }, "putRequest_onsuccess");
              putRequest.onerror = /* @__PURE__ */ __name(function putRequest_onerror() {
                fail++;
                if (ok + fail == total)
                  finish();
              }, "putRequest_onerror");
            });
            transaction.onerror = onerror;
          }, "openRequest_onsuccess");
          openRequest.onerror = onerror;
        }, loadFilesFromDB: function(paths, onload, onerror) {
          onload = onload || function() {
          };
          onerror = onerror || function() {
          };
          var indexedDB = FS.indexedDB();
          try {
            var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
          } catch (e) {
            return onerror(e);
          }
          openRequest.onupgradeneeded = onerror;
          openRequest.onsuccess = /* @__PURE__ */ __name(function openRequest_onsuccess() {
            var db = openRequest.result;
            try {
              var transaction = db.transaction([FS.DB_STORE_NAME], "readonly");
            } catch (e) {
              onerror(e);
              return;
            }
            var files = transaction.objectStore(FS.DB_STORE_NAME);
            var ok = 0, fail = 0, total = paths.length;
            function finish() {
              if (fail == 0)
                onload();
              else
                onerror();
            }
            __name(finish, "finish");
            paths.forEach(function(path) {
              var getRequest = files.get(path);
              getRequest.onsuccess = /* @__PURE__ */ __name(function getRequest_onsuccess() {
                if (FS.analyzePath(path).exists) {
                  FS.unlink(path);
                }
                FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
                ok++;
                if (ok + fail == total)
                  finish();
              }, "getRequest_onsuccess");
              getRequest.onerror = /* @__PURE__ */ __name(function getRequest_onerror() {
                fail++;
                if (ok + fail == total)
                  finish();
              }, "getRequest_onerror");
            });
            transaction.onerror = onerror;
          }, "openRequest_onsuccess");
          openRequest.onerror = onerror;
        } };
        var SYSCALLS = { mappings: {}, DEFAULT_POLLMASK: 5, umask: 511, calculateAt: function(dirfd, path, allowEmpty) {
          if (path[0] === "/") {
            return path;
          }
          var dir;
          if (dirfd === -100) {
            dir = FS.cwd();
          } else {
            var dirstream = FS.getStream(dirfd);
            if (!dirstream)
              throw new FS.ErrnoError(8);
            dir = dirstream.path;
          }
          if (path.length == 0) {
            if (!allowEmpty) {
              throw new FS.ErrnoError(44);
            }
            return dir;
          }
          return PATH.join2(dir, path);
        }, doStat: function(func, path, buf) {
          try {
            var stat = func(path);
          } catch (e) {
            if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
              return -54;
            }
            throw e;
          }
          GROWABLE_HEAP_I32()[buf >>> 2] = stat.dev;
          GROWABLE_HEAP_I32()[buf + 4 >>> 2] = 0;
          GROWABLE_HEAP_I32()[buf + 8 >>> 2] = stat.ino;
          GROWABLE_HEAP_I32()[buf + 12 >>> 2] = stat.mode;
          GROWABLE_HEAP_I32()[buf + 16 >>> 2] = stat.nlink;
          GROWABLE_HEAP_I32()[buf + 20 >>> 2] = stat.uid;
          GROWABLE_HEAP_I32()[buf + 24 >>> 2] = stat.gid;
          GROWABLE_HEAP_I32()[buf + 28 >>> 2] = stat.rdev;
          GROWABLE_HEAP_I32()[buf + 32 >>> 2] = 0;
          tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], GROWABLE_HEAP_I32()[buf + 40 >>> 2] = tempI64[0], GROWABLE_HEAP_I32()[buf + 44 >>> 2] = tempI64[1];
          GROWABLE_HEAP_I32()[buf + 48 >>> 2] = 4096;
          GROWABLE_HEAP_I32()[buf + 52 >>> 2] = stat.blocks;
          GROWABLE_HEAP_I32()[buf + 56 >>> 2] = stat.atime.getTime() / 1e3 | 0;
          GROWABLE_HEAP_I32()[buf + 60 >>> 2] = 0;
          GROWABLE_HEAP_I32()[buf + 64 >>> 2] = stat.mtime.getTime() / 1e3 | 0;
          GROWABLE_HEAP_I32()[buf + 68 >>> 2] = 0;
          GROWABLE_HEAP_I32()[buf + 72 >>> 2] = stat.ctime.getTime() / 1e3 | 0;
          GROWABLE_HEAP_I32()[buf + 76 >>> 2] = 0;
          tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], GROWABLE_HEAP_I32()[buf + 80 >>> 2] = tempI64[0], GROWABLE_HEAP_I32()[buf + 84 >>> 2] = tempI64[1];
          return 0;
        }, doMsync: function(addr, stream, len, flags, offset) {
          var buffer2 = GROWABLE_HEAP_U8().slice(addr, addr + len);
          FS.msync(stream, buffer2, offset, len, flags);
        }, doMkdir: function(path, mode) {
          path = PATH.normalize(path);
          if (path[path.length - 1] === "/")
            path = path.substr(0, path.length - 1);
          FS.mkdir(path, mode, 0);
          return 0;
        }, doMknod: function(path, mode, dev) {
          switch (mode & 61440) {
            case 32768:
            case 8192:
            case 24576:
            case 4096:
            case 49152:
              break;
            default:
              return -28;
          }
          FS.mknod(path, mode, dev);
          return 0;
        }, doReadlink: function(path, buf, bufsize) {
          if (bufsize <= 0)
            return -28;
          var ret = FS.readlink(path);
          var len = Math.min(bufsize, lengthBytesUTF8(ret));
          var endChar = GROWABLE_HEAP_I8()[buf + len >>> 0];
          stringToUTF8(ret, buf, bufsize + 1);
          GROWABLE_HEAP_I8()[buf + len >>> 0] = endChar;
          return len;
        }, doAccess: function(path, amode) {
          if (amode & ~7) {
            return -28;
          }
          var node;
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
          if (!node) {
            return -44;
          }
          var perms = "";
          if (amode & 4)
            perms += "r";
          if (amode & 2)
            perms += "w";
          if (amode & 1)
            perms += "x";
          if (perms && FS.nodePermissions(node, perms)) {
            return -2;
          }
          return 0;
        }, doDup: function(path, flags, suggestFD) {
          var suggest = FS.getStream(suggestFD);
          if (suggest)
            FS.close(suggest);
          return FS.open(path, flags, 0, suggestFD, suggestFD).fd;
        }, doReadv: function(stream, iov, iovcnt, offset) {
          var ret = 0;
          for (var i = 0; i < iovcnt; i++) {
            var ptr = GROWABLE_HEAP_I32()[iov + i * 8 >>> 2];
            var len = GROWABLE_HEAP_I32()[iov + (i * 8 + 4) >>> 2];
            var curr = FS.read(stream, GROWABLE_HEAP_I8(), ptr, len, offset);
            if (curr < 0)
              return -1;
            ret += curr;
            if (curr < len)
              break;
          }
          return ret;
        }, doWritev: function(stream, iov, iovcnt, offset) {
          var ret = 0;
          for (var i = 0; i < iovcnt; i++) {
            var ptr = GROWABLE_HEAP_I32()[iov + i * 8 >>> 2];
            var len = GROWABLE_HEAP_I32()[iov + (i * 8 + 4) >>> 2];
            var curr = FS.write(stream, GROWABLE_HEAP_I8(), ptr, len, offset);
            if (curr < 0)
              return -1;
            ret += curr;
          }
          return ret;
        }, varargs: void 0, get: function() {
          SYSCALLS.varargs += 4;
          var ret = GROWABLE_HEAP_I32()[SYSCALLS.varargs - 4 >>> 2];
          return ret;
        }, getStr: function(ptr) {
          var ret = UTF8ToString(ptr);
          return ret;
        }, getStreamFromFD: function(fd) {
          var stream = FS.getStream(fd);
          if (!stream)
            throw new FS.ErrnoError(8);
          return stream;
        }, get64: function(low, high) {
          return low;
        } };
        function ___sys_fcntl64(fd, cmd, varargs) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(2, 1, fd, cmd, varargs);
          SYSCALLS.varargs = varargs;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            switch (cmd) {
              case 0: {
                var arg = SYSCALLS.get();
                if (arg < 0) {
                  return -28;
                }
                var newStream;
                newStream = FS.open(stream.path, stream.flags, 0, arg);
                return newStream.fd;
              }
              case 1:
              case 2:
                return 0;
              case 3:
                return stream.flags;
              case 4: {
                var arg = SYSCALLS.get();
                stream.flags |= arg;
                return 0;
              }
              case 12: {
                var arg = SYSCALLS.get();
                var offset = 0;
                GROWABLE_HEAP_I16()[arg + offset >>> 1] = 2;
                return 0;
              }
              case 13:
              case 14:
                return 0;
              case 16:
              case 8:
                return -28;
              case 9:
                setErrNo(28);
                return -1;
              default: {
                return -28;
              }
            }
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return -e.errno;
          }
        }
        __name(___sys_fcntl64, "___sys_fcntl64");
        function ___sys_ioctl(fd, op, varargs) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(3, 1, fd, op, varargs);
          SYSCALLS.varargs = varargs;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            switch (op) {
              case 21509:
              case 21505: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              case 21510:
              case 21511:
              case 21512:
              case 21506:
              case 21507:
              case 21508: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              case 21519: {
                if (!stream.tty)
                  return -59;
                var argp = SYSCALLS.get();
                GROWABLE_HEAP_I32()[argp >>> 2] = 0;
                return 0;
              }
              case 21520: {
                if (!stream.tty)
                  return -59;
                return -28;
              }
              case 21531: {
                var argp = SYSCALLS.get();
                return FS.ioctl(stream, op, argp);
              }
              case 21523: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              case 21524: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              default:
                abort("bad ioctl syscall " + op);
            }
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return -e.errno;
          }
        }
        __name(___sys_ioctl, "___sys_ioctl");
        function ___sys_open(path, flags, varargs) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(4, 1, path, flags, varargs);
          SYSCALLS.varargs = varargs;
          try {
            var pathname = SYSCALLS.getStr(path);
            var mode = varargs ? SYSCALLS.get() : 0;
            var stream = FS.open(pathname, flags, mode);
            return stream.fd;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return -e.errno;
          }
        }
        __name(___sys_open, "___sys_open");
        var tupleRegistrations = {};
        function runDestructors(destructors) {
          while (destructors.length) {
            var ptr = destructors.pop();
            var del = destructors.pop();
            del(ptr);
          }
        }
        __name(runDestructors, "runDestructors");
        function simpleReadValueFromPointer(pointer) {
          return this["fromWireType"](GROWABLE_HEAP_U32()[pointer >>> 2]);
        }
        __name(simpleReadValueFromPointer, "simpleReadValueFromPointer");
        var awaitingDependencies = {};
        var registeredTypes = {};
        var typeDependencies = {};
        var char_0 = 48;
        var char_9 = 57;
        function makeLegalFunctionName(name2) {
          if (name2 === void 0) {
            return "_unknown";
          }
          name2 = name2.replace(/[^a-zA-Z0-9_]/g, "$");
          var f = name2.charCodeAt(0);
          if (f >= char_0 && f <= char_9) {
            return "_" + name2;
          } else {
            return name2;
          }
        }
        __name(makeLegalFunctionName, "makeLegalFunctionName");
        function createNamedFunction(name2, body) {
          name2 = makeLegalFunctionName(name2);
          return new Function("body", "return function " + name2 + '() {\n    "use strict";    return body.apply(this, arguments);\n};\n')(body);
        }
        __name(createNamedFunction, "createNamedFunction");
        function extendError(baseErrorType, errorName) {
          var errorClass = createNamedFunction(errorName, function(message) {
            this.name = errorName;
            this.message = message;
            var stack = new Error(message).stack;
            if (stack !== void 0) {
              this.stack = this.toString() + "\n" + stack.replace(/^Error(:[^\n]*)?\n/, "");
            }
          });
          errorClass.prototype = Object.create(baseErrorType.prototype);
          errorClass.prototype.constructor = errorClass;
          errorClass.prototype.toString = function() {
            if (this.message === void 0) {
              return this.name;
            } else {
              return this.name + ": " + this.message;
            }
          };
          return errorClass;
        }
        __name(extendError, "extendError");
        var InternalError = void 0;
        function throwInternalError(message) {
          throw new InternalError(message);
        }
        __name(throwInternalError, "throwInternalError");
        function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {
          myTypes.forEach(function(type) {
            typeDependencies[type] = dependentTypes;
          });
          function onComplete(typeConverters2) {
            var myTypeConverters = getTypeConverters(typeConverters2);
            if (myTypeConverters.length !== myTypes.length) {
              throwInternalError("Mismatched type converter count");
            }
            for (var i = 0; i < myTypes.length; ++i) {
              registerType(myTypes[i], myTypeConverters[i]);
            }
          }
          __name(onComplete, "onComplete");
          var typeConverters = new Array(dependentTypes.length);
          var unregisteredTypes = [];
          var registered = 0;
          dependentTypes.forEach(function(dt, i) {
            if (registeredTypes.hasOwnProperty(dt)) {
              typeConverters[i] = registeredTypes[dt];
            } else {
              unregisteredTypes.push(dt);
              if (!awaitingDependencies.hasOwnProperty(dt)) {
                awaitingDependencies[dt] = [];
              }
              awaitingDependencies[dt].push(function() {
                typeConverters[i] = registeredTypes[dt];
                ++registered;
                if (registered === unregisteredTypes.length) {
                  onComplete(typeConverters);
                }
              });
            }
          });
          if (unregisteredTypes.length === 0) {
            onComplete(typeConverters);
          }
        }
        __name(whenDependentTypesAreResolved, "whenDependentTypesAreResolved");
        function __embind_finalize_value_array(rawTupleType) {
          var reg = tupleRegistrations[rawTupleType];
          delete tupleRegistrations[rawTupleType];
          var elements = reg.elements;
          var elementsLength = elements.length;
          var elementTypes = elements.map(function(elt) {
            return elt.getterReturnType;
          }).concat(elements.map(function(elt) {
            return elt.setterArgumentType;
          }));
          var rawConstructor = reg.rawConstructor;
          var rawDestructor = reg.rawDestructor;
          whenDependentTypesAreResolved([rawTupleType], elementTypes, function(elementTypes2) {
            elements.forEach(function(elt, i) {
              var getterReturnType = elementTypes2[i];
              var getter = elt.getter;
              var getterContext = elt.getterContext;
              var setterArgumentType = elementTypes2[i + elementsLength];
              var setter = elt.setter;
              var setterContext = elt.setterContext;
              elt.read = function(ptr) {
                return getterReturnType["fromWireType"](getter(getterContext, ptr));
              };
              elt.write = function(ptr, o) {
                var destructors = [];
                setter(setterContext, ptr, setterArgumentType["toWireType"](destructors, o));
                runDestructors(destructors);
              };
            });
            return [{ name: reg.name, "fromWireType": function(ptr) {
              var rv = new Array(elementsLength);
              for (var i = 0; i < elementsLength; ++i) {
                rv[i] = elements[i].read(ptr);
              }
              rawDestructor(ptr);
              return rv;
            }, "toWireType": function(destructors, o) {
              if (elementsLength !== o.length) {
                throw new TypeError("Incorrect number of tuple elements for " + reg.name + ": expected=" + elementsLength + ", actual=" + o.length);
              }
              var ptr = rawConstructor();
              for (var i = 0; i < elementsLength; ++i) {
                elements[i].write(ptr, o[i]);
              }
              if (destructors !== null) {
                destructors.push(rawDestructor, ptr);
              }
              return ptr;
            }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: rawDestructor }];
          });
        }
        __name(__embind_finalize_value_array, "__embind_finalize_value_array");
        var structRegistrations = {};
        function __embind_finalize_value_object(structType) {
          var reg = structRegistrations[structType];
          delete structRegistrations[structType];
          var rawConstructor = reg.rawConstructor;
          var rawDestructor = reg.rawDestructor;
          var fieldRecords = reg.fields;
          var fieldTypes = fieldRecords.map(function(field) {
            return field.getterReturnType;
          }).concat(fieldRecords.map(function(field) {
            return field.setterArgumentType;
          }));
          whenDependentTypesAreResolved([structType], fieldTypes, function(fieldTypes2) {
            var fields = {};
            fieldRecords.forEach(function(field, i) {
              var fieldName = field.fieldName;
              var getterReturnType = fieldTypes2[i];
              var getter = field.getter;
              var getterContext = field.getterContext;
              var setterArgumentType = fieldTypes2[i + fieldRecords.length];
              var setter = field.setter;
              var setterContext = field.setterContext;
              fields[fieldName] = { read: function(ptr) {
                return getterReturnType["fromWireType"](getter(getterContext, ptr));
              }, write: function(ptr, o) {
                var destructors = [];
                setter(setterContext, ptr, setterArgumentType["toWireType"](destructors, o));
                runDestructors(destructors);
              } };
            });
            return [{ name: reg.name, "fromWireType": function(ptr) {
              var rv = {};
              for (var i in fields) {
                rv[i] = fields[i].read(ptr);
              }
              rawDestructor(ptr);
              return rv;
            }, "toWireType": function(destructors, o) {
              for (var fieldName in fields) {
                if (!(fieldName in o)) {
                  throw new TypeError('Missing field:  "' + fieldName + '"');
                }
              }
              var ptr = rawConstructor();
              for (fieldName in fields) {
                fields[fieldName].write(ptr, o[fieldName]);
              }
              if (destructors !== null) {
                destructors.push(rawDestructor, ptr);
              }
              return ptr;
            }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: rawDestructor }];
          });
        }
        __name(__embind_finalize_value_object, "__embind_finalize_value_object");
        function __embind_register_bigint(primitiveType, name2, size, minRange, maxRange) {
        }
        __name(__embind_register_bigint, "__embind_register_bigint");
        function getShiftFromSize(size) {
          switch (size) {
            case 1:
              return 0;
            case 2:
              return 1;
            case 4:
              return 2;
            case 8:
              return 3;
            default:
              throw new TypeError("Unknown type size: " + size);
          }
        }
        __name(getShiftFromSize, "getShiftFromSize");
        function embind_init_charCodes() {
          var codes = new Array(256);
          for (var i = 0; i < 256; ++i) {
            codes[i] = String.fromCharCode(i);
          }
          embind_charCodes = codes;
        }
        __name(embind_init_charCodes, "embind_init_charCodes");
        var embind_charCodes = void 0;
        function readLatin1String(ptr) {
          var ret = "";
          var c = ptr;
          while (GROWABLE_HEAP_U8()[c >>> 0]) {
            ret += embind_charCodes[GROWABLE_HEAP_U8()[c++ >>> 0]];
          }
          return ret;
        }
        __name(readLatin1String, "readLatin1String");
        var BindingError = void 0;
        function throwBindingError(message) {
          throw new BindingError(message);
        }
        __name(throwBindingError, "throwBindingError");
        function registerType(rawType, registeredInstance, options) {
          options = options || {};
          if (!("argPackAdvance" in registeredInstance)) {
            throw new TypeError("registerType registeredInstance requires argPackAdvance");
          }
          var name2 = registeredInstance.name;
          if (!rawType) {
            throwBindingError('type "' + name2 + '" must have a positive integer typeid pointer');
          }
          if (registeredTypes.hasOwnProperty(rawType)) {
            if (options.ignoreDuplicateRegistrations) {
              return;
            } else {
              throwBindingError("Cannot register type '" + name2 + "' twice");
            }
          }
          registeredTypes[rawType] = registeredInstance;
          delete typeDependencies[rawType];
          if (awaitingDependencies.hasOwnProperty(rawType)) {
            var callbacks = awaitingDependencies[rawType];
            delete awaitingDependencies[rawType];
            callbacks.forEach(function(cb) {
              cb();
            });
          }
        }
        __name(registerType, "registerType");
        function __embind_register_bool(rawType, name2, size, trueValue, falseValue) {
          var shift = getShiftFromSize(size);
          name2 = readLatin1String(name2);
          registerType(rawType, { name: name2, "fromWireType": function(wt) {
            return !!wt;
          }, "toWireType": function(destructors, o) {
            return o ? trueValue : falseValue;
          }, "argPackAdvance": 8, "readValueFromPointer": function(pointer) {
            var heap;
            if (size === 1) {
              heap = GROWABLE_HEAP_I8();
            } else if (size === 2) {
              heap = GROWABLE_HEAP_I16();
            } else if (size === 4) {
              heap = GROWABLE_HEAP_I32();
            } else {
              throw new TypeError("Unknown boolean type size: " + name2);
            }
            return this["fromWireType"](heap[pointer >>> shift]);
          }, destructorFunction: null });
        }
        __name(__embind_register_bool, "__embind_register_bool");
        function ClassHandle_isAliasOf(other) {
          if (!(this instanceof ClassHandle)) {
            return false;
          }
          if (!(other instanceof ClassHandle)) {
            return false;
          }
          var leftClass = this.$$.ptrType.registeredClass;
          var left = this.$$.ptr;
          var rightClass = other.$$.ptrType.registeredClass;
          var right = other.$$.ptr;
          while (leftClass.baseClass) {
            left = leftClass.upcast(left);
            leftClass = leftClass.baseClass;
          }
          while (rightClass.baseClass) {
            right = rightClass.upcast(right);
            rightClass = rightClass.baseClass;
          }
          return leftClass === rightClass && left === right;
        }
        __name(ClassHandle_isAliasOf, "ClassHandle_isAliasOf");
        function shallowCopyInternalPointer(o) {
          return { count: o.count, deleteScheduled: o.deleteScheduled, preservePointerOnDelete: o.preservePointerOnDelete, ptr: o.ptr, ptrType: o.ptrType, smartPtr: o.smartPtr, smartPtrType: o.smartPtrType };
        }
        __name(shallowCopyInternalPointer, "shallowCopyInternalPointer");
        function throwInstanceAlreadyDeleted(obj) {
          function getInstanceTypeName(handle) {
            return handle.$$.ptrType.registeredClass.name;
          }
          __name(getInstanceTypeName, "getInstanceTypeName");
          throwBindingError(getInstanceTypeName(obj) + " instance already deleted");
        }
        __name(throwInstanceAlreadyDeleted, "throwInstanceAlreadyDeleted");
        var finalizationGroup = false;
        function detachFinalizer(handle) {
        }
        __name(detachFinalizer, "detachFinalizer");
        function runDestructor($$) {
          if ($$.smartPtr) {
            $$.smartPtrType.rawDestructor($$.smartPtr);
          } else {
            $$.ptrType.registeredClass.rawDestructor($$.ptr);
          }
        }
        __name(runDestructor, "runDestructor");
        function releaseClassHandle($$) {
          $$.count.value -= 1;
          var toDelete = $$.count.value === 0;
          if (toDelete) {
            runDestructor($$);
          }
        }
        __name(releaseClassHandle, "releaseClassHandle");
        function attachFinalizer(handle) {
          if (typeof FinalizationGroup === "undefined") {
            attachFinalizer = /* @__PURE__ */ __name(function(handle2) {
              return handle2;
            }, "attachFinalizer");
            return handle;
          }
          finalizationGroup = new FinalizationGroup(function(iter) {
            for (var result = iter.next(); !result.done; result = iter.next()) {
              var $$ = result.value;
              if (!$$.ptr) {
                console.warn("object already deleted: " + $$.ptr);
              } else {
                releaseClassHandle($$);
              }
            }
          });
          attachFinalizer = /* @__PURE__ */ __name(function(handle2) {
            finalizationGroup.register(handle2, handle2.$$, handle2.$$);
            return handle2;
          }, "attachFinalizer");
          detachFinalizer = /* @__PURE__ */ __name(function(handle2) {
            finalizationGroup.unregister(handle2.$$);
          }, "detachFinalizer");
          return attachFinalizer(handle);
        }
        __name(attachFinalizer, "attachFinalizer");
        function ClassHandle_clone() {
          if (!this.$$.ptr) {
            throwInstanceAlreadyDeleted(this);
          }
          if (this.$$.preservePointerOnDelete) {
            this.$$.count.value += 1;
            return this;
          } else {
            var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), { $$: { value: shallowCopyInternalPointer(this.$$) } }));
            clone.$$.count.value += 1;
            clone.$$.deleteScheduled = false;
            return clone;
          }
        }
        __name(ClassHandle_clone, "ClassHandle_clone");
        function ClassHandle_delete() {
          if (!this.$$.ptr) {
            throwInstanceAlreadyDeleted(this);
          }
          if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
            throwBindingError("Object already scheduled for deletion");
          }
          detachFinalizer(this);
          releaseClassHandle(this.$$);
          if (!this.$$.preservePointerOnDelete) {
            this.$$.smartPtr = void 0;
            this.$$.ptr = void 0;
          }
        }
        __name(ClassHandle_delete, "ClassHandle_delete");
        function ClassHandle_isDeleted() {
          return !this.$$.ptr;
        }
        __name(ClassHandle_isDeleted, "ClassHandle_isDeleted");
        var delayFunction = void 0;
        var deletionQueue = [];
        function flushPendingDeletes() {
          while (deletionQueue.length) {
            var obj = deletionQueue.pop();
            obj.$$.deleteScheduled = false;
            obj["delete"]();
          }
        }
        __name(flushPendingDeletes, "flushPendingDeletes");
        function ClassHandle_deleteLater() {
          if (!this.$$.ptr) {
            throwInstanceAlreadyDeleted(this);
          }
          if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
            throwBindingError("Object already scheduled for deletion");
          }
          deletionQueue.push(this);
          if (deletionQueue.length === 1 && delayFunction) {
            delayFunction(flushPendingDeletes);
          }
          this.$$.deleteScheduled = true;
          return this;
        }
        __name(ClassHandle_deleteLater, "ClassHandle_deleteLater");
        function init_ClassHandle() {
          ClassHandle.prototype["isAliasOf"] = ClassHandle_isAliasOf;
          ClassHandle.prototype["clone"] = ClassHandle_clone;
          ClassHandle.prototype["delete"] = ClassHandle_delete;
          ClassHandle.prototype["isDeleted"] = ClassHandle_isDeleted;
          ClassHandle.prototype["deleteLater"] = ClassHandle_deleteLater;
        }
        __name(init_ClassHandle, "init_ClassHandle");
        function ClassHandle() {
        }
        __name(ClassHandle, "ClassHandle");
        var registeredPointers = {};
        function ensureOverloadTable(proto, methodName, humanName) {
          if (proto[methodName].overloadTable === void 0) {
            var prevFunc = proto[methodName];
            proto[methodName] = function() {
              if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
                throwBindingError("Function '" + humanName + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + proto[methodName].overloadTable + ")!");
              }
              return proto[methodName].overloadTable[arguments.length].apply(this, arguments);
            };
            proto[methodName].overloadTable = [];
            proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
          }
        }
        __name(ensureOverloadTable, "ensureOverloadTable");
        function exposePublicSymbol(name2, value, numArguments) {
          if (Module.hasOwnProperty(name2)) {
            if (numArguments === void 0 || Module[name2].overloadTable !== void 0 && Module[name2].overloadTable[numArguments] !== void 0) {
              throwBindingError("Cannot register public name '" + name2 + "' twice");
            }
            ensureOverloadTable(Module, name2, name2);
            if (Module.hasOwnProperty(numArguments)) {
              throwBindingError("Cannot register multiple overloads of a function with the same number of arguments (" + numArguments + ")!");
            }
            Module[name2].overloadTable[numArguments] = value;
          } else {
            Module[name2] = value;
            if (numArguments !== void 0) {
              Module[name2].numArguments = numArguments;
            }
          }
        }
        __name(exposePublicSymbol, "exposePublicSymbol");
        function RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {
          this.name = name2;
          this.constructor = constructor;
          this.instancePrototype = instancePrototype;
          this.rawDestructor = rawDestructor;
          this.baseClass = baseClass;
          this.getActualType = getActualType;
          this.upcast = upcast;
          this.downcast = downcast;
          this.pureVirtualFunctions = [];
        }
        __name(RegisteredClass, "RegisteredClass");
        function upcastPointer(ptr, ptrClass, desiredClass) {
          while (ptrClass !== desiredClass) {
            if (!ptrClass.upcast) {
              throwBindingError("Expected null or instance of " + desiredClass.name + ", got an instance of " + ptrClass.name);
            }
            ptr = ptrClass.upcast(ptr);
            ptrClass = ptrClass.baseClass;
          }
          return ptr;
        }
        __name(upcastPointer, "upcastPointer");
        function constNoSmartPtrRawPointerToWireType(destructors, handle) {
          if (handle === null) {
            if (this.isReference) {
              throwBindingError("null is not a valid " + this.name);
            }
            return 0;
          }
          if (!handle.$$) {
            throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
          }
          if (!handle.$$.ptr) {
            throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
          }
          var handleClass = handle.$$.ptrType.registeredClass;
          var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
          return ptr;
        }
        __name(constNoSmartPtrRawPointerToWireType, "constNoSmartPtrRawPointerToWireType");
        function genericPointerToWireType(destructors, handle) {
          var ptr;
          if (handle === null) {
            if (this.isReference) {
              throwBindingError("null is not a valid " + this.name);
            }
            if (this.isSmartPointer) {
              ptr = this.rawConstructor();
              if (destructors !== null) {
                destructors.push(this.rawDestructor, ptr);
              }
              return ptr;
            } else {
              return 0;
            }
          }
          if (!handle.$$) {
            throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
          }
          if (!handle.$$.ptr) {
            throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
          }
          if (!this.isConst && handle.$$.ptrType.isConst) {
            throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
          }
          var handleClass = handle.$$.ptrType.registeredClass;
          ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
          if (this.isSmartPointer) {
            if (handle.$$.smartPtr === void 0) {
              throwBindingError("Passing raw pointer to smart pointer is illegal");
            }
            switch (this.sharingPolicy) {
              case 0:
                if (handle.$$.smartPtrType === this) {
                  ptr = handle.$$.smartPtr;
                } else {
                  throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
                }
                break;
              case 1:
                ptr = handle.$$.smartPtr;
                break;
              case 2:
                if (handle.$$.smartPtrType === this) {
                  ptr = handle.$$.smartPtr;
                } else {
                  var clonedHandle = handle["clone"]();
                  ptr = this.rawShare(ptr, __emval_register(function() {
                    clonedHandle["delete"]();
                  }));
                  if (destructors !== null) {
                    destructors.push(this.rawDestructor, ptr);
                  }
                }
                break;
              default:
                throwBindingError("Unsupporting sharing policy");
            }
          }
          return ptr;
        }
        __name(genericPointerToWireType, "genericPointerToWireType");
        function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
          if (handle === null) {
            if (this.isReference) {
              throwBindingError("null is not a valid " + this.name);
            }
            return 0;
          }
          if (!handle.$$) {
            throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
          }
          if (!handle.$$.ptr) {
            throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
          }
          if (handle.$$.ptrType.isConst) {
            throwBindingError("Cannot convert argument of type " + handle.$$.ptrType.name + " to parameter type " + this.name);
          }
          var handleClass = handle.$$.ptrType.registeredClass;
          var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
          return ptr;
        }
        __name(nonConstNoSmartPtrRawPointerToWireType, "nonConstNoSmartPtrRawPointerToWireType");
        function RegisteredPointer_getPointee(ptr) {
          if (this.rawGetPointee) {
            ptr = this.rawGetPointee(ptr);
          }
          return ptr;
        }
        __name(RegisteredPointer_getPointee, "RegisteredPointer_getPointee");
        function RegisteredPointer_destructor(ptr) {
          if (this.rawDestructor) {
            this.rawDestructor(ptr);
          }
        }
        __name(RegisteredPointer_destructor, "RegisteredPointer_destructor");
        function RegisteredPointer_deleteObject(handle) {
          if (handle !== null) {
            handle["delete"]();
          }
        }
        __name(RegisteredPointer_deleteObject, "RegisteredPointer_deleteObject");
        function downcastPointer(ptr, ptrClass, desiredClass) {
          if (ptrClass === desiredClass) {
            return ptr;
          }
          if (desiredClass.baseClass === void 0) {
            return null;
          }
          var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
          if (rv === null) {
            return null;
          }
          return desiredClass.downcast(rv);
        }
        __name(downcastPointer, "downcastPointer");
        function getInheritedInstanceCount() {
          return Object.keys(registeredInstances).length;
        }
        __name(getInheritedInstanceCount, "getInheritedInstanceCount");
        function getLiveInheritedInstances() {
          var rv = [];
          for (var k in registeredInstances) {
            if (registeredInstances.hasOwnProperty(k)) {
              rv.push(registeredInstances[k]);
            }
          }
          return rv;
        }
        __name(getLiveInheritedInstances, "getLiveInheritedInstances");
        function setDelayFunction(fn) {
          delayFunction = fn;
          if (deletionQueue.length && delayFunction) {
            delayFunction(flushPendingDeletes);
          }
        }
        __name(setDelayFunction, "setDelayFunction");
        function init_embind() {
          Module["getInheritedInstanceCount"] = getInheritedInstanceCount;
          Module["getLiveInheritedInstances"] = getLiveInheritedInstances;
          Module["flushPendingDeletes"] = flushPendingDeletes;
          Module["setDelayFunction"] = setDelayFunction;
        }
        __name(init_embind, "init_embind");
        var registeredInstances = {};
        function getBasestPointer(class_, ptr) {
          if (ptr === void 0) {
            throwBindingError("ptr should not be undefined");
          }
          while (class_.baseClass) {
            ptr = class_.upcast(ptr);
            class_ = class_.baseClass;
          }
          return ptr;
        }
        __name(getBasestPointer, "getBasestPointer");
        function getInheritedInstance(class_, ptr) {
          ptr = getBasestPointer(class_, ptr);
          return registeredInstances[ptr];
        }
        __name(getInheritedInstance, "getInheritedInstance");
        function makeClassHandle(prototype, record) {
          if (!record.ptrType || !record.ptr) {
            throwInternalError("makeClassHandle requires ptr and ptrType");
          }
          var hasSmartPtrType = !!record.smartPtrType;
          var hasSmartPtr = !!record.smartPtr;
          if (hasSmartPtrType !== hasSmartPtr) {
            throwInternalError("Both smartPtrType and smartPtr must be specified");
          }
          record.count = { value: 1 };
          return attachFinalizer(Object.create(prototype, { $$: { value: record } }));
        }
        __name(makeClassHandle, "makeClassHandle");
        function RegisteredPointer_fromWireType(ptr) {
          var rawPointer = this.getPointee(ptr);
          if (!rawPointer) {
            this.destructor(ptr);
            return null;
          }
          var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
          if (registeredInstance !== void 0) {
            if (registeredInstance.$$.count.value === 0) {
              registeredInstance.$$.ptr = rawPointer;
              registeredInstance.$$.smartPtr = ptr;
              return registeredInstance["clone"]();
            } else {
              var rv = registeredInstance["clone"]();
              this.destructor(ptr);
              return rv;
            }
          }
          function makeDefaultHandle() {
            if (this.isSmartPointer) {
              return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this.pointeeType, ptr: rawPointer, smartPtrType: this, smartPtr: ptr });
            } else {
              return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this, ptr });
            }
          }
          __name(makeDefaultHandle, "makeDefaultHandle");
          var actualType = this.registeredClass.getActualType(rawPointer);
          var registeredPointerRecord = registeredPointers[actualType];
          if (!registeredPointerRecord) {
            return makeDefaultHandle.call(this);
          }
          var toType;
          if (this.isConst) {
            toType = registeredPointerRecord.constPointerType;
          } else {
            toType = registeredPointerRecord.pointerType;
          }
          var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);
          if (dp === null) {
            return makeDefaultHandle.call(this);
          }
          if (this.isSmartPointer) {
            return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp, smartPtrType: this, smartPtr: ptr });
          } else {
            return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp });
          }
        }
        __name(RegisteredPointer_fromWireType, "RegisteredPointer_fromWireType");
        function init_RegisteredPointer() {
          RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;
          RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;
          RegisteredPointer.prototype["argPackAdvance"] = 8;
          RegisteredPointer.prototype["readValueFromPointer"] = simpleReadValueFromPointer;
          RegisteredPointer.prototype["deleteObject"] = RegisteredPointer_deleteObject;
          RegisteredPointer.prototype["fromWireType"] = RegisteredPointer_fromWireType;
        }
        __name(init_RegisteredPointer, "init_RegisteredPointer");
        function RegisteredPointer(name2, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {
          this.name = name2;
          this.registeredClass = registeredClass;
          this.isReference = isReference;
          this.isConst = isConst;
          this.isSmartPointer = isSmartPointer;
          this.pointeeType = pointeeType;
          this.sharingPolicy = sharingPolicy;
          this.rawGetPointee = rawGetPointee;
          this.rawConstructor = rawConstructor;
          this.rawShare = rawShare;
          this.rawDestructor = rawDestructor;
          if (!isSmartPointer && registeredClass.baseClass === void 0) {
            if (isConst) {
              this["toWireType"] = constNoSmartPtrRawPointerToWireType;
              this.destructorFunction = null;
            } else {
              this["toWireType"] = nonConstNoSmartPtrRawPointerToWireType;
              this.destructorFunction = null;
            }
          } else {
            this["toWireType"] = genericPointerToWireType;
          }
        }
        __name(RegisteredPointer, "RegisteredPointer");
        function replacePublicSymbol(name2, value, numArguments) {
          if (!Module.hasOwnProperty(name2)) {
            throwInternalError("Replacing nonexistant public symbol");
          }
          if (Module[name2].overloadTable !== void 0 && numArguments !== void 0) {
            Module[name2].overloadTable[numArguments] = value;
          } else {
            Module[name2] = value;
            Module[name2].argCount = numArguments;
          }
        }
        __name(replacePublicSymbol, "replacePublicSymbol");
        function dynCallLegacy(sig, ptr, args) {
          var f = Module["dynCall_" + sig];
          return args && args.length ? f.apply(null, [ptr].concat(args)) : f.call(null, ptr);
        }
        __name(dynCallLegacy, "dynCallLegacy");
        function dynCall(sig, ptr, args) {
          if (sig.includes("j")) {
            return dynCallLegacy(sig, ptr, args);
          }
          return wasmTable.get(ptr).apply(null, args);
        }
        __name(dynCall, "dynCall");
        function getDynCaller(sig, ptr) {
          var argCache = [];
          return function() {
            argCache.length = arguments.length;
            for (var i = 0; i < arguments.length; i++) {
              argCache[i] = arguments[i];
            }
            return dynCall(sig, ptr, argCache);
          };
        }
        __name(getDynCaller, "getDynCaller");
        function embind__requireFunction(signature, rawFunction) {
          signature = readLatin1String(signature);
          function makeDynCaller() {
            if (signature.includes("j")) {
              return getDynCaller(signature, rawFunction);
            }
            return wasmTable.get(rawFunction);
          }
          __name(makeDynCaller, "makeDynCaller");
          var fp = makeDynCaller();
          if (typeof fp !== "function") {
            throwBindingError("unknown function pointer with signature " + signature + ": " + rawFunction);
          }
          return fp;
        }
        __name(embind__requireFunction, "embind__requireFunction");
        var UnboundTypeError = void 0;
        function getTypeName(type) {
          var ptr = ___getTypeName(type);
          var rv = readLatin1String(ptr);
          _free(ptr);
          return rv;
        }
        __name(getTypeName, "getTypeName");
        function throwUnboundTypeError(message, types) {
          var unboundTypes = [];
          var seen = {};
          function visit(type) {
            if (seen[type]) {
              return;
            }
            if (registeredTypes[type]) {
              return;
            }
            if (typeDependencies[type]) {
              typeDependencies[type].forEach(visit);
              return;
            }
            unboundTypes.push(type);
            seen[type] = true;
          }
          __name(visit, "visit");
          types.forEach(visit);
          throw new UnboundTypeError(message + ": " + unboundTypes.map(getTypeName).join([", "]));
        }
        __name(throwUnboundTypeError, "throwUnboundTypeError");
        function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name2, destructorSignature, rawDestructor) {
          name2 = readLatin1String(name2);
          getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
          if (upcast) {
            upcast = embind__requireFunction(upcastSignature, upcast);
          }
          if (downcast) {
            downcast = embind__requireFunction(downcastSignature, downcast);
          }
          rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
          var legalFunctionName = makeLegalFunctionName(name2);
          exposePublicSymbol(legalFunctionName, function() {
            throwUnboundTypeError("Cannot construct " + name2 + " due to unbound types", [baseClassRawType]);
          });
          whenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], function(base) {
            base = base[0];
            var baseClass;
            var basePrototype;
            if (baseClassRawType) {
              baseClass = base.registeredClass;
              basePrototype = baseClass.instancePrototype;
            } else {
              basePrototype = ClassHandle.prototype;
            }
            var constructor = createNamedFunction(legalFunctionName, function() {
              if (Object.getPrototypeOf(this) !== instancePrototype) {
                throw new BindingError("Use 'new' to construct " + name2);
              }
              if (registeredClass.constructor_body === void 0) {
                throw new BindingError(name2 + " has no accessible constructor");
              }
              var body = registeredClass.constructor_body[arguments.length];
              if (body === void 0) {
                throw new BindingError("Tried to invoke ctor of " + name2 + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(registeredClass.constructor_body).toString() + ") parameters instead!");
              }
              return body.apply(this, arguments);
            });
            var instancePrototype = Object.create(basePrototype, { constructor: { value: constructor } });
            constructor.prototype = instancePrototype;
            var registeredClass = new RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);
            var referenceConverter = new RegisteredPointer(name2, registeredClass, true, false, false);
            var pointerConverter = new RegisteredPointer(name2 + "*", registeredClass, false, false, false);
            var constPointerConverter = new RegisteredPointer(name2 + " const*", registeredClass, false, true, false);
            registeredPointers[rawType] = { pointerType: pointerConverter, constPointerType: constPointerConverter };
            replacePublicSymbol(legalFunctionName, constructor);
            return [referenceConverter, pointerConverter, constPointerConverter];
          });
        }
        __name(__embind_register_class, "__embind_register_class");
        function heap32VectorToArray(count, firstElement) {
          var array = [];
          for (var i = 0; i < count; i++) {
            array.push(GROWABLE_HEAP_I32()[(firstElement >> 2) + i >>> 0]);
          }
          return array;
        }
        __name(heap32VectorToArray, "heap32VectorToArray");
        function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {
          assert(argCount > 0);
          var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          invoker = embind__requireFunction(invokerSignature, invoker);
          var args = [rawConstructor];
          var destructors = [];
          whenDependentTypesAreResolved([], [rawClassType], function(classType) {
            classType = classType[0];
            var humanName = "constructor " + classType.name;
            if (classType.registeredClass.constructor_body === void 0) {
              classType.registeredClass.constructor_body = [];
            }
            if (classType.registeredClass.constructor_body[argCount - 1] !== void 0) {
              throw new BindingError("Cannot register multiple constructors with identical number of parameters (" + (argCount - 1) + ") for class '" + classType.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
            }
            classType.registeredClass.constructor_body[argCount - 1] = /* @__PURE__ */ __name(function unboundTypeHandler() {
              throwUnboundTypeError("Cannot construct " + classType.name + " due to unbound types", rawArgTypes);
            }, "unboundTypeHandler");
            whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
              classType.registeredClass.constructor_body[argCount - 1] = /* @__PURE__ */ __name(function constructor_body() {
                if (arguments.length !== argCount - 1) {
                  throwBindingError(humanName + " called with " + arguments.length + " arguments, expected " + (argCount - 1));
                }
                destructors.length = 0;
                args.length = argCount;
                for (var i = 1; i < argCount; ++i) {
                  args[i] = argTypes[i]["toWireType"](destructors, arguments[i - 1]);
                }
                var ptr = invoker.apply(null, args);
                runDestructors(destructors);
                return argTypes[0]["fromWireType"](ptr);
              }, "constructor_body");
              return [];
            });
            return [];
          });
        }
        __name(__embind_register_class_constructor, "__embind_register_class_constructor");
        function new_(constructor, argumentList) {
          if (!(constructor instanceof Function)) {
            throw new TypeError("new_ called with constructor type " + typeof constructor + " which is not a function");
          }
          var dummy = createNamedFunction(constructor.name || "unknownFunctionName", function() {
          });
          dummy.prototype = constructor.prototype;
          var obj = new dummy();
          var r = constructor.apply(obj, argumentList);
          return r instanceof Object ? r : obj;
        }
        __name(new_, "new_");
        function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {
          var argCount = argTypes.length;
          if (argCount < 2) {
            throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
          }
          var isClassMethodFunc = argTypes[1] !== null && classType !== null;
          var needsDestructorStack = false;
          for (var i = 1; i < argTypes.length; ++i) {
            if (argTypes[i] !== null && argTypes[i].destructorFunction === void 0) {
              needsDestructorStack = true;
              break;
            }
          }
          var returns = argTypes[0].name !== "void";
          var argsList = "";
          var argsListWired = "";
          for (var i = 0; i < argCount - 2; ++i) {
            argsList += (i !== 0 ? ", " : "") + "arg" + i;
            argsListWired += (i !== 0 ? ", " : "") + "arg" + i + "Wired";
          }
          var invokerFnBody = "return function " + makeLegalFunctionName(humanName) + "(" + argsList + ") {\nif (arguments.length !== " + (argCount - 2) + ") {\nthrowBindingError('function " + humanName + " called with ' + arguments.length + ' arguments, expected " + (argCount - 2) + " args!');\n}\n";
          if (needsDestructorStack) {
            invokerFnBody += "var destructors = [];\n";
          }
          var dtorStack = needsDestructorStack ? "destructors" : "null";
          var args1 = ["throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"];
          var args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];
          if (isClassMethodFunc) {
            invokerFnBody += "var thisWired = classParam.toWireType(" + dtorStack + ", this);\n";
          }
          for (var i = 0; i < argCount - 2; ++i) {
            invokerFnBody += "var arg" + i + "Wired = argType" + i + ".toWireType(" + dtorStack + ", arg" + i + "); // " + argTypes[i + 2].name + "\n";
            args1.push("argType" + i);
            args2.push(argTypes[i + 2]);
          }
          if (isClassMethodFunc) {
            argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
          }
          invokerFnBody += (returns ? "var rv = " : "") + "invoker(fn" + (argsListWired.length > 0 ? ", " : "") + argsListWired + ");\n";
          if (needsDestructorStack) {
            invokerFnBody += "runDestructors(destructors);\n";
          } else {
            for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {
              var paramName = i === 1 ? "thisWired" : "arg" + (i - 2) + "Wired";
              if (argTypes[i].destructorFunction !== null) {
                invokerFnBody += paramName + "_dtor(" + paramName + "); // " + argTypes[i].name + "\n";
                args1.push(paramName + "_dtor");
                args2.push(argTypes[i].destructorFunction);
              }
            }
          }
          if (returns) {
            invokerFnBody += "var ret = retType.fromWireType(rv);\nreturn ret;\n";
          } else {
          }
          invokerFnBody += "}\n";
          args1.push(invokerFnBody);
          var invokerFunction = new_(Function, args1).apply(null, args2);
          return invokerFunction;
        }
        __name(craftInvokerFunction, "craftInvokerFunction");
        function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual) {
          var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          methodName = readLatin1String(methodName);
          rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
          whenDependentTypesAreResolved([], [rawClassType], function(classType) {
            classType = classType[0];
            var humanName = classType.name + "." + methodName;
            if (methodName.startsWith("@@")) {
              methodName = Symbol[methodName.substring(2)];
            }
            if (isPureVirtual) {
              classType.registeredClass.pureVirtualFunctions.push(methodName);
            }
            function unboundTypesHandler() {
              throwUnboundTypeError("Cannot call " + humanName + " due to unbound types", rawArgTypes);
            }
            __name(unboundTypesHandler, "unboundTypesHandler");
            var proto = classType.registeredClass.instancePrototype;
            var method = proto[methodName];
            if (method === void 0 || method.overloadTable === void 0 && method.className !== classType.name && method.argCount === argCount - 2) {
              unboundTypesHandler.argCount = argCount - 2;
              unboundTypesHandler.className = classType.name;
              proto[methodName] = unboundTypesHandler;
            } else {
              ensureOverloadTable(proto, methodName, humanName);
              proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
            }
            whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
              var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);
              if (proto[methodName].overloadTable === void 0) {
                memberFunction.argCount = argCount - 2;
                proto[methodName] = memberFunction;
              } else {
                proto[methodName].overloadTable[argCount - 2] = memberFunction;
              }
              return [];
            });
            return [];
          });
        }
        __name(__embind_register_class_function, "__embind_register_class_function");
        var emval_free_list = [];
        var emval_handle_array = [{}, { value: void 0 }, { value: null }, { value: true }, { value: false }];
        function __emval_decref(handle) {
          if (handle > 4 && --emval_handle_array[handle].refcount === 0) {
            emval_handle_array[handle] = void 0;
            emval_free_list.push(handle);
          }
        }
        __name(__emval_decref, "__emval_decref");
        function count_emval_handles() {
          var count = 0;
          for (var i = 5; i < emval_handle_array.length; ++i) {
            if (emval_handle_array[i] !== void 0) {
              ++count;
            }
          }
          return count;
        }
        __name(count_emval_handles, "count_emval_handles");
        function get_first_emval() {
          for (var i = 5; i < emval_handle_array.length; ++i) {
            if (emval_handle_array[i] !== void 0) {
              return emval_handle_array[i];
            }
          }
          return null;
        }
        __name(get_first_emval, "get_first_emval");
        function init_emval() {
          Module["count_emval_handles"] = count_emval_handles;
          Module["get_first_emval"] = get_first_emval;
        }
        __name(init_emval, "init_emval");
        function __emval_register(value) {
          switch (value) {
            case void 0: {
              return 1;
            }
            case null: {
              return 2;
            }
            case true: {
              return 3;
            }
            case false: {
              return 4;
            }
            default: {
              var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;
              emval_handle_array[handle] = { refcount: 1, value };
              return handle;
            }
          }
        }
        __name(__emval_register, "__emval_register");
        function __embind_register_emval(rawType, name2) {
          name2 = readLatin1String(name2);
          registerType(rawType, { name: name2, "fromWireType": function(handle) {
            var rv = emval_handle_array[handle].value;
            __emval_decref(handle);
            return rv;
          }, "toWireType": function(destructors, value) {
            return __emval_register(value);
          }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: null });
        }
        __name(__embind_register_emval, "__embind_register_emval");
        function enumReadValueFromPointer(name2, shift, signed) {
          switch (shift) {
            case 0:
              return function(pointer) {
                var heap = signed ? GROWABLE_HEAP_I8() : GROWABLE_HEAP_U8();
                return this["fromWireType"](heap[pointer >>> 0]);
              };
            case 1:
              return function(pointer) {
                var heap = signed ? GROWABLE_HEAP_I16() : GROWABLE_HEAP_U16();
                return this["fromWireType"](heap[pointer >>> 1]);
              };
            case 2:
              return function(pointer) {
                var heap = signed ? GROWABLE_HEAP_I32() : GROWABLE_HEAP_U32();
                return this["fromWireType"](heap[pointer >>> 2]);
              };
            default:
              throw new TypeError("Unknown integer type: " + name2);
          }
        }
        __name(enumReadValueFromPointer, "enumReadValueFromPointer");
        function __embind_register_enum(rawType, name2, size, isSigned) {
          var shift = getShiftFromSize(size);
          name2 = readLatin1String(name2);
          function ctor() {
          }
          __name(ctor, "ctor");
          ctor.values = {};
          registerType(rawType, { name: name2, constructor: ctor, "fromWireType": function(c) {
            return this.constructor.values[c];
          }, "toWireType": function(destructors, c) {
            return c.value;
          }, "argPackAdvance": 8, "readValueFromPointer": enumReadValueFromPointer(name2, shift, isSigned), destructorFunction: null });
          exposePublicSymbol(name2, ctor);
        }
        __name(__embind_register_enum, "__embind_register_enum");
        function requireRegisteredType(rawType, humanName) {
          var impl = registeredTypes[rawType];
          if (impl === void 0) {
            throwBindingError(humanName + " has unknown type " + getTypeName(rawType));
          }
          return impl;
        }
        __name(requireRegisteredType, "requireRegisteredType");
        function __embind_register_enum_value(rawEnumType, name2, enumValue) {
          var enumType = requireRegisteredType(rawEnumType, "enum");
          name2 = readLatin1String(name2);
          var Enum = enumType.constructor;
          var Value2 = Object.create(enumType.constructor.prototype, { value: { value: enumValue }, constructor: { value: createNamedFunction(enumType.name + "_" + name2, function() {
          }) } });
          Enum.values[enumValue] = Value2;
          Enum[name2] = Value2;
        }
        __name(__embind_register_enum_value, "__embind_register_enum_value");
        function _embind_repr(v) {
          if (v === null) {
            return "null";
          }
          var t = typeof v;
          if (t === "object" || t === "array" || t === "function") {
            return v.toString();
          } else {
            return "" + v;
          }
        }
        __name(_embind_repr, "_embind_repr");
        function floatReadValueFromPointer(name2, shift) {
          switch (shift) {
            case 2:
              return function(pointer) {
                return this["fromWireType"](GROWABLE_HEAP_F32()[pointer >>> 2]);
              };
            case 3:
              return function(pointer) {
                return this["fromWireType"](GROWABLE_HEAP_F64()[pointer >>> 3]);
              };
            default:
              throw new TypeError("Unknown float type: " + name2);
          }
        }
        __name(floatReadValueFromPointer, "floatReadValueFromPointer");
        function __embind_register_float(rawType, name2, size) {
          var shift = getShiftFromSize(size);
          name2 = readLatin1String(name2);
          registerType(rawType, { name: name2, "fromWireType": function(value) {
            return value;
          }, "toWireType": function(destructors, value) {
            if (typeof value !== "number" && typeof value !== "boolean") {
              throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
            }
            return value;
          }, "argPackAdvance": 8, "readValueFromPointer": floatReadValueFromPointer(name2, shift), destructorFunction: null });
        }
        __name(__embind_register_float, "__embind_register_float");
        function __embind_register_function(name2, argCount, rawArgTypesAddr, signature, rawInvoker, fn) {
          var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          name2 = readLatin1String(name2);
          rawInvoker = embind__requireFunction(signature, rawInvoker);
          exposePublicSymbol(name2, function() {
            throwUnboundTypeError("Cannot call " + name2 + " due to unbound types", argTypes);
          }, argCount - 1);
          whenDependentTypesAreResolved([], argTypes, function(argTypes2) {
            var invokerArgsArray = [argTypes2[0], null].concat(argTypes2.slice(1));
            replacePublicSymbol(name2, craftInvokerFunction(name2, invokerArgsArray, null, rawInvoker, fn), argCount - 1);
            return [];
          });
        }
        __name(__embind_register_function, "__embind_register_function");
        function integerReadValueFromPointer(name2, shift, signed) {
          switch (shift) {
            case 0:
              return signed ? /* @__PURE__ */ __name(function readS8FromPointer(pointer) {
                return GROWABLE_HEAP_I8()[pointer >>> 0];
              }, "readS8FromPointer") : /* @__PURE__ */ __name(function readU8FromPointer(pointer) {
                return GROWABLE_HEAP_U8()[pointer >>> 0];
              }, "readU8FromPointer");
            case 1:
              return signed ? /* @__PURE__ */ __name(function readS16FromPointer(pointer) {
                return GROWABLE_HEAP_I16()[pointer >>> 1];
              }, "readS16FromPointer") : /* @__PURE__ */ __name(function readU16FromPointer(pointer) {
                return GROWABLE_HEAP_U16()[pointer >>> 1];
              }, "readU16FromPointer");
            case 2:
              return signed ? /* @__PURE__ */ __name(function readS32FromPointer(pointer) {
                return GROWABLE_HEAP_I32()[pointer >>> 2];
              }, "readS32FromPointer") : /* @__PURE__ */ __name(function readU32FromPointer(pointer) {
                return GROWABLE_HEAP_U32()[pointer >>> 2];
              }, "readU32FromPointer");
            default:
              throw new TypeError("Unknown integer type: " + name2);
          }
        }
        __name(integerReadValueFromPointer, "integerReadValueFromPointer");
        function __embind_register_integer(primitiveType, name2, size, minRange, maxRange) {
          name2 = readLatin1String(name2);
          if (maxRange === -1) {
            maxRange = 4294967295;
          }
          var shift = getShiftFromSize(size);
          var fromWireType = /* @__PURE__ */ __name(function(value) {
            return value;
          }, "fromWireType");
          if (minRange === 0) {
            var bitshift = 32 - 8 * size;
            fromWireType = /* @__PURE__ */ __name(function(value) {
              return value << bitshift >>> bitshift;
            }, "fromWireType");
          }
          var isUnsignedType = name2.includes("unsigned");
          registerType(primitiveType, { name: name2, "fromWireType": fromWireType, "toWireType": function(destructors, value) {
            if (typeof value !== "number" && typeof value !== "boolean") {
              throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
            }
            if (value < minRange || value > maxRange) {
              throw new TypeError('Passing a number "' + _embind_repr(value) + '" from JS side to C/C++ side to an argument of type "' + name2 + '", which is outside the valid range [' + minRange + ", " + maxRange + "]!");
            }
            return isUnsignedType ? value >>> 0 : value | 0;
          }, "argPackAdvance": 8, "readValueFromPointer": integerReadValueFromPointer(name2, shift, minRange !== 0), destructorFunction: null });
        }
        __name(__embind_register_integer, "__embind_register_integer");
        function __embind_register_memory_view(rawType, dataTypeIndex, name2) {
          var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
          var TA = typeMapping[dataTypeIndex];
          function decodeMemoryView(handle) {
            handle = handle >> 2;
            var heap = GROWABLE_HEAP_U32();
            var size = heap[handle >>> 0];
            var data = heap[handle + 1 >>> 0];
            return new TA(buffer, data, size);
          }
          __name(decodeMemoryView, "decodeMemoryView");
          name2 = readLatin1String(name2);
          registerType(rawType, { name: name2, "fromWireType": decodeMemoryView, "argPackAdvance": 8, "readValueFromPointer": decodeMemoryView }, { ignoreDuplicateRegistrations: true });
        }
        __name(__embind_register_memory_view, "__embind_register_memory_view");
        function __embind_register_std_string(rawType, name2) {
          name2 = readLatin1String(name2);
          var stdStringIsUTF8 = name2 === "std::string";
          registerType(rawType, { name: name2, "fromWireType": function(value) {
            var length = GROWABLE_HEAP_U32()[value >>> 2];
            var str;
            if (stdStringIsUTF8) {
              var decodeStartPtr = value + 4;
              for (var i = 0; i <= length; ++i) {
                var currentBytePtr = value + 4 + i;
                if (i == length || GROWABLE_HEAP_U8()[currentBytePtr >>> 0] == 0) {
                  var maxRead = currentBytePtr - decodeStartPtr;
                  var stringSegment = UTF8ToString(decodeStartPtr, maxRead);
                  if (str === void 0) {
                    str = stringSegment;
                  } else {
                    str += String.fromCharCode(0);
                    str += stringSegment;
                  }
                  decodeStartPtr = currentBytePtr + 1;
                }
              }
            } else {
              var a = new Array(length);
              for (var i = 0; i < length; ++i) {
                a[i] = String.fromCharCode(GROWABLE_HEAP_U8()[value + 4 + i >>> 0]);
              }
              str = a.join("");
            }
            _free(value);
            return str;
          }, "toWireType": function(destructors, value) {
            if (value instanceof ArrayBuffer) {
              value = new Uint8Array(value);
            }
            var getLength;
            var valueIsOfTypeString = typeof value === "string";
            if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
              throwBindingError("Cannot pass non-string to std::string");
            }
            if (stdStringIsUTF8 && valueIsOfTypeString) {
              getLength = /* @__PURE__ */ __name(function() {
                return lengthBytesUTF8(value);
              }, "getLength");
            } else {
              getLength = /* @__PURE__ */ __name(function() {
                return value.length;
              }, "getLength");
            }
            var length = getLength();
            var ptr = _malloc(4 + length + 1);
            ptr >>>= 0;
            GROWABLE_HEAP_U32()[ptr >>> 2] = length;
            if (stdStringIsUTF8 && valueIsOfTypeString) {
              stringToUTF8(value, ptr + 4, length + 1);
            } else {
              if (valueIsOfTypeString) {
                for (var i = 0; i < length; ++i) {
                  var charCode = value.charCodeAt(i);
                  if (charCode > 255) {
                    _free(ptr);
                    throwBindingError("String has UTF-16 code units that do not fit in 8 bits");
                  }
                  GROWABLE_HEAP_U8()[ptr + 4 + i >>> 0] = charCode;
                }
              } else {
                for (var i = 0; i < length; ++i) {
                  GROWABLE_HEAP_U8()[ptr + 4 + i >>> 0] = value[i];
                }
              }
            }
            if (destructors !== null) {
              destructors.push(_free, ptr);
            }
            return ptr;
          }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: function(ptr) {
            _free(ptr);
          } });
        }
        __name(__embind_register_std_string, "__embind_register_std_string");
        function __embind_register_std_wstring(rawType, charSize, name2) {
          name2 = readLatin1String(name2);
          var decodeString, encodeString, getHeap, lengthBytesUTF, shift;
          if (charSize === 2) {
            decodeString = UTF16ToString;
            encodeString = stringToUTF16;
            lengthBytesUTF = lengthBytesUTF16;
            getHeap = /* @__PURE__ */ __name(function() {
              return GROWABLE_HEAP_U16();
            }, "getHeap");
            shift = 1;
          } else if (charSize === 4) {
            decodeString = UTF32ToString;
            encodeString = stringToUTF32;
            lengthBytesUTF = lengthBytesUTF32;
            getHeap = /* @__PURE__ */ __name(function() {
              return GROWABLE_HEAP_U32();
            }, "getHeap");
            shift = 2;
          }
          registerType(rawType, { name: name2, "fromWireType": function(value) {
            var length = GROWABLE_HEAP_U32()[value >>> 2];
            var HEAP = getHeap();
            var str;
            var decodeStartPtr = value + 4;
            for (var i = 0; i <= length; ++i) {
              var currentBytePtr = value + 4 + i * charSize;
              if (i == length || HEAP[currentBytePtr >>> shift] == 0) {
                var maxReadBytes = currentBytePtr - decodeStartPtr;
                var stringSegment = decodeString(decodeStartPtr, maxReadBytes);
                if (str === void 0) {
                  str = stringSegment;
                } else {
                  str += String.fromCharCode(0);
                  str += stringSegment;
                }
                decodeStartPtr = currentBytePtr + charSize;
              }
            }
            _free(value);
            return str;
          }, "toWireType": function(destructors, value) {
            if (!(typeof value === "string")) {
              throwBindingError("Cannot pass non-string to C++ string type " + name2);
            }
            var length = lengthBytesUTF(value);
            var ptr = _malloc(4 + length + charSize);
            ptr >>>= 0;
            GROWABLE_HEAP_U32()[ptr >>> 2] = length >> shift;
            encodeString(value, ptr + 4, length + charSize);
            if (destructors !== null) {
              destructors.push(_free, ptr);
            }
            return ptr;
          }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: function(ptr) {
            _free(ptr);
          } });
        }
        __name(__embind_register_std_wstring, "__embind_register_std_wstring");
        function __embind_register_value_array(rawType, name2, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {
          tupleRegistrations[rawType] = { name: readLatin1String(name2), rawConstructor: embind__requireFunction(constructorSignature, rawConstructor), rawDestructor: embind__requireFunction(destructorSignature, rawDestructor), elements: [] };
        }
        __name(__embind_register_value_array, "__embind_register_value_array");
        function __embind_register_value_array_element(rawTupleType, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
          tupleRegistrations[rawTupleType].elements.push({ getterReturnType, getter: embind__requireFunction(getterSignature, getter), getterContext, setterArgumentType, setter: embind__requireFunction(setterSignature, setter), setterContext });
        }
        __name(__embind_register_value_array_element, "__embind_register_value_array_element");
        function __embind_register_value_object(rawType, name2, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {
          structRegistrations[rawType] = { name: readLatin1String(name2), rawConstructor: embind__requireFunction(constructorSignature, rawConstructor), rawDestructor: embind__requireFunction(destructorSignature, rawDestructor), fields: [] };
        }
        __name(__embind_register_value_object, "__embind_register_value_object");
        function __embind_register_value_object_field(structType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
          structRegistrations[structType].fields.push({ fieldName: readLatin1String(fieldName), getterReturnType, getter: embind__requireFunction(getterSignature, getter), getterContext, setterArgumentType, setter: embind__requireFunction(setterSignature, setter), setterContext });
        }
        __name(__embind_register_value_object_field, "__embind_register_value_object_field");
        function __embind_register_void(rawType, name2) {
          name2 = readLatin1String(name2);
          registerType(rawType, { isVoid: true, name: name2, "argPackAdvance": 0, "fromWireType": function() {
            return void 0;
          }, "toWireType": function(destructors, o) {
            return void 0;
          } });
        }
        __name(__embind_register_void, "__embind_register_void");
        function __emscripten_notify_thread_queue(targetThreadId, mainThreadId) {
          if (targetThreadId == mainThreadId) {
            postMessage({ "cmd": "processQueuedMainThreadWork" });
          } else if (ENVIRONMENT_IS_PTHREAD) {
            postMessage({ "targetThread": targetThreadId, "cmd": "processThreadQueue" });
          } else {
            var pthread = PThread.pthreads[targetThreadId];
            var worker = pthread && pthread.worker;
            if (!worker) {
              return;
            }
            worker.postMessage({ "cmd": "processThreadQueue" });
          }
          return 1;
        }
        __name(__emscripten_notify_thread_queue, "__emscripten_notify_thread_queue");
        function requireHandle(handle) {
          if (!handle) {
            throwBindingError("Cannot use deleted val. handle = " + handle);
          }
          return emval_handle_array[handle].value;
        }
        __name(requireHandle, "requireHandle");
        function __emval_as(handle, returnType, destructorsRef) {
          handle = requireHandle(handle);
          returnType = requireRegisteredType(returnType, "emval::as");
          var destructors = [];
          var rd = __emval_register(destructors);
          GROWABLE_HEAP_I32()[destructorsRef >>> 2] = rd;
          return returnType["toWireType"](destructors, handle);
        }
        __name(__emval_as, "__emval_as");
        function __emval_lookupTypes(argCount, argTypes) {
          var a = new Array(argCount);
          for (var i = 0; i < argCount; ++i) {
            a[i] = requireRegisteredType(GROWABLE_HEAP_I32()[(argTypes >> 2) + i >>> 0], "parameter " + i);
          }
          return a;
        }
        __name(__emval_lookupTypes, "__emval_lookupTypes");
        function __emval_call(handle, argCount, argTypes, argv) {
          handle = requireHandle(handle);
          var types = __emval_lookupTypes(argCount, argTypes);
          var args = new Array(argCount);
          for (var i = 0; i < argCount; ++i) {
            var type = types[i];
            args[i] = type["readValueFromPointer"](argv);
            argv += type["argPackAdvance"];
          }
          var rv = handle.apply(void 0, args);
          return __emval_register(rv);
        }
        __name(__emval_call, "__emval_call");
        var emval_symbols = {};
        function getStringOrSymbol(address) {
          var symbol = emval_symbols[address];
          if (symbol === void 0) {
            return readLatin1String(address);
          } else {
            return symbol;
          }
        }
        __name(getStringOrSymbol, "getStringOrSymbol");
        function emval_get_global() {
          if (typeof globalThis === "object") {
            return globalThis;
          }
          return function() {
            return Function;
          }()("return this")();
        }
        __name(emval_get_global, "emval_get_global");
        function __emval_get_global(name2) {
          if (name2 === 0) {
            return __emval_register(emval_get_global());
          } else {
            name2 = getStringOrSymbol(name2);
            return __emval_register(emval_get_global()[name2]);
          }
        }
        __name(__emval_get_global, "__emval_get_global");
        function __emval_get_property(handle, key2) {
          handle = requireHandle(handle);
          key2 = requireHandle(key2);
          return __emval_register(handle[key2]);
        }
        __name(__emval_get_property, "__emval_get_property");
        function __emval_incref(handle) {
          if (handle > 4) {
            emval_handle_array[handle].refcount += 1;
          }
        }
        __name(__emval_incref, "__emval_incref");
        function __emval_instanceof(object, constructor) {
          object = requireHandle(object);
          constructor = requireHandle(constructor);
          return object instanceof constructor;
        }
        __name(__emval_instanceof, "__emval_instanceof");
        function __emval_is_number(handle) {
          handle = requireHandle(handle);
          return typeof handle === "number";
        }
        __name(__emval_is_number, "__emval_is_number");
        function __emval_new_array() {
          return __emval_register([]);
        }
        __name(__emval_new_array, "__emval_new_array");
        function __emval_new_cstring(v) {
          return __emval_register(getStringOrSymbol(v));
        }
        __name(__emval_new_cstring, "__emval_new_cstring");
        function __emval_new_object() {
          return __emval_register({});
        }
        __name(__emval_new_object, "__emval_new_object");
        function __emval_run_destructors(handle) {
          var destructors = emval_handle_array[handle].value;
          runDestructors(destructors);
          __emval_decref(handle);
        }
        __name(__emval_run_destructors, "__emval_run_destructors");
        function __emval_set_property(handle, key2, value) {
          handle = requireHandle(handle);
          key2 = requireHandle(key2);
          value = requireHandle(value);
          handle[key2] = value;
        }
        __name(__emval_set_property, "__emval_set_property");
        function __emval_take_value(type, argv) {
          type = requireRegisteredType(type, "_emval_take_value");
          var v = type["readValueFromPointer"](argv);
          return __emval_register(v);
        }
        __name(__emval_take_value, "__emval_take_value");
        function _abort() {
          abort();
        }
        __name(_abort, "_abort");
        var readAsmConstArgsArray = [];
        function readAsmConstArgs(sigPtr, buf) {
          readAsmConstArgsArray.length = 0;
          var ch;
          buf >>= 2;
          while (ch = GROWABLE_HEAP_U8()[sigPtr++ >>> 0]) {
            var double = ch < 105;
            if (double && buf & 1)
              buf++;
            readAsmConstArgsArray.push(double ? GROWABLE_HEAP_F64()[buf++ >>> 1] : GROWABLE_HEAP_I32()[buf >>> 0]);
            ++buf;
          }
          return readAsmConstArgsArray;
        }
        __name(readAsmConstArgs, "readAsmConstArgs");
        function _emscripten_asm_const_int(code, sigPtr, argbuf) {
          var args = readAsmConstArgs(sigPtr, argbuf);
          return ASM_CONSTS[code].apply(null, args);
        }
        __name(_emscripten_asm_const_int, "_emscripten_asm_const_int");
        function _emscripten_check_blocking_allowed() {
          if (ENVIRONMENT_IS_NODE)
            return;
          if (ENVIRONMENT_IS_WORKER)
            return;
          warnOnce("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread");
        }
        __name(_emscripten_check_blocking_allowed, "_emscripten_check_blocking_allowed");
        function _emscripten_conditional_set_current_thread_status(expectedStatus, newStatus) {
        }
        __name(_emscripten_conditional_set_current_thread_status, "_emscripten_conditional_set_current_thread_status");
        function _emscripten_futex_wait(addr, val, timeout) {
          if (addr <= 0 || addr > GROWABLE_HEAP_I8().length || addr & true)
            return -28;
          if (!ENVIRONMENT_IS_WEB) {
            var ret = Atomics.wait(GROWABLE_HEAP_I32(), addr >> 2, val, timeout);
            if (ret === "timed-out")
              return -73;
            if (ret === "not-equal")
              return -6;
            if (ret === "ok")
              return 0;
            throw "Atomics.wait returned an unexpected value " + ret;
          } else {
            if (Atomics.load(GROWABLE_HEAP_I32(), addr >> 2) != val) {
              return -6;
            }
            var tNow = performance.now();
            var tEnd = tNow + timeout;
            var lastAddr = Atomics.exchange(GROWABLE_HEAP_I32(), __emscripten_main_thread_futex >> 2, addr);
            while (1) {
              tNow = performance.now();
              if (tNow > tEnd) {
                lastAddr = Atomics.exchange(GROWABLE_HEAP_I32(), __emscripten_main_thread_futex >> 2, 0);
                return -73;
              }
              lastAddr = Atomics.exchange(GROWABLE_HEAP_I32(), __emscripten_main_thread_futex >> 2, 0);
              if (lastAddr == 0) {
                break;
              }
              _emscripten_main_thread_process_queued_calls();
              if (Atomics.load(GROWABLE_HEAP_I32(), addr >> 2) != val) {
                return -6;
              }
              lastAddr = Atomics.exchange(GROWABLE_HEAP_I32(), __emscripten_main_thread_futex >> 2, addr);
            }
            return 0;
          }
        }
        __name(_emscripten_futex_wait, "_emscripten_futex_wait");
        function _emscripten_memcpy_big(dest, src, num) {
          GROWABLE_HEAP_U8().copyWithin(dest >>> 0, src >>> 0, src + num >>> 0);
        }
        __name(_emscripten_memcpy_big, "_emscripten_memcpy_big");
        function _emscripten_proxy_to_main_thread_js(index, sync) {
          var numCallArgs = arguments.length - 2;
          var stack = stackSave();
          var serializedNumCallArgs = numCallArgs;
          var args = stackAlloc(serializedNumCallArgs * 8);
          var b = args >> 3;
          for (var i = 0; i < numCallArgs; i++) {
            var arg = arguments[2 + i];
            GROWABLE_HEAP_F64()[b + i >>> 0] = arg;
          }
          var ret = _emscripten_run_in_main_runtime_thread_js(index, serializedNumCallArgs, args, sync);
          stackRestore(stack);
          return ret;
        }
        __name(_emscripten_proxy_to_main_thread_js, "_emscripten_proxy_to_main_thread_js");
        var _emscripten_receive_on_main_thread_js_callArgs = [];
        function _emscripten_receive_on_main_thread_js(index, numCallArgs, args) {
          _emscripten_receive_on_main_thread_js_callArgs.length = numCallArgs;
          var b = args >> 3;
          for (var i = 0; i < numCallArgs; i++) {
            _emscripten_receive_on_main_thread_js_callArgs[i] = GROWABLE_HEAP_F64()[b + i >>> 0];
          }
          var isEmAsmConst = index < 0;
          var func = !isEmAsmConst ? proxiedFunctionTable[index] : ASM_CONSTS[-index - 1];
          return func.apply(null, _emscripten_receive_on_main_thread_js_callArgs);
        }
        __name(_emscripten_receive_on_main_thread_js, "_emscripten_receive_on_main_thread_js");
        function emscripten_realloc_buffer(size) {
          try {
            wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);
            updateGlobalBufferAndViews(wasmMemory.buffer);
            return 1;
          } catch (e) {
          }
        }
        __name(emscripten_realloc_buffer, "emscripten_realloc_buffer");
        function _emscripten_resize_heap(requestedSize) {
          var oldSize = GROWABLE_HEAP_U8().length;
          requestedSize = requestedSize >>> 0;
          if (requestedSize <= oldSize) {
            return false;
          }
          var maxHeapSize = 4294901760;
          if (requestedSize > maxHeapSize) {
            return false;
          }
          for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
            var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
            overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
            var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
            var replacement = emscripten_realloc_buffer(newSize);
            if (replacement) {
              return true;
            }
          }
          return false;
        }
        __name(_emscripten_resize_heap, "_emscripten_resize_heap");
        var JSEvents = { inEventHandler: 0, removeAllEventListeners: function() {
          for (var i = JSEvents.eventHandlers.length - 1; i >= 0; --i) {
            JSEvents._removeHandler(i);
          }
          JSEvents.eventHandlers = [];
          JSEvents.deferredCalls = [];
        }, registerRemoveEventListeners: function() {
          if (!JSEvents.removeEventListenersRegistered) {
            __ATEXIT__.push(JSEvents.removeAllEventListeners);
            JSEvents.removeEventListenersRegistered = true;
          }
        }, deferredCalls: [], deferCall: function(targetFunction, precedence, argsList) {
          function arraysHaveEqualContent(arrA, arrB) {
            if (arrA.length != arrB.length)
              return false;
            for (var i2 in arrA) {
              if (arrA[i2] != arrB[i2])
                return false;
            }
            return true;
          }
          __name(arraysHaveEqualContent, "arraysHaveEqualContent");
          for (var i in JSEvents.deferredCalls) {
            var call = JSEvents.deferredCalls[i];
            if (call.targetFunction == targetFunction && arraysHaveEqualContent(call.argsList, argsList)) {
              return;
            }
          }
          JSEvents.deferredCalls.push({ targetFunction, precedence, argsList });
          JSEvents.deferredCalls.sort(function(x, y) {
            return x.precedence < y.precedence;
          });
        }, removeDeferredCalls: function(targetFunction) {
          for (var i = 0; i < JSEvents.deferredCalls.length; ++i) {
            if (JSEvents.deferredCalls[i].targetFunction == targetFunction) {
              JSEvents.deferredCalls.splice(i, 1);
              --i;
            }
          }
        }, canPerformEventHandlerRequests: function() {
          return JSEvents.inEventHandler && JSEvents.currentEventHandler.allowsDeferredCalls;
        }, runDeferredCalls: function() {
          if (!JSEvents.canPerformEventHandlerRequests()) {
            return;
          }
          for (var i = 0; i < JSEvents.deferredCalls.length; ++i) {
            var call = JSEvents.deferredCalls[i];
            JSEvents.deferredCalls.splice(i, 1);
            --i;
            call.targetFunction.apply(null, call.argsList);
          }
        }, eventHandlers: [], removeAllHandlersOnTarget: function(target, eventTypeString) {
          for (var i = 0; i < JSEvents.eventHandlers.length; ++i) {
            if (JSEvents.eventHandlers[i].target == target && (!eventTypeString || eventTypeString == JSEvents.eventHandlers[i].eventTypeString)) {
              JSEvents._removeHandler(i--);
            }
          }
        }, _removeHandler: function(i) {
          var h = JSEvents.eventHandlers[i];
          h.target.removeEventListener(h.eventTypeString, h.eventListenerFunc, h.useCapture);
          JSEvents.eventHandlers.splice(i, 1);
        }, registerOrRemoveHandler: function(eventHandler) {
          var jsEventHandler = /* @__PURE__ */ __name(function jsEventHandler2(event) {
            ++JSEvents.inEventHandler;
            JSEvents.currentEventHandler = eventHandler;
            JSEvents.runDeferredCalls();
            eventHandler.handlerFunc(event);
            JSEvents.runDeferredCalls();
            --JSEvents.inEventHandler;
          }, "jsEventHandler2");
          if (eventHandler.callbackfunc) {
            eventHandler.eventListenerFunc = jsEventHandler;
            eventHandler.target.addEventListener(eventHandler.eventTypeString, jsEventHandler, eventHandler.useCapture);
            JSEvents.eventHandlers.push(eventHandler);
            JSEvents.registerRemoveEventListeners();
          } else {
            for (var i = 0; i < JSEvents.eventHandlers.length; ++i) {
              if (JSEvents.eventHandlers[i].target == eventHandler.target && JSEvents.eventHandlers[i].eventTypeString == eventHandler.eventTypeString) {
                JSEvents._removeHandler(i--);
              }
            }
          }
        }, queueEventHandlerOnThread_iiii: function(targetThread, eventHandlerFunc, eventTypeId, eventData, userData) {
          var stackTop = stackSave();
          var varargs = stackAlloc(12);
          GROWABLE_HEAP_I32()[varargs >>> 2] = eventTypeId;
          GROWABLE_HEAP_I32()[varargs + 4 >>> 2] = eventData;
          GROWABLE_HEAP_I32()[varargs + 8 >>> 2] = userData;
          __emscripten_call_on_thread(0, targetThread, 637534208, eventHandlerFunc, eventData, varargs);
          stackRestore(stackTop);
        }, getTargetThreadForEventCallback: function(targetThread) {
          switch (targetThread) {
            case 1:
              return 0;
            case 2:
              return PThread.currentProxiedOperationCallerThread;
            default:
              return targetThread;
          }
        }, getNodeNameForTarget: function(target) {
          if (!target)
            return "";
          if (target == window)
            return "#window";
          if (target == screen)
            return "#screen";
          return target && target.nodeName ? target.nodeName : "";
        }, fullscreenEnabled: function() {
          return document.fullscreenEnabled || document.webkitFullscreenEnabled;
        } };
        function stringToNewUTF8(jsString) {
          var length = lengthBytesUTF8(jsString) + 1;
          var cString = _malloc(length);
          stringToUTF8(jsString, cString, length);
          return cString;
        }
        __name(stringToNewUTF8, "stringToNewUTF8");
        function _emscripten_set_offscreencanvas_size_on_target_thread_js(targetThread, targetCanvas, width, height) {
          var stackTop = stackSave();
          var varargs = stackAlloc(12);
          var targetCanvasPtr = 0;
          if (targetCanvas) {
            targetCanvasPtr = stringToNewUTF8(targetCanvas);
          }
          GROWABLE_HEAP_I32()[varargs >>> 2] = targetCanvasPtr;
          GROWABLE_HEAP_I32()[varargs + 4 >>> 2] = width;
          GROWABLE_HEAP_I32()[varargs + 8 >>> 2] = height;
          __emscripten_call_on_thread(0, targetThread, 657457152, 0, targetCanvasPtr, varargs);
          stackRestore(stackTop);
        }
        __name(_emscripten_set_offscreencanvas_size_on_target_thread_js, "_emscripten_set_offscreencanvas_size_on_target_thread_js");
        function _emscripten_set_offscreencanvas_size_on_target_thread(targetThread, targetCanvas, width, height) {
          targetCanvas = targetCanvas ? UTF8ToString(targetCanvas) : "";
          _emscripten_set_offscreencanvas_size_on_target_thread_js(targetThread, targetCanvas, width, height);
        }
        __name(_emscripten_set_offscreencanvas_size_on_target_thread, "_emscripten_set_offscreencanvas_size_on_target_thread");
        function maybeCStringToJsString(cString) {
          return cString > 2 ? UTF8ToString(cString) : cString;
        }
        __name(maybeCStringToJsString, "maybeCStringToJsString");
        var specialHTMLTargets = [0, typeof document !== "undefined" ? document : 0, typeof window !== "undefined" ? window : 0];
        function findEventTarget(target) {
          target = maybeCStringToJsString(target);
          var domElement = specialHTMLTargets[target] || (typeof document !== "undefined" ? document.querySelector(target) : void 0);
          return domElement;
        }
        __name(findEventTarget, "findEventTarget");
        function findCanvasEventTarget(target) {
          return findEventTarget(target);
        }
        __name(findCanvasEventTarget, "findCanvasEventTarget");
        function _emscripten_set_canvas_element_size_calling_thread(target, width, height) {
          var canvas = findCanvasEventTarget(target);
          if (!canvas)
            return -4;
          if (canvas.canvasSharedPtr) {
            GROWABLE_HEAP_I32()[canvas.canvasSharedPtr >>> 2] = width;
            GROWABLE_HEAP_I32()[canvas.canvasSharedPtr + 4 >>> 2] = height;
          }
          if (canvas.offscreenCanvas || !canvas.controlTransferredOffscreen) {
            if (canvas.offscreenCanvas)
              canvas = canvas.offscreenCanvas;
            var autoResizeViewport = false;
            if (canvas.GLctxObject && canvas.GLctxObject.GLctx) {
              var prevViewport = canvas.GLctxObject.GLctx.getParameter(2978);
              autoResizeViewport = prevViewport[0] === 0 && prevViewport[1] === 0 && prevViewport[2] === canvas.width && prevViewport[3] === canvas.height;
            }
            canvas.width = width;
            canvas.height = height;
            if (autoResizeViewport) {
              canvas.GLctxObject.GLctx.viewport(0, 0, width, height);
            }
          } else if (canvas.canvasSharedPtr) {
            var targetThread = GROWABLE_HEAP_I32()[canvas.canvasSharedPtr + 8 >>> 2];
            _emscripten_set_offscreencanvas_size_on_target_thread(targetThread, target, width, height);
            return 1;
          } else {
            return -4;
          }
          return 0;
        }
        __name(_emscripten_set_canvas_element_size_calling_thread, "_emscripten_set_canvas_element_size_calling_thread");
        function _emscripten_set_canvas_element_size_main_thread(target, width, height) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(5, 1, target, width, height);
          return _emscripten_set_canvas_element_size_calling_thread(target, width, height);
        }
        __name(_emscripten_set_canvas_element_size_main_thread, "_emscripten_set_canvas_element_size_main_thread");
        function _emscripten_set_canvas_element_size(target, width, height) {
          var canvas = findCanvasEventTarget(target);
          if (canvas) {
            return _emscripten_set_canvas_element_size_calling_thread(target, width, height);
          } else {
            return _emscripten_set_canvas_element_size_main_thread(target, width, height);
          }
        }
        __name(_emscripten_set_canvas_element_size, "_emscripten_set_canvas_element_size");
        function _emscripten_set_current_thread_status(newStatus) {
        }
        __name(_emscripten_set_current_thread_status, "_emscripten_set_current_thread_status");
        function __webgl_enable_ANGLE_instanced_arrays(ctx) {
          var ext = ctx.getExtension("ANGLE_instanced_arrays");
          if (ext) {
            ctx["vertexAttribDivisor"] = function(index, divisor) {
              ext["vertexAttribDivisorANGLE"](index, divisor);
            };
            ctx["drawArraysInstanced"] = function(mode, first, count, primcount) {
              ext["drawArraysInstancedANGLE"](mode, first, count, primcount);
            };
            ctx["drawElementsInstanced"] = function(mode, count, type, indices, primcount) {
              ext["drawElementsInstancedANGLE"](mode, count, type, indices, primcount);
            };
            return 1;
          }
        }
        __name(__webgl_enable_ANGLE_instanced_arrays, "__webgl_enable_ANGLE_instanced_arrays");
        function __webgl_enable_OES_vertex_array_object(ctx) {
          var ext = ctx.getExtension("OES_vertex_array_object");
          if (ext) {
            ctx["createVertexArray"] = function() {
              return ext["createVertexArrayOES"]();
            };
            ctx["deleteVertexArray"] = function(vao) {
              ext["deleteVertexArrayOES"](vao);
            };
            ctx["bindVertexArray"] = function(vao) {
              ext["bindVertexArrayOES"](vao);
            };
            ctx["isVertexArray"] = function(vao) {
              return ext["isVertexArrayOES"](vao);
            };
            return 1;
          }
        }
        __name(__webgl_enable_OES_vertex_array_object, "__webgl_enable_OES_vertex_array_object");
        function __webgl_enable_WEBGL_draw_buffers(ctx) {
          var ext = ctx.getExtension("WEBGL_draw_buffers");
          if (ext) {
            ctx["drawBuffers"] = function(n, bufs) {
              ext["drawBuffersWEBGL"](n, bufs);
            };
            return 1;
          }
        }
        __name(__webgl_enable_WEBGL_draw_buffers, "__webgl_enable_WEBGL_draw_buffers");
        function __webgl_enable_WEBGL_multi_draw(ctx) {
          return !!(ctx.multiDrawWebgl = ctx.getExtension("WEBGL_multi_draw"));
        }
        __name(__webgl_enable_WEBGL_multi_draw, "__webgl_enable_WEBGL_multi_draw");
        var GL = { counter: 1, buffers: [], programs: [], framebuffers: [], renderbuffers: [], textures: [], shaders: [], vaos: [], contexts: {}, offscreenCanvases: {}, queries: [], stringCache: {}, unpackAlignment: 4, recordError: /* @__PURE__ */ __name(function recordError(errorCode) {
          if (!GL.lastError) {
            GL.lastError = errorCode;
          }
        }, "recordError"), getNewId: function(table) {
          var ret = GL.counter++;
          for (var i = table.length; i < ret; i++) {
            table[i] = null;
          }
          return ret;
        }, getSource: function(shader, count, string, length) {
          var source = "";
          for (var i = 0; i < count; ++i) {
            var len = length ? GROWABLE_HEAP_I32()[length + i * 4 >>> 2] : -1;
            source += UTF8ToString(GROWABLE_HEAP_I32()[string + i * 4 >>> 2], len < 0 ? void 0 : len);
          }
          return source;
        }, createContext: function(canvas, webGLContextAttributes) {
          if (!canvas.getContextSafariWebGL2Fixed) {
            canvas.getContextSafariWebGL2Fixed = canvas.getContext;
            canvas.getContext = function(ver, attrs) {
              var gl = canvas.getContextSafariWebGL2Fixed(ver, attrs);
              return ver == "webgl" == gl instanceof WebGLRenderingContext ? gl : null;
            };
          }
          var ctx = canvas.getContext("webgl", webGLContextAttributes);
          if (!ctx)
            return 0;
          var handle = GL.registerContext(ctx, webGLContextAttributes);
          return handle;
        }, registerContext: function(ctx, webGLContextAttributes) {
          var handle = _malloc(8);
          GROWABLE_HEAP_I32()[handle + 4 >>> 2] = _pthread_self();
          var context = { handle, attributes: webGLContextAttributes, version: webGLContextAttributes.majorVersion, GLctx: ctx };
          if (ctx.canvas)
            ctx.canvas.GLctxObject = context;
          GL.contexts[handle] = context;
          if (typeof webGLContextAttributes.enableExtensionsByDefault === "undefined" || webGLContextAttributes.enableExtensionsByDefault) {
            GL.initExtensions(context);
          }
          return handle;
        }, makeContextCurrent: function(contextHandle) {
          GL.currentContext = GL.contexts[contextHandle];
          Module.ctx = GLctx = GL.currentContext && GL.currentContext.GLctx;
          return !(contextHandle && !GLctx);
        }, getContext: function(contextHandle) {
          return GL.contexts[contextHandle];
        }, deleteContext: function(contextHandle) {
          if (GL.currentContext === GL.contexts[contextHandle])
            GL.currentContext = null;
          if (typeof JSEvents === "object")
            JSEvents.removeAllHandlersOnTarget(GL.contexts[contextHandle].GLctx.canvas);
          if (GL.contexts[contextHandle] && GL.contexts[contextHandle].GLctx.canvas)
            GL.contexts[contextHandle].GLctx.canvas.GLctxObject = void 0;
          _free(GL.contexts[contextHandle].handle);
          GL.contexts[contextHandle] = null;
        }, initExtensions: function(context) {
          if (!context)
            context = GL.currentContext;
          if (context.initExtensionsDone)
            return;
          context.initExtensionsDone = true;
          var GLctx2 = context.GLctx;
          __webgl_enable_ANGLE_instanced_arrays(GLctx2);
          __webgl_enable_OES_vertex_array_object(GLctx2);
          __webgl_enable_WEBGL_draw_buffers(GLctx2);
          {
            GLctx2.disjointTimerQueryExt = GLctx2.getExtension("EXT_disjoint_timer_query");
          }
          __webgl_enable_WEBGL_multi_draw(GLctx2);
          var exts = GLctx2.getSupportedExtensions() || [];
          exts.forEach(function(ext) {
            if (!ext.includes("lose_context") && !ext.includes("debug")) {
              GLctx2.getExtension(ext);
            }
          });
        } };
        var __emscripten_webgl_power_preferences = ["default", "low-power", "high-performance"];
        function _emscripten_webgl_do_create_context(target, attributes) {
          var a = attributes >> 2;
          var powerPreference = GROWABLE_HEAP_I32()[a + (24 >> 2) >>> 0];
          var contextAttributes = { "alpha": !!GROWABLE_HEAP_I32()[a + (0 >> 2) >>> 0], "depth": !!GROWABLE_HEAP_I32()[a + (4 >> 2) >>> 0], "stencil": !!GROWABLE_HEAP_I32()[a + (8 >> 2) >>> 0], "antialias": !!GROWABLE_HEAP_I32()[a + (12 >> 2) >>> 0], "premultipliedAlpha": !!GROWABLE_HEAP_I32()[a + (16 >> 2) >>> 0], "preserveDrawingBuffer": !!GROWABLE_HEAP_I32()[a + (20 >> 2) >>> 0], "powerPreference": __emscripten_webgl_power_preferences[powerPreference], "failIfMajorPerformanceCaveat": !!GROWABLE_HEAP_I32()[a + (28 >> 2) >>> 0], majorVersion: GROWABLE_HEAP_I32()[a + (32 >> 2) >>> 0], minorVersion: GROWABLE_HEAP_I32()[a + (36 >> 2) >>> 0], enableExtensionsByDefault: GROWABLE_HEAP_I32()[a + (40 >> 2) >>> 0], explicitSwapControl: GROWABLE_HEAP_I32()[a + (44 >> 2) >>> 0], proxyContextToMainThread: GROWABLE_HEAP_I32()[a + (48 >> 2) >>> 0], renderViaOffscreenBackBuffer: GROWABLE_HEAP_I32()[a + (52 >> 2) >>> 0] };
          var canvas = findCanvasEventTarget(target);
          if (!canvas) {
            return 0;
          }
          if (contextAttributes.explicitSwapControl) {
            return 0;
          }
          var contextHandle = GL.createContext(canvas, contextAttributes);
          return contextHandle;
        }
        __name(_emscripten_webgl_do_create_context, "_emscripten_webgl_do_create_context");
        function _emscripten_webgl_create_context(a0, a1) {
          return _emscripten_webgl_do_create_context(a0, a1);
        }
        __name(_emscripten_webgl_create_context, "_emscripten_webgl_create_context");
        var ENV = {};
        function getExecutableName() {
          return thisProgram || "./this.program";
        }
        __name(getExecutableName, "getExecutableName");
        function getEnvStrings() {
          if (!getEnvStrings.strings) {
            var lang = (typeof navigator === "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
            var env = { "USER": "web_user", "LOGNAME": "web_user", "PATH": "/", "PWD": "/", "HOME": "/home/web_user", "LANG": lang, "_": getExecutableName() };
            for (var x in ENV) {
              if (ENV[x] === void 0)
                delete env[x];
              else
                env[x] = ENV[x];
            }
            var strings = [];
            for (var x in env) {
              strings.push(x + "=" + env[x]);
            }
            getEnvStrings.strings = strings;
          }
          return getEnvStrings.strings;
        }
        __name(getEnvStrings, "getEnvStrings");
        function _environ_get(__environ, environ_buf) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(6, 1, __environ, environ_buf);
          try {
            var bufSize = 0;
            getEnvStrings().forEach(function(string, i) {
              var ptr = environ_buf + bufSize;
              GROWABLE_HEAP_I32()[__environ + i * 4 >>> 2] = ptr;
              writeAsciiToMemory(string, ptr);
              bufSize += string.length + 1;
            });
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        __name(_environ_get, "_environ_get");
        function _environ_sizes_get(penviron_count, penviron_buf_size) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(7, 1, penviron_count, penviron_buf_size);
          try {
            var strings = getEnvStrings();
            GROWABLE_HEAP_I32()[penviron_count >>> 2] = strings.length;
            var bufSize = 0;
            strings.forEach(function(string) {
              bufSize += string.length + 1;
            });
            GROWABLE_HEAP_I32()[penviron_buf_size >>> 2] = bufSize;
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        __name(_environ_sizes_get, "_environ_sizes_get");
        function _fd_close(fd) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(8, 1, fd);
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            FS.close(stream);
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        __name(_fd_close, "_fd_close");
        function _fd_read(fd, iov, iovcnt, pnum) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(9, 1, fd, iov, iovcnt, pnum);
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var num = SYSCALLS.doReadv(stream, iov, iovcnt);
            GROWABLE_HEAP_I32()[pnum >>> 2] = num;
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        __name(_fd_read, "_fd_read");
        function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(10, 1, fd, offset_low, offset_high, whence, newOffset);
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var HIGH_OFFSET = 4294967296;
            var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);
            var DOUBLE_LIMIT = 9007199254740992;
            if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {
              return -61;
            }
            FS.llseek(stream, offset, whence);
            tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], GROWABLE_HEAP_I32()[newOffset >>> 2] = tempI64[0], GROWABLE_HEAP_I32()[newOffset + 4 >>> 2] = tempI64[1];
            if (stream.getdents && offset === 0 && whence === 0)
              stream.getdents = null;
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        __name(_fd_seek, "_fd_seek");
        function _fd_write(fd, iov, iovcnt, pnum) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(11, 1, fd, iov, iovcnt, pnum);
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var num = SYSCALLS.doWritev(stream, iov, iovcnt);
            GROWABLE_HEAP_I32()[pnum >>> 2] = num;
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        __name(_fd_write, "_fd_write");
        function _getTempRet0() {
          return getTempRet0();
        }
        __name(_getTempRet0, "_getTempRet0");
        function _llvm_eh_typeid_for(type) {
          return type;
        }
        __name(_llvm_eh_typeid_for, "_llvm_eh_typeid_for");
        function spawnThread(threadParams) {
          if (ENVIRONMENT_IS_PTHREAD)
            throw "Internal Error! spawnThread() can only ever be called from main application thread!";
          var worker = PThread.getNewWorker();
          if (!worker) {
            return 6;
          }
          if (worker.pthread !== void 0)
            throw "Internal error!";
          if (!threadParams.pthread_ptr)
            throw "Internal error, no pthread ptr!";
          PThread.runningWorkers.push(worker);
          var tlsMemory = _malloc(128 * 4);
          for (var i = 0; i < 128; ++i) {
            GROWABLE_HEAP_I32()[tlsMemory + i * 4 >>> 2] = 0;
          }
          var stackHigh = threadParams.stackBase + threadParams.stackSize;
          var pthread = PThread.pthreads[threadParams.pthread_ptr] = { worker, stackBase: threadParams.stackBase, stackSize: threadParams.stackSize, allocatedOwnStack: threadParams.allocatedOwnStack, threadInfoStruct: threadParams.pthread_ptr };
          var tis = pthread.threadInfoStruct >> 2;
          Atomics.store(GROWABLE_HEAP_U32(), tis + (64 >> 2), threadParams.detached);
          Atomics.store(GROWABLE_HEAP_U32(), tis + (100 >> 2), tlsMemory);
          Atomics.store(GROWABLE_HEAP_U32(), tis + (40 >> 2), pthread.threadInfoStruct);
          Atomics.store(GROWABLE_HEAP_U32(), tis + (80 >> 2), threadParams.stackSize);
          Atomics.store(GROWABLE_HEAP_U32(), tis + (76 >> 2), stackHigh);
          Atomics.store(GROWABLE_HEAP_U32(), tis + (104 >> 2), threadParams.stackSize);
          Atomics.store(GROWABLE_HEAP_U32(), tis + (104 + 8 >> 2), stackHigh);
          Atomics.store(GROWABLE_HEAP_U32(), tis + (104 + 12 >> 2), threadParams.detached);
          var global_libc = _emscripten_get_global_libc();
          var global_locale = global_libc + 40;
          Atomics.store(GROWABLE_HEAP_U32(), tis + (172 >> 2), global_locale);
          worker.pthread = pthread;
          var msg = { "cmd": "run", "start_routine": threadParams.startRoutine, "arg": threadParams.arg, "threadInfoStruct": threadParams.pthread_ptr, "stackBase": threadParams.stackBase, "stackSize": threadParams.stackSize };
          worker.runPthread = function() {
            msg.time = performance.now();
            worker.postMessage(msg, threadParams.transferList);
          };
          if (worker.loaded) {
            worker.runPthread();
            delete worker.runPthread;
          }
          return 0;
        }
        __name(spawnThread, "spawnThread");
        function _pthread_create(pthread_ptr, attr, start_routine, arg) {
          if (typeof SharedArrayBuffer === "undefined") {
            err("Current environment does not support SharedArrayBuffer, pthreads are not available!");
            return 6;
          }
          if (!pthread_ptr) {
            err("pthread_create called with a null thread pointer!");
            return 28;
          }
          var transferList = [];
          var error = 0;
          if (ENVIRONMENT_IS_PTHREAD && (transferList.length === 0 || error)) {
            return _emscripten_sync_run_in_main_thread_4(687865856, pthread_ptr, attr, start_routine, arg);
          }
          if (error)
            return error;
          var stackSize = 0;
          var stackBase = 0;
          var detached = 0;
          if (attr && attr != -1) {
            stackSize = GROWABLE_HEAP_I32()[attr >>> 2];
            stackSize += 81920;
            stackBase = GROWABLE_HEAP_I32()[attr + 8 >>> 2];
            detached = GROWABLE_HEAP_I32()[attr + 12 >>> 2] !== 0;
          } else {
            stackSize = 2097152;
          }
          var allocatedOwnStack = stackBase == 0;
          if (allocatedOwnStack) {
            stackBase = _memalign(16, stackSize);
          } else {
            stackBase -= stackSize;
            assert(stackBase > 0);
          }
          var threadInfoStruct = _malloc(228);
          for (var i = 0; i < 228 >> 2; ++i)
            GROWABLE_HEAP_U32()[(threadInfoStruct >> 2) + i >>> 0] = 0;
          GROWABLE_HEAP_I32()[pthread_ptr >>> 2] = threadInfoStruct;
          GROWABLE_HEAP_I32()[threadInfoStruct + 12 >>> 2] = threadInfoStruct;
          var headPtr = threadInfoStruct + 152;
          GROWABLE_HEAP_I32()[headPtr >>> 2] = headPtr;
          var threadParams = { stackBase, stackSize, allocatedOwnStack, detached, startRoutine: start_routine, pthread_ptr: threadInfoStruct, arg, transferList };
          if (ENVIRONMENT_IS_PTHREAD) {
            threadParams.cmd = "spawnThread";
            postMessage(threadParams, transferList);
            return 0;
          }
          return spawnThread(threadParams);
        }
        __name(_pthread_create, "_pthread_create");
        function _setTempRet0(val) {
          setTempRet0(val);
        }
        __name(_setTempRet0, "_setTempRet0");
        function __isLeapYear(year) {
          return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
        }
        __name(__isLeapYear, "__isLeapYear");
        function __arraySum(array, index) {
          var sum = 0;
          for (var i = 0; i <= index; sum += array[i++]) {
          }
          return sum;
        }
        __name(__arraySum, "__arraySum");
        var __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        var __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        function __addDays(date, days) {
          var newDate = new Date(date.getTime());
          while (days > 0) {
            var leap = __isLeapYear(newDate.getFullYear());
            var currentMonth = newDate.getMonth();
            var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];
            if (days > daysInCurrentMonth - newDate.getDate()) {
              days -= daysInCurrentMonth - newDate.getDate() + 1;
              newDate.setDate(1);
              if (currentMonth < 11) {
                newDate.setMonth(currentMonth + 1);
              } else {
                newDate.setMonth(0);
                newDate.setFullYear(newDate.getFullYear() + 1);
              }
            } else {
              newDate.setDate(newDate.getDate() + days);
              return newDate;
            }
          }
          return newDate;
        }
        __name(__addDays, "__addDays");
        function _strftime(s, maxsize, format2, tm) {
          var tm_zone = GROWABLE_HEAP_I32()[tm + 40 >>> 2];
          var date = { tm_sec: GROWABLE_HEAP_I32()[tm >>> 2], tm_min: GROWABLE_HEAP_I32()[tm + 4 >>> 2], tm_hour: GROWABLE_HEAP_I32()[tm + 8 >>> 2], tm_mday: GROWABLE_HEAP_I32()[tm + 12 >>> 2], tm_mon: GROWABLE_HEAP_I32()[tm + 16 >>> 2], tm_year: GROWABLE_HEAP_I32()[tm + 20 >>> 2], tm_wday: GROWABLE_HEAP_I32()[tm + 24 >>> 2], tm_yday: GROWABLE_HEAP_I32()[tm + 28 >>> 2], tm_isdst: GROWABLE_HEAP_I32()[tm + 32 >>> 2], tm_gmtoff: GROWABLE_HEAP_I32()[tm + 36 >>> 2], tm_zone: tm_zone ? UTF8ToString(tm_zone) : "" };
          var pattern = UTF8ToString(format2);
          var EXPANSION_RULES_1 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" };
          for (var rule in EXPANSION_RULES_1) {
            pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
          }
          var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
          var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
          function leadingSomething(value, digits, character) {
            var str = typeof value === "number" ? value.toString() : value || "";
            while (str.length < digits) {
              str = character[0] + str;
            }
            return str;
          }
          __name(leadingSomething, "leadingSomething");
          function leadingNulls(value, digits) {
            return leadingSomething(value, digits, "0");
          }
          __name(leadingNulls, "leadingNulls");
          function compareByDay(date1, date2) {
            function sgn(value) {
              return value < 0 ? -1 : value > 0 ? 1 : 0;
            }
            __name(sgn, "sgn");
            var compare;
            if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
              if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
                compare = sgn(date1.getDate() - date2.getDate());
              }
            }
            return compare;
          }
          __name(compareByDay, "compareByDay");
          function getFirstWeekStartDate(janFourth) {
            switch (janFourth.getDay()) {
              case 0:
                return new Date(janFourth.getFullYear() - 1, 11, 29);
              case 1:
                return janFourth;
              case 2:
                return new Date(janFourth.getFullYear(), 0, 3);
              case 3:
                return new Date(janFourth.getFullYear(), 0, 2);
              case 4:
                return new Date(janFourth.getFullYear(), 0, 1);
              case 5:
                return new Date(janFourth.getFullYear() - 1, 11, 31);
              case 6:
                return new Date(janFourth.getFullYear() - 1, 11, 30);
            }
          }
          __name(getFirstWeekStartDate, "getFirstWeekStartDate");
          function getWeekBasedYear(date2) {
            var thisDate = __addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
            var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
            var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
            var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
            var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
            if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
              if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
                return thisDate.getFullYear() + 1;
              } else {
                return thisDate.getFullYear();
              }
            } else {
              return thisDate.getFullYear() - 1;
            }
          }
          __name(getWeekBasedYear, "getWeekBasedYear");
          var EXPANSION_RULES_2 = { "%a": function(date2) {
            return WEEKDAYS[date2.tm_wday].substring(0, 3);
          }, "%A": function(date2) {
            return WEEKDAYS[date2.tm_wday];
          }, "%b": function(date2) {
            return MONTHS[date2.tm_mon].substring(0, 3);
          }, "%B": function(date2) {
            return MONTHS[date2.tm_mon];
          }, "%C": function(date2) {
            var year = date2.tm_year + 1900;
            return leadingNulls(year / 100 | 0, 2);
          }, "%d": function(date2) {
            return leadingNulls(date2.tm_mday, 2);
          }, "%e": function(date2) {
            return leadingSomething(date2.tm_mday, 2, " ");
          }, "%g": function(date2) {
            return getWeekBasedYear(date2).toString().substring(2);
          }, "%G": function(date2) {
            return getWeekBasedYear(date2);
          }, "%H": function(date2) {
            return leadingNulls(date2.tm_hour, 2);
          }, "%I": function(date2) {
            var twelveHour = date2.tm_hour;
            if (twelveHour == 0)
              twelveHour = 12;
            else if (twelveHour > 12)
              twelveHour -= 12;
            return leadingNulls(twelveHour, 2);
          }, "%j": function(date2) {
            return leadingNulls(date2.tm_mday + __arraySum(__isLeapYear(date2.tm_year + 1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3);
          }, "%m": function(date2) {
            return leadingNulls(date2.tm_mon + 1, 2);
          }, "%M": function(date2) {
            return leadingNulls(date2.tm_min, 2);
          }, "%n": function() {
            return "\n";
          }, "%p": function(date2) {
            if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
              return "AM";
            } else {
              return "PM";
            }
          }, "%S": function(date2) {
            return leadingNulls(date2.tm_sec, 2);
          }, "%t": function() {
            return "	";
          }, "%u": function(date2) {
            return date2.tm_wday || 7;
          }, "%U": function(date2) {
            var janFirst = new Date(date2.tm_year + 1900, 0, 1);
            var firstSunday = janFirst.getDay() === 0 ? janFirst : __addDays(janFirst, 7 - janFirst.getDay());
            var endDate = new Date(date2.tm_year + 1900, date2.tm_mon, date2.tm_mday);
            if (compareByDay(firstSunday, endDate) < 0) {
              var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;
              var firstSundayUntilEndJanuary = 31 - firstSunday.getDate();
              var days = firstSundayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();
              return leadingNulls(Math.ceil(days / 7), 2);
            }
            return compareByDay(firstSunday, janFirst) === 0 ? "01" : "00";
          }, "%V": function(date2) {
            var janFourthThisYear = new Date(date2.tm_year + 1900, 0, 4);
            var janFourthNextYear = new Date(date2.tm_year + 1901, 0, 4);
            var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
            var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
            var endDate = __addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
            if (compareByDay(endDate, firstWeekStartThisYear) < 0) {
              return "53";
            }
            if (compareByDay(firstWeekStartNextYear, endDate) <= 0) {
              return "01";
            }
            var daysDifference;
            if (firstWeekStartThisYear.getFullYear() < date2.tm_year + 1900) {
              daysDifference = date2.tm_yday + 32 - firstWeekStartThisYear.getDate();
            } else {
              daysDifference = date2.tm_yday + 1 - firstWeekStartThisYear.getDate();
            }
            return leadingNulls(Math.ceil(daysDifference / 7), 2);
          }, "%w": function(date2) {
            return date2.tm_wday;
          }, "%W": function(date2) {
            var janFirst = new Date(date2.tm_year, 0, 1);
            var firstMonday = janFirst.getDay() === 1 ? janFirst : __addDays(janFirst, janFirst.getDay() === 0 ? 1 : 7 - janFirst.getDay() + 1);
            var endDate = new Date(date2.tm_year + 1900, date2.tm_mon, date2.tm_mday);
            if (compareByDay(firstMonday, endDate) < 0) {
              var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;
              var firstMondayUntilEndJanuary = 31 - firstMonday.getDate();
              var days = firstMondayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();
              return leadingNulls(Math.ceil(days / 7), 2);
            }
            return compareByDay(firstMonday, janFirst) === 0 ? "01" : "00";
          }, "%y": function(date2) {
            return (date2.tm_year + 1900).toString().substring(2);
          }, "%Y": function(date2) {
            return date2.tm_year + 1900;
          }, "%z": function(date2) {
            var off = date2.tm_gmtoff;
            var ahead = off >= 0;
            off = Math.abs(off) / 60;
            off = off / 60 * 100 + off % 60;
            return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
          }, "%Z": function(date2) {
            return date2.tm_zone;
          }, "%%": function() {
            return "%";
          } };
          for (var rule in EXPANSION_RULES_2) {
            if (pattern.includes(rule)) {
              pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
            }
          }
          var bytes = intArrayFromString(pattern, false);
          if (bytes.length > maxsize) {
            return 0;
          }
          writeArrayToMemory(bytes, s);
          return bytes.length - 1;
        }
        __name(_strftime, "_strftime");
        function _strftime_l(s, maxsize, format2, tm) {
          return _strftime(s, maxsize, format2, tm);
        }
        __name(_strftime_l, "_strftime_l");
        if (!ENVIRONMENT_IS_PTHREAD)
          PThread.initMainThreadBlock();
        var FSNode = /* @__PURE__ */ __name(function(parent, name2, mode, rdev) {
          if (!parent) {
            parent = this;
          }
          this.parent = parent;
          this.mount = parent.mount;
          this.mounted = null;
          this.id = FS.nextInode++;
          this.name = name2;
          this.mode = mode;
          this.node_ops = {};
          this.stream_ops = {};
          this.rdev = rdev;
        }, "FSNode");
        var readMode = 292 | 73;
        var writeMode = 146;
        Object.defineProperties(FSNode.prototype, { read: { get: function() {
          return (this.mode & readMode) === readMode;
        }, set: function(val) {
          val ? this.mode |= readMode : this.mode &= ~readMode;
        } }, write: { get: function() {
          return (this.mode & writeMode) === writeMode;
        }, set: function(val) {
          val ? this.mode |= writeMode : this.mode &= ~writeMode;
        } }, isFolder: { get: function() {
          return FS.isDir(this.mode);
        } }, isDevice: { get: function() {
          return FS.isChrdev(this.mode);
        } } });
        FS.FSNode = FSNode;
        FS.staticInit();
        Module["FS_createPath"] = FS.createPath;
        Module["FS_createDataFile"] = FS.createDataFile;
        Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
        Module["FS_createLazyFile"] = FS.createLazyFile;
        Module["FS_createDevice"] = FS.createDevice;
        Module["FS_unlink"] = FS.unlink;
        InternalError = Module["InternalError"] = extendError(Error, "InternalError");
        embind_init_charCodes();
        BindingError = Module["BindingError"] = extendError(Error, "BindingError");
        init_ClassHandle();
        init_RegisteredPointer();
        init_embind();
        UnboundTypeError = Module["UnboundTypeError"] = extendError(Error, "UnboundTypeError");
        init_emval();
        var GLctx;
        var proxiedFunctionTable = [null, _atexit, ___sys_fcntl64, ___sys_ioctl, ___sys_open, _emscripten_set_canvas_element_size_main_thread, _environ_get, _environ_sizes_get, _fd_close, _fd_read, _fd_seek, _fd_write];
        function intArrayFromString(stringy, dontAddNull, length) {
          var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
          var u8array = new Array(len);
          var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
          if (dontAddNull)
            u8array.length = numBytesWritten;
          return u8array;
        }
        __name(intArrayFromString, "intArrayFromString");
        var asmLibraryArg = { "z": ___assert_fail, "n": ___cxa_allocate_exception, "v": ___cxa_begin_catch, "y": ___cxa_end_catch, "c": ___cxa_find_matching_catch_2, "m": ___cxa_find_matching_catch_3, "C": ___cxa_free_exception, "ba": ___cxa_rethrow, "La": ___cxa_thread_atexit, "o": ___cxa_throw, "ta": ___cxa_uncaught_exceptions, "i": ___resumeException, "da": ___sys_fcntl64, "ua": ___sys_ioctl, "va": ___sys_open, "Oa": __embind_finalize_value_array, "Ra": __embind_finalize_value_object, "_a": __embind_register_bigint, "Ja": __embind_register_bool, "O": __embind_register_class, "N": __embind_register_class_constructor, "q": __embind_register_class_function, "Ia": __embind_register_emval, "Ma": __embind_register_enum, "T": __embind_register_enum_value, "ja": __embind_register_float, "t": __embind_register_function, "B": __embind_register_integer, "x": __embind_register_memory_view, "ka": __embind_register_std_string, "Y": __embind_register_std_wstring, "Pa": __embind_register_value_array, "Na": __embind_register_value_array_element, "M": __embind_register_value_object, "Qa": __embind_register_value_object_field, "Ka": __embind_register_void, "Ca": __emscripten_notify_thread_queue, "U": __emval_as, "la": __emval_call, "xa": __emval_decref, "$a": __emval_get_global, "Ua": __emval_get_property, "aa": __emval_incref, "pa": __emval_instanceof, "Xa": __emval_is_number, "Wa": __emval_new_array, "Z": __emval_new_cstring, "Va": __emval_new_object, "Ta": __emval_run_destructors, "Sa": __emval_set_property, "D": __emval_take_value, "ia": _abort, "ca": _clock_gettime, "ga": _emscripten_asm_const_int, "wa": _emscripten_check_blocking_allowed, "fa": _emscripten_conditional_set_current_thread_status, "K": _emscripten_futex_wait, "J": _emscripten_futex_wake, "S": _emscripten_get_now, "ra": _emscripten_memcpy_big, "ya": _emscripten_receive_on_main_thread_js, "sa": _emscripten_resize_heap, "za": _emscripten_set_canvas_element_size, "ea": _emscripten_set_current_thread_status, "Aa": _emscripten_webgl_create_context, "Ea": _environ_get, "Fa": _environ_sizes_get, "ha": _fd_close, "Ha": _fd_read, "Za": _fd_seek, "Ga": _fd_write, "b": _getTempRet0, "qa": initPthreadsJS, "I": invoke_diii, "E": invoke_i, "d": invoke_ii, "Q": invoke_iid, "j": invoke_iii, "k": invoke_iiii, "R": invoke_iiiii, "na": invoke_iiiiid, "G": invoke_iiiiii, "A": invoke_iiiiiii, "_": invoke_iiiiiiii, "P": invoke_iiiiiiiii, "W": invoke_iiiiiiiiiiii, "Ya": invoke_j, "g": invoke_v, "f": invoke_vi, "L": invoke_viddi, "H": invoke_viffiid, "h": invoke_vii, "s": invoke_viidd, "e": invoke_viii, "l": invoke_viiii, "$": invoke_viiiid, "X": invoke_viiiidii, "F": invoke_viiiii, "w": invoke_viiiiii, "r": invoke_viiiiiii, "u": invoke_viiiiiiiii, "p": invoke_viiiiiiiiii, "V": invoke_viiiiiiiiiiiiiii, "oa": _llvm_eh_typeid_for, "a": wasmMemory || Module["wasmMemory"], "Ba": _pthread_create, "ma": _setTempRet0, "Da": _strftime_l };
        var asm = createWasm();
        var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
          return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["ab"]).apply(null, arguments);
        };
        var _main = Module["_main"] = function() {
          return (_main = Module["_main"] = Module["asm"]["bb"]).apply(null, arguments);
        };
        var _malloc = Module["_malloc"] = function() {
          return (_malloc = Module["_malloc"] = Module["asm"]["cb"]).apply(null, arguments);
        };
        var _free = Module["_free"] = function() {
          return (_free = Module["_free"] = Module["asm"]["eb"]).apply(null, arguments);
        };
        var _emscripten_tls_init = Module["_emscripten_tls_init"] = function() {
          return (_emscripten_tls_init = Module["_emscripten_tls_init"] = Module["asm"]["fb"]).apply(null, arguments);
        };
        var ___getTypeName = Module["___getTypeName"] = function() {
          return (___getTypeName = Module["___getTypeName"] = Module["asm"]["gb"]).apply(null, arguments);
        };
        var ___embind_register_native_and_builtin_types = Module["___embind_register_native_and_builtin_types"] = function() {
          return (___embind_register_native_and_builtin_types = Module["___embind_register_native_and_builtin_types"] = Module["asm"]["hb"]).apply(null, arguments);
        };
        var _emscripten_current_thread_process_queued_calls = Module["_emscripten_current_thread_process_queued_calls"] = function() {
          return (_emscripten_current_thread_process_queued_calls = Module["_emscripten_current_thread_process_queued_calls"] = Module["asm"]["ib"]).apply(null, arguments);
        };
        var _emscripten_register_main_browser_thread_id = Module["_emscripten_register_main_browser_thread_id"] = function() {
          return (_emscripten_register_main_browser_thread_id = Module["_emscripten_register_main_browser_thread_id"] = Module["asm"]["jb"]).apply(null, arguments);
        };
        var __emscripten_do_dispatch_to_thread = Module["__emscripten_do_dispatch_to_thread"] = function() {
          return (__emscripten_do_dispatch_to_thread = Module["__emscripten_do_dispatch_to_thread"] = Module["asm"]["kb"]).apply(null, arguments);
        };
        var _emscripten_sync_run_in_main_thread_4 = Module["_emscripten_sync_run_in_main_thread_4"] = function() {
          return (_emscripten_sync_run_in_main_thread_4 = Module["_emscripten_sync_run_in_main_thread_4"] = Module["asm"]["lb"]).apply(null, arguments);
        };
        var _emscripten_main_thread_process_queued_calls = Module["_emscripten_main_thread_process_queued_calls"] = function() {
          return (_emscripten_main_thread_process_queued_calls = Module["_emscripten_main_thread_process_queued_calls"] = Module["asm"]["mb"]).apply(null, arguments);
        };
        var _emscripten_run_in_main_runtime_thread_js = Module["_emscripten_run_in_main_runtime_thread_js"] = function() {
          return (_emscripten_run_in_main_runtime_thread_js = Module["_emscripten_run_in_main_runtime_thread_js"] = Module["asm"]["nb"]).apply(null, arguments);
        };
        var __emscripten_call_on_thread = Module["__emscripten_call_on_thread"] = function() {
          return (__emscripten_call_on_thread = Module["__emscripten_call_on_thread"] = Module["asm"]["ob"]).apply(null, arguments);
        };
        var __emscripten_thread_init = Module["__emscripten_thread_init"] = function() {
          return (__emscripten_thread_init = Module["__emscripten_thread_init"] = Module["asm"]["pb"]).apply(null, arguments);
        };
        var _emscripten_get_global_libc = Module["_emscripten_get_global_libc"] = function() {
          return (_emscripten_get_global_libc = Module["_emscripten_get_global_libc"] = Module["asm"]["qb"]).apply(null, arguments);
        };
        var ___errno_location = Module["___errno_location"] = function() {
          return (___errno_location = Module["___errno_location"] = Module["asm"]["rb"]).apply(null, arguments);
        };
        var _pthread_self = Module["_pthread_self"] = function() {
          return (_pthread_self = Module["_pthread_self"] = Module["asm"]["sb"]).apply(null, arguments);
        };
        var ___pthread_tsd_run_dtors = Module["___pthread_tsd_run_dtors"] = function() {
          return (___pthread_tsd_run_dtors = Module["___pthread_tsd_run_dtors"] = Module["asm"]["tb"]).apply(null, arguments);
        };
        var stackSave = Module["stackSave"] = function() {
          return (stackSave = Module["stackSave"] = Module["asm"]["ub"]).apply(null, arguments);
        };
        var stackRestore = Module["stackRestore"] = function() {
          return (stackRestore = Module["stackRestore"] = Module["asm"]["vb"]).apply(null, arguments);
        };
        var stackAlloc = Module["stackAlloc"] = function() {
          return (stackAlloc = Module["stackAlloc"] = Module["asm"]["wb"]).apply(null, arguments);
        };
        var _emscripten_stack_set_limits = Module["_emscripten_stack_set_limits"] = function() {
          return (_emscripten_stack_set_limits = Module["_emscripten_stack_set_limits"] = Module["asm"]["xb"]).apply(null, arguments);
        };
        var _setThrew = Module["_setThrew"] = function() {
          return (_setThrew = Module["_setThrew"] = Module["asm"]["yb"]).apply(null, arguments);
        };
        var ___cxa_can_catch = Module["___cxa_can_catch"] = function() {
          return (___cxa_can_catch = Module["___cxa_can_catch"] = Module["asm"]["zb"]).apply(null, arguments);
        };
        var ___cxa_is_pointer_type = Module["___cxa_is_pointer_type"] = function() {
          return (___cxa_is_pointer_type = Module["___cxa_is_pointer_type"] = Module["asm"]["Ab"]).apply(null, arguments);
        };
        var _memalign = Module["_memalign"] = function() {
          return (_memalign = Module["_memalign"] = Module["asm"]["Bb"]).apply(null, arguments);
        };
        var dynCall_jiji = Module["dynCall_jiji"] = function() {
          return (dynCall_jiji = Module["dynCall_jiji"] = Module["asm"]["Cb"]).apply(null, arguments);
        };
        var dynCall_j = Module["dynCall_j"] = function() {
          return (dynCall_j = Module["dynCall_j"] = Module["asm"]["Db"]).apply(null, arguments);
        };
        var dynCall_viijii = Module["dynCall_viijii"] = function() {
          return (dynCall_viijii = Module["dynCall_viijii"] = Module["asm"]["Eb"]).apply(null, arguments);
        };
        var dynCall_iiiiij = Module["dynCall_iiiiij"] = function() {
          return (dynCall_iiiiij = Module["dynCall_iiiiij"] = Module["asm"]["Fb"]).apply(null, arguments);
        };
        var dynCall_iiiiijj = Module["dynCall_iiiiijj"] = function() {
          return (dynCall_iiiiijj = Module["dynCall_iiiiijj"] = Module["asm"]["Gb"]).apply(null, arguments);
        };
        var dynCall_iiiiiijj = Module["dynCall_iiiiiijj"] = function() {
          return (dynCall_iiiiiijj = Module["dynCall_iiiiiijj"] = Module["asm"]["Hb"]).apply(null, arguments);
        };
        var __emscripten_allow_main_runtime_queued_calls = Module["__emscripten_allow_main_runtime_queued_calls"] = 56672;
        var __emscripten_main_thread_futex = Module["__emscripten_main_thread_futex"] = 60132;
        function invoke_ii(index, a1) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_ii, "invoke_ii");
        function invoke_viiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_viiiiiiiiii, "invoke_viiiiiiiiii");
        function invoke_vi(index, a1) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_vi, "invoke_vi");
        function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_viiiiiiiii, "invoke_viiiiiiiii");
        function invoke_v(index) {
          var sp = stackSave();
          try {
            wasmTable.get(index)();
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_v, "invoke_v");
        function invoke_viii(index, a1, a2, a3) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_viii, "invoke_viii");
        function invoke_viiii(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_viiii, "invoke_viiii");
        function invoke_iii(index, a1, a2) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_iii, "invoke_iii");
        function invoke_vii(index, a1, a2) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_vii, "invoke_vii");
        function invoke_iiiii(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_iiiii, "invoke_iiiii");
        function invoke_diii(index, a1, a2, a3) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_diii, "invoke_diii");
        function invoke_i(index) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)();
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_i, "invoke_i");
        function invoke_iiii(index, a1, a2, a3) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_iiii, "invoke_iiii");
        function invoke_iid(index, a1, a2) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_iid, "invoke_iid");
        function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_iiiiiii, "invoke_iiiiiii");
        function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_viiiiii, "invoke_viiiiii");
        function invoke_viiiidii(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_viiiidii, "invoke_viiiidii");
        function invoke_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_viiiiiii, "invoke_viiiiiii");
        function invoke_viffiid(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_viffiid, "invoke_viffiid");
        function invoke_viddi(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_viddi, "invoke_viddi");
        function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_iiiiii, "invoke_iiiiii");
        function invoke_viiiii(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_viiiii, "invoke_viiiii");
        function invoke_viidd(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_viidd, "invoke_viidd");
        function invoke_viiiid(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_viiiid, "invoke_viiiid");
        function invoke_iiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_iiiiiiiii, "invoke_iiiiiiiii");
        function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_iiiiiiii, "invoke_iiiiiiii");
        function invoke_iiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_iiiiiiiiiiii, "invoke_iiiiiiiiiiii");
        function invoke_viiiiiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_viiiiiiiiiiiiiii, "invoke_viiiiiiiiiiiiiii");
        function invoke_iiiiid(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_iiiiid, "invoke_iiiiid");
        function invoke_j(index) {
          var sp = stackSave();
          try {
            return dynCall_j(index);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_j, "invoke_j");
        Module["addRunDependency"] = addRunDependency;
        Module["removeRunDependency"] = removeRunDependency;
        Module["FS_createPath"] = FS.createPath;
        Module["FS_createDataFile"] = FS.createDataFile;
        Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
        Module["FS_createLazyFile"] = FS.createLazyFile;
        Module["FS_createDevice"] = FS.createDevice;
        Module["FS_unlink"] = FS.unlink;
        Module["keepRuntimeAlive"] = keepRuntimeAlive;
        Module["FS"] = FS;
        Module["PThread"] = PThread;
        Module["PThread"] = PThread;
        Module["wasmMemory"] = wasmMemory;
        Module["ExitStatus"] = ExitStatus;
        var calledRun;
        function ExitStatus(status) {
          this.name = "ExitStatus";
          this.message = "Program terminated with exit(" + status + ")";
          this.status = status;
        }
        __name(ExitStatus, "ExitStatus");
        var calledMain = false;
        dependenciesFulfilled = /* @__PURE__ */ __name(function runCaller() {
          if (!calledRun)
            run();
          if (!calledRun)
            dependenciesFulfilled = runCaller;
        }, "runCaller");
        function callMain(args) {
          var entryFunction = Module["_main"];
          var argc = 0;
          var argv = 0;
          try {
            var ret = entryFunction(argc, argv);
            exit(ret, true);
          } catch (e) {
            if (e instanceof ExitStatus || e == "unwind") {
              return;
            }
            var toLog = e;
            if (e && typeof e === "object" && e.stack) {
              toLog = [e, e.stack];
            }
            err("exception thrown: " + toLog);
            quit_(1, e);
          } finally {
            calledMain = true;
          }
        }
        __name(callMain, "callMain");
        function run(args) {
          args = args || arguments_;
          if (runDependencies > 0) {
            return;
          }
          if (ENVIRONMENT_IS_PTHREAD) {
            readyPromiseResolve(Module);
            initRuntime();
            postMessage({ "cmd": "loaded" });
            return;
          }
          preRun();
          if (runDependencies > 0) {
            return;
          }
          function doRun() {
            if (calledRun)
              return;
            calledRun = true;
            Module["calledRun"] = true;
            if (ABORT)
              return;
            initRuntime();
            preMain();
            readyPromiseResolve(Module);
            if (Module["onRuntimeInitialized"])
              Module["onRuntimeInitialized"]();
            if (shouldRunNow)
              callMain(args);
            postRun();
          }
          __name(doRun, "doRun");
          if (Module["setStatus"]) {
            Module["setStatus"]("Running...");
            setTimeout(function() {
              setTimeout(function() {
                Module["setStatus"]("");
              }, 1);
              doRun();
            }, 1);
          } else {
            doRun();
          }
        }
        __name(run, "run");
        Module["run"] = run;
        function exit(status, implicit) {
          EXITSTATUS = status;
          if (!implicit) {
            if (ENVIRONMENT_IS_PTHREAD) {
              postMessage({ "cmd": "exitProcess", "returnCode": status });
              throw new ExitStatus(status);
            } else {
            }
          }
          if (keepRuntimeAlive()) {
          } else {
            PThread.terminateAllThreads();
            exitRuntime();
            if (Module["onExit"])
              Module["onExit"](status);
            ABORT = true;
          }
          quit_(status, new ExitStatus(status));
        }
        __name(exit, "exit");
        if (Module["preInit"]) {
          if (typeof Module["preInit"] == "function")
            Module["preInit"] = [Module["preInit"]];
          while (Module["preInit"].length > 0) {
            Module["preInit"].pop()();
          }
        }
        var shouldRunNow = true;
        if (Module["noInitialRun"])
          shouldRunNow = false;
        if (ENVIRONMENT_IS_PTHREAD) {
          noExitRuntime = false;
          PThread.initWorker();
        }
        run();
        return WebIFCWasm3.ready;
      };
    }();
    if (typeof exports === "object" && typeof module === "object")
      module.exports = WebIFCWasm2;
    else if (typeof define === "function" && define["amd"])
      define([], function() {
        return WebIFCWasm2;
      });
    else if (typeof exports === "object")
      exports["WebIFCWasm"] = WebIFCWasm2;
  }
});
var require_web_ifc = __commonJS2({
  "dist/web-ifc.js"(exports, module) {
    var WebIFCWasm2 = function() {
      var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
      if (typeof __filename !== "undefined")
        _scriptDir = _scriptDir || __filename;
      return function(WebIFCWasm3) {
        WebIFCWasm3 = WebIFCWasm3 || {};
        var Module = typeof WebIFCWasm3 !== "undefined" ? WebIFCWasm3 : {};
        var readyPromiseResolve, readyPromiseReject;
        Module["ready"] = new Promise(function(resolve, reject) {
          readyPromiseResolve = resolve;
          readyPromiseReject = reject;
        });
        var moduleOverrides = {};
        var key;
        for (key in Module) {
          if (Module.hasOwnProperty(key)) {
            moduleOverrides[key] = Module[key];
          }
        }
        var arguments_ = [];
        var thisProgram = "./this.program";
        var quit_ = /* @__PURE__ */ __name(function(status, toThrow) {
          throw toThrow;
        }, "quit_");
        var ENVIRONMENT_IS_WEB = typeof window === "object";
        var ENVIRONMENT_IS_WORKER = typeof importScripts === "function";
        var ENVIRONMENT_IS_NODE = typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node === "string";
        var scriptDirectory = "";
        function locateFile(path) {
          if (Module["locateFile"]) {
            return Module["locateFile"](path, scriptDirectory);
          }
          return scriptDirectory + path;
        }
        __name(locateFile, "locateFile");
        var read_, readAsync, readBinary, setWindowTitle;
        var nodeFS;
        var nodePath;
        if (ENVIRONMENT_IS_NODE) {
          if (ENVIRONMENT_IS_WORKER) {
            scriptDirectory = __require2("path").dirname(scriptDirectory) + "/";
          } else {
            scriptDirectory = __dirname + "/";
          }
          read_ = /* @__PURE__ */ __name(function shell_read(filename, binary) {
            if (!nodeFS)
              nodeFS = __require2("fs");
            if (!nodePath)
              nodePath = __require2("path");
            filename = nodePath["normalize"](filename);
            return nodeFS["readFileSync"](filename, binary ? null : "utf8");
          }, "shell_read");
          readBinary = /* @__PURE__ */ __name(function readBinary2(filename) {
            var ret = read_(filename, true);
            if (!ret.buffer) {
              ret = new Uint8Array(ret);
            }
            assert(ret.buffer);
            return ret;
          }, "readBinary2");
          readAsync = /* @__PURE__ */ __name(function readAsync2(filename, onload, onerror) {
            if (!nodeFS)
              nodeFS = __require2("fs");
            if (!nodePath)
              nodePath = __require2("path");
            filename = nodePath["normalize"](filename);
            nodeFS["readFile"](filename, function(err2, data) {
              if (err2)
                onerror(err2);
              else
                onload(data.buffer);
            });
          }, "readAsync2");
          if (process["argv"].length > 1) {
            thisProgram = process["argv"][1].replace(/\\/g, "/");
          }
          arguments_ = process["argv"].slice(2);
          process["on"]("uncaughtException", function(ex) {
            if (!(ex instanceof ExitStatus)) {
              throw ex;
            }
          });
          process["on"]("unhandledRejection", abort);
          quit_ = /* @__PURE__ */ __name(function(status, toThrow) {
            if (keepRuntimeAlive()) {
              process["exitCode"] = status;
              throw toThrow;
            }
            process["exit"](status);
          }, "quit_");
          Module["inspect"] = function() {
            return "[Emscripten Module object]";
          };
        } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
          if (ENVIRONMENT_IS_WORKER) {
            scriptDirectory = self.location.href;
          } else if (typeof document !== "undefined" && document.currentScript) {
            scriptDirectory = document.currentScript.src;
          }
          if (_scriptDir) {
            scriptDirectory = _scriptDir;
          }
          if (scriptDirectory.indexOf("blob:") !== 0) {
            scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1);
          } else {
            scriptDirectory = "";
          }
          {
            read_ = /* @__PURE__ */ __name(function(url) {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, false);
              xhr.send(null);
              return xhr.responseText;
            }, "read_");
            if (ENVIRONMENT_IS_WORKER) {
              readBinary = /* @__PURE__ */ __name(function(url) {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url, false);
                xhr.responseType = "arraybuffer";
                xhr.send(null);
                return new Uint8Array(xhr.response);
              }, "readBinary");
            }
            readAsync = /* @__PURE__ */ __name(function(url, onload, onerror) {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, true);
              xhr.responseType = "arraybuffer";
              xhr.onload = function() {
                if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                  onload(xhr.response);
                  return;
                }
                onerror();
              };
              xhr.onerror = onerror;
              xhr.send(null);
            }, "readAsync");
          }
          setWindowTitle = /* @__PURE__ */ __name(function(title) {
            document.title = title;
          }, "setWindowTitle");
        } else {
        }
        var out = Module["print"] || console.log.bind(console);
        var err = Module["printErr"] || console.warn.bind(console);
        for (key in moduleOverrides) {
          if (moduleOverrides.hasOwnProperty(key)) {
            Module[key] = moduleOverrides[key];
          }
        }
        moduleOverrides = null;
        if (Module["arguments"])
          arguments_ = Module["arguments"];
        if (Module["thisProgram"])
          thisProgram = Module["thisProgram"];
        if (Module["quit"])
          quit_ = Module["quit"];
        var tempRet0 = 0;
        var setTempRet0 = /* @__PURE__ */ __name(function(value) {
          tempRet0 = value;
        }, "setTempRet0");
        var getTempRet0 = /* @__PURE__ */ __name(function() {
          return tempRet0;
        }, "getTempRet0");
        var wasmBinary;
        if (Module["wasmBinary"])
          wasmBinary = Module["wasmBinary"];
        var noExitRuntime = Module["noExitRuntime"] || true;
        if (typeof WebAssembly !== "object") {
          abort("no native wasm support detected");
        }
        var wasmMemory;
        var ABORT = false;
        var EXITSTATUS;
        function assert(condition, text) {
          if (!condition) {
            abort("Assertion failed: " + text);
          }
        }
        __name(assert, "assert");
        var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : void 0;
        function UTF8ArrayToString(heap, idx, maxBytesToRead) {
          idx >>>= 0;
          var endIdx = idx + maxBytesToRead;
          var endPtr = idx;
          while (heap[endPtr >>> 0] && !(endPtr >= endIdx))
            ++endPtr;
          if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
            return UTF8Decoder.decode(heap.subarray(idx >>> 0, endPtr >>> 0));
          } else {
            var str = "";
            while (idx < endPtr) {
              var u0 = heap[idx++ >>> 0];
              if (!(u0 & 128)) {
                str += String.fromCharCode(u0);
                continue;
              }
              var u1 = heap[idx++ >>> 0] & 63;
              if ((u0 & 224) == 192) {
                str += String.fromCharCode((u0 & 31) << 6 | u1);
                continue;
              }
              var u2 = heap[idx++ >>> 0] & 63;
              if ((u0 & 240) == 224) {
                u0 = (u0 & 15) << 12 | u1 << 6 | u2;
              } else {
                u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++ >>> 0] & 63;
              }
              if (u0 < 65536) {
                str += String.fromCharCode(u0);
              } else {
                var ch = u0 - 65536;
                str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
              }
            }
          }
          return str;
        }
        __name(UTF8ArrayToString, "UTF8ArrayToString");
        function UTF8ToString(ptr, maxBytesToRead) {
          ptr >>>= 0;
          return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
        }
        __name(UTF8ToString, "UTF8ToString");
        function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
          outIdx >>>= 0;
          if (!(maxBytesToWrite > 0))
            return 0;
          var startIdx = outIdx;
          var endIdx = outIdx + maxBytesToWrite - 1;
          for (var i = 0; i < str.length; ++i) {
            var u = str.charCodeAt(i);
            if (u >= 55296 && u <= 57343) {
              var u1 = str.charCodeAt(++i);
              u = 65536 + ((u & 1023) << 10) | u1 & 1023;
            }
            if (u <= 127) {
              if (outIdx >= endIdx)
                break;
              heap[outIdx++ >>> 0] = u;
            } else if (u <= 2047) {
              if (outIdx + 1 >= endIdx)
                break;
              heap[outIdx++ >>> 0] = 192 | u >> 6;
              heap[outIdx++ >>> 0] = 128 | u & 63;
            } else if (u <= 65535) {
              if (outIdx + 2 >= endIdx)
                break;
              heap[outIdx++ >>> 0] = 224 | u >> 12;
              heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
              heap[outIdx++ >>> 0] = 128 | u & 63;
            } else {
              if (outIdx + 3 >= endIdx)
                break;
              heap[outIdx++ >>> 0] = 240 | u >> 18;
              heap[outIdx++ >>> 0] = 128 | u >> 12 & 63;
              heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
              heap[outIdx++ >>> 0] = 128 | u & 63;
            }
          }
          heap[outIdx >>> 0] = 0;
          return outIdx - startIdx;
        }
        __name(stringToUTF8Array, "stringToUTF8Array");
        function stringToUTF8(str, outPtr, maxBytesToWrite) {
          return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
        }
        __name(stringToUTF8, "stringToUTF8");
        function lengthBytesUTF8(str) {
          var len = 0;
          for (var i = 0; i < str.length; ++i) {
            var u = str.charCodeAt(i);
            if (u >= 55296 && u <= 57343)
              u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
            if (u <= 127)
              ++len;
            else if (u <= 2047)
              len += 2;
            else if (u <= 65535)
              len += 3;
            else
              len += 4;
          }
          return len;
        }
        __name(lengthBytesUTF8, "lengthBytesUTF8");
        var UTF16Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : void 0;
        function UTF16ToString(ptr, maxBytesToRead) {
          var endPtr = ptr;
          var idx = endPtr >> 1;
          var maxIdx = idx + maxBytesToRead / 2;
          while (!(idx >= maxIdx) && HEAPU16[idx >>> 0])
            ++idx;
          endPtr = idx << 1;
          if (endPtr - ptr > 32 && UTF16Decoder) {
            return UTF16Decoder.decode(HEAPU8.subarray(ptr >>> 0, endPtr >>> 0));
          } else {
            var str = "";
            for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {
              var codeUnit = HEAP16[ptr + i * 2 >>> 1];
              if (codeUnit == 0)
                break;
              str += String.fromCharCode(codeUnit);
            }
            return str;
          }
        }
        __name(UTF16ToString, "UTF16ToString");
        function stringToUTF16(str, outPtr, maxBytesToWrite) {
          if (maxBytesToWrite === void 0) {
            maxBytesToWrite = 2147483647;
          }
          if (maxBytesToWrite < 2)
            return 0;
          maxBytesToWrite -= 2;
          var startPtr = outPtr;
          var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
          for (var i = 0; i < numCharsToWrite; ++i) {
            var codeUnit = str.charCodeAt(i);
            HEAP16[outPtr >>> 1] = codeUnit;
            outPtr += 2;
          }
          HEAP16[outPtr >>> 1] = 0;
          return outPtr - startPtr;
        }
        __name(stringToUTF16, "stringToUTF16");
        function lengthBytesUTF16(str) {
          return str.length * 2;
        }
        __name(lengthBytesUTF16, "lengthBytesUTF16");
        function UTF32ToString(ptr, maxBytesToRead) {
          var i = 0;
          var str = "";
          while (!(i >= maxBytesToRead / 4)) {
            var utf32 = HEAP32[ptr + i * 4 >>> 2];
            if (utf32 == 0)
              break;
            ++i;
            if (utf32 >= 65536) {
              var ch = utf32 - 65536;
              str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
            } else {
              str += String.fromCharCode(utf32);
            }
          }
          return str;
        }
        __name(UTF32ToString, "UTF32ToString");
        function stringToUTF32(str, outPtr, maxBytesToWrite) {
          outPtr >>>= 0;
          if (maxBytesToWrite === void 0) {
            maxBytesToWrite = 2147483647;
          }
          if (maxBytesToWrite < 4)
            return 0;
          var startPtr = outPtr;
          var endPtr = startPtr + maxBytesToWrite - 4;
          for (var i = 0; i < str.length; ++i) {
            var codeUnit = str.charCodeAt(i);
            if (codeUnit >= 55296 && codeUnit <= 57343) {
              var trailSurrogate = str.charCodeAt(++i);
              codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;
            }
            HEAP32[outPtr >>> 2] = codeUnit;
            outPtr += 4;
            if (outPtr + 4 > endPtr)
              break;
          }
          HEAP32[outPtr >>> 2] = 0;
          return outPtr - startPtr;
        }
        __name(stringToUTF32, "stringToUTF32");
        function lengthBytesUTF32(str) {
          var len = 0;
          for (var i = 0; i < str.length; ++i) {
            var codeUnit = str.charCodeAt(i);
            if (codeUnit >= 55296 && codeUnit <= 57343)
              ++i;
            len += 4;
          }
          return len;
        }
        __name(lengthBytesUTF32, "lengthBytesUTF32");
        function writeArrayToMemory(array, buffer2) {
          HEAP8.set(array, buffer2 >>> 0);
        }
        __name(writeArrayToMemory, "writeArrayToMemory");
        function writeAsciiToMemory(str, buffer2, dontAddNull) {
          for (var i = 0; i < str.length; ++i) {
            HEAP8[buffer2++ >>> 0] = str.charCodeAt(i);
          }
          if (!dontAddNull)
            HEAP8[buffer2 >>> 0] = 0;
        }
        __name(writeAsciiToMemory, "writeAsciiToMemory");
        function alignUp(x, multiple) {
          if (x % multiple > 0) {
            x += multiple - x % multiple;
          }
          return x;
        }
        __name(alignUp, "alignUp");
        var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
        function updateGlobalBufferAndViews(buf) {
          buffer = buf;
          Module["HEAP8"] = HEAP8 = new Int8Array(buf);
          Module["HEAP16"] = HEAP16 = new Int16Array(buf);
          Module["HEAP32"] = HEAP32 = new Int32Array(buf);
          Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
          Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
          Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
          Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
          Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
        }
        __name(updateGlobalBufferAndViews, "updateGlobalBufferAndViews");
        var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;
        var wasmTable;
        var __ATPRERUN__ = [];
        var __ATINIT__ = [];
        var __ATMAIN__ = [];
        var __ATPOSTRUN__ = [];
        var runtimeInitialized = false;
        var runtimeExited = false;
        var runtimeKeepaliveCounter = 0;
        function keepRuntimeAlive() {
          return noExitRuntime || runtimeKeepaliveCounter > 0;
        }
        __name(keepRuntimeAlive, "keepRuntimeAlive");
        function preRun() {
          if (Module["preRun"]) {
            if (typeof Module["preRun"] == "function")
              Module["preRun"] = [Module["preRun"]];
            while (Module["preRun"].length) {
              addOnPreRun(Module["preRun"].shift());
            }
          }
          callRuntimeCallbacks(__ATPRERUN__);
        }
        __name(preRun, "preRun");
        function initRuntime() {
          runtimeInitialized = true;
          if (!Module["noFSInit"] && !FS.init.initialized)
            FS.init();
          FS.ignorePermissions = false;
          TTY.init();
          callRuntimeCallbacks(__ATINIT__);
        }
        __name(initRuntime, "initRuntime");
        function preMain() {
          callRuntimeCallbacks(__ATMAIN__);
        }
        __name(preMain, "preMain");
        function exitRuntime() {
          runtimeExited = true;
        }
        __name(exitRuntime, "exitRuntime");
        function postRun() {
          if (Module["postRun"]) {
            if (typeof Module["postRun"] == "function")
              Module["postRun"] = [Module["postRun"]];
            while (Module["postRun"].length) {
              addOnPostRun(Module["postRun"].shift());
            }
          }
          callRuntimeCallbacks(__ATPOSTRUN__);
        }
        __name(postRun, "postRun");
        function addOnPreRun(cb) {
          __ATPRERUN__.unshift(cb);
        }
        __name(addOnPreRun, "addOnPreRun");
        function addOnInit(cb) {
          __ATINIT__.unshift(cb);
        }
        __name(addOnInit, "addOnInit");
        function addOnPostRun(cb) {
          __ATPOSTRUN__.unshift(cb);
        }
        __name(addOnPostRun, "addOnPostRun");
        var runDependencies = 0;
        var runDependencyWatcher = null;
        var dependenciesFulfilled = null;
        function getUniqueRunDependency(id) {
          return id;
        }
        __name(getUniqueRunDependency, "getUniqueRunDependency");
        function addRunDependency(id) {
          runDependencies++;
          if (Module["monitorRunDependencies"]) {
            Module["monitorRunDependencies"](runDependencies);
          }
        }
        __name(addRunDependency, "addRunDependency");
        function removeRunDependency(id) {
          runDependencies--;
          if (Module["monitorRunDependencies"]) {
            Module["monitorRunDependencies"](runDependencies);
          }
          if (runDependencies == 0) {
            if (runDependencyWatcher !== null) {
              clearInterval(runDependencyWatcher);
              runDependencyWatcher = null;
            }
            if (dependenciesFulfilled) {
              var callback = dependenciesFulfilled;
              dependenciesFulfilled = null;
              callback();
            }
          }
        }
        __name(removeRunDependency, "removeRunDependency");
        Module["preloadedImages"] = {};
        Module["preloadedAudios"] = {};
        function abort(what) {
          if (Module["onAbort"]) {
            Module["onAbort"](what);
          }
          what += "";
          err(what);
          ABORT = true;
          EXITSTATUS = 1;
          what = "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
          var e = new WebAssembly.RuntimeError(what);
          readyPromiseReject(e);
          throw e;
        }
        __name(abort, "abort");
        var dataURIPrefix = "data:application/octet-stream;base64,";
        function isDataURI(filename) {
          return filename.startsWith(dataURIPrefix);
        }
        __name(isDataURI, "isDataURI");
        function isFileURI(filename) {
          return filename.startsWith("file://");
        }
        __name(isFileURI, "isFileURI");
        var wasmBinaryFile;
        wasmBinaryFile = "web-ifc.wasm";
        if (!isDataURI(wasmBinaryFile)) {
          wasmBinaryFile = locateFile(wasmBinaryFile);
        }
        function getBinary(file) {
          try {
            if (file == wasmBinaryFile && wasmBinary) {
              return new Uint8Array(wasmBinary);
            }
            if (readBinary) {
              return readBinary(file);
            } else {
              throw "both async and sync fetching of the wasm failed";
            }
          } catch (err2) {
            abort(err2);
          }
        }
        __name(getBinary, "getBinary");
        function getBinaryPromise() {
          if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
            if (typeof fetch === "function" && !isFileURI(wasmBinaryFile)) {
              return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
                if (!response["ok"]) {
                  throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
                }
                return response["arrayBuffer"]();
              }).catch(function() {
                return getBinary(wasmBinaryFile);
              });
            } else {
              if (readAsync) {
                return new Promise(function(resolve, reject) {
                  readAsync(wasmBinaryFile, function(response) {
                    resolve(new Uint8Array(response));
                  }, reject);
                });
              }
            }
          }
          return Promise.resolve().then(function() {
            return getBinary(wasmBinaryFile);
          });
        }
        __name(getBinaryPromise, "getBinaryPromise");
        function createWasm() {
          var info = { "a": asmLibraryArg };
          function receiveInstance(instance, module2) {
            var exports3 = instance.exports;
            Module["asm"] = exports3;
            wasmMemory = Module["asm"]["Na"];
            updateGlobalBufferAndViews(wasmMemory.buffer);
            wasmTable = Module["asm"]["Ra"];
            addOnInit(Module["asm"]["Oa"]);
            removeRunDependency("wasm-instantiate");
          }
          __name(receiveInstance, "receiveInstance");
          addRunDependency("wasm-instantiate");
          function receiveInstantiationResult(result) {
            receiveInstance(result["instance"]);
          }
          __name(receiveInstantiationResult, "receiveInstantiationResult");
          function instantiateArrayBuffer(receiver) {
            return getBinaryPromise().then(function(binary) {
              var result = WebAssembly.instantiate(binary, info);
              return result;
            }).then(receiver, function(reason) {
              err("failed to asynchronously prepare wasm: " + reason);
              abort(reason);
            });
          }
          __name(instantiateArrayBuffer, "instantiateArrayBuffer");
          function instantiateAsync() {
            if (!wasmBinary && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch === "function") {
              return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
                var result = WebAssembly.instantiateStreaming(response, info);
                return result.then(receiveInstantiationResult, function(reason) {
                  err("wasm streaming compile failed: " + reason);
                  err("falling back to ArrayBuffer instantiation");
                  return instantiateArrayBuffer(receiveInstantiationResult);
                });
              });
            } else {
              return instantiateArrayBuffer(receiveInstantiationResult);
            }
          }
          __name(instantiateAsync, "instantiateAsync");
          if (Module["instantiateWasm"]) {
            try {
              var exports2 = Module["instantiateWasm"](info, receiveInstance);
              return exports2;
            } catch (e) {
              err("Module.instantiateWasm callback failed with error: " + e);
              return false;
            }
          }
          instantiateAsync().catch(readyPromiseReject);
          return {};
        }
        __name(createWasm, "createWasm");
        var tempDouble;
        var tempI64;
        function callRuntimeCallbacks(callbacks) {
          while (callbacks.length > 0) {
            var callback = callbacks.shift();
            if (typeof callback == "function") {
              callback(Module);
              continue;
            }
            var func = callback.func;
            if (typeof func === "number") {
              if (callback.arg === void 0) {
                wasmTable.get(func)();
              } else {
                wasmTable.get(func)(callback.arg);
              }
            } else {
              func(callback.arg === void 0 ? null : callback.arg);
            }
          }
        }
        __name(callRuntimeCallbacks, "callRuntimeCallbacks");
        function ___assert_fail(condition, filename, line, func) {
          abort("Assertion failed: " + UTF8ToString(condition) + ", at: " + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
        }
        __name(___assert_fail, "___assert_fail");
        function ___cxa_allocate_exception(size) {
          return _malloc(size + 16) + 16;
        }
        __name(___cxa_allocate_exception, "___cxa_allocate_exception");
        function ExceptionInfo(excPtr) {
          this.excPtr = excPtr;
          this.ptr = excPtr - 16;
          this.set_type = function(type) {
            HEAP32[this.ptr + 4 >>> 2] = type;
          };
          this.get_type = function() {
            return HEAP32[this.ptr + 4 >>> 2];
          };
          this.set_destructor = function(destructor) {
            HEAP32[this.ptr + 8 >>> 2] = destructor;
          };
          this.get_destructor = function() {
            return HEAP32[this.ptr + 8 >>> 2];
          };
          this.set_refcount = function(refcount) {
            HEAP32[this.ptr >>> 2] = refcount;
          };
          this.set_caught = function(caught) {
            caught = caught ? 1 : 0;
            HEAP8[this.ptr + 12 >>> 0] = caught;
          };
          this.get_caught = function() {
            return HEAP8[this.ptr + 12 >>> 0] != 0;
          };
          this.set_rethrown = function(rethrown) {
            rethrown = rethrown ? 1 : 0;
            HEAP8[this.ptr + 13 >>> 0] = rethrown;
          };
          this.get_rethrown = function() {
            return HEAP8[this.ptr + 13 >>> 0] != 0;
          };
          this.init = function(type, destructor) {
            this.set_type(type);
            this.set_destructor(destructor);
            this.set_refcount(0);
            this.set_caught(false);
            this.set_rethrown(false);
          };
          this.add_ref = function() {
            var value = HEAP32[this.ptr >>> 2];
            HEAP32[this.ptr >>> 2] = value + 1;
          };
          this.release_ref = function() {
            var prev = HEAP32[this.ptr >>> 2];
            HEAP32[this.ptr >>> 2] = prev - 1;
            return prev === 1;
          };
        }
        __name(ExceptionInfo, "ExceptionInfo");
        function CatchInfo(ptr) {
          this.free = function() {
            _free(this.ptr);
            this.ptr = 0;
          };
          this.set_base_ptr = function(basePtr) {
            HEAP32[this.ptr >>> 2] = basePtr;
          };
          this.get_base_ptr = function() {
            return HEAP32[this.ptr >>> 2];
          };
          this.set_adjusted_ptr = function(adjustedPtr) {
            HEAP32[this.ptr + 4 >>> 2] = adjustedPtr;
          };
          this.get_adjusted_ptr_addr = function() {
            return this.ptr + 4;
          };
          this.get_adjusted_ptr = function() {
            return HEAP32[this.ptr + 4 >>> 2];
          };
          this.get_exception_ptr = function() {
            var isPointer = ___cxa_is_pointer_type(this.get_exception_info().get_type());
            if (isPointer) {
              return HEAP32[this.get_base_ptr() >>> 2];
            }
            var adjusted = this.get_adjusted_ptr();
            if (adjusted !== 0)
              return adjusted;
            return this.get_base_ptr();
          };
          this.get_exception_info = function() {
            return new ExceptionInfo(this.get_base_ptr());
          };
          if (ptr === void 0) {
            this.ptr = _malloc(8);
            this.set_adjusted_ptr(0);
          } else {
            this.ptr = ptr;
          }
        }
        __name(CatchInfo, "CatchInfo");
        var exceptionCaught = [];
        function exception_addRef(info) {
          info.add_ref();
        }
        __name(exception_addRef, "exception_addRef");
        var uncaughtExceptionCount = 0;
        function ___cxa_begin_catch(ptr) {
          var catchInfo = new CatchInfo(ptr);
          var info = catchInfo.get_exception_info();
          if (!info.get_caught()) {
            info.set_caught(true);
            uncaughtExceptionCount--;
          }
          info.set_rethrown(false);
          exceptionCaught.push(catchInfo);
          exception_addRef(info);
          return catchInfo.get_exception_ptr();
        }
        __name(___cxa_begin_catch, "___cxa_begin_catch");
        var exceptionLast = 0;
        function ___cxa_free_exception(ptr) {
          return _free(new ExceptionInfo(ptr).ptr);
        }
        __name(___cxa_free_exception, "___cxa_free_exception");
        function exception_decRef(info) {
          if (info.release_ref() && !info.get_rethrown()) {
            var destructor = info.get_destructor();
            if (destructor) {
              wasmTable.get(destructor)(info.excPtr);
            }
            ___cxa_free_exception(info.excPtr);
          }
        }
        __name(exception_decRef, "exception_decRef");
        function ___cxa_end_catch() {
          _setThrew(0);
          var catchInfo = exceptionCaught.pop();
          exception_decRef(catchInfo.get_exception_info());
          catchInfo.free();
          exceptionLast = 0;
        }
        __name(___cxa_end_catch, "___cxa_end_catch");
        function ___resumeException(catchInfoPtr) {
          var catchInfo = new CatchInfo(catchInfoPtr);
          var ptr = catchInfo.get_base_ptr();
          if (!exceptionLast) {
            exceptionLast = ptr;
          }
          catchInfo.free();
          throw ptr;
        }
        __name(___resumeException, "___resumeException");
        function ___cxa_find_matching_catch_2() {
          var thrown = exceptionLast;
          if (!thrown) {
            setTempRet0(0);
            return 0 | 0;
          }
          var info = new ExceptionInfo(thrown);
          var thrownType = info.get_type();
          var catchInfo = new CatchInfo();
          catchInfo.set_base_ptr(thrown);
          catchInfo.set_adjusted_ptr(thrown);
          if (!thrownType) {
            setTempRet0(0);
            return catchInfo.ptr | 0;
          }
          var typeArray = Array.prototype.slice.call(arguments);
          for (var i = 0; i < typeArray.length; i++) {
            var caughtType = typeArray[i];
            if (caughtType === 0 || caughtType === thrownType) {
              break;
            }
            if (___cxa_can_catch(caughtType, thrownType, catchInfo.get_adjusted_ptr_addr())) {
              setTempRet0(caughtType);
              return catchInfo.ptr | 0;
            }
          }
          setTempRet0(thrownType);
          return catchInfo.ptr | 0;
        }
        __name(___cxa_find_matching_catch_2, "___cxa_find_matching_catch_2");
        function ___cxa_find_matching_catch_3() {
          var thrown = exceptionLast;
          if (!thrown) {
            setTempRet0(0);
            return 0 | 0;
          }
          var info = new ExceptionInfo(thrown);
          var thrownType = info.get_type();
          var catchInfo = new CatchInfo();
          catchInfo.set_base_ptr(thrown);
          catchInfo.set_adjusted_ptr(thrown);
          if (!thrownType) {
            setTempRet0(0);
            return catchInfo.ptr | 0;
          }
          var typeArray = Array.prototype.slice.call(arguments);
          for (var i = 0; i < typeArray.length; i++) {
            var caughtType = typeArray[i];
            if (caughtType === 0 || caughtType === thrownType) {
              break;
            }
            if (___cxa_can_catch(caughtType, thrownType, catchInfo.get_adjusted_ptr_addr())) {
              setTempRet0(caughtType);
              return catchInfo.ptr | 0;
            }
          }
          setTempRet0(thrownType);
          return catchInfo.ptr | 0;
        }
        __name(___cxa_find_matching_catch_3, "___cxa_find_matching_catch_3");
        function ___cxa_rethrow() {
          var catchInfo = exceptionCaught.pop();
          if (!catchInfo) {
            abort("no exception to throw");
          }
          var info = catchInfo.get_exception_info();
          var ptr = catchInfo.get_base_ptr();
          if (!info.get_rethrown()) {
            exceptionCaught.push(catchInfo);
            info.set_rethrown(true);
            info.set_caught(false);
            uncaughtExceptionCount++;
          } else {
            catchInfo.free();
          }
          exceptionLast = ptr;
          throw ptr;
        }
        __name(___cxa_rethrow, "___cxa_rethrow");
        function ___cxa_throw(ptr, type, destructor) {
          var info = new ExceptionInfo(ptr);
          info.init(type, destructor);
          exceptionLast = ptr;
          uncaughtExceptionCount++;
          throw ptr;
        }
        __name(___cxa_throw, "___cxa_throw");
        function ___cxa_uncaught_exceptions() {
          return uncaughtExceptionCount;
        }
        __name(___cxa_uncaught_exceptions, "___cxa_uncaught_exceptions");
        function setErrNo(value) {
          HEAP32[___errno_location() >>> 2] = value;
          return value;
        }
        __name(setErrNo, "setErrNo");
        var PATH = { splitPath: function(filename) {
          var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
          return splitPathRe.exec(filename).slice(1);
        }, normalizeArray: function(parts, allowAboveRoot) {
          var up = 0;
          for (var i = parts.length - 1; i >= 0; i--) {
            var last = parts[i];
            if (last === ".") {
              parts.splice(i, 1);
            } else if (last === "..") {
              parts.splice(i, 1);
              up++;
            } else if (up) {
              parts.splice(i, 1);
              up--;
            }
          }
          if (allowAboveRoot) {
            for (; up; up--) {
              parts.unshift("..");
            }
          }
          return parts;
        }, normalize: function(path) {
          var isAbsolute = path.charAt(0) === "/", trailingSlash = path.substr(-1) === "/";
          path = PATH.normalizeArray(path.split("/").filter(function(p) {
            return !!p;
          }), !isAbsolute).join("/");
          if (!path && !isAbsolute) {
            path = ".";
          }
          if (path && trailingSlash) {
            path += "/";
          }
          return (isAbsolute ? "/" : "") + path;
        }, dirname: function(path) {
          var result = PATH.splitPath(path), root2 = result[0], dir = result[1];
          if (!root2 && !dir) {
            return ".";
          }
          if (dir) {
            dir = dir.substr(0, dir.length - 1);
          }
          return root2 + dir;
        }, basename: function(path) {
          if (path === "/")
            return "/";
          path = PATH.normalize(path);
          path = path.replace(/\/$/, "");
          var lastSlash = path.lastIndexOf("/");
          if (lastSlash === -1)
            return path;
          return path.substr(lastSlash + 1);
        }, extname: function(path) {
          return PATH.splitPath(path)[3];
        }, join: function() {
          var paths = Array.prototype.slice.call(arguments, 0);
          return PATH.normalize(paths.join("/"));
        }, join2: function(l, r) {
          return PATH.normalize(l + "/" + r);
        } };
        function getRandomDevice() {
          if (typeof crypto === "object" && typeof crypto["getRandomValues"] === "function") {
            var randomBuffer = new Uint8Array(1);
            return function() {
              crypto.getRandomValues(randomBuffer);
              return randomBuffer[0];
            };
          } else if (ENVIRONMENT_IS_NODE) {
            try {
              var crypto_module = require_crypto();
              return function() {
                return crypto_module["randomBytes"](1)[0];
              };
            } catch (e) {
            }
          }
          return function() {
            abort("randomDevice");
          };
        }
        __name(getRandomDevice, "getRandomDevice");
        var PATH_FS = { resolve: function() {
          var resolvedPath = "", resolvedAbsolute = false;
          for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            var path = i >= 0 ? arguments[i] : FS.cwd();
            if (typeof path !== "string") {
              throw new TypeError("Arguments to path.resolve must be strings");
            } else if (!path) {
              return "";
            }
            resolvedPath = path + "/" + resolvedPath;
            resolvedAbsolute = path.charAt(0) === "/";
          }
          resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter(function(p) {
            return !!p;
          }), !resolvedAbsolute).join("/");
          return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
        }, relative: function(from, to) {
          from = PATH_FS.resolve(from).substr(1);
          to = PATH_FS.resolve(to).substr(1);
          function trim(arr) {
            var start = 0;
            for (; start < arr.length; start++) {
              if (arr[start] !== "")
                break;
            }
            var end = arr.length - 1;
            for (; end >= 0; end--) {
              if (arr[end] !== "")
                break;
            }
            if (start > end)
              return [];
            return arr.slice(start, end - start + 1);
          }
          __name(trim, "trim");
          var fromParts = trim(from.split("/"));
          var toParts = trim(to.split("/"));
          var length = Math.min(fromParts.length, toParts.length);
          var samePartsLength = length;
          for (var i = 0; i < length; i++) {
            if (fromParts[i] !== toParts[i]) {
              samePartsLength = i;
              break;
            }
          }
          var outputParts = [];
          for (var i = samePartsLength; i < fromParts.length; i++) {
            outputParts.push("..");
          }
          outputParts = outputParts.concat(toParts.slice(samePartsLength));
          return outputParts.join("/");
        } };
        var TTY = { ttys: [], init: function() {
        }, shutdown: function() {
        }, register: function(dev, ops) {
          TTY.ttys[dev] = { input: [], output: [], ops };
          FS.registerDevice(dev, TTY.stream_ops);
        }, stream_ops: { open: function(stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(43);
          }
          stream.tty = tty;
          stream.seekable = false;
        }, close: function(stream) {
          stream.tty.ops.flush(stream.tty);
        }, flush: function(stream) {
          stream.tty.ops.flush(stream.tty);
        }, read: function(stream, buffer2, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer2[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        }, write: function(stream, buffer2, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i = 0; i < length; i++) {
              stream.tty.ops.put_char(stream.tty, buffer2[offset + i]);
            }
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        } }, default_tty_ops: { get_char: function(tty) {
          if (!tty.input.length) {
            var result = null;
            if (ENVIRONMENT_IS_NODE) {
              var BUFSIZE = 256;
              var buf = Buffer.alloc(BUFSIZE);
              var bytesRead = 0;
              try {
                bytesRead = nodeFS.readSync(process.stdin.fd, buf, 0, BUFSIZE, null);
              } catch (e) {
                if (e.toString().includes("EOF"))
                  bytesRead = 0;
                else
                  throw e;
              }
              if (bytesRead > 0) {
                result = buf.slice(0, bytesRead).toString("utf-8");
              } else {
                result = null;
              }
            } else if (typeof window != "undefined" && typeof window.prompt == "function") {
              result = window.prompt("Input: ");
              if (result !== null) {
                result += "\n";
              }
            } else if (typeof readline == "function") {
              result = readline();
              if (result !== null) {
                result += "\n";
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        }, put_char: function(tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0)
              tty.output.push(val);
          }
        }, flush: function(tty) {
          if (tty.output && tty.output.length > 0) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        } }, default_tty1_ops: { put_char: function(tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0)
              tty.output.push(val);
          }
        }, flush: function(tty) {
          if (tty.output && tty.output.length > 0) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        } } };
        function mmapAlloc(size) {
          abort();
        }
        __name(mmapAlloc, "mmapAlloc");
        var MEMFS = { ops_table: null, mount: function(mount) {
          return MEMFS.createNode(null, "/", 16384 | 511, 0);
        }, createNode: function(parent, name2, mode, dev) {
          if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
            throw new FS.ErrnoError(63);
          }
          if (!MEMFS.ops_table) {
            MEMFS.ops_table = { dir: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, lookup: MEMFS.node_ops.lookup, mknod: MEMFS.node_ops.mknod, rename: MEMFS.node_ops.rename, unlink: MEMFS.node_ops.unlink, rmdir: MEMFS.node_ops.rmdir, readdir: MEMFS.node_ops.readdir, symlink: MEMFS.node_ops.symlink }, stream: { llseek: MEMFS.stream_ops.llseek } }, file: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: { llseek: MEMFS.stream_ops.llseek, read: MEMFS.stream_ops.read, write: MEMFS.stream_ops.write, allocate: MEMFS.stream_ops.allocate, mmap: MEMFS.stream_ops.mmap, msync: MEMFS.stream_ops.msync } }, link: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, readlink: MEMFS.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: FS.chrdev_stream_ops } };
          }
          var node = FS.createNode(parent, name2, mode, dev);
          if (FS.isDir(node.mode)) {
            node.node_ops = MEMFS.ops_table.dir.node;
            node.stream_ops = MEMFS.ops_table.dir.stream;
            node.contents = {};
          } else if (FS.isFile(node.mode)) {
            node.node_ops = MEMFS.ops_table.file.node;
            node.stream_ops = MEMFS.ops_table.file.stream;
            node.usedBytes = 0;
            node.contents = null;
          } else if (FS.isLink(node.mode)) {
            node.node_ops = MEMFS.ops_table.link.node;
            node.stream_ops = MEMFS.ops_table.link.stream;
          } else if (FS.isChrdev(node.mode)) {
            node.node_ops = MEMFS.ops_table.chrdev.node;
            node.stream_ops = MEMFS.ops_table.chrdev.stream;
          }
          node.timestamp = Date.now();
          if (parent) {
            parent.contents[name2] = node;
            parent.timestamp = node.timestamp;
          }
          return node;
        }, getFileDataAsTypedArray: function(node) {
          if (!node.contents)
            return new Uint8Array(0);
          if (node.contents.subarray)
            return node.contents.subarray(0, node.usedBytes);
          return new Uint8Array(node.contents);
        }, expandFileStorage: function(node, newCapacity) {
          newCapacity >>>= 0;
          var prevCapacity = node.contents ? node.contents.length : 0;
          if (prevCapacity >= newCapacity)
            return;
          var CAPACITY_DOUBLING_MAX = 1024 * 1024;
          newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
          if (prevCapacity != 0)
            newCapacity = Math.max(newCapacity, 256);
          var oldContents = node.contents;
          node.contents = new Uint8Array(newCapacity);
          if (node.usedBytes > 0)
            node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
        }, resizeFileStorage: function(node, newSize) {
          newSize >>>= 0;
          if (node.usedBytes == newSize)
            return;
          if (newSize == 0) {
            node.contents = null;
            node.usedBytes = 0;
          } else {
            var oldContents = node.contents;
            node.contents = new Uint8Array(newSize);
            if (oldContents) {
              node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
            }
            node.usedBytes = newSize;
          }
        }, node_ops: { getattr: function(node) {
          var attr = {};
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        }, setattr: function(node, attr) {
          if (attr.mode !== void 0) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== void 0) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        }, lookup: function(parent, name2) {
          throw FS.genericErrors[44];
        }, mknod: function(parent, name2, mode, dev) {
          return MEMFS.createNode(parent, name2, mode, dev);
        }, rename: function(old_node, new_dir, new_name) {
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
          }
          delete old_node.parent.contents[old_node.name];
          old_node.parent.timestamp = Date.now();
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          new_dir.timestamp = old_node.parent.timestamp;
          old_node.parent = new_dir;
        }, unlink: function(parent, name2) {
          delete parent.contents[name2];
          parent.timestamp = Date.now();
        }, rmdir: function(parent, name2) {
          var node = FS.lookupNode(parent, name2);
          for (var i in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name2];
          parent.timestamp = Date.now();
        }, readdir: function(node) {
          var entries = [".", ".."];
          for (var key2 in node.contents) {
            if (!node.contents.hasOwnProperty(key2)) {
              continue;
            }
            entries.push(key2);
          }
          return entries;
        }, symlink: function(parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
          node.link = oldpath;
          return node;
        }, readlink: function(node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        } }, stream_ops: { read: function(stream, buffer2, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes)
            return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          if (size > 8 && contents.subarray) {
            buffer2.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++)
              buffer2[offset + i] = contents[position + i];
          }
          return size;
        }, write: function(stream, buffer2, offset, length, position, canOwn) {
          if (buffer2.buffer === HEAP8.buffer) {
            canOwn = false;
          }
          if (!length)
            return 0;
          var node = stream.node;
          node.timestamp = Date.now();
          if (buffer2.subarray && (!node.contents || node.contents.subarray)) {
            if (canOwn) {
              node.contents = buffer2.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) {
              node.contents = buffer2.slice(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) {
              node.contents.set(buffer2.subarray(offset, offset + length), position);
              return length;
            }
          }
          MEMFS.expandFileStorage(node, position + length);
          if (node.contents.subarray && buffer2.subarray) {
            node.contents.set(buffer2.subarray(offset, offset + length), position);
          } else {
            for (var i = 0; i < length; i++) {
              node.contents[position + i] = buffer2[offset + i];
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        }, llseek: function(stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        }, allocate: function(stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
        }, mmap: function(stream, address, length, position, prot, flags) {
          if (address !== 0) {
            throw new FS.ErrnoError(28);
          }
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          if (!(flags & 2) && contents.buffer === buffer) {
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length);
              }
            }
            allocated = true;
            ptr = mmapAlloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            ptr >>>= 0;
            HEAP8.set(contents, ptr >>> 0);
          }
          return { ptr, allocated };
        }, msync: function(stream, buffer2, offset, length, mmapFlags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          if (mmapFlags & 2) {
            return 0;
          }
          var bytesWritten = MEMFS.stream_ops.write(stream, buffer2, 0, length, offset, false);
          return 0;
        } } };
        function asyncLoad(url, onload, onerror, noRunDep) {
          var dep = !noRunDep ? getUniqueRunDependency("al " + url) : "";
          readAsync(url, function(arrayBuffer) {
            assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
            onload(new Uint8Array(arrayBuffer));
            if (dep)
              removeRunDependency(dep);
          }, function(event) {
            if (onerror) {
              onerror();
            } else {
              throw 'Loading data file "' + url + '" failed.';
            }
          });
          if (dep)
            addRunDependency(dep);
        }
        __name(asyncLoad, "asyncLoad");
        var FS = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: false, ignorePermissions: true, trackingDelegate: {}, tracking: { openFlags: { READ: 1, WRITE: 2 } }, ErrnoError: null, genericErrors: {}, filesystems: null, syncFSRequests: 0, lookupPath: function(path, opts) {
          path = PATH_FS.resolve(FS.cwd(), path);
          opts = opts || {};
          if (!path)
            return { path: "", node: null };
          var defaults = { follow_mount: true, recurse_count: 0 };
          for (var key2 in defaults) {
            if (opts[key2] === void 0) {
              opts[key2] = defaults[key2];
            }
          }
          if (opts.recurse_count > 8) {
            throw new FS.ErrnoError(32);
          }
          var parts = PATH.normalizeArray(path.split("/").filter(function(p) {
            return !!p;
          }), false);
          var current = FS.root;
          var current_path = "/";
          for (var i = 0; i < parts.length; i++) {
            var islast = i === parts.length - 1;
            if (islast && opts.parent) {
              break;
            }
            current = FS.lookupNode(current, parts[i]);
            current_path = PATH.join2(current_path, parts[i]);
            if (FS.isMountpoint(current)) {
              if (!islast || islast && opts.follow_mount) {
                current = current.mounted.root;
              }
            }
            if (!islast || opts.follow) {
              var count = 0;
              while (FS.isLink(current.mode)) {
                var link = FS.readlink(current_path);
                current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
                var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count });
                current = lookup.node;
                if (count++ > 40) {
                  throw new FS.ErrnoError(32);
                }
              }
            }
          }
          return { path: current_path, node: current };
        }, getPath: function(node) {
          var path;
          while (true) {
            if (FS.isRoot(node)) {
              var mount = node.mount.mountpoint;
              if (!path)
                return mount;
              return mount[mount.length - 1] !== "/" ? mount + "/" + path : mount + path;
            }
            path = path ? node.name + "/" + path : node.name;
            node = node.parent;
          }
        }, hashName: function(parentid, name2) {
          var hash = 0;
          for (var i = 0; i < name2.length; i++) {
            hash = (hash << 5) - hash + name2.charCodeAt(i) | 0;
          }
          return (parentid + hash >>> 0) % FS.nameTable.length;
        }, hashAddNode: function(node) {
          var hash = FS.hashName(node.parent.id, node.name);
          node.name_next = FS.nameTable[hash];
          FS.nameTable[hash] = node;
        }, hashRemoveNode: function(node) {
          var hash = FS.hashName(node.parent.id, node.name);
          if (FS.nameTable[hash] === node) {
            FS.nameTable[hash] = node.name_next;
          } else {
            var current = FS.nameTable[hash];
            while (current) {
              if (current.name_next === node) {
                current.name_next = node.name_next;
                break;
              }
              current = current.name_next;
            }
          }
        }, lookupNode: function(parent, name2) {
          var errCode = FS.mayLookup(parent);
          if (errCode) {
            throw new FS.ErrnoError(errCode, parent);
          }
          var hash = FS.hashName(parent.id, name2);
          for (var node = FS.nameTable[hash]; node; node = node.name_next) {
            var nodeName = node.name;
            if (node.parent.id === parent.id && nodeName === name2) {
              return node;
            }
          }
          return FS.lookup(parent, name2);
        }, createNode: function(parent, name2, mode, rdev) {
          var node = new FS.FSNode(parent, name2, mode, rdev);
          FS.hashAddNode(node);
          return node;
        }, destroyNode: function(node) {
          FS.hashRemoveNode(node);
        }, isRoot: function(node) {
          return node === node.parent;
        }, isMountpoint: function(node) {
          return !!node.mounted;
        }, isFile: function(mode) {
          return (mode & 61440) === 32768;
        }, isDir: function(mode) {
          return (mode & 61440) === 16384;
        }, isLink: function(mode) {
          return (mode & 61440) === 40960;
        }, isChrdev: function(mode) {
          return (mode & 61440) === 8192;
        }, isBlkdev: function(mode) {
          return (mode & 61440) === 24576;
        }, isFIFO: function(mode) {
          return (mode & 61440) === 4096;
        }, isSocket: function(mode) {
          return (mode & 49152) === 49152;
        }, flagModes: { "r": 0, "r+": 2, "w": 577, "w+": 578, "a": 1089, "a+": 1090 }, modeStringToFlags: function(str) {
          var flags = FS.flagModes[str];
          if (typeof flags === "undefined") {
            throw new Error("Unknown file open mode: " + str);
          }
          return flags;
        }, flagsToPermissionString: function(flag) {
          var perms = ["r", "w", "rw"][flag & 3];
          if (flag & 512) {
            perms += "w";
          }
          return perms;
        }, nodePermissions: function(node, perms) {
          if (FS.ignorePermissions) {
            return 0;
          }
          if (perms.includes("r") && !(node.mode & 292)) {
            return 2;
          } else if (perms.includes("w") && !(node.mode & 146)) {
            return 2;
          } else if (perms.includes("x") && !(node.mode & 73)) {
            return 2;
          }
          return 0;
        }, mayLookup: function(dir) {
          var errCode = FS.nodePermissions(dir, "x");
          if (errCode)
            return errCode;
          if (!dir.node_ops.lookup)
            return 2;
          return 0;
        }, mayCreate: function(dir, name2) {
          try {
            var node = FS.lookupNode(dir, name2);
            return 20;
          } catch (e) {
          }
          return FS.nodePermissions(dir, "wx");
        }, mayDelete: function(dir, name2, isdir) {
          var node;
          try {
            node = FS.lookupNode(dir, name2);
          } catch (e) {
            return e.errno;
          }
          var errCode = FS.nodePermissions(dir, "wx");
          if (errCode) {
            return errCode;
          }
          if (isdir) {
            if (!FS.isDir(node.mode)) {
              return 54;
            }
            if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
              return 10;
            }
          } else {
            if (FS.isDir(node.mode)) {
              return 31;
            }
          }
          return 0;
        }, mayOpen: function(node, flags) {
          if (!node) {
            return 44;
          }
          if (FS.isLink(node.mode)) {
            return 32;
          } else if (FS.isDir(node.mode)) {
            if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
              return 31;
            }
          }
          return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
        }, MAX_OPEN_FDS: 4096, nextfd: function(fd_start, fd_end) {
          fd_start = fd_start || 0;
          fd_end = fd_end || FS.MAX_OPEN_FDS;
          for (var fd = fd_start; fd <= fd_end; fd++) {
            if (!FS.streams[fd]) {
              return fd;
            }
          }
          throw new FS.ErrnoError(33);
        }, getStream: function(fd) {
          return FS.streams[fd];
        }, createStream: function(stream, fd_start, fd_end) {
          if (!FS.FSStream) {
            FS.FSStream = function() {
            };
            FS.FSStream.prototype = { object: { get: function() {
              return this.node;
            }, set: function(val) {
              this.node = val;
            } }, isRead: { get: function() {
              return (this.flags & 2097155) !== 1;
            } }, isWrite: { get: function() {
              return (this.flags & 2097155) !== 0;
            } }, isAppend: { get: function() {
              return this.flags & 1024;
            } } };
          }
          var newStream = new FS.FSStream();
          for (var p in stream) {
            newStream[p] = stream[p];
          }
          stream = newStream;
          var fd = FS.nextfd(fd_start, fd_end);
          stream.fd = fd;
          FS.streams[fd] = stream;
          return stream;
        }, closeStream: function(fd) {
          FS.streams[fd] = null;
        }, chrdev_stream_ops: { open: function(stream) {
          var device = FS.getDevice(stream.node.rdev);
          stream.stream_ops = device.stream_ops;
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        }, llseek: function() {
          throw new FS.ErrnoError(70);
        } }, major: function(dev) {
          return dev >> 8;
        }, minor: function(dev) {
          return dev & 255;
        }, makedev: function(ma, mi) {
          return ma << 8 | mi;
        }, registerDevice: function(dev, ops) {
          FS.devices[dev] = { stream_ops: ops };
        }, getDevice: function(dev) {
          return FS.devices[dev];
        }, getMounts: function(mount) {
          var mounts = [];
          var check = [mount];
          while (check.length) {
            var m = check.pop();
            mounts.push(m);
            check.push.apply(check, m.mounts);
          }
          return mounts;
        }, syncfs: function(populate, callback) {
          if (typeof populate === "function") {
            callback = populate;
            populate = false;
          }
          FS.syncFSRequests++;
          if (FS.syncFSRequests > 1) {
            err("warning: " + FS.syncFSRequests + " FS.syncfs operations in flight at once, probably just doing extra work");
          }
          var mounts = FS.getMounts(FS.root.mount);
          var completed = 0;
          function doCallback(errCode) {
            FS.syncFSRequests--;
            return callback(errCode);
          }
          __name(doCallback, "doCallback");
          function done(errCode) {
            if (errCode) {
              if (!done.errored) {
                done.errored = true;
                return doCallback(errCode);
              }
              return;
            }
            if (++completed >= mounts.length) {
              doCallback(null);
            }
          }
          __name(done, "done");
          mounts.forEach(function(mount) {
            if (!mount.type.syncfs) {
              return done(null);
            }
            mount.type.syncfs(mount, populate, done);
          });
        }, mount: function(type, opts, mountpoint) {
          var root2 = mountpoint === "/";
          var pseudo = !mountpoint;
          var node;
          if (root2 && FS.root) {
            throw new FS.ErrnoError(10);
          } else if (!root2 && !pseudo) {
            var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
            mountpoint = lookup.path;
            node = lookup.node;
            if (FS.isMountpoint(node)) {
              throw new FS.ErrnoError(10);
            }
            if (!FS.isDir(node.mode)) {
              throw new FS.ErrnoError(54);
            }
          }
          var mount = { type, opts, mountpoint, mounts: [] };
          var mountRoot = type.mount(mount);
          mountRoot.mount = mount;
          mount.root = mountRoot;
          if (root2) {
            FS.root = mountRoot;
          } else if (node) {
            node.mounted = mount;
            if (node.mount) {
              node.mount.mounts.push(mount);
            }
          }
          return mountRoot;
        }, unmount: function(mountpoint) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
          if (!FS.isMountpoint(lookup.node)) {
            throw new FS.ErrnoError(28);
          }
          var node = lookup.node;
          var mount = node.mounted;
          var mounts = FS.getMounts(mount);
          Object.keys(FS.nameTable).forEach(function(hash) {
            var current = FS.nameTable[hash];
            while (current) {
              var next = current.name_next;
              if (mounts.includes(current.mount)) {
                FS.destroyNode(current);
              }
              current = next;
            }
          });
          node.mounted = null;
          var idx = node.mount.mounts.indexOf(mount);
          node.mount.mounts.splice(idx, 1);
        }, lookup: function(parent, name2) {
          return parent.node_ops.lookup(parent, name2);
        }, mknod: function(path, mode, dev) {
          var lookup = FS.lookupPath(path, { parent: true });
          var parent = lookup.node;
          var name2 = PATH.basename(path);
          if (!name2 || name2 === "." || name2 === "..") {
            throw new FS.ErrnoError(28);
          }
          var errCode = FS.mayCreate(parent, name2);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!parent.node_ops.mknod) {
            throw new FS.ErrnoError(63);
          }
          return parent.node_ops.mknod(parent, name2, mode, dev);
        }, create: function(path, mode) {
          mode = mode !== void 0 ? mode : 438;
          mode &= 4095;
          mode |= 32768;
          return FS.mknod(path, mode, 0);
        }, mkdir: function(path, mode) {
          mode = mode !== void 0 ? mode : 511;
          mode &= 511 | 512;
          mode |= 16384;
          return FS.mknod(path, mode, 0);
        }, mkdirTree: function(path, mode) {
          var dirs = path.split("/");
          var d = "";
          for (var i = 0; i < dirs.length; ++i) {
            if (!dirs[i])
              continue;
            d += "/" + dirs[i];
            try {
              FS.mkdir(d, mode);
            } catch (e) {
              if (e.errno != 20)
                throw e;
            }
          }
        }, mkdev: function(path, mode, dev) {
          if (typeof dev === "undefined") {
            dev = mode;
            mode = 438;
          }
          mode |= 8192;
          return FS.mknod(path, mode, dev);
        }, symlink: function(oldpath, newpath) {
          if (!PATH_FS.resolve(oldpath)) {
            throw new FS.ErrnoError(44);
          }
          var lookup = FS.lookupPath(newpath, { parent: true });
          var parent = lookup.node;
          if (!parent) {
            throw new FS.ErrnoError(44);
          }
          var newname = PATH.basename(newpath);
          var errCode = FS.mayCreate(parent, newname);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!parent.node_ops.symlink) {
            throw new FS.ErrnoError(63);
          }
          return parent.node_ops.symlink(parent, newname, oldpath);
        }, rename: function(old_path, new_path) {
          var old_dirname = PATH.dirname(old_path);
          var new_dirname = PATH.dirname(new_path);
          var old_name = PATH.basename(old_path);
          var new_name = PATH.basename(new_path);
          var lookup, old_dir, new_dir;
          lookup = FS.lookupPath(old_path, { parent: true });
          old_dir = lookup.node;
          lookup = FS.lookupPath(new_path, { parent: true });
          new_dir = lookup.node;
          if (!old_dir || !new_dir)
            throw new FS.ErrnoError(44);
          if (old_dir.mount !== new_dir.mount) {
            throw new FS.ErrnoError(75);
          }
          var old_node = FS.lookupNode(old_dir, old_name);
          var relative = PATH_FS.relative(old_path, new_dirname);
          if (relative.charAt(0) !== ".") {
            throw new FS.ErrnoError(28);
          }
          relative = PATH_FS.relative(new_path, old_dirname);
          if (relative.charAt(0) !== ".") {
            throw new FS.ErrnoError(55);
          }
          var new_node;
          try {
            new_node = FS.lookupNode(new_dir, new_name);
          } catch (e) {
          }
          if (old_node === new_node) {
            return;
          }
          var isdir = FS.isDir(old_node.mode);
          var errCode = FS.mayDelete(old_dir, old_name, isdir);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!old_dir.node_ops.rename) {
            throw new FS.ErrnoError(63);
          }
          if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
            throw new FS.ErrnoError(10);
          }
          if (new_dir !== old_dir) {
            errCode = FS.nodePermissions(old_dir, "w");
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
          }
          try {
            if (FS.trackingDelegate["willMovePath"]) {
              FS.trackingDelegate["willMovePath"](old_path, new_path);
            }
          } catch (e) {
            err("FS.trackingDelegate['willMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
          }
          FS.hashRemoveNode(old_node);
          try {
            old_dir.node_ops.rename(old_node, new_dir, new_name);
          } catch (e) {
            throw e;
          } finally {
            FS.hashAddNode(old_node);
          }
          try {
            if (FS.trackingDelegate["onMovePath"])
              FS.trackingDelegate["onMovePath"](old_path, new_path);
          } catch (e) {
            err("FS.trackingDelegate['onMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
          }
        }, rmdir: function(path) {
          var lookup = FS.lookupPath(path, { parent: true });
          var parent = lookup.node;
          var name2 = PATH.basename(path);
          var node = FS.lookupNode(parent, name2);
          var errCode = FS.mayDelete(parent, name2, true);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!parent.node_ops.rmdir) {
            throw new FS.ErrnoError(63);
          }
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
          try {
            if (FS.trackingDelegate["willDeletePath"]) {
              FS.trackingDelegate["willDeletePath"](path);
            }
          } catch (e) {
            err("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
          }
          parent.node_ops.rmdir(parent, name2);
          FS.destroyNode(node);
          try {
            if (FS.trackingDelegate["onDeletePath"])
              FS.trackingDelegate["onDeletePath"](path);
          } catch (e) {
            err("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
          }
        }, readdir: function(path) {
          var lookup = FS.lookupPath(path, { follow: true });
          var node = lookup.node;
          if (!node.node_ops.readdir) {
            throw new FS.ErrnoError(54);
          }
          return node.node_ops.readdir(node);
        }, unlink: function(path) {
          var lookup = FS.lookupPath(path, { parent: true });
          var parent = lookup.node;
          var name2 = PATH.basename(path);
          var node = FS.lookupNode(parent, name2);
          var errCode = FS.mayDelete(parent, name2, false);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!parent.node_ops.unlink) {
            throw new FS.ErrnoError(63);
          }
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
          try {
            if (FS.trackingDelegate["willDeletePath"]) {
              FS.trackingDelegate["willDeletePath"](path);
            }
          } catch (e) {
            err("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
          }
          parent.node_ops.unlink(parent, name2);
          FS.destroyNode(node);
          try {
            if (FS.trackingDelegate["onDeletePath"])
              FS.trackingDelegate["onDeletePath"](path);
          } catch (e) {
            err("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
          }
        }, readlink: function(path) {
          var lookup = FS.lookupPath(path);
          var link = lookup.node;
          if (!link) {
            throw new FS.ErrnoError(44);
          }
          if (!link.node_ops.readlink) {
            throw new FS.ErrnoError(28);
          }
          return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
        }, stat: function(path, dontFollow) {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          var node = lookup.node;
          if (!node) {
            throw new FS.ErrnoError(44);
          }
          if (!node.node_ops.getattr) {
            throw new FS.ErrnoError(63);
          }
          return node.node_ops.getattr(node);
        }, lstat: function(path) {
          return FS.stat(path, true);
        }, chmod: function(path, mode, dontFollow) {
          var node;
          if (typeof path === "string") {
            var lookup = FS.lookupPath(path, { follow: !dontFollow });
            node = lookup.node;
          } else {
            node = path;
          }
          if (!node.node_ops.setattr) {
            throw new FS.ErrnoError(63);
          }
          node.node_ops.setattr(node, { mode: mode & 4095 | node.mode & ~4095, timestamp: Date.now() });
        }, lchmod: function(path, mode) {
          FS.chmod(path, mode, true);
        }, fchmod: function(fd, mode) {
          var stream = FS.getStream(fd);
          if (!stream) {
            throw new FS.ErrnoError(8);
          }
          FS.chmod(stream.node, mode);
        }, chown: function(path, uid, gid, dontFollow) {
          var node;
          if (typeof path === "string") {
            var lookup = FS.lookupPath(path, { follow: !dontFollow });
            node = lookup.node;
          } else {
            node = path;
          }
          if (!node.node_ops.setattr) {
            throw new FS.ErrnoError(63);
          }
          node.node_ops.setattr(node, { timestamp: Date.now() });
        }, lchown: function(path, uid, gid) {
          FS.chown(path, uid, gid, true);
        }, fchown: function(fd, uid, gid) {
          var stream = FS.getStream(fd);
          if (!stream) {
            throw new FS.ErrnoError(8);
          }
          FS.chown(stream.node, uid, gid);
        }, truncate: function(path, len) {
          if (len < 0) {
            throw new FS.ErrnoError(28);
          }
          var node;
          if (typeof path === "string") {
            var lookup = FS.lookupPath(path, { follow: true });
            node = lookup.node;
          } else {
            node = path;
          }
          if (!node.node_ops.setattr) {
            throw new FS.ErrnoError(63);
          }
          if (FS.isDir(node.mode)) {
            throw new FS.ErrnoError(31);
          }
          if (!FS.isFile(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          var errCode = FS.nodePermissions(node, "w");
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          node.node_ops.setattr(node, { size: len, timestamp: Date.now() });
        }, ftruncate: function(fd, len) {
          var stream = FS.getStream(fd);
          if (!stream) {
            throw new FS.ErrnoError(8);
          }
          if ((stream.flags & 2097155) === 0) {
            throw new FS.ErrnoError(28);
          }
          FS.truncate(stream.node, len);
        }, utime: function(path, atime, mtime) {
          var lookup = FS.lookupPath(path, { follow: true });
          var node = lookup.node;
          node.node_ops.setattr(node, { timestamp: Math.max(atime, mtime) });
        }, open: function(path, flags, mode, fd_start, fd_end) {
          if (path === "") {
            throw new FS.ErrnoError(44);
          }
          flags = typeof flags === "string" ? FS.modeStringToFlags(flags) : flags;
          mode = typeof mode === "undefined" ? 438 : mode;
          if (flags & 64) {
            mode = mode & 4095 | 32768;
          } else {
            mode = 0;
          }
          var node;
          if (typeof path === "object") {
            node = path;
          } else {
            path = PATH.normalize(path);
            try {
              var lookup = FS.lookupPath(path, { follow: !(flags & 131072) });
              node = lookup.node;
            } catch (e) {
            }
          }
          var created = false;
          if (flags & 64) {
            if (node) {
              if (flags & 128) {
                throw new FS.ErrnoError(20);
              }
            } else {
              node = FS.mknod(path, mode, 0);
              created = true;
            }
          }
          if (!node) {
            throw new FS.ErrnoError(44);
          }
          if (FS.isChrdev(node.mode)) {
            flags &= ~512;
          }
          if (flags & 65536 && !FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
          if (!created) {
            var errCode = FS.mayOpen(node, flags);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
          }
          if (flags & 512) {
            FS.truncate(node, 0);
          }
          flags &= ~(128 | 512 | 131072);
          var stream = FS.createStream({ node, path: FS.getPath(node), flags, seekable: true, position: 0, stream_ops: node.stream_ops, ungotten: [], error: false }, fd_start, fd_end);
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
          if (Module["logReadFiles"] && !(flags & 1)) {
            if (!FS.readFiles)
              FS.readFiles = {};
            if (!(path in FS.readFiles)) {
              FS.readFiles[path] = 1;
              err("FS.trackingDelegate error on read file: " + path);
            }
          }
          try {
            if (FS.trackingDelegate["onOpenFile"]) {
              var trackingFlags = 0;
              if ((flags & 2097155) !== 1) {
                trackingFlags |= FS.tracking.openFlags.READ;
              }
              if ((flags & 2097155) !== 0) {
                trackingFlags |= FS.tracking.openFlags.WRITE;
              }
              FS.trackingDelegate["onOpenFile"](path, trackingFlags);
            }
          } catch (e) {
            err("FS.trackingDelegate['onOpenFile']('" + path + "', flags) threw an exception: " + e.message);
          }
          return stream;
        }, close: function(stream) {
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if (stream.getdents)
            stream.getdents = null;
          try {
            if (stream.stream_ops.close) {
              stream.stream_ops.close(stream);
            }
          } catch (e) {
            throw e;
          } finally {
            FS.closeStream(stream.fd);
          }
          stream.fd = null;
        }, isClosed: function(stream) {
          return stream.fd === null;
        }, llseek: function(stream, offset, whence) {
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if (!stream.seekable || !stream.stream_ops.llseek) {
            throw new FS.ErrnoError(70);
          }
          if (whence != 0 && whence != 1 && whence != 2) {
            throw new FS.ErrnoError(28);
          }
          stream.position = stream.stream_ops.llseek(stream, offset, whence);
          stream.ungotten = [];
          return stream.position;
        }, read: function(stream, buffer2, offset, length, position) {
          offset >>>= 0;
          if (length < 0 || position < 0) {
            throw new FS.ErrnoError(28);
          }
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if ((stream.flags & 2097155) === 1) {
            throw new FS.ErrnoError(8);
          }
          if (FS.isDir(stream.node.mode)) {
            throw new FS.ErrnoError(31);
          }
          if (!stream.stream_ops.read) {
            throw new FS.ErrnoError(28);
          }
          var seeking = typeof position !== "undefined";
          if (!seeking) {
            position = stream.position;
          } else if (!stream.seekable) {
            throw new FS.ErrnoError(70);
          }
          var bytesRead = stream.stream_ops.read(stream, buffer2, offset, length, position);
          if (!seeking)
            stream.position += bytesRead;
          return bytesRead;
        }, write: function(stream, buffer2, offset, length, position, canOwn) {
          offset >>>= 0;
          if (length < 0 || position < 0) {
            throw new FS.ErrnoError(28);
          }
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if ((stream.flags & 2097155) === 0) {
            throw new FS.ErrnoError(8);
          }
          if (FS.isDir(stream.node.mode)) {
            throw new FS.ErrnoError(31);
          }
          if (!stream.stream_ops.write) {
            throw new FS.ErrnoError(28);
          }
          if (stream.seekable && stream.flags & 1024) {
            FS.llseek(stream, 0, 2);
          }
          var seeking = typeof position !== "undefined";
          if (!seeking) {
            position = stream.position;
          } else if (!stream.seekable) {
            throw new FS.ErrnoError(70);
          }
          var bytesWritten = stream.stream_ops.write(stream, buffer2, offset, length, position, canOwn);
          if (!seeking)
            stream.position += bytesWritten;
          try {
            if (stream.path && FS.trackingDelegate["onWriteToFile"])
              FS.trackingDelegate["onWriteToFile"](stream.path);
          } catch (e) {
            err("FS.trackingDelegate['onWriteToFile']('" + stream.path + "') threw an exception: " + e.message);
          }
          return bytesWritten;
        }, allocate: function(stream, offset, length) {
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if (offset < 0 || length <= 0) {
            throw new FS.ErrnoError(28);
          }
          if ((stream.flags & 2097155) === 0) {
            throw new FS.ErrnoError(8);
          }
          if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          if (!stream.stream_ops.allocate) {
            throw new FS.ErrnoError(138);
          }
          stream.stream_ops.allocate(stream, offset, length);
        }, mmap: function(stream, address, length, position, prot, flags) {
          address >>>= 0;
          if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
            throw new FS.ErrnoError(2);
          }
          if ((stream.flags & 2097155) === 1) {
            throw new FS.ErrnoError(2);
          }
          if (!stream.stream_ops.mmap) {
            throw new FS.ErrnoError(43);
          }
          return stream.stream_ops.mmap(stream, address, length, position, prot, flags);
        }, msync: function(stream, buffer2, offset, length, mmapFlags) {
          offset >>>= 0;
          if (!stream || !stream.stream_ops.msync) {
            return 0;
          }
          return stream.stream_ops.msync(stream, buffer2, offset, length, mmapFlags);
        }, munmap: function(stream) {
          return 0;
        }, ioctl: function(stream, cmd, arg) {
          if (!stream.stream_ops.ioctl) {
            throw new FS.ErrnoError(59);
          }
          return stream.stream_ops.ioctl(stream, cmd, arg);
        }, readFile: function(path, opts) {
          opts = opts || {};
          opts.flags = opts.flags || 0;
          opts.encoding = opts.encoding || "binary";
          if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
            throw new Error('Invalid encoding type "' + opts.encoding + '"');
          }
          var ret;
          var stream = FS.open(path, opts.flags);
          var stat = FS.stat(path);
          var length = stat.size;
          var buf = new Uint8Array(length);
          FS.read(stream, buf, 0, length, 0);
          if (opts.encoding === "utf8") {
            ret = UTF8ArrayToString(buf, 0);
          } else if (opts.encoding === "binary") {
            ret = buf;
          }
          FS.close(stream);
          return ret;
        }, writeFile: function(path, data, opts) {
          opts = opts || {};
          opts.flags = opts.flags || 577;
          var stream = FS.open(path, opts.flags, opts.mode);
          if (typeof data === "string") {
            var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
            var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
            FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
          } else if (ArrayBuffer.isView(data)) {
            FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
          } else {
            throw new Error("Unsupported data type");
          }
          FS.close(stream);
        }, cwd: function() {
          return FS.currentPath;
        }, chdir: function(path) {
          var lookup = FS.lookupPath(path, { follow: true });
          if (lookup.node === null) {
            throw new FS.ErrnoError(44);
          }
          if (!FS.isDir(lookup.node.mode)) {
            throw new FS.ErrnoError(54);
          }
          var errCode = FS.nodePermissions(lookup.node, "x");
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          FS.currentPath = lookup.path;
        }, createDefaultDirectories: function() {
          FS.mkdir("/tmp");
          FS.mkdir("/home");
          FS.mkdir("/home/web_user");
        }, createDefaultDevices: function() {
          FS.mkdir("/dev");
          FS.registerDevice(FS.makedev(1, 3), { read: function() {
            return 0;
          }, write: function(stream, buffer2, offset, length, pos) {
            return length;
          } });
          FS.mkdev("/dev/null", FS.makedev(1, 3));
          TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
          TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
          FS.mkdev("/dev/tty", FS.makedev(5, 0));
          FS.mkdev("/dev/tty1", FS.makedev(6, 0));
          var random_device = getRandomDevice();
          FS.createDevice("/dev", "random", random_device);
          FS.createDevice("/dev", "urandom", random_device);
          FS.mkdir("/dev/shm");
          FS.mkdir("/dev/shm/tmp");
        }, createSpecialDirectories: function() {
          FS.mkdir("/proc");
          var proc_self = FS.mkdir("/proc/self");
          FS.mkdir("/proc/self/fd");
          FS.mount({ mount: function() {
            var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
            node.node_ops = { lookup: function(parent, name2) {
              var fd = +name2;
              var stream = FS.getStream(fd);
              if (!stream)
                throw new FS.ErrnoError(8);
              var ret = { parent: null, mount: { mountpoint: "fake" }, node_ops: { readlink: function() {
                return stream.path;
              } } };
              ret.parent = ret;
              return ret;
            } };
            return node;
          } }, {}, "/proc/self/fd");
        }, createStandardStreams: function() {
          if (Module["stdin"]) {
            FS.createDevice("/dev", "stdin", Module["stdin"]);
          } else {
            FS.symlink("/dev/tty", "/dev/stdin");
          }
          if (Module["stdout"]) {
            FS.createDevice("/dev", "stdout", null, Module["stdout"]);
          } else {
            FS.symlink("/dev/tty", "/dev/stdout");
          }
          if (Module["stderr"]) {
            FS.createDevice("/dev", "stderr", null, Module["stderr"]);
          } else {
            FS.symlink("/dev/tty1", "/dev/stderr");
          }
          var stdin = FS.open("/dev/stdin", 0);
          var stdout = FS.open("/dev/stdout", 1);
          var stderr = FS.open("/dev/stderr", 1);
        }, ensureErrnoError: function() {
          if (FS.ErrnoError)
            return;
          FS.ErrnoError = /* @__PURE__ */ __name(function ErrnoError(errno, node) {
            this.node = node;
            this.setErrno = function(errno2) {
              this.errno = errno2;
            };
            this.setErrno(errno);
            this.message = "FS error";
          }, "ErrnoError");
          FS.ErrnoError.prototype = new Error();
          FS.ErrnoError.prototype.constructor = FS.ErrnoError;
          [44].forEach(function(code) {
            FS.genericErrors[code] = new FS.ErrnoError(code);
            FS.genericErrors[code].stack = "<generic error, no stack>";
          });
        }, staticInit: function() {
          FS.ensureErrnoError();
          FS.nameTable = new Array(4096);
          FS.mount(MEMFS, {}, "/");
          FS.createDefaultDirectories();
          FS.createDefaultDevices();
          FS.createSpecialDirectories();
          FS.filesystems = { "MEMFS": MEMFS };
        }, init: function(input, output, error) {
          FS.init.initialized = true;
          FS.ensureErrnoError();
          Module["stdin"] = input || Module["stdin"];
          Module["stdout"] = output || Module["stdout"];
          Module["stderr"] = error || Module["stderr"];
          FS.createStandardStreams();
        }, quit: function() {
          FS.init.initialized = false;
          var fflush = Module["_fflush"];
          if (fflush)
            fflush(0);
          for (var i = 0; i < FS.streams.length; i++) {
            var stream = FS.streams[i];
            if (!stream) {
              continue;
            }
            FS.close(stream);
          }
        }, getMode: function(canRead, canWrite) {
          var mode = 0;
          if (canRead)
            mode |= 292 | 73;
          if (canWrite)
            mode |= 146;
          return mode;
        }, findObject: function(path, dontResolveLastLink) {
          var ret = FS.analyzePath(path, dontResolveLastLink);
          if (ret.exists) {
            return ret.object;
          } else {
            return null;
          }
        }, analyzePath: function(path, dontResolveLastLink) {
          try {
            var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
            path = lookup.path;
          } catch (e) {
          }
          var ret = { isRoot: false, exists: false, error: 0, name: null, path: null, object: null, parentExists: false, parentPath: null, parentObject: null };
          try {
            var lookup = FS.lookupPath(path, { parent: true });
            ret.parentExists = true;
            ret.parentPath = lookup.path;
            ret.parentObject = lookup.node;
            ret.name = PATH.basename(path);
            lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
            ret.exists = true;
            ret.path = lookup.path;
            ret.object = lookup.node;
            ret.name = lookup.node.name;
            ret.isRoot = lookup.path === "/";
          } catch (e) {
            ret.error = e.errno;
          }
          return ret;
        }, createPath: function(parent, path, canRead, canWrite) {
          parent = typeof parent === "string" ? parent : FS.getPath(parent);
          var parts = path.split("/").reverse();
          while (parts.length) {
            var part = parts.pop();
            if (!part)
              continue;
            var current = PATH.join2(parent, part);
            try {
              FS.mkdir(current);
            } catch (e) {
            }
            parent = current;
          }
          return current;
        }, createFile: function(parent, name2, properties, canRead, canWrite) {
          var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name2);
          var mode = FS.getMode(canRead, canWrite);
          return FS.create(path, mode);
        }, createDataFile: function(parent, name2, data, canRead, canWrite, canOwn) {
          var path = name2 ? PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name2) : parent;
          var mode = FS.getMode(canRead, canWrite);
          var node = FS.create(path, mode);
          if (data) {
            if (typeof data === "string") {
              var arr = new Array(data.length);
              for (var i = 0, len = data.length; i < len; ++i)
                arr[i] = data.charCodeAt(i);
              data = arr;
            }
            FS.chmod(node, mode | 146);
            var stream = FS.open(node, 577);
            FS.write(stream, data, 0, data.length, 0, canOwn);
            FS.close(stream);
            FS.chmod(node, mode);
          }
          return node;
        }, createDevice: function(parent, name2, input, output) {
          var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name2);
          var mode = FS.getMode(!!input, !!output);
          if (!FS.createDevice.major)
            FS.createDevice.major = 64;
          var dev = FS.makedev(FS.createDevice.major++, 0);
          FS.registerDevice(dev, { open: function(stream) {
            stream.seekable = false;
          }, close: function(stream) {
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          }, read: function(stream, buffer2, offset, length, pos) {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === void 0 && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === void 0)
                break;
              bytesRead++;
              buffer2[offset + i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          }, write: function(stream, buffer2, offset, length, pos) {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer2[offset + i]);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          } });
          return FS.mkdev(path, mode, dev);
        }, forceLoadFile: function(obj) {
          if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
            return true;
          if (typeof XMLHttpRequest !== "undefined") {
            throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
          } else if (read_) {
            try {
              obj.contents = intArrayFromString(read_(obj.url), true);
              obj.usedBytes = obj.contents.length;
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          } else {
            throw new Error("Cannot load without read() or XMLHttpRequest.");
          }
        }, createLazyFile: function(parent, name2, url, canRead, canWrite) {
          function LazyUint8Array() {
            this.lengthKnown = false;
            this.chunks = [];
          }
          __name(LazyUint8Array, "LazyUint8Array");
          LazyUint8Array.prototype.get = /* @__PURE__ */ __name(function LazyUint8Array_get(idx) {
            if (idx > this.length - 1 || idx < 0) {
              return void 0;
            }
            var chunkOffset = idx % this.chunkSize;
            var chunkNum = idx / this.chunkSize | 0;
            return this.getter(chunkNum)[chunkOffset];
          }, "LazyUint8Array_get");
          LazyUint8Array.prototype.setDataGetter = /* @__PURE__ */ __name(function LazyUint8Array_setDataGetter(getter) {
            this.getter = getter;
          }, "LazyUint8Array_setDataGetter");
          LazyUint8Array.prototype.cacheLength = /* @__PURE__ */ __name(function LazyUint8Array_cacheLength() {
            var xhr = new XMLHttpRequest();
            xhr.open("HEAD", url, false);
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
              throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            var datalength = Number(xhr.getResponseHeader("Content-length"));
            var header;
            var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
            var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
            var chunkSize = 1024 * 1024;
            if (!hasByteServing)
              chunkSize = datalength;
            var doXHR = /* @__PURE__ */ __name(function(from, to) {
              if (from > to)
                throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
              if (to > datalength - 1)
                throw new Error("only " + datalength + " bytes available! programmer error!");
              var xhr2 = new XMLHttpRequest();
              xhr2.open("GET", url, false);
              if (datalength !== chunkSize)
                xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
              if (typeof Uint8Array != "undefined")
                xhr2.responseType = "arraybuffer";
              if (xhr2.overrideMimeType) {
                xhr2.overrideMimeType("text/plain; charset=x-user-defined");
              }
              xhr2.send(null);
              if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
                throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
              if (xhr2.response !== void 0) {
                return new Uint8Array(xhr2.response || []);
              } else {
                return intArrayFromString(xhr2.responseText || "", true);
              }
            }, "doXHR");
            var lazyArray2 = this;
            lazyArray2.setDataGetter(function(chunkNum) {
              var start = chunkNum * chunkSize;
              var end = (chunkNum + 1) * chunkSize - 1;
              end = Math.min(end, datalength - 1);
              if (typeof lazyArray2.chunks[chunkNum] === "undefined") {
                lazyArray2.chunks[chunkNum] = doXHR(start, end);
              }
              if (typeof lazyArray2.chunks[chunkNum] === "undefined")
                throw new Error("doXHR failed!");
              return lazyArray2.chunks[chunkNum];
            });
            if (usesGzip || !datalength) {
              chunkSize = datalength = 1;
              datalength = this.getter(0).length;
              chunkSize = datalength;
              out("LazyFiles on gzip forces download of the whole file when length is accessed");
            }
            this._length = datalength;
            this._chunkSize = chunkSize;
            this.lengthKnown = true;
          }, "LazyUint8Array_cacheLength");
          if (typeof XMLHttpRequest !== "undefined") {
            if (!ENVIRONMENT_IS_WORKER)
              throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
            var lazyArray = new LazyUint8Array();
            Object.defineProperties(lazyArray, { length: { get: function() {
              if (!this.lengthKnown) {
                this.cacheLength();
              }
              return this._length;
            } }, chunkSize: { get: function() {
              if (!this.lengthKnown) {
                this.cacheLength();
              }
              return this._chunkSize;
            } } });
            var properties = { isDevice: false, contents: lazyArray };
          } else {
            var properties = { isDevice: false, url };
          }
          var node = FS.createFile(parent, name2, properties, canRead, canWrite);
          if (properties.contents) {
            node.contents = properties.contents;
          } else if (properties.url) {
            node.contents = null;
            node.url = properties.url;
          }
          Object.defineProperties(node, { usedBytes: { get: function() {
            return this.contents.length;
          } } });
          var stream_ops = {};
          var keys = Object.keys(node.stream_ops);
          keys.forEach(function(key2) {
            var fn = node.stream_ops[key2];
            stream_ops[key2] = /* @__PURE__ */ __name(function forceLoadLazyFile() {
              FS.forceLoadFile(node);
              return fn.apply(null, arguments);
            }, "forceLoadLazyFile");
          });
          stream_ops.read = /* @__PURE__ */ __name(function stream_ops_read(stream, buffer2, offset, length, position) {
            FS.forceLoadFile(node);
            var contents = stream.node.contents;
            if (position >= contents.length)
              return 0;
            var size = Math.min(contents.length - position, length);
            if (contents.slice) {
              for (var i = 0; i < size; i++) {
                buffer2[offset + i] = contents[position + i];
              }
            } else {
              for (var i = 0; i < size; i++) {
                buffer2[offset + i] = contents.get(position + i);
              }
            }
            return size;
          }, "stream_ops_read");
          node.stream_ops = stream_ops;
          return node;
        }, createPreloadedFile: function(parent, name2, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
          Browser.init();
          var fullname = name2 ? PATH_FS.resolve(PATH.join2(parent, name2)) : parent;
          var dep = getUniqueRunDependency("cp " + fullname);
          function processData(byteArray) {
            function finish(byteArray2) {
              if (preFinish)
                preFinish();
              if (!dontCreateFile) {
                FS.createDataFile(parent, name2, byteArray2, canRead, canWrite, canOwn);
              }
              if (onload)
                onload();
              removeRunDependency(dep);
            }
            __name(finish, "finish");
            var handled = false;
            Module["preloadPlugins"].forEach(function(plugin) {
              if (handled)
                return;
              if (plugin["canHandle"](fullname)) {
                plugin["handle"](byteArray, fullname, finish, function() {
                  if (onerror)
                    onerror();
                  removeRunDependency(dep);
                });
                handled = true;
              }
            });
            if (!handled)
              finish(byteArray);
          }
          __name(processData, "processData");
          addRunDependency(dep);
          if (typeof url == "string") {
            asyncLoad(url, function(byteArray) {
              processData(byteArray);
            }, onerror);
          } else {
            processData(url);
          }
        }, indexedDB: function() {
          return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
        }, DB_NAME: function() {
          return "EM_FS_" + window.location.pathname;
        }, DB_VERSION: 20, DB_STORE_NAME: "FILE_DATA", saveFilesToDB: function(paths, onload, onerror) {
          onload = onload || function() {
          };
          onerror = onerror || function() {
          };
          var indexedDB = FS.indexedDB();
          try {
            var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
          } catch (e) {
            return onerror(e);
          }
          openRequest.onupgradeneeded = /* @__PURE__ */ __name(function openRequest_onupgradeneeded() {
            out("creating db");
            var db = openRequest.result;
            db.createObjectStore(FS.DB_STORE_NAME);
          }, "openRequest_onupgradeneeded");
          openRequest.onsuccess = /* @__PURE__ */ __name(function openRequest_onsuccess() {
            var db = openRequest.result;
            var transaction = db.transaction([FS.DB_STORE_NAME], "readwrite");
            var files = transaction.objectStore(FS.DB_STORE_NAME);
            var ok = 0, fail = 0, total = paths.length;
            function finish() {
              if (fail == 0)
                onload();
              else
                onerror();
            }
            __name(finish, "finish");
            paths.forEach(function(path) {
              var putRequest = files.put(FS.analyzePath(path).object.contents, path);
              putRequest.onsuccess = /* @__PURE__ */ __name(function putRequest_onsuccess() {
                ok++;
                if (ok + fail == total)
                  finish();
              }, "putRequest_onsuccess");
              putRequest.onerror = /* @__PURE__ */ __name(function putRequest_onerror() {
                fail++;
                if (ok + fail == total)
                  finish();
              }, "putRequest_onerror");
            });
            transaction.onerror = onerror;
          }, "openRequest_onsuccess");
          openRequest.onerror = onerror;
        }, loadFilesFromDB: function(paths, onload, onerror) {
          onload = onload || function() {
          };
          onerror = onerror || function() {
          };
          var indexedDB = FS.indexedDB();
          try {
            var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
          } catch (e) {
            return onerror(e);
          }
          openRequest.onupgradeneeded = onerror;
          openRequest.onsuccess = /* @__PURE__ */ __name(function openRequest_onsuccess() {
            var db = openRequest.result;
            try {
              var transaction = db.transaction([FS.DB_STORE_NAME], "readonly");
            } catch (e) {
              onerror(e);
              return;
            }
            var files = transaction.objectStore(FS.DB_STORE_NAME);
            var ok = 0, fail = 0, total = paths.length;
            function finish() {
              if (fail == 0)
                onload();
              else
                onerror();
            }
            __name(finish, "finish");
            paths.forEach(function(path) {
              var getRequest = files.get(path);
              getRequest.onsuccess = /* @__PURE__ */ __name(function getRequest_onsuccess() {
                if (FS.analyzePath(path).exists) {
                  FS.unlink(path);
                }
                FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
                ok++;
                if (ok + fail == total)
                  finish();
              }, "getRequest_onsuccess");
              getRequest.onerror = /* @__PURE__ */ __name(function getRequest_onerror() {
                fail++;
                if (ok + fail == total)
                  finish();
              }, "getRequest_onerror");
            });
            transaction.onerror = onerror;
          }, "openRequest_onsuccess");
          openRequest.onerror = onerror;
        } };
        var SYSCALLS = { mappings: {}, DEFAULT_POLLMASK: 5, umask: 511, calculateAt: function(dirfd, path, allowEmpty) {
          if (path[0] === "/") {
            return path;
          }
          var dir;
          if (dirfd === -100) {
            dir = FS.cwd();
          } else {
            var dirstream = FS.getStream(dirfd);
            if (!dirstream)
              throw new FS.ErrnoError(8);
            dir = dirstream.path;
          }
          if (path.length == 0) {
            if (!allowEmpty) {
              throw new FS.ErrnoError(44);
            }
            return dir;
          }
          return PATH.join2(dir, path);
        }, doStat: function(func, path, buf) {
          try {
            var stat = func(path);
          } catch (e) {
            if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
              return -54;
            }
            throw e;
          }
          HEAP32[buf >>> 2] = stat.dev;
          HEAP32[buf + 4 >>> 2] = 0;
          HEAP32[buf + 8 >>> 2] = stat.ino;
          HEAP32[buf + 12 >>> 2] = stat.mode;
          HEAP32[buf + 16 >>> 2] = stat.nlink;
          HEAP32[buf + 20 >>> 2] = stat.uid;
          HEAP32[buf + 24 >>> 2] = stat.gid;
          HEAP32[buf + 28 >>> 2] = stat.rdev;
          HEAP32[buf + 32 >>> 2] = 0;
          tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >>> 2] = tempI64[0], HEAP32[buf + 44 >>> 2] = tempI64[1];
          HEAP32[buf + 48 >>> 2] = 4096;
          HEAP32[buf + 52 >>> 2] = stat.blocks;
          HEAP32[buf + 56 >>> 2] = stat.atime.getTime() / 1e3 | 0;
          HEAP32[buf + 60 >>> 2] = 0;
          HEAP32[buf + 64 >>> 2] = stat.mtime.getTime() / 1e3 | 0;
          HEAP32[buf + 68 >>> 2] = 0;
          HEAP32[buf + 72 >>> 2] = stat.ctime.getTime() / 1e3 | 0;
          HEAP32[buf + 76 >>> 2] = 0;
          tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 80 >>> 2] = tempI64[0], HEAP32[buf + 84 >>> 2] = tempI64[1];
          return 0;
        }, doMsync: function(addr, stream, len, flags, offset) {
          var buffer2 = HEAPU8.slice(addr, addr + len);
          FS.msync(stream, buffer2, offset, len, flags);
        }, doMkdir: function(path, mode) {
          path = PATH.normalize(path);
          if (path[path.length - 1] === "/")
            path = path.substr(0, path.length - 1);
          FS.mkdir(path, mode, 0);
          return 0;
        }, doMknod: function(path, mode, dev) {
          switch (mode & 61440) {
            case 32768:
            case 8192:
            case 24576:
            case 4096:
            case 49152:
              break;
            default:
              return -28;
          }
          FS.mknod(path, mode, dev);
          return 0;
        }, doReadlink: function(path, buf, bufsize) {
          if (bufsize <= 0)
            return -28;
          var ret = FS.readlink(path);
          var len = Math.min(bufsize, lengthBytesUTF8(ret));
          var endChar = HEAP8[buf + len >>> 0];
          stringToUTF8(ret, buf, bufsize + 1);
          HEAP8[buf + len >>> 0] = endChar;
          return len;
        }, doAccess: function(path, amode) {
          if (amode & ~7) {
            return -28;
          }
          var node;
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
          if (!node) {
            return -44;
          }
          var perms = "";
          if (amode & 4)
            perms += "r";
          if (amode & 2)
            perms += "w";
          if (amode & 1)
            perms += "x";
          if (perms && FS.nodePermissions(node, perms)) {
            return -2;
          }
          return 0;
        }, doDup: function(path, flags, suggestFD) {
          var suggest = FS.getStream(suggestFD);
          if (suggest)
            FS.close(suggest);
          return FS.open(path, flags, 0, suggestFD, suggestFD).fd;
        }, doReadv: function(stream, iov, iovcnt, offset) {
          var ret = 0;
          for (var i = 0; i < iovcnt; i++) {
            var ptr = HEAP32[iov + i * 8 >>> 2];
            var len = HEAP32[iov + (i * 8 + 4) >>> 2];
            var curr = FS.read(stream, HEAP8, ptr, len, offset);
            if (curr < 0)
              return -1;
            ret += curr;
            if (curr < len)
              break;
          }
          return ret;
        }, doWritev: function(stream, iov, iovcnt, offset) {
          var ret = 0;
          for (var i = 0; i < iovcnt; i++) {
            var ptr = HEAP32[iov + i * 8 >>> 2];
            var len = HEAP32[iov + (i * 8 + 4) >>> 2];
            var curr = FS.write(stream, HEAP8, ptr, len, offset);
            if (curr < 0)
              return -1;
            ret += curr;
          }
          return ret;
        }, varargs: void 0, get: function() {
          SYSCALLS.varargs += 4;
          var ret = HEAP32[SYSCALLS.varargs - 4 >>> 2];
          return ret;
        }, getStr: function(ptr) {
          var ret = UTF8ToString(ptr);
          return ret;
        }, getStreamFromFD: function(fd) {
          var stream = FS.getStream(fd);
          if (!stream)
            throw new FS.ErrnoError(8);
          return stream;
        }, get64: function(low, high) {
          return low;
        } };
        function ___sys_fcntl64(fd, cmd, varargs) {
          SYSCALLS.varargs = varargs;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            switch (cmd) {
              case 0: {
                var arg = SYSCALLS.get();
                if (arg < 0) {
                  return -28;
                }
                var newStream;
                newStream = FS.open(stream.path, stream.flags, 0, arg);
                return newStream.fd;
              }
              case 1:
              case 2:
                return 0;
              case 3:
                return stream.flags;
              case 4: {
                var arg = SYSCALLS.get();
                stream.flags |= arg;
                return 0;
              }
              case 12: {
                var arg = SYSCALLS.get();
                var offset = 0;
                HEAP16[arg + offset >>> 1] = 2;
                return 0;
              }
              case 13:
              case 14:
                return 0;
              case 16:
              case 8:
                return -28;
              case 9:
                setErrNo(28);
                return -1;
              default: {
                return -28;
              }
            }
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return -e.errno;
          }
        }
        __name(___sys_fcntl64, "___sys_fcntl64");
        function ___sys_ioctl(fd, op, varargs) {
          SYSCALLS.varargs = varargs;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            switch (op) {
              case 21509:
              case 21505: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              case 21510:
              case 21511:
              case 21512:
              case 21506:
              case 21507:
              case 21508: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              case 21519: {
                if (!stream.tty)
                  return -59;
                var argp = SYSCALLS.get();
                HEAP32[argp >>> 2] = 0;
                return 0;
              }
              case 21520: {
                if (!stream.tty)
                  return -59;
                return -28;
              }
              case 21531: {
                var argp = SYSCALLS.get();
                return FS.ioctl(stream, op, argp);
              }
              case 21523: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              case 21524: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              default:
                abort("bad ioctl syscall " + op);
            }
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return -e.errno;
          }
        }
        __name(___sys_ioctl, "___sys_ioctl");
        function ___sys_open(path, flags, varargs) {
          SYSCALLS.varargs = varargs;
          try {
            var pathname = SYSCALLS.getStr(path);
            var mode = varargs ? SYSCALLS.get() : 0;
            var stream = FS.open(pathname, flags, mode);
            return stream.fd;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return -e.errno;
          }
        }
        __name(___sys_open, "___sys_open");
        var tupleRegistrations = {};
        function runDestructors(destructors) {
          while (destructors.length) {
            var ptr = destructors.pop();
            var del = destructors.pop();
            del(ptr);
          }
        }
        __name(runDestructors, "runDestructors");
        function simpleReadValueFromPointer(pointer) {
          return this["fromWireType"](HEAPU32[pointer >>> 2]);
        }
        __name(simpleReadValueFromPointer, "simpleReadValueFromPointer");
        var awaitingDependencies = {};
        var registeredTypes = {};
        var typeDependencies = {};
        var char_0 = 48;
        var char_9 = 57;
        function makeLegalFunctionName(name2) {
          if (name2 === void 0) {
            return "_unknown";
          }
          name2 = name2.replace(/[^a-zA-Z0-9_]/g, "$");
          var f = name2.charCodeAt(0);
          if (f >= char_0 && f <= char_9) {
            return "_" + name2;
          } else {
            return name2;
          }
        }
        __name(makeLegalFunctionName, "makeLegalFunctionName");
        function createNamedFunction(name2, body) {
          name2 = makeLegalFunctionName(name2);
          return new Function("body", "return function " + name2 + '() {\n    "use strict";    return body.apply(this, arguments);\n};\n')(body);
        }
        __name(createNamedFunction, "createNamedFunction");
        function extendError(baseErrorType, errorName) {
          var errorClass = createNamedFunction(errorName, function(message) {
            this.name = errorName;
            this.message = message;
            var stack = new Error(message).stack;
            if (stack !== void 0) {
              this.stack = this.toString() + "\n" + stack.replace(/^Error(:[^\n]*)?\n/, "");
            }
          });
          errorClass.prototype = Object.create(baseErrorType.prototype);
          errorClass.prototype.constructor = errorClass;
          errorClass.prototype.toString = function() {
            if (this.message === void 0) {
              return this.name;
            } else {
              return this.name + ": " + this.message;
            }
          };
          return errorClass;
        }
        __name(extendError, "extendError");
        var InternalError = void 0;
        function throwInternalError(message) {
          throw new InternalError(message);
        }
        __name(throwInternalError, "throwInternalError");
        function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {
          myTypes.forEach(function(type) {
            typeDependencies[type] = dependentTypes;
          });
          function onComplete(typeConverters2) {
            var myTypeConverters = getTypeConverters(typeConverters2);
            if (myTypeConverters.length !== myTypes.length) {
              throwInternalError("Mismatched type converter count");
            }
            for (var i = 0; i < myTypes.length; ++i) {
              registerType(myTypes[i], myTypeConverters[i]);
            }
          }
          __name(onComplete, "onComplete");
          var typeConverters = new Array(dependentTypes.length);
          var unregisteredTypes = [];
          var registered = 0;
          dependentTypes.forEach(function(dt, i) {
            if (registeredTypes.hasOwnProperty(dt)) {
              typeConverters[i] = registeredTypes[dt];
            } else {
              unregisteredTypes.push(dt);
              if (!awaitingDependencies.hasOwnProperty(dt)) {
                awaitingDependencies[dt] = [];
              }
              awaitingDependencies[dt].push(function() {
                typeConverters[i] = registeredTypes[dt];
                ++registered;
                if (registered === unregisteredTypes.length) {
                  onComplete(typeConverters);
                }
              });
            }
          });
          if (unregisteredTypes.length === 0) {
            onComplete(typeConverters);
          }
        }
        __name(whenDependentTypesAreResolved, "whenDependentTypesAreResolved");
        function __embind_finalize_value_array(rawTupleType) {
          var reg = tupleRegistrations[rawTupleType];
          delete tupleRegistrations[rawTupleType];
          var elements = reg.elements;
          var elementsLength = elements.length;
          var elementTypes = elements.map(function(elt) {
            return elt.getterReturnType;
          }).concat(elements.map(function(elt) {
            return elt.setterArgumentType;
          }));
          var rawConstructor = reg.rawConstructor;
          var rawDestructor = reg.rawDestructor;
          whenDependentTypesAreResolved([rawTupleType], elementTypes, function(elementTypes2) {
            elements.forEach(function(elt, i) {
              var getterReturnType = elementTypes2[i];
              var getter = elt.getter;
              var getterContext = elt.getterContext;
              var setterArgumentType = elementTypes2[i + elementsLength];
              var setter = elt.setter;
              var setterContext = elt.setterContext;
              elt.read = function(ptr) {
                return getterReturnType["fromWireType"](getter(getterContext, ptr));
              };
              elt.write = function(ptr, o) {
                var destructors = [];
                setter(setterContext, ptr, setterArgumentType["toWireType"](destructors, o));
                runDestructors(destructors);
              };
            });
            return [{ name: reg.name, "fromWireType": function(ptr) {
              var rv = new Array(elementsLength);
              for (var i = 0; i < elementsLength; ++i) {
                rv[i] = elements[i].read(ptr);
              }
              rawDestructor(ptr);
              return rv;
            }, "toWireType": function(destructors, o) {
              if (elementsLength !== o.length) {
                throw new TypeError("Incorrect number of tuple elements for " + reg.name + ": expected=" + elementsLength + ", actual=" + o.length);
              }
              var ptr = rawConstructor();
              for (var i = 0; i < elementsLength; ++i) {
                elements[i].write(ptr, o[i]);
              }
              if (destructors !== null) {
                destructors.push(rawDestructor, ptr);
              }
              return ptr;
            }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: rawDestructor }];
          });
        }
        __name(__embind_finalize_value_array, "__embind_finalize_value_array");
        var structRegistrations = {};
        function __embind_finalize_value_object(structType) {
          var reg = structRegistrations[structType];
          delete structRegistrations[structType];
          var rawConstructor = reg.rawConstructor;
          var rawDestructor = reg.rawDestructor;
          var fieldRecords = reg.fields;
          var fieldTypes = fieldRecords.map(function(field) {
            return field.getterReturnType;
          }).concat(fieldRecords.map(function(field) {
            return field.setterArgumentType;
          }));
          whenDependentTypesAreResolved([structType], fieldTypes, function(fieldTypes2) {
            var fields = {};
            fieldRecords.forEach(function(field, i) {
              var fieldName = field.fieldName;
              var getterReturnType = fieldTypes2[i];
              var getter = field.getter;
              var getterContext = field.getterContext;
              var setterArgumentType = fieldTypes2[i + fieldRecords.length];
              var setter = field.setter;
              var setterContext = field.setterContext;
              fields[fieldName] = { read: function(ptr) {
                return getterReturnType["fromWireType"](getter(getterContext, ptr));
              }, write: function(ptr, o) {
                var destructors = [];
                setter(setterContext, ptr, setterArgumentType["toWireType"](destructors, o));
                runDestructors(destructors);
              } };
            });
            return [{ name: reg.name, "fromWireType": function(ptr) {
              var rv = {};
              for (var i in fields) {
                rv[i] = fields[i].read(ptr);
              }
              rawDestructor(ptr);
              return rv;
            }, "toWireType": function(destructors, o) {
              for (var fieldName in fields) {
                if (!(fieldName in o)) {
                  throw new TypeError('Missing field:  "' + fieldName + '"');
                }
              }
              var ptr = rawConstructor();
              for (fieldName in fields) {
                fields[fieldName].write(ptr, o[fieldName]);
              }
              if (destructors !== null) {
                destructors.push(rawDestructor, ptr);
              }
              return ptr;
            }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: rawDestructor }];
          });
        }
        __name(__embind_finalize_value_object, "__embind_finalize_value_object");
        function __embind_register_bigint(primitiveType, name2, size, minRange, maxRange) {
        }
        __name(__embind_register_bigint, "__embind_register_bigint");
        function getShiftFromSize(size) {
          switch (size) {
            case 1:
              return 0;
            case 2:
              return 1;
            case 4:
              return 2;
            case 8:
              return 3;
            default:
              throw new TypeError("Unknown type size: " + size);
          }
        }
        __name(getShiftFromSize, "getShiftFromSize");
        function embind_init_charCodes() {
          var codes = new Array(256);
          for (var i = 0; i < 256; ++i) {
            codes[i] = String.fromCharCode(i);
          }
          embind_charCodes = codes;
        }
        __name(embind_init_charCodes, "embind_init_charCodes");
        var embind_charCodes = void 0;
        function readLatin1String(ptr) {
          var ret = "";
          var c = ptr;
          while (HEAPU8[c >>> 0]) {
            ret += embind_charCodes[HEAPU8[c++ >>> 0]];
          }
          return ret;
        }
        __name(readLatin1String, "readLatin1String");
        var BindingError = void 0;
        function throwBindingError(message) {
          throw new BindingError(message);
        }
        __name(throwBindingError, "throwBindingError");
        function registerType(rawType, registeredInstance, options) {
          options = options || {};
          if (!("argPackAdvance" in registeredInstance)) {
            throw new TypeError("registerType registeredInstance requires argPackAdvance");
          }
          var name2 = registeredInstance.name;
          if (!rawType) {
            throwBindingError('type "' + name2 + '" must have a positive integer typeid pointer');
          }
          if (registeredTypes.hasOwnProperty(rawType)) {
            if (options.ignoreDuplicateRegistrations) {
              return;
            } else {
              throwBindingError("Cannot register type '" + name2 + "' twice");
            }
          }
          registeredTypes[rawType] = registeredInstance;
          delete typeDependencies[rawType];
          if (awaitingDependencies.hasOwnProperty(rawType)) {
            var callbacks = awaitingDependencies[rawType];
            delete awaitingDependencies[rawType];
            callbacks.forEach(function(cb) {
              cb();
            });
          }
        }
        __name(registerType, "registerType");
        function __embind_register_bool(rawType, name2, size, trueValue, falseValue) {
          var shift = getShiftFromSize(size);
          name2 = readLatin1String(name2);
          registerType(rawType, { name: name2, "fromWireType": function(wt) {
            return !!wt;
          }, "toWireType": function(destructors, o) {
            return o ? trueValue : falseValue;
          }, "argPackAdvance": 8, "readValueFromPointer": function(pointer) {
            var heap;
            if (size === 1) {
              heap = HEAP8;
            } else if (size === 2) {
              heap = HEAP16;
            } else if (size === 4) {
              heap = HEAP32;
            } else {
              throw new TypeError("Unknown boolean type size: " + name2);
            }
            return this["fromWireType"](heap[pointer >>> shift]);
          }, destructorFunction: null });
        }
        __name(__embind_register_bool, "__embind_register_bool");
        function ClassHandle_isAliasOf(other) {
          if (!(this instanceof ClassHandle)) {
            return false;
          }
          if (!(other instanceof ClassHandle)) {
            return false;
          }
          var leftClass = this.$$.ptrType.registeredClass;
          var left = this.$$.ptr;
          var rightClass = other.$$.ptrType.registeredClass;
          var right = other.$$.ptr;
          while (leftClass.baseClass) {
            left = leftClass.upcast(left);
            leftClass = leftClass.baseClass;
          }
          while (rightClass.baseClass) {
            right = rightClass.upcast(right);
            rightClass = rightClass.baseClass;
          }
          return leftClass === rightClass && left === right;
        }
        __name(ClassHandle_isAliasOf, "ClassHandle_isAliasOf");
        function shallowCopyInternalPointer(o) {
          return { count: o.count, deleteScheduled: o.deleteScheduled, preservePointerOnDelete: o.preservePointerOnDelete, ptr: o.ptr, ptrType: o.ptrType, smartPtr: o.smartPtr, smartPtrType: o.smartPtrType };
        }
        __name(shallowCopyInternalPointer, "shallowCopyInternalPointer");
        function throwInstanceAlreadyDeleted(obj) {
          function getInstanceTypeName(handle) {
            return handle.$$.ptrType.registeredClass.name;
          }
          __name(getInstanceTypeName, "getInstanceTypeName");
          throwBindingError(getInstanceTypeName(obj) + " instance already deleted");
        }
        __name(throwInstanceAlreadyDeleted, "throwInstanceAlreadyDeleted");
        var finalizationGroup = false;
        function detachFinalizer(handle) {
        }
        __name(detachFinalizer, "detachFinalizer");
        function runDestructor($$) {
          if ($$.smartPtr) {
            $$.smartPtrType.rawDestructor($$.smartPtr);
          } else {
            $$.ptrType.registeredClass.rawDestructor($$.ptr);
          }
        }
        __name(runDestructor, "runDestructor");
        function releaseClassHandle($$) {
          $$.count.value -= 1;
          var toDelete = $$.count.value === 0;
          if (toDelete) {
            runDestructor($$);
          }
        }
        __name(releaseClassHandle, "releaseClassHandle");
        function attachFinalizer(handle) {
          if (typeof FinalizationGroup === "undefined") {
            attachFinalizer = /* @__PURE__ */ __name(function(handle2) {
              return handle2;
            }, "attachFinalizer");
            return handle;
          }
          finalizationGroup = new FinalizationGroup(function(iter) {
            for (var result = iter.next(); !result.done; result = iter.next()) {
              var $$ = result.value;
              if (!$$.ptr) {
                console.warn("object already deleted: " + $$.ptr);
              } else {
                releaseClassHandle($$);
              }
            }
          });
          attachFinalizer = /* @__PURE__ */ __name(function(handle2) {
            finalizationGroup.register(handle2, handle2.$$, handle2.$$);
            return handle2;
          }, "attachFinalizer");
          detachFinalizer = /* @__PURE__ */ __name(function(handle2) {
            finalizationGroup.unregister(handle2.$$);
          }, "detachFinalizer");
          return attachFinalizer(handle);
        }
        __name(attachFinalizer, "attachFinalizer");
        function ClassHandle_clone() {
          if (!this.$$.ptr) {
            throwInstanceAlreadyDeleted(this);
          }
          if (this.$$.preservePointerOnDelete) {
            this.$$.count.value += 1;
            return this;
          } else {
            var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), { $$: { value: shallowCopyInternalPointer(this.$$) } }));
            clone.$$.count.value += 1;
            clone.$$.deleteScheduled = false;
            return clone;
          }
        }
        __name(ClassHandle_clone, "ClassHandle_clone");
        function ClassHandle_delete() {
          if (!this.$$.ptr) {
            throwInstanceAlreadyDeleted(this);
          }
          if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
            throwBindingError("Object already scheduled for deletion");
          }
          detachFinalizer(this);
          releaseClassHandle(this.$$);
          if (!this.$$.preservePointerOnDelete) {
            this.$$.smartPtr = void 0;
            this.$$.ptr = void 0;
          }
        }
        __name(ClassHandle_delete, "ClassHandle_delete");
        function ClassHandle_isDeleted() {
          return !this.$$.ptr;
        }
        __name(ClassHandle_isDeleted, "ClassHandle_isDeleted");
        var delayFunction = void 0;
        var deletionQueue = [];
        function flushPendingDeletes() {
          while (deletionQueue.length) {
            var obj = deletionQueue.pop();
            obj.$$.deleteScheduled = false;
            obj["delete"]();
          }
        }
        __name(flushPendingDeletes, "flushPendingDeletes");
        function ClassHandle_deleteLater() {
          if (!this.$$.ptr) {
            throwInstanceAlreadyDeleted(this);
          }
          if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
            throwBindingError("Object already scheduled for deletion");
          }
          deletionQueue.push(this);
          if (deletionQueue.length === 1 && delayFunction) {
            delayFunction(flushPendingDeletes);
          }
          this.$$.deleteScheduled = true;
          return this;
        }
        __name(ClassHandle_deleteLater, "ClassHandle_deleteLater");
        function init_ClassHandle() {
          ClassHandle.prototype["isAliasOf"] = ClassHandle_isAliasOf;
          ClassHandle.prototype["clone"] = ClassHandle_clone;
          ClassHandle.prototype["delete"] = ClassHandle_delete;
          ClassHandle.prototype["isDeleted"] = ClassHandle_isDeleted;
          ClassHandle.prototype["deleteLater"] = ClassHandle_deleteLater;
        }
        __name(init_ClassHandle, "init_ClassHandle");
        function ClassHandle() {
        }
        __name(ClassHandle, "ClassHandle");
        var registeredPointers = {};
        function ensureOverloadTable(proto, methodName, humanName) {
          if (proto[methodName].overloadTable === void 0) {
            var prevFunc = proto[methodName];
            proto[methodName] = function() {
              if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
                throwBindingError("Function '" + humanName + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + proto[methodName].overloadTable + ")!");
              }
              return proto[methodName].overloadTable[arguments.length].apply(this, arguments);
            };
            proto[methodName].overloadTable = [];
            proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
          }
        }
        __name(ensureOverloadTable, "ensureOverloadTable");
        function exposePublicSymbol(name2, value, numArguments) {
          if (Module.hasOwnProperty(name2)) {
            if (numArguments === void 0 || Module[name2].overloadTable !== void 0 && Module[name2].overloadTable[numArguments] !== void 0) {
              throwBindingError("Cannot register public name '" + name2 + "' twice");
            }
            ensureOverloadTable(Module, name2, name2);
            if (Module.hasOwnProperty(numArguments)) {
              throwBindingError("Cannot register multiple overloads of a function with the same number of arguments (" + numArguments + ")!");
            }
            Module[name2].overloadTable[numArguments] = value;
          } else {
            Module[name2] = value;
            if (numArguments !== void 0) {
              Module[name2].numArguments = numArguments;
            }
          }
        }
        __name(exposePublicSymbol, "exposePublicSymbol");
        function RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {
          this.name = name2;
          this.constructor = constructor;
          this.instancePrototype = instancePrototype;
          this.rawDestructor = rawDestructor;
          this.baseClass = baseClass;
          this.getActualType = getActualType;
          this.upcast = upcast;
          this.downcast = downcast;
          this.pureVirtualFunctions = [];
        }
        __name(RegisteredClass, "RegisteredClass");
        function upcastPointer(ptr, ptrClass, desiredClass) {
          while (ptrClass !== desiredClass) {
            if (!ptrClass.upcast) {
              throwBindingError("Expected null or instance of " + desiredClass.name + ", got an instance of " + ptrClass.name);
            }
            ptr = ptrClass.upcast(ptr);
            ptrClass = ptrClass.baseClass;
          }
          return ptr;
        }
        __name(upcastPointer, "upcastPointer");
        function constNoSmartPtrRawPointerToWireType(destructors, handle) {
          if (handle === null) {
            if (this.isReference) {
              throwBindingError("null is not a valid " + this.name);
            }
            return 0;
          }
          if (!handle.$$) {
            throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
          }
          if (!handle.$$.ptr) {
            throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
          }
          var handleClass = handle.$$.ptrType.registeredClass;
          var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
          return ptr;
        }
        __name(constNoSmartPtrRawPointerToWireType, "constNoSmartPtrRawPointerToWireType");
        function genericPointerToWireType(destructors, handle) {
          var ptr;
          if (handle === null) {
            if (this.isReference) {
              throwBindingError("null is not a valid " + this.name);
            }
            if (this.isSmartPointer) {
              ptr = this.rawConstructor();
              if (destructors !== null) {
                destructors.push(this.rawDestructor, ptr);
              }
              return ptr;
            } else {
              return 0;
            }
          }
          if (!handle.$$) {
            throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
          }
          if (!handle.$$.ptr) {
            throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
          }
          if (!this.isConst && handle.$$.ptrType.isConst) {
            throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
          }
          var handleClass = handle.$$.ptrType.registeredClass;
          ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
          if (this.isSmartPointer) {
            if (handle.$$.smartPtr === void 0) {
              throwBindingError("Passing raw pointer to smart pointer is illegal");
            }
            switch (this.sharingPolicy) {
              case 0:
                if (handle.$$.smartPtrType === this) {
                  ptr = handle.$$.smartPtr;
                } else {
                  throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
                }
                break;
              case 1:
                ptr = handle.$$.smartPtr;
                break;
              case 2:
                if (handle.$$.smartPtrType === this) {
                  ptr = handle.$$.smartPtr;
                } else {
                  var clonedHandle = handle["clone"]();
                  ptr = this.rawShare(ptr, __emval_register(function() {
                    clonedHandle["delete"]();
                  }));
                  if (destructors !== null) {
                    destructors.push(this.rawDestructor, ptr);
                  }
                }
                break;
              default:
                throwBindingError("Unsupporting sharing policy");
            }
          }
          return ptr;
        }
        __name(genericPointerToWireType, "genericPointerToWireType");
        function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
          if (handle === null) {
            if (this.isReference) {
              throwBindingError("null is not a valid " + this.name);
            }
            return 0;
          }
          if (!handle.$$) {
            throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
          }
          if (!handle.$$.ptr) {
            throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
          }
          if (handle.$$.ptrType.isConst) {
            throwBindingError("Cannot convert argument of type " + handle.$$.ptrType.name + " to parameter type " + this.name);
          }
          var handleClass = handle.$$.ptrType.registeredClass;
          var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
          return ptr;
        }
        __name(nonConstNoSmartPtrRawPointerToWireType, "nonConstNoSmartPtrRawPointerToWireType");
        function RegisteredPointer_getPointee(ptr) {
          if (this.rawGetPointee) {
            ptr = this.rawGetPointee(ptr);
          }
          return ptr;
        }
        __name(RegisteredPointer_getPointee, "RegisteredPointer_getPointee");
        function RegisteredPointer_destructor(ptr) {
          if (this.rawDestructor) {
            this.rawDestructor(ptr);
          }
        }
        __name(RegisteredPointer_destructor, "RegisteredPointer_destructor");
        function RegisteredPointer_deleteObject(handle) {
          if (handle !== null) {
            handle["delete"]();
          }
        }
        __name(RegisteredPointer_deleteObject, "RegisteredPointer_deleteObject");
        function downcastPointer(ptr, ptrClass, desiredClass) {
          if (ptrClass === desiredClass) {
            return ptr;
          }
          if (desiredClass.baseClass === void 0) {
            return null;
          }
          var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
          if (rv === null) {
            return null;
          }
          return desiredClass.downcast(rv);
        }
        __name(downcastPointer, "downcastPointer");
        function getInheritedInstanceCount() {
          return Object.keys(registeredInstances).length;
        }
        __name(getInheritedInstanceCount, "getInheritedInstanceCount");
        function getLiveInheritedInstances() {
          var rv = [];
          for (var k in registeredInstances) {
            if (registeredInstances.hasOwnProperty(k)) {
              rv.push(registeredInstances[k]);
            }
          }
          return rv;
        }
        __name(getLiveInheritedInstances, "getLiveInheritedInstances");
        function setDelayFunction(fn) {
          delayFunction = fn;
          if (deletionQueue.length && delayFunction) {
            delayFunction(flushPendingDeletes);
          }
        }
        __name(setDelayFunction, "setDelayFunction");
        function init_embind() {
          Module["getInheritedInstanceCount"] = getInheritedInstanceCount;
          Module["getLiveInheritedInstances"] = getLiveInheritedInstances;
          Module["flushPendingDeletes"] = flushPendingDeletes;
          Module["setDelayFunction"] = setDelayFunction;
        }
        __name(init_embind, "init_embind");
        var registeredInstances = {};
        function getBasestPointer(class_, ptr) {
          if (ptr === void 0) {
            throwBindingError("ptr should not be undefined");
          }
          while (class_.baseClass) {
            ptr = class_.upcast(ptr);
            class_ = class_.baseClass;
          }
          return ptr;
        }
        __name(getBasestPointer, "getBasestPointer");
        function getInheritedInstance(class_, ptr) {
          ptr = getBasestPointer(class_, ptr);
          return registeredInstances[ptr];
        }
        __name(getInheritedInstance, "getInheritedInstance");
        function makeClassHandle(prototype, record) {
          if (!record.ptrType || !record.ptr) {
            throwInternalError("makeClassHandle requires ptr and ptrType");
          }
          var hasSmartPtrType = !!record.smartPtrType;
          var hasSmartPtr = !!record.smartPtr;
          if (hasSmartPtrType !== hasSmartPtr) {
            throwInternalError("Both smartPtrType and smartPtr must be specified");
          }
          record.count = { value: 1 };
          return attachFinalizer(Object.create(prototype, { $$: { value: record } }));
        }
        __name(makeClassHandle, "makeClassHandle");
        function RegisteredPointer_fromWireType(ptr) {
          var rawPointer = this.getPointee(ptr);
          if (!rawPointer) {
            this.destructor(ptr);
            return null;
          }
          var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
          if (registeredInstance !== void 0) {
            if (registeredInstance.$$.count.value === 0) {
              registeredInstance.$$.ptr = rawPointer;
              registeredInstance.$$.smartPtr = ptr;
              return registeredInstance["clone"]();
            } else {
              var rv = registeredInstance["clone"]();
              this.destructor(ptr);
              return rv;
            }
          }
          function makeDefaultHandle() {
            if (this.isSmartPointer) {
              return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this.pointeeType, ptr: rawPointer, smartPtrType: this, smartPtr: ptr });
            } else {
              return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this, ptr });
            }
          }
          __name(makeDefaultHandle, "makeDefaultHandle");
          var actualType = this.registeredClass.getActualType(rawPointer);
          var registeredPointerRecord = registeredPointers[actualType];
          if (!registeredPointerRecord) {
            return makeDefaultHandle.call(this);
          }
          var toType;
          if (this.isConst) {
            toType = registeredPointerRecord.constPointerType;
          } else {
            toType = registeredPointerRecord.pointerType;
          }
          var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);
          if (dp === null) {
            return makeDefaultHandle.call(this);
          }
          if (this.isSmartPointer) {
            return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp, smartPtrType: this, smartPtr: ptr });
          } else {
            return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp });
          }
        }
        __name(RegisteredPointer_fromWireType, "RegisteredPointer_fromWireType");
        function init_RegisteredPointer() {
          RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;
          RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;
          RegisteredPointer.prototype["argPackAdvance"] = 8;
          RegisteredPointer.prototype["readValueFromPointer"] = simpleReadValueFromPointer;
          RegisteredPointer.prototype["deleteObject"] = RegisteredPointer_deleteObject;
          RegisteredPointer.prototype["fromWireType"] = RegisteredPointer_fromWireType;
        }
        __name(init_RegisteredPointer, "init_RegisteredPointer");
        function RegisteredPointer(name2, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {
          this.name = name2;
          this.registeredClass = registeredClass;
          this.isReference = isReference;
          this.isConst = isConst;
          this.isSmartPointer = isSmartPointer;
          this.pointeeType = pointeeType;
          this.sharingPolicy = sharingPolicy;
          this.rawGetPointee = rawGetPointee;
          this.rawConstructor = rawConstructor;
          this.rawShare = rawShare;
          this.rawDestructor = rawDestructor;
          if (!isSmartPointer && registeredClass.baseClass === void 0) {
            if (isConst) {
              this["toWireType"] = constNoSmartPtrRawPointerToWireType;
              this.destructorFunction = null;
            } else {
              this["toWireType"] = nonConstNoSmartPtrRawPointerToWireType;
              this.destructorFunction = null;
            }
          } else {
            this["toWireType"] = genericPointerToWireType;
          }
        }
        __name(RegisteredPointer, "RegisteredPointer");
        function replacePublicSymbol(name2, value, numArguments) {
          if (!Module.hasOwnProperty(name2)) {
            throwInternalError("Replacing nonexistant public symbol");
          }
          if (Module[name2].overloadTable !== void 0 && numArguments !== void 0) {
            Module[name2].overloadTable[numArguments] = value;
          } else {
            Module[name2] = value;
            Module[name2].argCount = numArguments;
          }
        }
        __name(replacePublicSymbol, "replacePublicSymbol");
        function dynCallLegacy(sig, ptr, args) {
          var f = Module["dynCall_" + sig];
          return args && args.length ? f.apply(null, [ptr].concat(args)) : f.call(null, ptr);
        }
        __name(dynCallLegacy, "dynCallLegacy");
        function dynCall(sig, ptr, args) {
          if (sig.includes("j")) {
            return dynCallLegacy(sig, ptr, args);
          }
          return wasmTable.get(ptr).apply(null, args);
        }
        __name(dynCall, "dynCall");
        function getDynCaller(sig, ptr) {
          var argCache = [];
          return function() {
            argCache.length = arguments.length;
            for (var i = 0; i < arguments.length; i++) {
              argCache[i] = arguments[i];
            }
            return dynCall(sig, ptr, argCache);
          };
        }
        __name(getDynCaller, "getDynCaller");
        function embind__requireFunction(signature, rawFunction) {
          signature = readLatin1String(signature);
          function makeDynCaller() {
            if (signature.includes("j")) {
              return getDynCaller(signature, rawFunction);
            }
            return wasmTable.get(rawFunction);
          }
          __name(makeDynCaller, "makeDynCaller");
          var fp = makeDynCaller();
          if (typeof fp !== "function") {
            throwBindingError("unknown function pointer with signature " + signature + ": " + rawFunction);
          }
          return fp;
        }
        __name(embind__requireFunction, "embind__requireFunction");
        var UnboundTypeError = void 0;
        function getTypeName(type) {
          var ptr = ___getTypeName(type);
          var rv = readLatin1String(ptr);
          _free(ptr);
          return rv;
        }
        __name(getTypeName, "getTypeName");
        function throwUnboundTypeError(message, types) {
          var unboundTypes = [];
          var seen = {};
          function visit(type) {
            if (seen[type]) {
              return;
            }
            if (registeredTypes[type]) {
              return;
            }
            if (typeDependencies[type]) {
              typeDependencies[type].forEach(visit);
              return;
            }
            unboundTypes.push(type);
            seen[type] = true;
          }
          __name(visit, "visit");
          types.forEach(visit);
          throw new UnboundTypeError(message + ": " + unboundTypes.map(getTypeName).join([", "]));
        }
        __name(throwUnboundTypeError, "throwUnboundTypeError");
        function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name2, destructorSignature, rawDestructor) {
          name2 = readLatin1String(name2);
          getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
          if (upcast) {
            upcast = embind__requireFunction(upcastSignature, upcast);
          }
          if (downcast) {
            downcast = embind__requireFunction(downcastSignature, downcast);
          }
          rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
          var legalFunctionName = makeLegalFunctionName(name2);
          exposePublicSymbol(legalFunctionName, function() {
            throwUnboundTypeError("Cannot construct " + name2 + " due to unbound types", [baseClassRawType]);
          });
          whenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], function(base) {
            base = base[0];
            var baseClass;
            var basePrototype;
            if (baseClassRawType) {
              baseClass = base.registeredClass;
              basePrototype = baseClass.instancePrototype;
            } else {
              basePrototype = ClassHandle.prototype;
            }
            var constructor = createNamedFunction(legalFunctionName, function() {
              if (Object.getPrototypeOf(this) !== instancePrototype) {
                throw new BindingError("Use 'new' to construct " + name2);
              }
              if (registeredClass.constructor_body === void 0) {
                throw new BindingError(name2 + " has no accessible constructor");
              }
              var body = registeredClass.constructor_body[arguments.length];
              if (body === void 0) {
                throw new BindingError("Tried to invoke ctor of " + name2 + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(registeredClass.constructor_body).toString() + ") parameters instead!");
              }
              return body.apply(this, arguments);
            });
            var instancePrototype = Object.create(basePrototype, { constructor: { value: constructor } });
            constructor.prototype = instancePrototype;
            var registeredClass = new RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);
            var referenceConverter = new RegisteredPointer(name2, registeredClass, true, false, false);
            var pointerConverter = new RegisteredPointer(name2 + "*", registeredClass, false, false, false);
            var constPointerConverter = new RegisteredPointer(name2 + " const*", registeredClass, false, true, false);
            registeredPointers[rawType] = { pointerType: pointerConverter, constPointerType: constPointerConverter };
            replacePublicSymbol(legalFunctionName, constructor);
            return [referenceConverter, pointerConverter, constPointerConverter];
          });
        }
        __name(__embind_register_class, "__embind_register_class");
        function heap32VectorToArray(count, firstElement) {
          var array = [];
          for (var i = 0; i < count; i++) {
            array.push(HEAP32[(firstElement >> 2) + i >>> 0]);
          }
          return array;
        }
        __name(heap32VectorToArray, "heap32VectorToArray");
        function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {
          assert(argCount > 0);
          var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          invoker = embind__requireFunction(invokerSignature, invoker);
          var args = [rawConstructor];
          var destructors = [];
          whenDependentTypesAreResolved([], [rawClassType], function(classType) {
            classType = classType[0];
            var humanName = "constructor " + classType.name;
            if (classType.registeredClass.constructor_body === void 0) {
              classType.registeredClass.constructor_body = [];
            }
            if (classType.registeredClass.constructor_body[argCount - 1] !== void 0) {
              throw new BindingError("Cannot register multiple constructors with identical number of parameters (" + (argCount - 1) + ") for class '" + classType.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
            }
            classType.registeredClass.constructor_body[argCount - 1] = /* @__PURE__ */ __name(function unboundTypeHandler() {
              throwUnboundTypeError("Cannot construct " + classType.name + " due to unbound types", rawArgTypes);
            }, "unboundTypeHandler");
            whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
              classType.registeredClass.constructor_body[argCount - 1] = /* @__PURE__ */ __name(function constructor_body() {
                if (arguments.length !== argCount - 1) {
                  throwBindingError(humanName + " called with " + arguments.length + " arguments, expected " + (argCount - 1));
                }
                destructors.length = 0;
                args.length = argCount;
                for (var i = 1; i < argCount; ++i) {
                  args[i] = argTypes[i]["toWireType"](destructors, arguments[i - 1]);
                }
                var ptr = invoker.apply(null, args);
                runDestructors(destructors);
                return argTypes[0]["fromWireType"](ptr);
              }, "constructor_body");
              return [];
            });
            return [];
          });
        }
        __name(__embind_register_class_constructor, "__embind_register_class_constructor");
        function new_(constructor, argumentList) {
          if (!(constructor instanceof Function)) {
            throw new TypeError("new_ called with constructor type " + typeof constructor + " which is not a function");
          }
          var dummy = createNamedFunction(constructor.name || "unknownFunctionName", function() {
          });
          dummy.prototype = constructor.prototype;
          var obj = new dummy();
          var r = constructor.apply(obj, argumentList);
          return r instanceof Object ? r : obj;
        }
        __name(new_, "new_");
        function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {
          var argCount = argTypes.length;
          if (argCount < 2) {
            throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
          }
          var isClassMethodFunc = argTypes[1] !== null && classType !== null;
          var needsDestructorStack = false;
          for (var i = 1; i < argTypes.length; ++i) {
            if (argTypes[i] !== null && argTypes[i].destructorFunction === void 0) {
              needsDestructorStack = true;
              break;
            }
          }
          var returns = argTypes[0].name !== "void";
          var argsList = "";
          var argsListWired = "";
          for (var i = 0; i < argCount - 2; ++i) {
            argsList += (i !== 0 ? ", " : "") + "arg" + i;
            argsListWired += (i !== 0 ? ", " : "") + "arg" + i + "Wired";
          }
          var invokerFnBody = "return function " + makeLegalFunctionName(humanName) + "(" + argsList + ") {\nif (arguments.length !== " + (argCount - 2) + ") {\nthrowBindingError('function " + humanName + " called with ' + arguments.length + ' arguments, expected " + (argCount - 2) + " args!');\n}\n";
          if (needsDestructorStack) {
            invokerFnBody += "var destructors = [];\n";
          }
          var dtorStack = needsDestructorStack ? "destructors" : "null";
          var args1 = ["throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"];
          var args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];
          if (isClassMethodFunc) {
            invokerFnBody += "var thisWired = classParam.toWireType(" + dtorStack + ", this);\n";
          }
          for (var i = 0; i < argCount - 2; ++i) {
            invokerFnBody += "var arg" + i + "Wired = argType" + i + ".toWireType(" + dtorStack + ", arg" + i + "); // " + argTypes[i + 2].name + "\n";
            args1.push("argType" + i);
            args2.push(argTypes[i + 2]);
          }
          if (isClassMethodFunc) {
            argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
          }
          invokerFnBody += (returns ? "var rv = " : "") + "invoker(fn" + (argsListWired.length > 0 ? ", " : "") + argsListWired + ");\n";
          if (needsDestructorStack) {
            invokerFnBody += "runDestructors(destructors);\n";
          } else {
            for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {
              var paramName = i === 1 ? "thisWired" : "arg" + (i - 2) + "Wired";
              if (argTypes[i].destructorFunction !== null) {
                invokerFnBody += paramName + "_dtor(" + paramName + "); // " + argTypes[i].name + "\n";
                args1.push(paramName + "_dtor");
                args2.push(argTypes[i].destructorFunction);
              }
            }
          }
          if (returns) {
            invokerFnBody += "var ret = retType.fromWireType(rv);\nreturn ret;\n";
          } else {
          }
          invokerFnBody += "}\n";
          args1.push(invokerFnBody);
          var invokerFunction = new_(Function, args1).apply(null, args2);
          return invokerFunction;
        }
        __name(craftInvokerFunction, "craftInvokerFunction");
        function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual) {
          var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          methodName = readLatin1String(methodName);
          rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
          whenDependentTypesAreResolved([], [rawClassType], function(classType) {
            classType = classType[0];
            var humanName = classType.name + "." + methodName;
            if (methodName.startsWith("@@")) {
              methodName = Symbol[methodName.substring(2)];
            }
            if (isPureVirtual) {
              classType.registeredClass.pureVirtualFunctions.push(methodName);
            }
            function unboundTypesHandler() {
              throwUnboundTypeError("Cannot call " + humanName + " due to unbound types", rawArgTypes);
            }
            __name(unboundTypesHandler, "unboundTypesHandler");
            var proto = classType.registeredClass.instancePrototype;
            var method = proto[methodName];
            if (method === void 0 || method.overloadTable === void 0 && method.className !== classType.name && method.argCount === argCount - 2) {
              unboundTypesHandler.argCount = argCount - 2;
              unboundTypesHandler.className = classType.name;
              proto[methodName] = unboundTypesHandler;
            } else {
              ensureOverloadTable(proto, methodName, humanName);
              proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
            }
            whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
              var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);
              if (proto[methodName].overloadTable === void 0) {
                memberFunction.argCount = argCount - 2;
                proto[methodName] = memberFunction;
              } else {
                proto[methodName].overloadTable[argCount - 2] = memberFunction;
              }
              return [];
            });
            return [];
          });
        }
        __name(__embind_register_class_function, "__embind_register_class_function");
        var emval_free_list = [];
        var emval_handle_array = [{}, { value: void 0 }, { value: null }, { value: true }, { value: false }];
        function __emval_decref(handle) {
          if (handle > 4 && --emval_handle_array[handle].refcount === 0) {
            emval_handle_array[handle] = void 0;
            emval_free_list.push(handle);
          }
        }
        __name(__emval_decref, "__emval_decref");
        function count_emval_handles() {
          var count = 0;
          for (var i = 5; i < emval_handle_array.length; ++i) {
            if (emval_handle_array[i] !== void 0) {
              ++count;
            }
          }
          return count;
        }
        __name(count_emval_handles, "count_emval_handles");
        function get_first_emval() {
          for (var i = 5; i < emval_handle_array.length; ++i) {
            if (emval_handle_array[i] !== void 0) {
              return emval_handle_array[i];
            }
          }
          return null;
        }
        __name(get_first_emval, "get_first_emval");
        function init_emval() {
          Module["count_emval_handles"] = count_emval_handles;
          Module["get_first_emval"] = get_first_emval;
        }
        __name(init_emval, "init_emval");
        function __emval_register(value) {
          switch (value) {
            case void 0: {
              return 1;
            }
            case null: {
              return 2;
            }
            case true: {
              return 3;
            }
            case false: {
              return 4;
            }
            default: {
              var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;
              emval_handle_array[handle] = { refcount: 1, value };
              return handle;
            }
          }
        }
        __name(__emval_register, "__emval_register");
        function __embind_register_emval(rawType, name2) {
          name2 = readLatin1String(name2);
          registerType(rawType, { name: name2, "fromWireType": function(handle) {
            var rv = emval_handle_array[handle].value;
            __emval_decref(handle);
            return rv;
          }, "toWireType": function(destructors, value) {
            return __emval_register(value);
          }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: null });
        }
        __name(__embind_register_emval, "__embind_register_emval");
        function enumReadValueFromPointer(name2, shift, signed) {
          switch (shift) {
            case 0:
              return function(pointer) {
                var heap = signed ? HEAP8 : HEAPU8;
                return this["fromWireType"](heap[pointer >>> 0]);
              };
            case 1:
              return function(pointer) {
                var heap = signed ? HEAP16 : HEAPU16;
                return this["fromWireType"](heap[pointer >>> 1]);
              };
            case 2:
              return function(pointer) {
                var heap = signed ? HEAP32 : HEAPU32;
                return this["fromWireType"](heap[pointer >>> 2]);
              };
            default:
              throw new TypeError("Unknown integer type: " + name2);
          }
        }
        __name(enumReadValueFromPointer, "enumReadValueFromPointer");
        function __embind_register_enum(rawType, name2, size, isSigned) {
          var shift = getShiftFromSize(size);
          name2 = readLatin1String(name2);
          function ctor() {
          }
          __name(ctor, "ctor");
          ctor.values = {};
          registerType(rawType, { name: name2, constructor: ctor, "fromWireType": function(c) {
            return this.constructor.values[c];
          }, "toWireType": function(destructors, c) {
            return c.value;
          }, "argPackAdvance": 8, "readValueFromPointer": enumReadValueFromPointer(name2, shift, isSigned), destructorFunction: null });
          exposePublicSymbol(name2, ctor);
        }
        __name(__embind_register_enum, "__embind_register_enum");
        function requireRegisteredType(rawType, humanName) {
          var impl = registeredTypes[rawType];
          if (impl === void 0) {
            throwBindingError(humanName + " has unknown type " + getTypeName(rawType));
          }
          return impl;
        }
        __name(requireRegisteredType, "requireRegisteredType");
        function __embind_register_enum_value(rawEnumType, name2, enumValue) {
          var enumType = requireRegisteredType(rawEnumType, "enum");
          name2 = readLatin1String(name2);
          var Enum = enumType.constructor;
          var Value2 = Object.create(enumType.constructor.prototype, { value: { value: enumValue }, constructor: { value: createNamedFunction(enumType.name + "_" + name2, function() {
          }) } });
          Enum.values[enumValue] = Value2;
          Enum[name2] = Value2;
        }
        __name(__embind_register_enum_value, "__embind_register_enum_value");
        function _embind_repr(v) {
          if (v === null) {
            return "null";
          }
          var t = typeof v;
          if (t === "object" || t === "array" || t === "function") {
            return v.toString();
          } else {
            return "" + v;
          }
        }
        __name(_embind_repr, "_embind_repr");
        function floatReadValueFromPointer(name2, shift) {
          switch (shift) {
            case 2:
              return function(pointer) {
                return this["fromWireType"](HEAPF32[pointer >>> 2]);
              };
            case 3:
              return function(pointer) {
                return this["fromWireType"](HEAPF64[pointer >>> 3]);
              };
            default:
              throw new TypeError("Unknown float type: " + name2);
          }
        }
        __name(floatReadValueFromPointer, "floatReadValueFromPointer");
        function __embind_register_float(rawType, name2, size) {
          var shift = getShiftFromSize(size);
          name2 = readLatin1String(name2);
          registerType(rawType, { name: name2, "fromWireType": function(value) {
            return value;
          }, "toWireType": function(destructors, value) {
            if (typeof value !== "number" && typeof value !== "boolean") {
              throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
            }
            return value;
          }, "argPackAdvance": 8, "readValueFromPointer": floatReadValueFromPointer(name2, shift), destructorFunction: null });
        }
        __name(__embind_register_float, "__embind_register_float");
        function __embind_register_function(name2, argCount, rawArgTypesAddr, signature, rawInvoker, fn) {
          var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          name2 = readLatin1String(name2);
          rawInvoker = embind__requireFunction(signature, rawInvoker);
          exposePublicSymbol(name2, function() {
            throwUnboundTypeError("Cannot call " + name2 + " due to unbound types", argTypes);
          }, argCount - 1);
          whenDependentTypesAreResolved([], argTypes, function(argTypes2) {
            var invokerArgsArray = [argTypes2[0], null].concat(argTypes2.slice(1));
            replacePublicSymbol(name2, craftInvokerFunction(name2, invokerArgsArray, null, rawInvoker, fn), argCount - 1);
            return [];
          });
        }
        __name(__embind_register_function, "__embind_register_function");
        function integerReadValueFromPointer(name2, shift, signed) {
          switch (shift) {
            case 0:
              return signed ? /* @__PURE__ */ __name(function readS8FromPointer(pointer) {
                return HEAP8[pointer >>> 0];
              }, "readS8FromPointer") : /* @__PURE__ */ __name(function readU8FromPointer(pointer) {
                return HEAPU8[pointer >>> 0];
              }, "readU8FromPointer");
            case 1:
              return signed ? /* @__PURE__ */ __name(function readS16FromPointer(pointer) {
                return HEAP16[pointer >>> 1];
              }, "readS16FromPointer") : /* @__PURE__ */ __name(function readU16FromPointer(pointer) {
                return HEAPU16[pointer >>> 1];
              }, "readU16FromPointer");
            case 2:
              return signed ? /* @__PURE__ */ __name(function readS32FromPointer(pointer) {
                return HEAP32[pointer >>> 2];
              }, "readS32FromPointer") : /* @__PURE__ */ __name(function readU32FromPointer(pointer) {
                return HEAPU32[pointer >>> 2];
              }, "readU32FromPointer");
            default:
              throw new TypeError("Unknown integer type: " + name2);
          }
        }
        __name(integerReadValueFromPointer, "integerReadValueFromPointer");
        function __embind_register_integer(primitiveType, name2, size, minRange, maxRange) {
          name2 = readLatin1String(name2);
          if (maxRange === -1) {
            maxRange = 4294967295;
          }
          var shift = getShiftFromSize(size);
          var fromWireType = /* @__PURE__ */ __name(function(value) {
            return value;
          }, "fromWireType");
          if (minRange === 0) {
            var bitshift = 32 - 8 * size;
            fromWireType = /* @__PURE__ */ __name(function(value) {
              return value << bitshift >>> bitshift;
            }, "fromWireType");
          }
          var isUnsignedType = name2.includes("unsigned");
          registerType(primitiveType, { name: name2, "fromWireType": fromWireType, "toWireType": function(destructors, value) {
            if (typeof value !== "number" && typeof value !== "boolean") {
              throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
            }
            if (value < minRange || value > maxRange) {
              throw new TypeError('Passing a number "' + _embind_repr(value) + '" from JS side to C/C++ side to an argument of type "' + name2 + '", which is outside the valid range [' + minRange + ", " + maxRange + "]!");
            }
            return isUnsignedType ? value >>> 0 : value | 0;
          }, "argPackAdvance": 8, "readValueFromPointer": integerReadValueFromPointer(name2, shift, minRange !== 0), destructorFunction: null });
        }
        __name(__embind_register_integer, "__embind_register_integer");
        function __embind_register_memory_view(rawType, dataTypeIndex, name2) {
          var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
          var TA = typeMapping[dataTypeIndex];
          function decodeMemoryView(handle) {
            handle = handle >> 2;
            var heap = HEAPU32;
            var size = heap[handle >>> 0];
            var data = heap[handle + 1 >>> 0];
            return new TA(buffer, data, size);
          }
          __name(decodeMemoryView, "decodeMemoryView");
          name2 = readLatin1String(name2);
          registerType(rawType, { name: name2, "fromWireType": decodeMemoryView, "argPackAdvance": 8, "readValueFromPointer": decodeMemoryView }, { ignoreDuplicateRegistrations: true });
        }
        __name(__embind_register_memory_view, "__embind_register_memory_view");
        function __embind_register_std_string(rawType, name2) {
          name2 = readLatin1String(name2);
          var stdStringIsUTF8 = name2 === "std::string";
          registerType(rawType, { name: name2, "fromWireType": function(value) {
            var length = HEAPU32[value >>> 2];
            var str;
            if (stdStringIsUTF8) {
              var decodeStartPtr = value + 4;
              for (var i = 0; i <= length; ++i) {
                var currentBytePtr = value + 4 + i;
                if (i == length || HEAPU8[currentBytePtr >>> 0] == 0) {
                  var maxRead = currentBytePtr - decodeStartPtr;
                  var stringSegment = UTF8ToString(decodeStartPtr, maxRead);
                  if (str === void 0) {
                    str = stringSegment;
                  } else {
                    str += String.fromCharCode(0);
                    str += stringSegment;
                  }
                  decodeStartPtr = currentBytePtr + 1;
                }
              }
            } else {
              var a = new Array(length);
              for (var i = 0; i < length; ++i) {
                a[i] = String.fromCharCode(HEAPU8[value + 4 + i >>> 0]);
              }
              str = a.join("");
            }
            _free(value);
            return str;
          }, "toWireType": function(destructors, value) {
            if (value instanceof ArrayBuffer) {
              value = new Uint8Array(value);
            }
            var getLength;
            var valueIsOfTypeString = typeof value === "string";
            if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
              throwBindingError("Cannot pass non-string to std::string");
            }
            if (stdStringIsUTF8 && valueIsOfTypeString) {
              getLength = /* @__PURE__ */ __name(function() {
                return lengthBytesUTF8(value);
              }, "getLength");
            } else {
              getLength = /* @__PURE__ */ __name(function() {
                return value.length;
              }, "getLength");
            }
            var length = getLength();
            var ptr = _malloc(4 + length + 1);
            ptr >>>= 0;
            HEAPU32[ptr >>> 2] = length;
            if (stdStringIsUTF8 && valueIsOfTypeString) {
              stringToUTF8(value, ptr + 4, length + 1);
            } else {
              if (valueIsOfTypeString) {
                for (var i = 0; i < length; ++i) {
                  var charCode = value.charCodeAt(i);
                  if (charCode > 255) {
                    _free(ptr);
                    throwBindingError("String has UTF-16 code units that do not fit in 8 bits");
                  }
                  HEAPU8[ptr + 4 + i >>> 0] = charCode;
                }
              } else {
                for (var i = 0; i < length; ++i) {
                  HEAPU8[ptr + 4 + i >>> 0] = value[i];
                }
              }
            }
            if (destructors !== null) {
              destructors.push(_free, ptr);
            }
            return ptr;
          }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: function(ptr) {
            _free(ptr);
          } });
        }
        __name(__embind_register_std_string, "__embind_register_std_string");
        function __embind_register_std_wstring(rawType, charSize, name2) {
          name2 = readLatin1String(name2);
          var decodeString, encodeString, getHeap, lengthBytesUTF, shift;
          if (charSize === 2) {
            decodeString = UTF16ToString;
            encodeString = stringToUTF16;
            lengthBytesUTF = lengthBytesUTF16;
            getHeap = /* @__PURE__ */ __name(function() {
              return HEAPU16;
            }, "getHeap");
            shift = 1;
          } else if (charSize === 4) {
            decodeString = UTF32ToString;
            encodeString = stringToUTF32;
            lengthBytesUTF = lengthBytesUTF32;
            getHeap = /* @__PURE__ */ __name(function() {
              return HEAPU32;
            }, "getHeap");
            shift = 2;
          }
          registerType(rawType, { name: name2, "fromWireType": function(value) {
            var length = HEAPU32[value >>> 2];
            var HEAP = getHeap();
            var str;
            var decodeStartPtr = value + 4;
            for (var i = 0; i <= length; ++i) {
              var currentBytePtr = value + 4 + i * charSize;
              if (i == length || HEAP[currentBytePtr >>> shift] == 0) {
                var maxReadBytes = currentBytePtr - decodeStartPtr;
                var stringSegment = decodeString(decodeStartPtr, maxReadBytes);
                if (str === void 0) {
                  str = stringSegment;
                } else {
                  str += String.fromCharCode(0);
                  str += stringSegment;
                }
                decodeStartPtr = currentBytePtr + charSize;
              }
            }
            _free(value);
            return str;
          }, "toWireType": function(destructors, value) {
            if (!(typeof value === "string")) {
              throwBindingError("Cannot pass non-string to C++ string type " + name2);
            }
            var length = lengthBytesUTF(value);
            var ptr = _malloc(4 + length + charSize);
            ptr >>>= 0;
            HEAPU32[ptr >>> 2] = length >> shift;
            encodeString(value, ptr + 4, length + charSize);
            if (destructors !== null) {
              destructors.push(_free, ptr);
            }
            return ptr;
          }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: function(ptr) {
            _free(ptr);
          } });
        }
        __name(__embind_register_std_wstring, "__embind_register_std_wstring");
        function __embind_register_value_array(rawType, name2, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {
          tupleRegistrations[rawType] = { name: readLatin1String(name2), rawConstructor: embind__requireFunction(constructorSignature, rawConstructor), rawDestructor: embind__requireFunction(destructorSignature, rawDestructor), elements: [] };
        }
        __name(__embind_register_value_array, "__embind_register_value_array");
        function __embind_register_value_array_element(rawTupleType, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
          tupleRegistrations[rawTupleType].elements.push({ getterReturnType, getter: embind__requireFunction(getterSignature, getter), getterContext, setterArgumentType, setter: embind__requireFunction(setterSignature, setter), setterContext });
        }
        __name(__embind_register_value_array_element, "__embind_register_value_array_element");
        function __embind_register_value_object(rawType, name2, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {
          structRegistrations[rawType] = { name: readLatin1String(name2), rawConstructor: embind__requireFunction(constructorSignature, rawConstructor), rawDestructor: embind__requireFunction(destructorSignature, rawDestructor), fields: [] };
        }
        __name(__embind_register_value_object, "__embind_register_value_object");
        function __embind_register_value_object_field(structType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
          structRegistrations[structType].fields.push({ fieldName: readLatin1String(fieldName), getterReturnType, getter: embind__requireFunction(getterSignature, getter), getterContext, setterArgumentType, setter: embind__requireFunction(setterSignature, setter), setterContext });
        }
        __name(__embind_register_value_object_field, "__embind_register_value_object_field");
        function __embind_register_void(rawType, name2) {
          name2 = readLatin1String(name2);
          registerType(rawType, { isVoid: true, name: name2, "argPackAdvance": 0, "fromWireType": function() {
            return void 0;
          }, "toWireType": function(destructors, o) {
            return void 0;
          } });
        }
        __name(__embind_register_void, "__embind_register_void");
        function requireHandle(handle) {
          if (!handle) {
            throwBindingError("Cannot use deleted val. handle = " + handle);
          }
          return emval_handle_array[handle].value;
        }
        __name(requireHandle, "requireHandle");
        function __emval_as(handle, returnType, destructorsRef) {
          handle = requireHandle(handle);
          returnType = requireRegisteredType(returnType, "emval::as");
          var destructors = [];
          var rd = __emval_register(destructors);
          HEAP32[destructorsRef >>> 2] = rd;
          return returnType["toWireType"](destructors, handle);
        }
        __name(__emval_as, "__emval_as");
        function __emval_lookupTypes(argCount, argTypes) {
          var a = new Array(argCount);
          for (var i = 0; i < argCount; ++i) {
            a[i] = requireRegisteredType(HEAP32[(argTypes >> 2) + i >>> 0], "parameter " + i);
          }
          return a;
        }
        __name(__emval_lookupTypes, "__emval_lookupTypes");
        function __emval_call(handle, argCount, argTypes, argv) {
          handle = requireHandle(handle);
          var types = __emval_lookupTypes(argCount, argTypes);
          var args = new Array(argCount);
          for (var i = 0; i < argCount; ++i) {
            var type = types[i];
            args[i] = type["readValueFromPointer"](argv);
            argv += type["argPackAdvance"];
          }
          var rv = handle.apply(void 0, args);
          return __emval_register(rv);
        }
        __name(__emval_call, "__emval_call");
        var emval_symbols = {};
        function getStringOrSymbol(address) {
          var symbol = emval_symbols[address];
          if (symbol === void 0) {
            return readLatin1String(address);
          } else {
            return symbol;
          }
        }
        __name(getStringOrSymbol, "getStringOrSymbol");
        function emval_get_global() {
          if (typeof globalThis === "object") {
            return globalThis;
          }
          return function() {
            return Function;
          }()("return this")();
        }
        __name(emval_get_global, "emval_get_global");
        function __emval_get_global(name2) {
          if (name2 === 0) {
            return __emval_register(emval_get_global());
          } else {
            name2 = getStringOrSymbol(name2);
            return __emval_register(emval_get_global()[name2]);
          }
        }
        __name(__emval_get_global, "__emval_get_global");
        function __emval_get_property(handle, key2) {
          handle = requireHandle(handle);
          key2 = requireHandle(key2);
          return __emval_register(handle[key2]);
        }
        __name(__emval_get_property, "__emval_get_property");
        function __emval_incref(handle) {
          if (handle > 4) {
            emval_handle_array[handle].refcount += 1;
          }
        }
        __name(__emval_incref, "__emval_incref");
        function __emval_instanceof(object, constructor) {
          object = requireHandle(object);
          constructor = requireHandle(constructor);
          return object instanceof constructor;
        }
        __name(__emval_instanceof, "__emval_instanceof");
        function __emval_is_number(handle) {
          handle = requireHandle(handle);
          return typeof handle === "number";
        }
        __name(__emval_is_number, "__emval_is_number");
        function __emval_new_array() {
          return __emval_register([]);
        }
        __name(__emval_new_array, "__emval_new_array");
        function __emval_new_cstring(v) {
          return __emval_register(getStringOrSymbol(v));
        }
        __name(__emval_new_cstring, "__emval_new_cstring");
        function __emval_new_object() {
          return __emval_register({});
        }
        __name(__emval_new_object, "__emval_new_object");
        function __emval_run_destructors(handle) {
          var destructors = emval_handle_array[handle].value;
          runDestructors(destructors);
          __emval_decref(handle);
        }
        __name(__emval_run_destructors, "__emval_run_destructors");
        function __emval_set_property(handle, key2, value) {
          handle = requireHandle(handle);
          key2 = requireHandle(key2);
          value = requireHandle(value);
          handle[key2] = value;
        }
        __name(__emval_set_property, "__emval_set_property");
        function __emval_take_value(type, argv) {
          type = requireRegisteredType(type, "_emval_take_value");
          var v = type["readValueFromPointer"](argv);
          return __emval_register(v);
        }
        __name(__emval_take_value, "__emval_take_value");
        function _abort() {
          abort();
        }
        __name(_abort, "_abort");
        var _emscripten_get_now;
        if (ENVIRONMENT_IS_NODE) {
          _emscripten_get_now = /* @__PURE__ */ __name(function() {
            var t = process["hrtime"]();
            return t[0] * 1e3 + t[1] / 1e6;
          }, "_emscripten_get_now");
        } else
          _emscripten_get_now = /* @__PURE__ */ __name(function() {
            return performance.now();
          }, "_emscripten_get_now");
        var _emscripten_get_now_is_monotonic = true;
        function _clock_gettime(clk_id, tp) {
          var now;
          if (clk_id === 0) {
            now = Date.now();
          } else if ((clk_id === 1 || clk_id === 4) && _emscripten_get_now_is_monotonic) {
            now = _emscripten_get_now();
          } else {
            setErrNo(28);
            return -1;
          }
          HEAP32[tp >>> 2] = now / 1e3 | 0;
          HEAP32[tp + 4 >>> 2] = now % 1e3 * 1e3 * 1e3 | 0;
          return 0;
        }
        __name(_clock_gettime, "_clock_gettime");
        function _emscripten_memcpy_big(dest, src, num) {
          HEAPU8.copyWithin(dest >>> 0, src >>> 0, src + num >>> 0);
        }
        __name(_emscripten_memcpy_big, "_emscripten_memcpy_big");
        function emscripten_realloc_buffer(size) {
          try {
            wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);
            updateGlobalBufferAndViews(wasmMemory.buffer);
            return 1;
          } catch (e) {
          }
        }
        __name(emscripten_realloc_buffer, "emscripten_realloc_buffer");
        function _emscripten_resize_heap(requestedSize) {
          var oldSize = HEAPU8.length;
          requestedSize = requestedSize >>> 0;
          var maxHeapSize = 4294901760;
          if (requestedSize > maxHeapSize) {
            return false;
          }
          for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
            var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
            overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
            var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
            var replacement = emscripten_realloc_buffer(newSize);
            if (replacement) {
              return true;
            }
          }
          return false;
        }
        __name(_emscripten_resize_heap, "_emscripten_resize_heap");
        var ENV = {};
        function getExecutableName() {
          return thisProgram || "./this.program";
        }
        __name(getExecutableName, "getExecutableName");
        function getEnvStrings() {
          if (!getEnvStrings.strings) {
            var lang = (typeof navigator === "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
            var env = { "USER": "web_user", "LOGNAME": "web_user", "PATH": "/", "PWD": "/", "HOME": "/home/web_user", "LANG": lang, "_": getExecutableName() };
            for (var x in ENV) {
              if (ENV[x] === void 0)
                delete env[x];
              else
                env[x] = ENV[x];
            }
            var strings = [];
            for (var x in env) {
              strings.push(x + "=" + env[x]);
            }
            getEnvStrings.strings = strings;
          }
          return getEnvStrings.strings;
        }
        __name(getEnvStrings, "getEnvStrings");
        function _environ_get(__environ, environ_buf) {
          try {
            var bufSize = 0;
            getEnvStrings().forEach(function(string, i) {
              var ptr = environ_buf + bufSize;
              HEAP32[__environ + i * 4 >>> 2] = ptr;
              writeAsciiToMemory(string, ptr);
              bufSize += string.length + 1;
            });
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        __name(_environ_get, "_environ_get");
        function _environ_sizes_get(penviron_count, penviron_buf_size) {
          try {
            var strings = getEnvStrings();
            HEAP32[penviron_count >>> 2] = strings.length;
            var bufSize = 0;
            strings.forEach(function(string) {
              bufSize += string.length + 1;
            });
            HEAP32[penviron_buf_size >>> 2] = bufSize;
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        __name(_environ_sizes_get, "_environ_sizes_get");
        function _fd_close(fd) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            FS.close(stream);
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        __name(_fd_close, "_fd_close");
        function _fd_read(fd, iov, iovcnt, pnum) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var num = SYSCALLS.doReadv(stream, iov, iovcnt);
            HEAP32[pnum >>> 2] = num;
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        __name(_fd_read, "_fd_read");
        function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var HIGH_OFFSET = 4294967296;
            var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);
            var DOUBLE_LIMIT = 9007199254740992;
            if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {
              return -61;
            }
            FS.llseek(stream, offset, whence);
            tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >>> 2] = tempI64[0], HEAP32[newOffset + 4 >>> 2] = tempI64[1];
            if (stream.getdents && offset === 0 && whence === 0)
              stream.getdents = null;
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        __name(_fd_seek, "_fd_seek");
        function _fd_write(fd, iov, iovcnt, pnum) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var num = SYSCALLS.doWritev(stream, iov, iovcnt);
            HEAP32[pnum >>> 2] = num;
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        __name(_fd_write, "_fd_write");
        function _getTempRet0() {
          return getTempRet0();
        }
        __name(_getTempRet0, "_getTempRet0");
        function _llvm_eh_typeid_for(type) {
          return type;
        }
        __name(_llvm_eh_typeid_for, "_llvm_eh_typeid_for");
        function _setTempRet0(val) {
          setTempRet0(val);
        }
        __name(_setTempRet0, "_setTempRet0");
        function __isLeapYear(year) {
          return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
        }
        __name(__isLeapYear, "__isLeapYear");
        function __arraySum(array, index) {
          var sum = 0;
          for (var i = 0; i <= index; sum += array[i++]) {
          }
          return sum;
        }
        __name(__arraySum, "__arraySum");
        var __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        var __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        function __addDays(date, days) {
          var newDate = new Date(date.getTime());
          while (days > 0) {
            var leap = __isLeapYear(newDate.getFullYear());
            var currentMonth = newDate.getMonth();
            var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];
            if (days > daysInCurrentMonth - newDate.getDate()) {
              days -= daysInCurrentMonth - newDate.getDate() + 1;
              newDate.setDate(1);
              if (currentMonth < 11) {
                newDate.setMonth(currentMonth + 1);
              } else {
                newDate.setMonth(0);
                newDate.setFullYear(newDate.getFullYear() + 1);
              }
            } else {
              newDate.setDate(newDate.getDate() + days);
              return newDate;
            }
          }
          return newDate;
        }
        __name(__addDays, "__addDays");
        function _strftime(s, maxsize, format2, tm) {
          var tm_zone = HEAP32[tm + 40 >>> 2];
          var date = { tm_sec: HEAP32[tm >>> 2], tm_min: HEAP32[tm + 4 >>> 2], tm_hour: HEAP32[tm + 8 >>> 2], tm_mday: HEAP32[tm + 12 >>> 2], tm_mon: HEAP32[tm + 16 >>> 2], tm_year: HEAP32[tm + 20 >>> 2], tm_wday: HEAP32[tm + 24 >>> 2], tm_yday: HEAP32[tm + 28 >>> 2], tm_isdst: HEAP32[tm + 32 >>> 2], tm_gmtoff: HEAP32[tm + 36 >>> 2], tm_zone: tm_zone ? UTF8ToString(tm_zone) : "" };
          var pattern = UTF8ToString(format2);
          var EXPANSION_RULES_1 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" };
          for (var rule in EXPANSION_RULES_1) {
            pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
          }
          var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
          var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
          function leadingSomething(value, digits, character) {
            var str = typeof value === "number" ? value.toString() : value || "";
            while (str.length < digits) {
              str = character[0] + str;
            }
            return str;
          }
          __name(leadingSomething, "leadingSomething");
          function leadingNulls(value, digits) {
            return leadingSomething(value, digits, "0");
          }
          __name(leadingNulls, "leadingNulls");
          function compareByDay(date1, date2) {
            function sgn(value) {
              return value < 0 ? -1 : value > 0 ? 1 : 0;
            }
            __name(sgn, "sgn");
            var compare;
            if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
              if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
                compare = sgn(date1.getDate() - date2.getDate());
              }
            }
            return compare;
          }
          __name(compareByDay, "compareByDay");
          function getFirstWeekStartDate(janFourth) {
            switch (janFourth.getDay()) {
              case 0:
                return new Date(janFourth.getFullYear() - 1, 11, 29);
              case 1:
                return janFourth;
              case 2:
                return new Date(janFourth.getFullYear(), 0, 3);
              case 3:
                return new Date(janFourth.getFullYear(), 0, 2);
              case 4:
                return new Date(janFourth.getFullYear(), 0, 1);
              case 5:
                return new Date(janFourth.getFullYear() - 1, 11, 31);
              case 6:
                return new Date(janFourth.getFullYear() - 1, 11, 30);
            }
          }
          __name(getFirstWeekStartDate, "getFirstWeekStartDate");
          function getWeekBasedYear(date2) {
            var thisDate = __addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
            var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
            var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
            var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
            var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
            if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
              if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
                return thisDate.getFullYear() + 1;
              } else {
                return thisDate.getFullYear();
              }
            } else {
              return thisDate.getFullYear() - 1;
            }
          }
          __name(getWeekBasedYear, "getWeekBasedYear");
          var EXPANSION_RULES_2 = { "%a": function(date2) {
            return WEEKDAYS[date2.tm_wday].substring(0, 3);
          }, "%A": function(date2) {
            return WEEKDAYS[date2.tm_wday];
          }, "%b": function(date2) {
            return MONTHS[date2.tm_mon].substring(0, 3);
          }, "%B": function(date2) {
            return MONTHS[date2.tm_mon];
          }, "%C": function(date2) {
            var year = date2.tm_year + 1900;
            return leadingNulls(year / 100 | 0, 2);
          }, "%d": function(date2) {
            return leadingNulls(date2.tm_mday, 2);
          }, "%e": function(date2) {
            return leadingSomething(date2.tm_mday, 2, " ");
          }, "%g": function(date2) {
            return getWeekBasedYear(date2).toString().substring(2);
          }, "%G": function(date2) {
            return getWeekBasedYear(date2);
          }, "%H": function(date2) {
            return leadingNulls(date2.tm_hour, 2);
          }, "%I": function(date2) {
            var twelveHour = date2.tm_hour;
            if (twelveHour == 0)
              twelveHour = 12;
            else if (twelveHour > 12)
              twelveHour -= 12;
            return leadingNulls(twelveHour, 2);
          }, "%j": function(date2) {
            return leadingNulls(date2.tm_mday + __arraySum(__isLeapYear(date2.tm_year + 1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3);
          }, "%m": function(date2) {
            return leadingNulls(date2.tm_mon + 1, 2);
          }, "%M": function(date2) {
            return leadingNulls(date2.tm_min, 2);
          }, "%n": function() {
            return "\n";
          }, "%p": function(date2) {
            if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
              return "AM";
            } else {
              return "PM";
            }
          }, "%S": function(date2) {
            return leadingNulls(date2.tm_sec, 2);
          }, "%t": function() {
            return "	";
          }, "%u": function(date2) {
            return date2.tm_wday || 7;
          }, "%U": function(date2) {
            var janFirst = new Date(date2.tm_year + 1900, 0, 1);
            var firstSunday = janFirst.getDay() === 0 ? janFirst : __addDays(janFirst, 7 - janFirst.getDay());
            var endDate = new Date(date2.tm_year + 1900, date2.tm_mon, date2.tm_mday);
            if (compareByDay(firstSunday, endDate) < 0) {
              var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;
              var firstSundayUntilEndJanuary = 31 - firstSunday.getDate();
              var days = firstSundayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();
              return leadingNulls(Math.ceil(days / 7), 2);
            }
            return compareByDay(firstSunday, janFirst) === 0 ? "01" : "00";
          }, "%V": function(date2) {
            var janFourthThisYear = new Date(date2.tm_year + 1900, 0, 4);
            var janFourthNextYear = new Date(date2.tm_year + 1901, 0, 4);
            var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
            var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
            var endDate = __addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
            if (compareByDay(endDate, firstWeekStartThisYear) < 0) {
              return "53";
            }
            if (compareByDay(firstWeekStartNextYear, endDate) <= 0) {
              return "01";
            }
            var daysDifference;
            if (firstWeekStartThisYear.getFullYear() < date2.tm_year + 1900) {
              daysDifference = date2.tm_yday + 32 - firstWeekStartThisYear.getDate();
            } else {
              daysDifference = date2.tm_yday + 1 - firstWeekStartThisYear.getDate();
            }
            return leadingNulls(Math.ceil(daysDifference / 7), 2);
          }, "%w": function(date2) {
            return date2.tm_wday;
          }, "%W": function(date2) {
            var janFirst = new Date(date2.tm_year, 0, 1);
            var firstMonday = janFirst.getDay() === 1 ? janFirst : __addDays(janFirst, janFirst.getDay() === 0 ? 1 : 7 - janFirst.getDay() + 1);
            var endDate = new Date(date2.tm_year + 1900, date2.tm_mon, date2.tm_mday);
            if (compareByDay(firstMonday, endDate) < 0) {
              var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;
              var firstMondayUntilEndJanuary = 31 - firstMonday.getDate();
              var days = firstMondayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();
              return leadingNulls(Math.ceil(days / 7), 2);
            }
            return compareByDay(firstMonday, janFirst) === 0 ? "01" : "00";
          }, "%y": function(date2) {
            return (date2.tm_year + 1900).toString().substring(2);
          }, "%Y": function(date2) {
            return date2.tm_year + 1900;
          }, "%z": function(date2) {
            var off = date2.tm_gmtoff;
            var ahead = off >= 0;
            off = Math.abs(off) / 60;
            off = off / 60 * 100 + off % 60;
            return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
          }, "%Z": function(date2) {
            return date2.tm_zone;
          }, "%%": function() {
            return "%";
          } };
          for (var rule in EXPANSION_RULES_2) {
            if (pattern.includes(rule)) {
              pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
            }
          }
          var bytes = intArrayFromString(pattern, false);
          if (bytes.length > maxsize) {
            return 0;
          }
          writeArrayToMemory(bytes, s);
          return bytes.length - 1;
        }
        __name(_strftime, "_strftime");
        function _strftime_l(s, maxsize, format2, tm) {
          return _strftime(s, maxsize, format2, tm);
        }
        __name(_strftime_l, "_strftime_l");
        var FSNode = /* @__PURE__ */ __name(function(parent, name2, mode, rdev) {
          if (!parent) {
            parent = this;
          }
          this.parent = parent;
          this.mount = parent.mount;
          this.mounted = null;
          this.id = FS.nextInode++;
          this.name = name2;
          this.mode = mode;
          this.node_ops = {};
          this.stream_ops = {};
          this.rdev = rdev;
        }, "FSNode");
        var readMode = 292 | 73;
        var writeMode = 146;
        Object.defineProperties(FSNode.prototype, { read: { get: function() {
          return (this.mode & readMode) === readMode;
        }, set: function(val) {
          val ? this.mode |= readMode : this.mode &= ~readMode;
        } }, write: { get: function() {
          return (this.mode & writeMode) === writeMode;
        }, set: function(val) {
          val ? this.mode |= writeMode : this.mode &= ~writeMode;
        } }, isFolder: { get: function() {
          return FS.isDir(this.mode);
        } }, isDevice: { get: function() {
          return FS.isChrdev(this.mode);
        } } });
        FS.FSNode = FSNode;
        FS.staticInit();
        Module["FS_createPath"] = FS.createPath;
        Module["FS_createDataFile"] = FS.createDataFile;
        Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
        Module["FS_createLazyFile"] = FS.createLazyFile;
        Module["FS_createDevice"] = FS.createDevice;
        Module["FS_unlink"] = FS.unlink;
        InternalError = Module["InternalError"] = extendError(Error, "InternalError");
        embind_init_charCodes();
        BindingError = Module["BindingError"] = extendError(Error, "BindingError");
        init_ClassHandle();
        init_RegisteredPointer();
        init_embind();
        UnboundTypeError = Module["UnboundTypeError"] = extendError(Error, "UnboundTypeError");
        init_emval();
        function intArrayFromString(stringy, dontAddNull, length) {
          var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
          var u8array = new Array(len);
          var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
          if (dontAddNull)
            u8array.length = numBytesWritten;
          return u8array;
        }
        __name(intArrayFromString, "intArrayFromString");
        var asmLibraryArg = { "ga": ___assert_fail, "m": ___cxa_allocate_exception, "u": ___cxa_begin_catch, "x": ___cxa_end_catch, "b": ___cxa_find_matching_catch_2, "l": ___cxa_find_matching_catch_3, "A": ___cxa_free_exception, "$": ___cxa_rethrow, "n": ___cxa_throw, "pa": ___cxa_uncaught_exceptions, "h": ___resumeException, "ba": ___sys_fcntl64, "qa": ___sys_ioctl, "ra": ___sys_open, "Ca": __embind_finalize_value_array, "Fa": __embind_finalize_value_object, "ka": __embind_register_bigint, "ya": __embind_register_bool, "K": __embind_register_class, "J": __embind_register_class_constructor, "p": __embind_register_class_function, "xa": __embind_register_emval, "Aa": __embind_register_enum, "Q": __embind_register_enum_value, "ea": __embind_register_float, "s": __embind_register_function, "z": __embind_register_integer, "w": __embind_register_memory_view, "fa": __embind_register_std_string, "U": __embind_register_std_wstring, "Da": __embind_register_value_array, "Ba": __embind_register_value_array_element, "I": __embind_register_value_object, "Ea": __embind_register_value_object_field, "za": __embind_register_void, "R": __emval_as, "ha": __emval_call, "na": __emval_decref, "Ma": __emval_get_global, "Ia": __emval_get_property, "_": __emval_incref, "la": __emval_instanceof, "La": __emval_is_number, "Ka": __emval_new_array, "V": __emval_new_cstring, "Ja": __emval_new_object, "Ha": __emval_run_destructors, "Ga": __emval_set_property, "B": __emval_take_value, "da": _abort, "aa": _clock_gettime, "oa": _emscripten_memcpy_big, "T": _emscripten_resize_heap, "ta": _environ_get, "ua": _environ_sizes_get, "ca": _fd_close, "wa": _fd_read, "ja": _fd_seek, "va": _fd_write, "a": _getTempRet0, "G": invoke_diii, "C": invoke_i, "c": invoke_ii, "O": invoke_iid, "i": invoke_iii, "j": invoke_iiii, "P": invoke_iiiii, "X": invoke_iiiiid, "E": invoke_iiiiii, "y": invoke_iiiiiii, "Y": invoke_iiiiiiii, "N": invoke_iiiiiiiii, "M": invoke_iiiiiiiiiiii, "ia": invoke_j, "f": invoke_v, "e": invoke_vi, "H": invoke_viddi, "F": invoke_viffiid, "g": invoke_vii, "r": invoke_viidd, "d": invoke_viii, "k": invoke_viiii, "Z": invoke_viiiid, "S": invoke_viiiidii, "D": invoke_viiiii, "v": invoke_viiiiii, "q": invoke_viiiiiii, "t": invoke_viiiiiiiii, "o": invoke_viiiiiiiiii, "L": invoke_viiiiiiiiiiiiiii, "ma": _llvm_eh_typeid_for, "W": _setTempRet0, "sa": _strftime_l };
        var asm = createWasm();
        var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
          return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["Oa"]).apply(null, arguments);
        };
        var _main = Module["_main"] = function() {
          return (_main = Module["_main"] = Module["asm"]["Pa"]).apply(null, arguments);
        };
        var _malloc = Module["_malloc"] = function() {
          return (_malloc = Module["_malloc"] = Module["asm"]["Qa"]).apply(null, arguments);
        };
        var _free = Module["_free"] = function() {
          return (_free = Module["_free"] = Module["asm"]["Sa"]).apply(null, arguments);
        };
        var ___getTypeName = Module["___getTypeName"] = function() {
          return (___getTypeName = Module["___getTypeName"] = Module["asm"]["Ta"]).apply(null, arguments);
        };
        var ___embind_register_native_and_builtin_types = Module["___embind_register_native_and_builtin_types"] = function() {
          return (___embind_register_native_and_builtin_types = Module["___embind_register_native_and_builtin_types"] = Module["asm"]["Ua"]).apply(null, arguments);
        };
        var ___errno_location = Module["___errno_location"] = function() {
          return (___errno_location = Module["___errno_location"] = Module["asm"]["Va"]).apply(null, arguments);
        };
        var stackSave = Module["stackSave"] = function() {
          return (stackSave = Module["stackSave"] = Module["asm"]["Wa"]).apply(null, arguments);
        };
        var stackRestore = Module["stackRestore"] = function() {
          return (stackRestore = Module["stackRestore"] = Module["asm"]["Xa"]).apply(null, arguments);
        };
        var _setThrew = Module["_setThrew"] = function() {
          return (_setThrew = Module["_setThrew"] = Module["asm"]["Ya"]).apply(null, arguments);
        };
        var ___cxa_can_catch = Module["___cxa_can_catch"] = function() {
          return (___cxa_can_catch = Module["___cxa_can_catch"] = Module["asm"]["Za"]).apply(null, arguments);
        };
        var ___cxa_is_pointer_type = Module["___cxa_is_pointer_type"] = function() {
          return (___cxa_is_pointer_type = Module["___cxa_is_pointer_type"] = Module["asm"]["_a"]).apply(null, arguments);
        };
        var dynCall_jiji = Module["dynCall_jiji"] = function() {
          return (dynCall_jiji = Module["dynCall_jiji"] = Module["asm"]["$a"]).apply(null, arguments);
        };
        var dynCall_j = Module["dynCall_j"] = function() {
          return (dynCall_j = Module["dynCall_j"] = Module["asm"]["ab"]).apply(null, arguments);
        };
        var dynCall_viijii = Module["dynCall_viijii"] = function() {
          return (dynCall_viijii = Module["dynCall_viijii"] = Module["asm"]["bb"]).apply(null, arguments);
        };
        var dynCall_iiiiij = Module["dynCall_iiiiij"] = function() {
          return (dynCall_iiiiij = Module["dynCall_iiiiij"] = Module["asm"]["cb"]).apply(null, arguments);
        };
        var dynCall_iiiiijj = Module["dynCall_iiiiijj"] = function() {
          return (dynCall_iiiiijj = Module["dynCall_iiiiijj"] = Module["asm"]["db"]).apply(null, arguments);
        };
        var dynCall_iiiiiijj = Module["dynCall_iiiiiijj"] = function() {
          return (dynCall_iiiiiijj = Module["dynCall_iiiiiijj"] = Module["asm"]["eb"]).apply(null, arguments);
        };
        function invoke_ii(index, a1) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_ii, "invoke_ii");
        function invoke_viiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_viiiiiiiiii, "invoke_viiiiiiiiii");
        function invoke_vi(index, a1) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_vi, "invoke_vi");
        function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_viiiiiiiii, "invoke_viiiiiiiii");
        function invoke_v(index) {
          var sp = stackSave();
          try {
            wasmTable.get(index)();
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_v, "invoke_v");
        function invoke_viii(index, a1, a2, a3) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_viii, "invoke_viii");
        function invoke_viiii(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_viiii, "invoke_viiii");
        function invoke_iii(index, a1, a2) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_iii, "invoke_iii");
        function invoke_vii(index, a1, a2) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_vii, "invoke_vii");
        function invoke_iiiii(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_iiiii, "invoke_iiiii");
        function invoke_diii(index, a1, a2, a3) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_diii, "invoke_diii");
        function invoke_i(index) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)();
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_i, "invoke_i");
        function invoke_iiii(index, a1, a2, a3) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_iiii, "invoke_iiii");
        function invoke_iid(index, a1, a2) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_iid, "invoke_iid");
        function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_iiiiiii, "invoke_iiiiiii");
        function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_viiiiii, "invoke_viiiiii");
        function invoke_viiiidii(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_viiiidii, "invoke_viiiidii");
        function invoke_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_viiiiiii, "invoke_viiiiiii");
        function invoke_viffiid(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_viffiid, "invoke_viffiid");
        function invoke_viddi(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_viddi, "invoke_viddi");
        function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_iiiiii, "invoke_iiiiii");
        function invoke_viiiii(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_viiiii, "invoke_viiiii");
        function invoke_viidd(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_viidd, "invoke_viidd");
        function invoke_viiiid(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_viiiid, "invoke_viiiid");
        function invoke_iiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_iiiiiiiii, "invoke_iiiiiiiii");
        function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_iiiiiiii, "invoke_iiiiiiii");
        function invoke_iiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_iiiiiiiiiiii, "invoke_iiiiiiiiiiii");
        function invoke_viiiiiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_viiiiiiiiiiiiiii, "invoke_viiiiiiiiiiiiiii");
        function invoke_iiiiid(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_iiiiid, "invoke_iiiiid");
        function invoke_j(index) {
          var sp = stackSave();
          try {
            return dynCall_j(index);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        __name(invoke_j, "invoke_j");
        Module["addRunDependency"] = addRunDependency;
        Module["removeRunDependency"] = removeRunDependency;
        Module["FS_createPath"] = FS.createPath;
        Module["FS_createDataFile"] = FS.createDataFile;
        Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
        Module["FS_createLazyFile"] = FS.createLazyFile;
        Module["FS_createDevice"] = FS.createDevice;
        Module["FS_unlink"] = FS.unlink;
        Module["FS"] = FS;
        var calledRun;
        function ExitStatus(status) {
          this.name = "ExitStatus";
          this.message = "Program terminated with exit(" + status + ")";
          this.status = status;
        }
        __name(ExitStatus, "ExitStatus");
        var calledMain = false;
        dependenciesFulfilled = /* @__PURE__ */ __name(function runCaller() {
          if (!calledRun)
            run();
          if (!calledRun)
            dependenciesFulfilled = runCaller;
        }, "runCaller");
        function callMain(args) {
          var entryFunction = Module["_main"];
          var argc = 0;
          var argv = 0;
          try {
            var ret = entryFunction(argc, argv);
            exit(ret, true);
          } catch (e) {
            if (e instanceof ExitStatus || e == "unwind") {
              return;
            }
            var toLog = e;
            if (e && typeof e === "object" && e.stack) {
              toLog = [e, e.stack];
            }
            err("exception thrown: " + toLog);
            quit_(1, e);
          } finally {
            calledMain = true;
          }
        }
        __name(callMain, "callMain");
        function run(args) {
          args = args || arguments_;
          if (runDependencies > 0) {
            return;
          }
          preRun();
          if (runDependencies > 0) {
            return;
          }
          function doRun() {
            if (calledRun)
              return;
            calledRun = true;
            Module["calledRun"] = true;
            if (ABORT)
              return;
            initRuntime();
            preMain();
            readyPromiseResolve(Module);
            if (Module["onRuntimeInitialized"])
              Module["onRuntimeInitialized"]();
            if (shouldRunNow)
              callMain(args);
            postRun();
          }
          __name(doRun, "doRun");
          if (Module["setStatus"]) {
            Module["setStatus"]("Running...");
            setTimeout(function() {
              setTimeout(function() {
                Module["setStatus"]("");
              }, 1);
              doRun();
            }, 1);
          } else {
            doRun();
          }
        }
        __name(run, "run");
        Module["run"] = run;
        function exit(status, implicit) {
          EXITSTATUS = status;
          if (keepRuntimeAlive()) {
          } else {
            exitRuntime();
            if (Module["onExit"])
              Module["onExit"](status);
            ABORT = true;
          }
          quit_(status, new ExitStatus(status));
        }
        __name(exit, "exit");
        if (Module["preInit"]) {
          if (typeof Module["preInit"] == "function")
            Module["preInit"] = [Module["preInit"]];
          while (Module["preInit"].length > 0) {
            Module["preInit"].pop()();
          }
        }
        var shouldRunNow = true;
        if (Module["noInitialRun"])
          shouldRunNow = false;
        run();
        return WebIFCWasm3.ready;
      };
    }();
    if (typeof exports === "object" && typeof module === "object")
      module.exports = WebIFCWasm2;
    else if (typeof define === "function" && define["amd"])
      define([], function() {
        return WebIFCWasm2;
      });
    else if (typeof exports === "object")
      exports["WebIFCWasm"] = WebIFCWasm2;
  }
});
var IFCACTIONREQUEST = 3821786052;
var IFCACTOR = 2296667514;
var IFCACTORROLE = 3630933823;
var IFCACTUATOR = 4288193352;
var IFCACTUATORTYPE = 2874132201;
var IFCADDRESS = 618182010;
var IFCADVANCEDBREP = 1635779807;
var IFCADVANCEDBREPWITHVOIDS = 2603310189;
var IFCADVANCEDFACE = 3406155212;
var IFCAIRTERMINAL = 1634111441;
var IFCAIRTERMINALBOX = 177149247;
var IFCAIRTERMINALBOXTYPE = 1411407467;
var IFCAIRTERMINALTYPE = 3352864051;
var IFCAIRTOAIRHEATRECOVERY = 2056796094;
var IFCAIRTOAIRHEATRECOVERYTYPE = 1871374353;
var IFCALARM = 3087945054;
var IFCALARMTYPE = 3001207471;
var IFCALIGNMENT = 325726236;
var IFCALIGNMENT2DHORIZONTAL = 749761778;
var IFCALIGNMENT2DHORIZONTALSEGMENT = 3199563722;
var IFCALIGNMENT2DSEGMENT = 2483840362;
var IFCALIGNMENT2DVERSEGCIRCULARARC = 3379348081;
var IFCALIGNMENT2DVERSEGLINE = 3239324667;
var IFCALIGNMENT2DVERSEGPARABOLICARC = 4263986512;
var IFCALIGNMENT2DVERTICAL = 53199957;
var IFCALIGNMENT2DVERTICALSEGMENT = 2029264950;
var IFCALIGNMENTCURVE = 3512275521;
var IFCANNOTATION = 1674181508;
var IFCANNOTATIONFILLAREA = 669184980;
var IFCAPPLICATION = 639542469;
var IFCAPPLIEDVALUE = 411424972;
var IFCAPPROVAL = 130549933;
var IFCAPPROVALRELATIONSHIP = 3869604511;
var IFCARBITRARYCLOSEDPROFILEDEF = 3798115385;
var IFCARBITRARYOPENPROFILEDEF = 1310608509;
var IFCARBITRARYPROFILEDEFWITHVOIDS = 2705031697;
var IFCASSET = 3460190687;
var IFCASYMMETRICISHAPEPROFILEDEF = 3207858831;
var IFCAUDIOVISUALAPPLIANCE = 277319702;
var IFCAUDIOVISUALAPPLIANCETYPE = 1532957894;
var IFCAXIS1PLACEMENT = 4261334040;
var IFCAXIS2PLACEMENT2D = 3125803723;
var IFCAXIS2PLACEMENT3D = 2740243338;
var IFCBSPLINECURVE = 1967976161;
var IFCBSPLINECURVEWITHKNOTS = 2461110595;
var IFCBSPLINESURFACE = 2887950389;
var IFCBSPLINESURFACEWITHKNOTS = 167062518;
var IFCBEAM = 753842376;
var IFCBEAMSTANDARDCASE = 2906023776;
var IFCBEAMTYPE = 819618141;
var IFCBEARING = 4196446775;
var IFCBEARINGTYPE = 3649138523;
var IFCBLOBTEXTURE = 616511568;
var IFCBLOCK = 1334484129;
var IFCBOILER = 32344328;
var IFCBOILERTYPE = 231477066;
var IFCBOOLEANCLIPPINGRESULT = 3649129432;
var IFCBOOLEANRESULT = 2736907675;
var IFCBOUNDARYCONDITION = 4037036970;
var IFCBOUNDARYCURVE = 1136057603;
var IFCBOUNDARYEDGECONDITION = 1560379544;
var IFCBOUNDARYFACECONDITION = 3367102660;
var IFCBOUNDARYNODECONDITION = 1387855156;
var IFCBOUNDARYNODECONDITIONWARPING = 2069777674;
var IFCBOUNDEDCURVE = 1260505505;
var IFCBOUNDEDSURFACE = 4182860854;
var IFCBOUNDINGBOX = 2581212453;
var IFCBOXEDHALFSPACE = 2713105998;
var IFCBRIDGE = 644574406;
var IFCBRIDGEPART = 963979645;
var IFCBUILDING = 4031249490;
var IFCBUILDINGELEMENT = 3299480353;
var IFCBUILDINGELEMENTPART = 2979338954;
var IFCBUILDINGELEMENTPARTTYPE = 39481116;
var IFCBUILDINGELEMENTPROXY = 1095909175;
var IFCBUILDINGELEMENTPROXYTYPE = 1909888760;
var IFCBUILDINGELEMENTTYPE = 1950629157;
var IFCBUILDINGSTOREY = 3124254112;
var IFCBUILDINGSYSTEM = 1177604601;
var IFCBURNER = 2938176219;
var IFCBURNERTYPE = 2188180465;
var IFCCSHAPEPROFILEDEF = 2898889636;
var IFCCABLECARRIERFITTING = 635142910;
var IFCCABLECARRIERFITTINGTYPE = 395041908;
var IFCCABLECARRIERSEGMENT = 3758799889;
var IFCCABLECARRIERSEGMENTTYPE = 3293546465;
var IFCCABLEFITTING = 1051757585;
var IFCCABLEFITTINGTYPE = 2674252688;
var IFCCABLESEGMENT = 4217484030;
var IFCCABLESEGMENTTYPE = 1285652485;
var IFCCAISSONFOUNDATION = 3999819293;
var IFCCAISSONFOUNDATIONTYPE = 3203706013;
var IFCCARTESIANPOINT = 1123145078;
var IFCCARTESIANPOINTLIST = 574549367;
var IFCCARTESIANPOINTLIST2D = 1675464909;
var IFCCARTESIANPOINTLIST3D = 2059837836;
var IFCCARTESIANTRANSFORMATIONOPERATOR = 59481748;
var IFCCARTESIANTRANSFORMATIONOPERATOR2D = 3749851601;
var IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM = 3486308946;
var IFCCARTESIANTRANSFORMATIONOPERATOR3D = 3331915920;
var IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM = 1416205885;
var IFCCENTERLINEPROFILEDEF = 3150382593;
var IFCCHILLER = 3902619387;
var IFCCHILLERTYPE = 2951183804;
var IFCCHIMNEY = 3296154744;
var IFCCHIMNEYTYPE = 2197970202;
var IFCCIRCLE = 2611217952;
var IFCCIRCLEHOLLOWPROFILEDEF = 2937912522;
var IFCCIRCLEPROFILEDEF = 1383045692;
var IFCCIRCULARARCSEGMENT2D = 1062206242;
var IFCCIVILELEMENT = 1677625105;
var IFCCIVILELEMENTTYPE = 3893394355;
var IFCCLASSIFICATION = 747523909;
var IFCCLASSIFICATIONREFERENCE = 647927063;
var IFCCLOSEDSHELL = 2205249479;
var IFCCOIL = 639361253;
var IFCCOILTYPE = 2301859152;
var IFCCOLOURRGB = 776857604;
var IFCCOLOURRGBLIST = 3285139300;
var IFCCOLOURSPECIFICATION = 3264961684;
var IFCCOLUMN = 843113511;
var IFCCOLUMNSTANDARDCASE = 905975707;
var IFCCOLUMNTYPE = 300633059;
var IFCCOMMUNICATIONSAPPLIANCE = 3221913625;
var IFCCOMMUNICATIONSAPPLIANCETYPE = 400855858;
var IFCCOMPLEXPROPERTY = 2542286263;
var IFCCOMPLEXPROPERTYTEMPLATE = 3875453745;
var IFCCOMPOSITECURVE = 3732776249;
var IFCCOMPOSITECURVEONSURFACE = 15328376;
var IFCCOMPOSITECURVESEGMENT = 2485617015;
var IFCCOMPOSITEPROFILEDEF = 1485152156;
var IFCCOMPRESSOR = 3571504051;
var IFCCOMPRESSORTYPE = 3850581409;
var IFCCONDENSER = 2272882330;
var IFCCONDENSERTYPE = 2816379211;
var IFCCONIC = 2510884976;
var IFCCONNECTEDFACESET = 370225590;
var IFCCONNECTIONCURVEGEOMETRY = 1981873012;
var IFCCONNECTIONGEOMETRY = 2859738748;
var IFCCONNECTIONPOINTECCENTRICITY = 45288368;
var IFCCONNECTIONPOINTGEOMETRY = 2614616156;
var IFCCONNECTIONSURFACEGEOMETRY = 2732653382;
var IFCCONNECTIONVOLUMEGEOMETRY = 775493141;
var IFCCONSTRAINT = 1959218052;
var IFCCONSTRUCTIONEQUIPMENTRESOURCE = 3898045240;
var IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE = 2185764099;
var IFCCONSTRUCTIONMATERIALRESOURCE = 1060000209;
var IFCCONSTRUCTIONMATERIALRESOURCETYPE = 4105962743;
var IFCCONSTRUCTIONPRODUCTRESOURCE = 488727124;
var IFCCONSTRUCTIONPRODUCTRESOURCETYPE = 1525564444;
var IFCCONSTRUCTIONRESOURCE = 2559216714;
var IFCCONSTRUCTIONRESOURCETYPE = 2574617495;
var IFCCONTEXT = 3419103109;
var IFCCONTEXTDEPENDENTUNIT = 3050246964;
var IFCCONTROL = 3293443760;
var IFCCONTROLLER = 25142252;
var IFCCONTROLLERTYPE = 578613899;
var IFCCONVERSIONBASEDUNIT = 2889183280;
var IFCCONVERSIONBASEDUNITWITHOFFSET = 2713554722;
var IFCCOOLEDBEAM = 4136498852;
var IFCCOOLEDBEAMTYPE = 335055490;
var IFCCOOLINGTOWER = 3640358203;
var IFCCOOLINGTOWERTYPE = 2954562838;
var IFCCOORDINATEOPERATION = 1785450214;
var IFCCOORDINATEREFERENCESYSTEM = 1466758467;
var IFCCOSTITEM = 3895139033;
var IFCCOSTSCHEDULE = 1419761937;
var IFCCOSTVALUE = 602808272;
var IFCCOVERING = 1973544240;
var IFCCOVERINGTYPE = 1916426348;
var IFCCREWRESOURCE = 3295246426;
var IFCCREWRESOURCETYPE = 1815067380;
var IFCCSGPRIMITIVE3D = 2506170314;
var IFCCSGSOLID = 2147822146;
var IFCCURRENCYRELATIONSHIP = 539742890;
var IFCCURTAINWALL = 3495092785;
var IFCCURTAINWALLTYPE = 1457835157;
var IFCCURVE = 2601014836;
var IFCCURVEBOUNDEDPLANE = 2827736869;
var IFCCURVEBOUNDEDSURFACE = 2629017746;
var IFCCURVESEGMENT2D = 1186437898;
var IFCCURVESTYLE = 3800577675;
var IFCCURVESTYLEFONT = 1105321065;
var IFCCURVESTYLEFONTANDSCALING = 2367409068;
var IFCCURVESTYLEFONTPATTERN = 3510044353;
var IFCCYLINDRICALSURFACE = 1213902940;
var IFCDAMPER = 4074379575;
var IFCDAMPERTYPE = 3961806047;
var IFCDEEPFOUNDATION = 3426335179;
var IFCDEEPFOUNDATIONTYPE = 1306400036;
var IFCDERIVEDPROFILEDEF = 3632507154;
var IFCDERIVEDUNIT = 1765591967;
var IFCDERIVEDUNITELEMENT = 1045800335;
var IFCDIMENSIONALEXPONENTS = 2949456006;
var IFCDIRECTION = 32440307;
var IFCDISCRETEACCESSORY = 1335981549;
var IFCDISCRETEACCESSORYTYPE = 2635815018;
var IFCDISTANCEEXPRESSION = 1945343521;
var IFCDISTRIBUTIONCHAMBERELEMENT = 1052013943;
var IFCDISTRIBUTIONCHAMBERELEMENTTYPE = 1599208980;
var IFCDISTRIBUTIONCIRCUIT = 562808652;
var IFCDISTRIBUTIONCONTROLELEMENT = 1062813311;
var IFCDISTRIBUTIONCONTROLELEMENTTYPE = 2063403501;
var IFCDISTRIBUTIONELEMENT = 1945004755;
var IFCDISTRIBUTIONELEMENTTYPE = 3256556792;
var IFCDISTRIBUTIONFLOWELEMENT = 3040386961;
var IFCDISTRIBUTIONFLOWELEMENTTYPE = 3849074793;
var IFCDISTRIBUTIONPORT = 3041715199;
var IFCDISTRIBUTIONSYSTEM = 3205830791;
var IFCDOCUMENTINFORMATION = 1154170062;
var IFCDOCUMENTINFORMATIONRELATIONSHIP = 770865208;
var IFCDOCUMENTREFERENCE = 3732053477;
var IFCDOOR = 395920057;
var IFCDOORLININGPROPERTIES = 2963535650;
var IFCDOORPANELPROPERTIES = 1714330368;
var IFCDOORSTANDARDCASE = 3242481149;
var IFCDOORSTYLE = 526551008;
var IFCDOORTYPE = 2323601079;
var IFCDRAUGHTINGPREDEFINEDCOLOUR = 445594917;
var IFCDRAUGHTINGPREDEFINEDCURVEFONT = 4006246654;
var IFCDUCTFITTING = 342316401;
var IFCDUCTFITTINGTYPE = 869906466;
var IFCDUCTSEGMENT = 3518393246;
var IFCDUCTSEGMENTTYPE = 3760055223;
var IFCDUCTSILENCER = 1360408905;
var IFCDUCTSILENCERTYPE = 2030761528;
var IFCEDGE = 3900360178;
var IFCEDGECURVE = 476780140;
var IFCEDGELOOP = 1472233963;
var IFCELECTRICAPPLIANCE = 1904799276;
var IFCELECTRICAPPLIANCETYPE = 663422040;
var IFCELECTRICDISTRIBUTIONBOARD = 862014818;
var IFCELECTRICDISTRIBUTIONBOARDTYPE = 2417008758;
var IFCELECTRICFLOWSTORAGEDEVICE = 3310460725;
var IFCELECTRICFLOWSTORAGEDEVICETYPE = 3277789161;
var IFCELECTRICGENERATOR = 264262732;
var IFCELECTRICGENERATORTYPE = 1534661035;
var IFCELECTRICMOTOR = 402227799;
var IFCELECTRICMOTORTYPE = 1217240411;
var IFCELECTRICTIMECONTROL = 1003880860;
var IFCELECTRICTIMECONTROLTYPE = 712377611;
var IFCELEMENT = 1758889154;
var IFCELEMENTASSEMBLY = 4123344466;
var IFCELEMENTASSEMBLYTYPE = 2397081782;
var IFCELEMENTCOMPONENT = 1623761950;
var IFCELEMENTCOMPONENTTYPE = 2590856083;
var IFCELEMENTQUANTITY = 1883228015;
var IFCELEMENTTYPE = 339256511;
var IFCELEMENTARYSURFACE = 2777663545;
var IFCELLIPSE = 1704287377;
var IFCELLIPSEPROFILEDEF = 2835456948;
var IFCENERGYCONVERSIONDEVICE = 1658829314;
var IFCENERGYCONVERSIONDEVICETYPE = 2107101300;
var IFCENGINE = 2814081492;
var IFCENGINETYPE = 132023988;
var IFCEVAPORATIVECOOLER = 3747195512;
var IFCEVAPORATIVECOOLERTYPE = 3174744832;
var IFCEVAPORATOR = 484807127;
var IFCEVAPORATORTYPE = 3390157468;
var IFCEVENT = 4148101412;
var IFCEVENTTIME = 211053100;
var IFCEVENTTYPE = 4024345920;
var IFCEXTENDEDPROPERTIES = 297599258;
var IFCEXTERNALINFORMATION = 4294318154;
var IFCEXTERNALREFERENCE = 3200245327;
var IFCEXTERNALREFERENCERELATIONSHIP = 1437805879;
var IFCEXTERNALSPATIALELEMENT = 1209101575;
var IFCEXTERNALSPATIALSTRUCTUREELEMENT = 2853485674;
var IFCEXTERNALLYDEFINEDHATCHSTYLE = 2242383968;
var IFCEXTERNALLYDEFINEDSURFACESTYLE = 1040185647;
var IFCEXTERNALLYDEFINEDTEXTFONT = 3548104201;
var IFCEXTRUDEDAREASOLID = 477187591;
var IFCEXTRUDEDAREASOLIDTAPERED = 2804161546;
var IFCFACE = 2556980723;
var IFCFACEBASEDSURFACEMODEL = 2047409740;
var IFCFACEBOUND = 1809719519;
var IFCFACEOUTERBOUND = 803316827;
var IFCFACESURFACE = 3008276851;
var IFCFACETEDBREP = 807026263;
var IFCFACETEDBREPWITHVOIDS = 3737207727;
var IFCFACILITY = 24185140;
var IFCFACILITYPART = 1310830890;
var IFCFAILURECONNECTIONCONDITION = 4219587988;
var IFCFAN = 3415622556;
var IFCFANTYPE = 346874300;
var IFCFASTENER = 647756555;
var IFCFASTENERTYPE = 2489546625;
var IFCFEATUREELEMENT = 2827207264;
var IFCFEATUREELEMENTADDITION = 2143335405;
var IFCFEATUREELEMENTSUBTRACTION = 1287392070;
var IFCFILLAREASTYLE = 738692330;
var IFCFILLAREASTYLEHATCHING = 374418227;
var IFCFILLAREASTYLETILES = 315944413;
var IFCFILTER = 819412036;
var IFCFILTERTYPE = 1810631287;
var IFCFIRESUPPRESSIONTERMINAL = 1426591983;
var IFCFIRESUPPRESSIONTERMINALTYPE = 4222183408;
var IFCFIXEDREFERENCESWEPTAREASOLID = 2652556860;
var IFCFLOWCONTROLLER = 2058353004;
var IFCFLOWCONTROLLERTYPE = 3907093117;
var IFCFLOWFITTING = 4278956645;
var IFCFLOWFITTINGTYPE = 3198132628;
var IFCFLOWINSTRUMENT = 182646315;
var IFCFLOWINSTRUMENTTYPE = 4037862832;
var IFCFLOWMETER = 2188021234;
var IFCFLOWMETERTYPE = 3815607619;
var IFCFLOWMOVINGDEVICE = 3132237377;
var IFCFLOWMOVINGDEVICETYPE = 1482959167;
var IFCFLOWSEGMENT = 987401354;
var IFCFLOWSEGMENTTYPE = 1834744321;
var IFCFLOWSTORAGEDEVICE = 707683696;
var IFCFLOWSTORAGEDEVICETYPE = 1339347760;
var IFCFLOWTERMINAL = 2223149337;
var IFCFLOWTERMINALTYPE = 2297155007;
var IFCFLOWTREATMENTDEVICE = 3508470533;
var IFCFLOWTREATMENTDEVICETYPE = 3009222698;
var IFCFOOTING = 900683007;
var IFCFOOTINGTYPE = 1893162501;
var IFCFURNISHINGELEMENT = 263784265;
var IFCFURNISHINGELEMENTTYPE = 4238390223;
var IFCFURNITURE = 1509553395;
var IFCFURNITURETYPE = 1268542332;
var IFCGEOGRAPHICELEMENT = 3493046030;
var IFCGEOGRAPHICELEMENTTYPE = 4095422895;
var IFCGEOMETRICCURVESET = 987898635;
var IFCGEOMETRICREPRESENTATIONCONTEXT = 3448662350;
var IFCGEOMETRICREPRESENTATIONITEM = 2453401579;
var IFCGEOMETRICREPRESENTATIONSUBCONTEXT = 4142052618;
var IFCGEOMETRICSET = 3590301190;
var IFCGRID = 3009204131;
var IFCGRIDAXIS = 852622518;
var IFCGRIDPLACEMENT = 178086475;
var IFCGROUP = 2706460486;
var IFCHALFSPACESOLID = 812098782;
var IFCHEATEXCHANGER = 3319311131;
var IFCHEATEXCHANGERTYPE = 1251058090;
var IFCHUMIDIFIER = 2068733104;
var IFCHUMIDIFIERTYPE = 1806887404;
var IFCISHAPEPROFILEDEF = 1484403080;
var IFCIMAGETEXTURE = 3905492369;
var IFCINDEXEDCOLOURMAP = 3570813810;
var IFCINDEXEDPOLYCURVE = 2571569899;
var IFCINDEXEDPOLYGONALFACE = 178912537;
var IFCINDEXEDPOLYGONALFACEWITHVOIDS = 2294589976;
var IFCINDEXEDTEXTUREMAP = 1437953363;
var IFCINDEXEDTRIANGLETEXTUREMAP = 2133299955;
var IFCINTERCEPTOR = 4175244083;
var IFCINTERCEPTORTYPE = 3946677679;
var IFCINTERSECTIONCURVE = 3113134337;
var IFCINVENTORY = 2391368822;
var IFCIRREGULARTIMESERIES = 3741457305;
var IFCIRREGULARTIMESERIESVALUE = 3020489413;
var IFCJUNCTIONBOX = 2176052936;
var IFCJUNCTIONBOXTYPE = 4288270099;
var IFCLSHAPEPROFILEDEF = 572779678;
var IFCLABORRESOURCE = 3827777499;
var IFCLABORRESOURCETYPE = 428585644;
var IFCLAGTIME = 1585845231;
var IFCLAMP = 76236018;
var IFCLAMPTYPE = 1051575348;
var IFCLIBRARYINFORMATION = 2655187982;
var IFCLIBRARYREFERENCE = 3452421091;
var IFCLIGHTDISTRIBUTIONDATA = 4162380809;
var IFCLIGHTFIXTURE = 629592764;
var IFCLIGHTFIXTURETYPE = 1161773419;
var IFCLIGHTINTENSITYDISTRIBUTION = 1566485204;
var IFCLIGHTSOURCE = 1402838566;
var IFCLIGHTSOURCEAMBIENT = 125510826;
var IFCLIGHTSOURCEDIRECTIONAL = 2604431987;
var IFCLIGHTSOURCEGONIOMETRIC = 4266656042;
var IFCLIGHTSOURCEPOSITIONAL = 1520743889;
var IFCLIGHTSOURCESPOT = 3422422726;
var IFCLINE = 1281925730;
var IFCLINESEGMENT2D = 3092502836;
var IFCLINEARPLACEMENT = 388784114;
var IFCLINEARPOSITIONINGELEMENT = 1154579445;
var IFCLOCALPLACEMENT = 2624227202;
var IFCLOOP = 1008929658;
var IFCMANIFOLDSOLIDBREP = 1425443689;
var IFCMAPCONVERSION = 3057273783;
var IFCMAPPEDITEM = 2347385850;
var IFCMATERIAL = 1838606355;
var IFCMATERIALCLASSIFICATIONRELATIONSHIP = 1847130766;
var IFCMATERIALCONSTITUENT = 3708119e3;
var IFCMATERIALCONSTITUENTSET = 2852063980;
var IFCMATERIALDEFINITION = 760658860;
var IFCMATERIALDEFINITIONREPRESENTATION = 2022407955;
var IFCMATERIALLAYER = 248100487;
var IFCMATERIALLAYERSET = 3303938423;
var IFCMATERIALLAYERSETUSAGE = 1303795690;
var IFCMATERIALLAYERWITHOFFSETS = 1847252529;
var IFCMATERIALLIST = 2199411900;
var IFCMATERIALPROFILE = 2235152071;
var IFCMATERIALPROFILESET = 164193824;
var IFCMATERIALPROFILESETUSAGE = 3079605661;
var IFCMATERIALPROFILESETUSAGETAPERING = 3404854881;
var IFCMATERIALPROFILEWITHOFFSETS = 552965576;
var IFCMATERIALPROPERTIES = 3265635763;
var IFCMATERIALRELATIONSHIP = 853536259;
var IFCMATERIALUSAGEDEFINITION = 1507914824;
var IFCMEASUREWITHUNIT = 2597039031;
var IFCMECHANICALFASTENER = 377706215;
var IFCMECHANICALFASTENERTYPE = 2108223431;
var IFCMEDICALDEVICE = 1437502449;
var IFCMEDICALDEVICETYPE = 1114901282;
var IFCMEMBER = 1073191201;
var IFCMEMBERSTANDARDCASE = 1911478936;
var IFCMEMBERTYPE = 3181161470;
var IFCMETRIC = 3368373690;
var IFCMIRROREDPROFILEDEF = 2998442950;
var IFCMONETARYUNIT = 2706619895;
var IFCMOTORCONNECTION = 2474470126;
var IFCMOTORCONNECTIONTYPE = 977012517;
var IFCNAMEDUNIT = 1918398963;
var IFCOBJECT = 3888040117;
var IFCOBJECTDEFINITION = 219451334;
var IFCOBJECTPLACEMENT = 3701648758;
var IFCOBJECTIVE = 2251480897;
var IFCOCCUPANT = 4143007308;
var IFCOFFSETCURVE = 590820931;
var IFCOFFSETCURVE2D = 3388369263;
var IFCOFFSETCURVE3D = 3505215534;
var IFCOFFSETCURVEBYDISTANCES = 2485787929;
var IFCOPENSHELL = 2665983363;
var IFCOPENINGELEMENT = 3588315303;
var IFCOPENINGSTANDARDCASE = 3079942009;
var IFCORGANIZATION = 4251960020;
var IFCORGANIZATIONRELATIONSHIP = 1411181986;
var IFCORIENTATIONEXPRESSION = 643959842;
var IFCORIENTEDEDGE = 1029017970;
var IFCOUTERBOUNDARYCURVE = 144952367;
var IFCOUTLET = 3694346114;
var IFCOUTLETTYPE = 2837617999;
var IFCOWNERHISTORY = 1207048766;
var IFCPARAMETERIZEDPROFILEDEF = 2529465313;
var IFCPATH = 2519244187;
var IFCPCURVE = 1682466193;
var IFCPERFORMANCEHISTORY = 2382730787;
var IFCPERMEABLECOVERINGPROPERTIES = 3566463478;
var IFCPERMIT = 3327091369;
var IFCPERSON = 2077209135;
var IFCPERSONANDORGANIZATION = 101040310;
var IFCPHYSICALCOMPLEXQUANTITY = 3021840470;
var IFCPHYSICALQUANTITY = 2483315170;
var IFCPHYSICALSIMPLEQUANTITY = 2226359599;
var IFCPILE = 1687234759;
var IFCPILETYPE = 1158309216;
var IFCPIPEFITTING = 310824031;
var IFCPIPEFITTINGTYPE = 804291784;
var IFCPIPESEGMENT = 3612865200;
var IFCPIPESEGMENTTYPE = 4231323485;
var IFCPIXELTEXTURE = 597895409;
var IFCPLACEMENT = 2004835150;
var IFCPLANARBOX = 603570806;
var IFCPLANAREXTENT = 1663979128;
var IFCPLANE = 220341763;
var IFCPLATE = 3171933400;
var IFCPLATESTANDARDCASE = 1156407060;
var IFCPLATETYPE = 4017108033;
var IFCPOINT = 2067069095;
var IFCPOINTONCURVE = 4022376103;
var IFCPOINTONSURFACE = 1423911732;
var IFCPOLYLOOP = 2924175390;
var IFCPOLYGONALBOUNDEDHALFSPACE = 2775532180;
var IFCPOLYGONALFACESET = 2839578677;
var IFCPOLYLINE = 3724593414;
var IFCPORT = 3740093272;
var IFCPOSITIONINGELEMENT = 1946335990;
var IFCPOSTALADDRESS = 3355820592;
var IFCPREDEFINEDCOLOUR = 759155922;
var IFCPREDEFINEDCURVEFONT = 2559016684;
var IFCPREDEFINEDITEM = 3727388367;
var IFCPREDEFINEDPROPERTIES = 3778827333;
var IFCPREDEFINEDPROPERTYSET = 3967405729;
var IFCPREDEFINEDTEXTFONT = 1775413392;
var IFCPRESENTATIONITEM = 677532197;
var IFCPRESENTATIONLAYERASSIGNMENT = 2022622350;
var IFCPRESENTATIONLAYERWITHSTYLE = 1304840413;
var IFCPRESENTATIONSTYLE = 3119450353;
var IFCPRESENTATIONSTYLEASSIGNMENT = 2417041796;
var IFCPROCEDURE = 2744685151;
var IFCPROCEDURETYPE = 569719735;
var IFCPROCESS = 2945172077;
var IFCPRODUCT = 4208778838;
var IFCPRODUCTDEFINITIONSHAPE = 673634403;
var IFCPRODUCTREPRESENTATION = 2095639259;
var IFCPROFILEDEF = 3958567839;
var IFCPROFILEPROPERTIES = 2802850158;
var IFCPROJECT = 103090709;
var IFCPROJECTLIBRARY = 653396225;
var IFCPROJECTORDER = 2904328755;
var IFCPROJECTEDCRS = 3843373140;
var IFCPROJECTIONELEMENT = 3651124850;
var IFCPROPERTY = 2598011224;
var IFCPROPERTYABSTRACTION = 986844984;
var IFCPROPERTYBOUNDEDVALUE = 871118103;
var IFCPROPERTYDEFINITION = 1680319473;
var IFCPROPERTYDEPENDENCYRELATIONSHIP = 148025276;
var IFCPROPERTYENUMERATEDVALUE = 4166981789;
var IFCPROPERTYENUMERATION = 3710013099;
var IFCPROPERTYLISTVALUE = 2752243245;
var IFCPROPERTYREFERENCEVALUE = 941946838;
var IFCPROPERTYSET = 1451395588;
var IFCPROPERTYSETDEFINITION = 3357820518;
var IFCPROPERTYSETTEMPLATE = 492091185;
var IFCPROPERTYSINGLEVALUE = 3650150729;
var IFCPROPERTYTABLEVALUE = 110355661;
var IFCPROPERTYTEMPLATE = 3521284610;
var IFCPROPERTYTEMPLATEDEFINITION = 1482703590;
var IFCPROTECTIVEDEVICE = 738039164;
var IFCPROTECTIVEDEVICETRIPPINGUNIT = 2295281155;
var IFCPROTECTIVEDEVICETRIPPINGUNITTYPE = 655969474;
var IFCPROTECTIVEDEVICETYPE = 1842657554;
var IFCPROXY = 3219374653;
var IFCPUMP = 90941305;
var IFCPUMPTYPE = 2250791053;
var IFCQUANTITYAREA = 2044713172;
var IFCQUANTITYCOUNT = 2093928680;
var IFCQUANTITYLENGTH = 931644368;
var IFCQUANTITYSET = 2090586900;
var IFCQUANTITYTIME = 3252649465;
var IFCQUANTITYVOLUME = 2405470396;
var IFCQUANTITYWEIGHT = 825690147;
var IFCRAILING = 2262370178;
var IFCRAILINGTYPE = 2893384427;
var IFCRAMP = 3024970846;
var IFCRAMPFLIGHT = 3283111854;
var IFCRAMPFLIGHTTYPE = 2324767716;
var IFCRAMPTYPE = 1469900589;
var IFCRATIONALBSPLINECURVEWITHKNOTS = 1232101972;
var IFCRATIONALBSPLINESURFACEWITHKNOTS = 683857671;
var IFCRECTANGLEHOLLOWPROFILEDEF = 2770003689;
var IFCRECTANGLEPROFILEDEF = 3615266464;
var IFCRECTANGULARPYRAMID = 2798486643;
var IFCRECTANGULARTRIMMEDSURFACE = 3454111270;
var IFCRECURRENCEPATTERN = 3915482550;
var IFCREFERENCE = 2433181523;
var IFCREFERENT = 4021432810;
var IFCREGULARTIMESERIES = 3413951693;
var IFCREINFORCEMENTBARPROPERTIES = 1580146022;
var IFCREINFORCEMENTDEFINITIONPROPERTIES = 3765753017;
var IFCREINFORCINGBAR = 979691226;
var IFCREINFORCINGBARTYPE = 2572171363;
var IFCREINFORCINGELEMENT = 3027567501;
var IFCREINFORCINGELEMENTTYPE = 964333572;
var IFCREINFORCINGMESH = 2320036040;
var IFCREINFORCINGMESHTYPE = 2310774935;
var IFCRELAGGREGATES = 160246688;
var IFCRELASSIGNS = 3939117080;
var IFCRELASSIGNSTOACTOR = 1683148259;
var IFCRELASSIGNSTOCONTROL = 2495723537;
var IFCRELASSIGNSTOGROUP = 1307041759;
var IFCRELASSIGNSTOGROUPBYFACTOR = 1027710054;
var IFCRELASSIGNSTOPROCESS = 4278684876;
var IFCRELASSIGNSTOPRODUCT = 2857406711;
var IFCRELASSIGNSTORESOURCE = 205026976;
var IFCRELASSOCIATES = 1865459582;
var IFCRELASSOCIATESAPPROVAL = 4095574036;
var IFCRELASSOCIATESCLASSIFICATION = 919958153;
var IFCRELASSOCIATESCONSTRAINT = 2728634034;
var IFCRELASSOCIATESDOCUMENT = 982818633;
var IFCRELASSOCIATESLIBRARY = 3840914261;
var IFCRELASSOCIATESMATERIAL = 2655215786;
var IFCRELCONNECTS = 826625072;
var IFCRELCONNECTSELEMENTS = 1204542856;
var IFCRELCONNECTSPATHELEMENTS = 3945020480;
var IFCRELCONNECTSPORTTOELEMENT = 4201705270;
var IFCRELCONNECTSPORTS = 3190031847;
var IFCRELCONNECTSSTRUCTURALACTIVITY = 2127690289;
var IFCRELCONNECTSSTRUCTURALMEMBER = 1638771189;
var IFCRELCONNECTSWITHECCENTRICITY = 504942748;
var IFCRELCONNECTSWITHREALIZINGELEMENTS = 3678494232;
var IFCRELCONTAINEDINSPATIALSTRUCTURE = 3242617779;
var IFCRELCOVERSBLDGELEMENTS = 886880790;
var IFCRELCOVERSSPACES = 2802773753;
var IFCRELDECLARES = 2565941209;
var IFCRELDECOMPOSES = 2551354335;
var IFCRELDEFINES = 693640335;
var IFCRELDEFINESBYOBJECT = 1462361463;
var IFCRELDEFINESBYPROPERTIES = 4186316022;
var IFCRELDEFINESBYTEMPLATE = 307848117;
var IFCRELDEFINESBYTYPE = 781010003;
var IFCRELFILLSELEMENT = 3940055652;
var IFCRELFLOWCONTROLELEMENTS = 279856033;
var IFCRELINTERFERESELEMENTS = 427948657;
var IFCRELNESTS = 3268803585;
var IFCRELPOSITIONS = 1441486842;
var IFCRELPROJECTSELEMENT = 750771296;
var IFCRELREFERENCEDINSPATIALSTRUCTURE = 1245217292;
var IFCRELSEQUENCE = 4122056220;
var IFCRELSERVICESBUILDINGS = 366585022;
var IFCRELSPACEBOUNDARY = 3451746338;
var IFCRELSPACEBOUNDARY1STLEVEL = 3523091289;
var IFCRELSPACEBOUNDARY2NDLEVEL = 1521410863;
var IFCRELVOIDSELEMENT = 1401173127;
var IFCRELATIONSHIP = 478536968;
var IFCREPARAMETRISEDCOMPOSITECURVESEGMENT = 816062949;
var IFCREPRESENTATION = 1076942058;
var IFCREPRESENTATIONCONTEXT = 3377609919;
var IFCREPRESENTATIONITEM = 3008791417;
var IFCREPRESENTATIONMAP = 1660063152;
var IFCRESOURCE = 2914609552;
var IFCRESOURCEAPPROVALRELATIONSHIP = 2943643501;
var IFCRESOURCECONSTRAINTRELATIONSHIP = 1608871552;
var IFCRESOURCELEVELRELATIONSHIP = 2439245199;
var IFCRESOURCETIME = 1042787934;
var IFCREVOLVEDAREASOLID = 1856042241;
var IFCREVOLVEDAREASOLIDTAPERED = 3243963512;
var IFCRIGHTCIRCULARCONE = 4158566097;
var IFCRIGHTCIRCULARCYLINDER = 3626867408;
var IFCROOF = 2016517767;
var IFCROOFTYPE = 2781568857;
var IFCROOT = 2341007311;
var IFCROUNDEDRECTANGLEPROFILEDEF = 2778083089;
var IFCSIUNIT = 448429030;
var IFCSANITARYTERMINAL = 3053780830;
var IFCSANITARYTERMINALTYPE = 1768891740;
var IFCSCHEDULINGTIME = 1054537805;
var IFCSEAMCURVE = 2157484638;
var IFCSECTIONPROPERTIES = 2042790032;
var IFCSECTIONREINFORCEMENTPROPERTIES = 4165799628;
var IFCSECTIONEDSOLID = 1862484736;
var IFCSECTIONEDSOLIDHORIZONTAL = 1290935644;
var IFCSECTIONEDSPINE = 1509187699;
var IFCSENSOR = 4086658281;
var IFCSENSORTYPE = 1783015770;
var IFCSHADINGDEVICE = 1329646415;
var IFCSHADINGDEVICETYPE = 4074543187;
var IFCSHAPEASPECT = 867548509;
var IFCSHAPEMODEL = 3982875396;
var IFCSHAPEREPRESENTATION = 4240577450;
var IFCSHELLBASEDSURFACEMODEL = 4124623270;
var IFCSIMPLEPROPERTY = 3692461612;
var IFCSIMPLEPROPERTYTEMPLATE = 3663146110;
var IFCSITE = 4097777520;
var IFCSLAB = 1529196076;
var IFCSLABELEMENTEDCASE = 3127900445;
var IFCSLABSTANDARDCASE = 3027962421;
var IFCSLABTYPE = 2533589738;
var IFCSLIPPAGECONNECTIONCONDITION = 2609359061;
var IFCSOLARDEVICE = 3420628829;
var IFCSOLARDEVICETYPE = 1072016465;
var IFCSOLIDMODEL = 723233188;
var IFCSPACE = 3856911033;
var IFCSPACEHEATER = 1999602285;
var IFCSPACEHEATERTYPE = 1305183839;
var IFCSPACETYPE = 3812236995;
var IFCSPATIALELEMENT = 1412071761;
var IFCSPATIALELEMENTTYPE = 710998568;
var IFCSPATIALSTRUCTUREELEMENT = 2706606064;
var IFCSPATIALSTRUCTUREELEMENTTYPE = 3893378262;
var IFCSPATIALZONE = 463610769;
var IFCSPATIALZONETYPE = 2481509218;
var IFCSPHERE = 451544542;
var IFCSPHERICALSURFACE = 4015995234;
var IFCSTACKTERMINAL = 1404847402;
var IFCSTACKTERMINALTYPE = 3112655638;
var IFCSTAIR = 331165859;
var IFCSTAIRFLIGHT = 4252922144;
var IFCSTAIRFLIGHTTYPE = 1039846685;
var IFCSTAIRTYPE = 338393293;
var IFCSTRUCTURALACTION = 682877961;
var IFCSTRUCTURALACTIVITY = 3544373492;
var IFCSTRUCTURALANALYSISMODEL = 2515109513;
var IFCSTRUCTURALCONNECTION = 1179482911;
var IFCSTRUCTURALCONNECTIONCONDITION = 2273995522;
var IFCSTRUCTURALCURVEACTION = 1004757350;
var IFCSTRUCTURALCURVECONNECTION = 4243806635;
var IFCSTRUCTURALCURVEMEMBER = 214636428;
var IFCSTRUCTURALCURVEMEMBERVARYING = 2445595289;
var IFCSTRUCTURALCURVEREACTION = 2757150158;
var IFCSTRUCTURALITEM = 3136571912;
var IFCSTRUCTURALLINEARACTION = 1807405624;
var IFCSTRUCTURALLOAD = 2162789131;
var IFCSTRUCTURALLOADCASE = 385403989;
var IFCSTRUCTURALLOADCONFIGURATION = 3478079324;
var IFCSTRUCTURALLOADGROUP = 1252848954;
var IFCSTRUCTURALLOADLINEARFORCE = 1595516126;
var IFCSTRUCTURALLOADORRESULT = 609421318;
var IFCSTRUCTURALLOADPLANARFORCE = 2668620305;
var IFCSTRUCTURALLOADSINGLEDISPLACEMENT = 2473145415;
var IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION = 1973038258;
var IFCSTRUCTURALLOADSINGLEFORCE = 1597423693;
var IFCSTRUCTURALLOADSINGLEFORCEWARPING = 1190533807;
var IFCSTRUCTURALLOADSTATIC = 2525727697;
var IFCSTRUCTURALLOADTEMPERATURE = 3408363356;
var IFCSTRUCTURALMEMBER = 530289379;
var IFCSTRUCTURALPLANARACTION = 1621171031;
var IFCSTRUCTURALPOINTACTION = 2082059205;
var IFCSTRUCTURALPOINTCONNECTION = 734778138;
var IFCSTRUCTURALPOINTREACTION = 1235345126;
var IFCSTRUCTURALREACTION = 3689010777;
var IFCSTRUCTURALRESULTGROUP = 2986769608;
var IFCSTRUCTURALSURFACEACTION = 3657597509;
var IFCSTRUCTURALSURFACECONNECTION = 1975003073;
var IFCSTRUCTURALSURFACEMEMBER = 3979015343;
var IFCSTRUCTURALSURFACEMEMBERVARYING = 2218152070;
var IFCSTRUCTURALSURFACEREACTION = 603775116;
var IFCSTYLEMODEL = 2830218821;
var IFCSTYLEDITEM = 3958052878;
var IFCSTYLEDREPRESENTATION = 3049322572;
var IFCSUBCONTRACTRESOURCE = 148013059;
var IFCSUBCONTRACTRESOURCETYPE = 4095615324;
var IFCSUBEDGE = 2233826070;
var IFCSURFACE = 2513912981;
var IFCSURFACECURVE = 699246055;
var IFCSURFACECURVESWEPTAREASOLID = 2028607225;
var IFCSURFACEFEATURE = 3101698114;
var IFCSURFACEOFLINEAREXTRUSION = 2809605785;
var IFCSURFACEOFREVOLUTION = 4124788165;
var IFCSURFACEREINFORCEMENTAREA = 2934153892;
var IFCSURFACESTYLE = 1300840506;
var IFCSURFACESTYLELIGHTING = 3303107099;
var IFCSURFACESTYLEREFRACTION = 1607154358;
var IFCSURFACESTYLERENDERING = 1878645084;
var IFCSURFACESTYLESHADING = 846575682;
var IFCSURFACESTYLEWITHTEXTURES = 1351298697;
var IFCSURFACETEXTURE = 626085974;
var IFCSWEPTAREASOLID = 2247615214;
var IFCSWEPTDISKSOLID = 1260650574;
var IFCSWEPTDISKSOLIDPOLYGONAL = 1096409881;
var IFCSWEPTSURFACE = 230924584;
var IFCSWITCHINGDEVICE = 1162798199;
var IFCSWITCHINGDEVICETYPE = 2315554128;
var IFCSYSTEM = 2254336722;
var IFCSYSTEMFURNITUREELEMENT = 413509423;
var IFCSYSTEMFURNITUREELEMENTTYPE = 1580310250;
var IFCTSHAPEPROFILEDEF = 3071757647;
var IFCTABLE = 985171141;
var IFCTABLECOLUMN = 2043862942;
var IFCTABLEROW = 531007025;
var IFCTANK = 812556717;
var IFCTANKTYPE = 5716631;
var IFCTASK = 3473067441;
var IFCTASKTIME = 1549132990;
var IFCTASKTIMERECURRING = 2771591690;
var IFCTASKTYPE = 3206491090;
var IFCTELECOMADDRESS = 912023232;
var IFCTENDON = 3824725483;
var IFCTENDONANCHOR = 2347447852;
var IFCTENDONANCHORTYPE = 3081323446;
var IFCTENDONCONDUIT = 3663046924;
var IFCTENDONCONDUITTYPE = 2281632017;
var IFCTENDONTYPE = 2415094496;
var IFCTESSELLATEDFACESET = 2387106220;
var IFCTESSELLATEDITEM = 901063453;
var IFCTEXTLITERAL = 4282788508;
var IFCTEXTLITERALWITHEXTENT = 3124975700;
var IFCTEXTSTYLE = 1447204868;
var IFCTEXTSTYLEFONTMODEL = 1983826977;
var IFCTEXTSTYLEFORDEFINEDFONT = 2636378356;
var IFCTEXTSTYLETEXTMODEL = 1640371178;
var IFCTEXTURECOORDINATE = 280115917;
var IFCTEXTURECOORDINATEGENERATOR = 1742049831;
var IFCTEXTUREMAP = 2552916305;
var IFCTEXTUREVERTEX = 1210645708;
var IFCTEXTUREVERTEXLIST = 3611470254;
var IFCTIMEPERIOD = 1199560280;
var IFCTIMESERIES = 3101149627;
var IFCTIMESERIESVALUE = 581633288;
var IFCTOPOLOGICALREPRESENTATIONITEM = 1377556343;
var IFCTOPOLOGYREPRESENTATION = 1735638870;
var IFCTOROIDALSURFACE = 1935646853;
var IFCTRANSFORMER = 3825984169;
var IFCTRANSFORMERTYPE = 1692211062;
var IFCTRANSITIONCURVESEGMENT2D = 2595432518;
var IFCTRANSPORTELEMENT = 1620046519;
var IFCTRANSPORTELEMENTTYPE = 2097647324;
var IFCTRAPEZIUMPROFILEDEF = 2715220739;
var IFCTRIANGULATEDFACESET = 2916149573;
var IFCTRIANGULATEDIRREGULARNETWORK = 1229763772;
var IFCTRIMMEDCURVE = 3593883385;
var IFCTUBEBUNDLE = 3026737570;
var IFCTUBEBUNDLETYPE = 1600972822;
var IFCTYPEOBJECT = 1628702193;
var IFCTYPEPROCESS = 3736923433;
var IFCTYPEPRODUCT = 2347495698;
var IFCTYPERESOURCE = 3698973494;
var IFCUSHAPEPROFILEDEF = 427810014;
var IFCUNITASSIGNMENT = 180925521;
var IFCUNITARYCONTROLELEMENT = 630975310;
var IFCUNITARYCONTROLELEMENTTYPE = 3179687236;
var IFCUNITARYEQUIPMENT = 4292641817;
var IFCUNITARYEQUIPMENTTYPE = 1911125066;
var IFCVALVE = 4207607924;
var IFCVALVETYPE = 728799441;
var IFCVECTOR = 1417489154;
var IFCVERTEX = 2799835756;
var IFCVERTEXLOOP = 2759199220;
var IFCVERTEXPOINT = 1907098498;
var IFCVIBRATIONDAMPER = 1530820697;
var IFCVIBRATIONDAMPERTYPE = 3956297820;
var IFCVIBRATIONISOLATOR = 2391383451;
var IFCVIBRATIONISOLATORTYPE = 3313531582;
var IFCVIRTUALELEMENT = 2769231204;
var IFCVIRTUALGRIDINTERSECTION = 891718957;
var IFCVOIDINGFEATURE = 926996030;
var IFCWALL = 2391406946;
var IFCWALLELEMENTEDCASE = 4156078855;
var IFCWALLSTANDARDCASE = 3512223829;
var IFCWALLTYPE = 1898987631;
var IFCWASTETERMINAL = 4237592921;
var IFCWASTETERMINALTYPE = 1133259667;
var IFCWINDOW = 3304561284;
var IFCWINDOWLININGPROPERTIES = 336235671;
var IFCWINDOWPANELPROPERTIES = 512836454;
var IFCWINDOWSTANDARDCASE = 486154966;
var IFCWINDOWSTYLE = 1299126871;
var IFCWINDOWTYPE = 4009809668;
var IFCWORKCALENDAR = 4088093105;
var IFCWORKCONTROL = 1028945134;
var IFCWORKPLAN = 4218914973;
var IFCWORKSCHEDULE = 3342526732;
var IFCWORKTIME = 1236880293;
var IFCZSHAPEPROFILEDEF = 2543172580;
var IFCZONE = 1033361043;
var IfcElements = [
  IFCACTUATOR,
  IFCAIRTERMINAL,
  IFCAIRTERMINALBOX,
  IFCAIRTOAIRHEATRECOVERY,
  IFCALARM,
  IFCALIGNMENT,
  IFCANNOTATION,
  IFCAUDIOVISUALAPPLIANCE,
  IFCBEAM,
  IFCBEAMSTANDARDCASE,
  IFCBEARING,
  IFCBOILER,
  IFCBRIDGE,
  IFCBRIDGEPART,
  IFCBUILDING,
  IFCBUILDINGELEMENT,
  IFCBUILDINGELEMENTPART,
  IFCBUILDINGELEMENTPROXY,
  IFCBUILDINGSTOREY,
  IFCBURNER,
  IFCCABLECARRIERFITTING,
  IFCCABLECARRIERSEGMENT,
  IFCCABLEFITTING,
  IFCCABLESEGMENT,
  IFCCAISSONFOUNDATION,
  IFCCHILLER,
  IFCCHIMNEY,
  IFCCIVILELEMENT,
  IFCCOIL,
  IFCCOLUMN,
  IFCCOLUMNSTANDARDCASE,
  IFCCOMMUNICATIONSAPPLIANCE,
  IFCCOMPRESSOR,
  IFCCONDENSER,
  IFCCONTROLLER,
  IFCCOOLEDBEAM,
  IFCCOOLINGTOWER,
  IFCCOVERING,
  IFCCURTAINWALL,
  IFCDAMPER,
  IFCDEEPFOUNDATION,
  IFCDISCRETEACCESSORY,
  IFCDISTRIBUTIONCHAMBERELEMENT,
  IFCDISTRIBUTIONCONTROLELEMENT,
  IFCDISTRIBUTIONELEMENT,
  IFCDISTRIBUTIONFLOWELEMENT,
  IFCDISTRIBUTIONPORT,
  IFCDOOR,
  IFCDOORSTANDARDCASE,
  IFCDUCTFITTING,
  IFCDUCTSEGMENT,
  IFCDUCTSILENCER,
  IFCELECTRICAPPLIANCE,
  IFCELECTRICDISTRIBUTIONBOARD,
  IFCELECTRICFLOWSTORAGEDEVICE,
  IFCELECTRICGENERATOR,
  IFCELECTRICMOTOR,
  IFCELECTRICTIMECONTROL,
  IFCELEMENT,
  IFCELEMENTASSEMBLY,
  IFCELEMENTCOMPONENT,
  IFCENERGYCONVERSIONDEVICE,
  IFCENGINE,
  IFCEVAPORATIVECOOLER,
  IFCEVAPORATOR,
  IFCEXTERNALSPATIALELEMENT,
  IFCEXTERNALSPATIALSTRUCTUREELEMENT,
  IFCFACILITY,
  IFCFACILITYPART,
  IFCFAN,
  IFCFASTENER,
  IFCFEATUREELEMENT,
  IFCFEATUREELEMENTADDITION,
  IFCFEATUREELEMENTSUBTRACTION,
  IFCFILTER,
  IFCFIRESUPPRESSIONTERMINAL,
  IFCFLOWCONTROLLER,
  IFCFLOWFITTING,
  IFCFLOWINSTRUMENT,
  IFCFLOWMETER,
  IFCFLOWMOVINGDEVICE,
  IFCFLOWSEGMENT,
  IFCFLOWSTORAGEDEVICE,
  IFCFLOWTERMINAL,
  IFCFLOWTREATMENTDEVICE,
  IFCFOOTING,
  IFCFURNISHINGELEMENT,
  IFCFURNITURE,
  IFCGEOGRAPHICELEMENT,
  IFCGRID,
  IFCHEATEXCHANGER,
  IFCHUMIDIFIER,
  IFCINTERCEPTOR,
  IFCJUNCTIONBOX,
  IFCLAMP,
  IFCLIGHTFIXTURE,
  IFCLINEARPOSITIONINGELEMENT,
  IFCMECHANICALFASTENER,
  IFCMEDICALDEVICE,
  IFCMEMBER,
  IFCMEMBERSTANDARDCASE,
  IFCMOTORCONNECTION,
  IFCOPENINGELEMENT,
  IFCOPENINGSTANDARDCASE,
  IFCOUTLET,
  IFCPILE,
  IFCPIPEFITTING,
  IFCPIPESEGMENT,
  IFCPLATE,
  IFCPLATESTANDARDCASE,
  IFCPORT,
  IFCPOSITIONINGELEMENT,
  IFCPROJECTIONELEMENT,
  IFCPROTECTIVEDEVICE,
  IFCPROTECTIVEDEVICETRIPPINGUNIT,
  IFCPROXY,
  IFCPUMP,
  IFCRAILING,
  IFCRAMP,
  IFCRAMPFLIGHT,
  IFCREFERENT,
  IFCREINFORCINGBAR,
  IFCREINFORCINGELEMENT,
  IFCREINFORCINGMESH,
  IFCROOF,
  IFCSANITARYTERMINAL,
  IFCSENSOR,
  IFCSHADINGDEVICE,
  IFCSITE,
  IFCSLAB,
  IFCSLABELEMENTEDCASE,
  IFCSLABSTANDARDCASE,
  IFCSOLARDEVICE,
  IFCSPACE,
  IFCSPACEHEATER,
  IFCSPATIALELEMENT,
  IFCSPATIALSTRUCTUREELEMENT,
  IFCSPATIALZONE,
  IFCSTACKTERMINAL,
  IFCSTAIR,
  IFCSTAIRFLIGHT,
  IFCSTRUCTURALACTION,
  IFCSTRUCTURALACTIVITY,
  IFCSTRUCTURALCONNECTION,
  IFCSTRUCTURALCURVEACTION,
  IFCSTRUCTURALCURVECONNECTION,
  IFCSTRUCTURALCURVEMEMBER,
  IFCSTRUCTURALCURVEMEMBERVARYING,
  IFCSTRUCTURALCURVEREACTION,
  IFCSTRUCTURALITEM,
  IFCSTRUCTURALLINEARACTION,
  IFCSTRUCTURALMEMBER,
  IFCSTRUCTURALPLANARACTION,
  IFCSTRUCTURALPOINTACTION,
  IFCSTRUCTURALPOINTCONNECTION,
  IFCSTRUCTURALPOINTREACTION,
  IFCSTRUCTURALREACTION,
  IFCSTRUCTURALSURFACEACTION,
  IFCSTRUCTURALSURFACECONNECTION,
  IFCSTRUCTURALSURFACEMEMBER,
  IFCSTRUCTURALSURFACEMEMBERVARYING,
  IFCSTRUCTURALSURFACEREACTION,
  IFCSURFACEFEATURE,
  IFCSWITCHINGDEVICE,
  IFCSYSTEMFURNITUREELEMENT,
  IFCTANK,
  IFCTENDON,
  IFCTENDONANCHOR,
  IFCTENDONCONDUIT,
  IFCTRANSFORMER,
  IFCTRANSPORTELEMENT,
  IFCTUBEBUNDLE,
  IFCUNITARYCONTROLELEMENT,
  IFCUNITARYEQUIPMENT,
  IFCVALVE,
  IFCVIBRATIONDAMPER,
  IFCVIBRATIONISOLATOR,
  IFCVIRTUALELEMENT,
  IFCVOIDINGFEATURE,
  IFCWALL,
  IFCWALLELEMENTEDCASE,
  IFCWALLSTANDARDCASE,
  IFCWASTETERMINAL,
  IFCWINDOW,
  IFCWINDOWSTANDARDCASE
];
var FromRawLineData = {};
FromRawLineData[IFCACTIONREQUEST] = (d) => {
  return IfcActionRequest.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCACTOR] = (d) => {
  return IfcActor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCACTORROLE] = (d) => {
  return IfcActorRole.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCACTUATOR] = (d) => {
  return IfcActuator.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCACTUATORTYPE] = (d) => {
  return IfcActuatorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCADDRESS] = (d) => {
  return IfcAddress.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCADVANCEDBREP] = (d) => {
  return IfcAdvancedBrep.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCADVANCEDBREPWITHVOIDS] = (d) => {
  return IfcAdvancedBrepWithVoids.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCADVANCEDFACE] = (d) => {
  return IfcAdvancedFace.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAIRTERMINAL] = (d) => {
  return IfcAirTerminal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAIRTERMINALBOX] = (d) => {
  return IfcAirTerminalBox.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAIRTERMINALBOXTYPE] = (d) => {
  return IfcAirTerminalBoxType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAIRTERMINALTYPE] = (d) => {
  return IfcAirTerminalType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAIRTOAIRHEATRECOVERY] = (d) => {
  return IfcAirToAirHeatRecovery.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAIRTOAIRHEATRECOVERYTYPE] = (d) => {
  return IfcAirToAirHeatRecoveryType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALARM] = (d) => {
  return IfcAlarm.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALARMTYPE] = (d) => {
  return IfcAlarmType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT] = (d) => {
  return IfcAlignment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT2DHORIZONTAL] = (d) => {
  return IfcAlignment2DHorizontal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT2DHORIZONTALSEGMENT] = (d) => {
  return IfcAlignment2DHorizontalSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT2DSEGMENT] = (d) => {
  return IfcAlignment2DSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT2DVERSEGCIRCULARARC] = (d) => {
  return IfcAlignment2DVerSegCircularArc.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT2DVERSEGLINE] = (d) => {
  return IfcAlignment2DVerSegLine.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT2DVERSEGPARABOLICARC] = (d) => {
  return IfcAlignment2DVerSegParabolicArc.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT2DVERTICAL] = (d) => {
  return IfcAlignment2DVertical.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT2DVERTICALSEGMENT] = (d) => {
  return IfcAlignment2DVerticalSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENTCURVE] = (d) => {
  return IfcAlignmentCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCANNOTATION] = (d) => {
  return IfcAnnotation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCANNOTATIONFILLAREA] = (d) => {
  return IfcAnnotationFillArea.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAPPLICATION] = (d) => {
  return IfcApplication.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAPPLIEDVALUE] = (d) => {
  return IfcAppliedValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAPPROVAL] = (d) => {
  return IfcApproval.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAPPROVALRELATIONSHIP] = (d) => {
  return IfcApprovalRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCARBITRARYCLOSEDPROFILEDEF] = (d) => {
  return IfcArbitraryClosedProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCARBITRARYOPENPROFILEDEF] = (d) => {
  return IfcArbitraryOpenProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCARBITRARYPROFILEDEFWITHVOIDS] = (d) => {
  return IfcArbitraryProfileDefWithVoids.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCASSET] = (d) => {
  return IfcAsset.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCASYMMETRICISHAPEPROFILEDEF] = (d) => {
  return IfcAsymmetricIShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAUDIOVISUALAPPLIANCE] = (d) => {
  return IfcAudioVisualAppliance.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAUDIOVISUALAPPLIANCETYPE] = (d) => {
  return IfcAudioVisualApplianceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAXIS1PLACEMENT] = (d) => {
  return IfcAxis1Placement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAXIS2PLACEMENT2D] = (d) => {
  return IfcAxis2Placement2D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAXIS2PLACEMENT3D] = (d) => {
  return IfcAxis2Placement3D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBSPLINECURVE] = (d) => {
  return IfcBSplineCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBSPLINECURVEWITHKNOTS] = (d) => {
  return IfcBSplineCurveWithKnots.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBSPLINESURFACE] = (d) => {
  return IfcBSplineSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBSPLINESURFACEWITHKNOTS] = (d) => {
  return IfcBSplineSurfaceWithKnots.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBEAM] = (d) => {
  return IfcBeam.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBEAMSTANDARDCASE] = (d) => {
  return IfcBeamStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBEAMTYPE] = (d) => {
  return IfcBeamType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBEARING] = (d) => {
  return IfcBearing.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBEARINGTYPE] = (d) => {
  return IfcBearingType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBLOBTEXTURE] = (d) => {
  return IfcBlobTexture.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBLOCK] = (d) => {
  return IfcBlock.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOILER] = (d) => {
  return IfcBoiler.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOILERTYPE] = (d) => {
  return IfcBoilerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOOLEANCLIPPINGRESULT] = (d) => {
  return IfcBooleanClippingResult.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOOLEANRESULT] = (d) => {
  return IfcBooleanResult.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDARYCONDITION] = (d) => {
  return IfcBoundaryCondition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDARYCURVE] = (d) => {
  return IfcBoundaryCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDARYEDGECONDITION] = (d) => {
  return IfcBoundaryEdgeCondition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDARYFACECONDITION] = (d) => {
  return IfcBoundaryFaceCondition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDARYNODECONDITION] = (d) => {
  return IfcBoundaryNodeCondition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDARYNODECONDITIONWARPING] = (d) => {
  return IfcBoundaryNodeConditionWarping.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDEDCURVE] = (d) => {
  return IfcBoundedCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDEDSURFACE] = (d) => {
  return IfcBoundedSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDINGBOX] = (d) => {
  return IfcBoundingBox.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOXEDHALFSPACE] = (d) => {
  return IfcBoxedHalfSpace.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBRIDGE] = (d) => {
  return IfcBridge.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBRIDGEPART] = (d) => {
  return IfcBridgePart.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDING] = (d) => {
  return IfcBuilding.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDINGELEMENT] = (d) => {
  return IfcBuildingElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDINGELEMENTPART] = (d) => {
  return IfcBuildingElementPart.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDINGELEMENTPARTTYPE] = (d) => {
  return IfcBuildingElementPartType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDINGELEMENTPROXY] = (d) => {
  return IfcBuildingElementProxy.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDINGELEMENTPROXYTYPE] = (d) => {
  return IfcBuildingElementProxyType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDINGELEMENTTYPE] = (d) => {
  return IfcBuildingElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDINGSTOREY] = (d) => {
  return IfcBuildingStorey.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDINGSYSTEM] = (d) => {
  return IfcBuildingSystem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBURNER] = (d) => {
  return IfcBurner.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBURNERTYPE] = (d) => {
  return IfcBurnerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCSHAPEPROFILEDEF] = (d) => {
  return IfcCShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCABLECARRIERFITTING] = (d) => {
  return IfcCableCarrierFitting.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCABLECARRIERFITTINGTYPE] = (d) => {
  return IfcCableCarrierFittingType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCABLECARRIERSEGMENT] = (d) => {
  return IfcCableCarrierSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCABLECARRIERSEGMENTTYPE] = (d) => {
  return IfcCableCarrierSegmentType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCABLEFITTING] = (d) => {
  return IfcCableFitting.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCABLEFITTINGTYPE] = (d) => {
  return IfcCableFittingType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCABLESEGMENT] = (d) => {
  return IfcCableSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCABLESEGMENTTYPE] = (d) => {
  return IfcCableSegmentType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCAISSONFOUNDATION] = (d) => {
  return IfcCaissonFoundation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCAISSONFOUNDATIONTYPE] = (d) => {
  return IfcCaissonFoundationType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANPOINT] = (d) => {
  return IfcCartesianPoint.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANPOINTLIST] = (d) => {
  return IfcCartesianPointList.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANPOINTLIST2D] = (d) => {
  return IfcCartesianPointList2D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANPOINTLIST3D] = (d) => {
  return IfcCartesianPointList3D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR] = (d) => {
  return IfcCartesianTransformationOperator.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR2D] = (d) => {
  return IfcCartesianTransformationOperator2D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM] = (d) => {
  return IfcCartesianTransformationOperator2DnonUniform.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR3D] = (d) => {
  return IfcCartesianTransformationOperator3D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM] = (d) => {
  return IfcCartesianTransformationOperator3DnonUniform.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCENTERLINEPROFILEDEF] = (d) => {
  return IfcCenterLineProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCHILLER] = (d) => {
  return IfcChiller.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCHILLERTYPE] = (d) => {
  return IfcChillerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCHIMNEY] = (d) => {
  return IfcChimney.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCHIMNEYTYPE] = (d) => {
  return IfcChimneyType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCIRCLE] = (d) => {
  return IfcCircle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCIRCLEHOLLOWPROFILEDEF] = (d) => {
  return IfcCircleHollowProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCIRCLEPROFILEDEF] = (d) => {
  return IfcCircleProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCIRCULARARCSEGMENT2D] = (d) => {
  return IfcCircularArcSegment2D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCIVILELEMENT] = (d) => {
  return IfcCivilElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCIVILELEMENTTYPE] = (d) => {
  return IfcCivilElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCLASSIFICATION] = (d) => {
  return IfcClassification.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCLASSIFICATIONREFERENCE] = (d) => {
  return IfcClassificationReference.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCLOSEDSHELL] = (d) => {
  return IfcClosedShell.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOIL] = (d) => {
  return IfcCoil.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOILTYPE] = (d) => {
  return IfcCoilType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOLOURRGB] = (d) => {
  return IfcColourRgb.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOLOURRGBLIST] = (d) => {
  return IfcColourRgbList.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOLOURSPECIFICATION] = (d) => {
  return IfcColourSpecification.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOLUMN] = (d) => {
  return IfcColumn.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOLUMNSTANDARDCASE] = (d) => {
  return IfcColumnStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOLUMNTYPE] = (d) => {
  return IfcColumnType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMMUNICATIONSAPPLIANCE] = (d) => {
  return IfcCommunicationsAppliance.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMMUNICATIONSAPPLIANCETYPE] = (d) => {
  return IfcCommunicationsApplianceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMPLEXPROPERTY] = (d) => {
  return IfcComplexProperty.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMPLEXPROPERTYTEMPLATE] = (d) => {
  return IfcComplexPropertyTemplate.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMPOSITECURVE] = (d) => {
  return IfcCompositeCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMPOSITECURVEONSURFACE] = (d) => {
  return IfcCompositeCurveOnSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMPOSITECURVESEGMENT] = (d) => {
  return IfcCompositeCurveSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMPOSITEPROFILEDEF] = (d) => {
  return IfcCompositeProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMPRESSOR] = (d) => {
  return IfcCompressor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMPRESSORTYPE] = (d) => {
  return IfcCompressorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONDENSER] = (d) => {
  return IfcCondenser.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONDENSERTYPE] = (d) => {
  return IfcCondenserType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONIC] = (d) => {
  return IfcConic.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONNECTEDFACESET] = (d) => {
  return IfcConnectedFaceSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONNECTIONCURVEGEOMETRY] = (d) => {
  return IfcConnectionCurveGeometry.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONNECTIONGEOMETRY] = (d) => {
  return IfcConnectionGeometry.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONNECTIONPOINTECCENTRICITY] = (d) => {
  return IfcConnectionPointEccentricity.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONNECTIONPOINTGEOMETRY] = (d) => {
  return IfcConnectionPointGeometry.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONNECTIONSURFACEGEOMETRY] = (d) => {
  return IfcConnectionSurfaceGeometry.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONNECTIONVOLUMEGEOMETRY] = (d) => {
  return IfcConnectionVolumeGeometry.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRAINT] = (d) => {
  return IfcConstraint.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRUCTIONEQUIPMENTRESOURCE] = (d) => {
  return IfcConstructionEquipmentResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE] = (d) => {
  return IfcConstructionEquipmentResourceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRUCTIONMATERIALRESOURCE] = (d) => {
  return IfcConstructionMaterialResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRUCTIONMATERIALRESOURCETYPE] = (d) => {
  return IfcConstructionMaterialResourceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRUCTIONPRODUCTRESOURCE] = (d) => {
  return IfcConstructionProductResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRUCTIONPRODUCTRESOURCETYPE] = (d) => {
  return IfcConstructionProductResourceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRUCTIONRESOURCE] = (d) => {
  return IfcConstructionResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRUCTIONRESOURCETYPE] = (d) => {
  return IfcConstructionResourceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONTEXT] = (d) => {
  return IfcContext.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONTEXTDEPENDENTUNIT] = (d) => {
  return IfcContextDependentUnit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONTROL] = (d) => {
  return IfcControl.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONTROLLER] = (d) => {
  return IfcController.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONTROLLERTYPE] = (d) => {
  return IfcControllerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONVERSIONBASEDUNIT] = (d) => {
  return IfcConversionBasedUnit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONVERSIONBASEDUNITWITHOFFSET] = (d) => {
  return IfcConversionBasedUnitWithOffset.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOOLEDBEAM] = (d) => {
  return IfcCooledBeam.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOOLEDBEAMTYPE] = (d) => {
  return IfcCooledBeamType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOOLINGTOWER] = (d) => {
  return IfcCoolingTower.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOOLINGTOWERTYPE] = (d) => {
  return IfcCoolingTowerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOORDINATEOPERATION] = (d) => {
  return IfcCoordinateOperation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOORDINATEREFERENCESYSTEM] = (d) => {
  return IfcCoordinateReferenceSystem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOSTITEM] = (d) => {
  return IfcCostItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOSTSCHEDULE] = (d) => {
  return IfcCostSchedule.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOSTVALUE] = (d) => {
  return IfcCostValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOVERING] = (d) => {
  return IfcCovering.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOVERINGTYPE] = (d) => {
  return IfcCoveringType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCREWRESOURCE] = (d) => {
  return IfcCrewResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCREWRESOURCETYPE] = (d) => {
  return IfcCrewResourceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCSGPRIMITIVE3D] = (d) => {
  return IfcCsgPrimitive3D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCSGSOLID] = (d) => {
  return IfcCsgSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURRENCYRELATIONSHIP] = (d) => {
  return IfcCurrencyRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURTAINWALL] = (d) => {
  return IfcCurtainWall.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURTAINWALLTYPE] = (d) => {
  return IfcCurtainWallType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURVE] = (d) => {
  return IfcCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURVEBOUNDEDPLANE] = (d) => {
  return IfcCurveBoundedPlane.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURVEBOUNDEDSURFACE] = (d) => {
  return IfcCurveBoundedSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURVESEGMENT2D] = (d) => {
  return IfcCurveSegment2D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURVESTYLE] = (d) => {
  return IfcCurveStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURVESTYLEFONT] = (d) => {
  return IfcCurveStyleFont.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURVESTYLEFONTANDSCALING] = (d) => {
  return IfcCurveStyleFontAndScaling.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURVESTYLEFONTPATTERN] = (d) => {
  return IfcCurveStyleFontPattern.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCYLINDRICALSURFACE] = (d) => {
  return IfcCylindricalSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDAMPER] = (d) => {
  return IfcDamper.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDAMPERTYPE] = (d) => {
  return IfcDamperType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDEEPFOUNDATION] = (d) => {
  return IfcDeepFoundation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDEEPFOUNDATIONTYPE] = (d) => {
  return IfcDeepFoundationType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDERIVEDPROFILEDEF] = (d) => {
  return IfcDerivedProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDERIVEDUNIT] = (d) => {
  return IfcDerivedUnit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDERIVEDUNITELEMENT] = (d) => {
  return IfcDerivedUnitElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDIMENSIONALEXPONENTS] = (d) => {
  return IfcDimensionalExponents.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDIRECTION] = (d) => {
  return IfcDirection.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISCRETEACCESSORY] = (d) => {
  return IfcDiscreteAccessory.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISCRETEACCESSORYTYPE] = (d) => {
  return IfcDiscreteAccessoryType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTANCEEXPRESSION] = (d) => {
  return IfcDistanceExpression.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONCHAMBERELEMENT] = (d) => {
  return IfcDistributionChamberElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONCHAMBERELEMENTTYPE] = (d) => {
  return IfcDistributionChamberElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONCIRCUIT] = (d) => {
  return IfcDistributionCircuit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONCONTROLELEMENT] = (d) => {
  return IfcDistributionControlElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONCONTROLELEMENTTYPE] = (d) => {
  return IfcDistributionControlElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONELEMENT] = (d) => {
  return IfcDistributionElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONELEMENTTYPE] = (d) => {
  return IfcDistributionElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONFLOWELEMENT] = (d) => {
  return IfcDistributionFlowElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONFLOWELEMENTTYPE] = (d) => {
  return IfcDistributionFlowElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONPORT] = (d) => {
  return IfcDistributionPort.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONSYSTEM] = (d) => {
  return IfcDistributionSystem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOCUMENTINFORMATION] = (d) => {
  return IfcDocumentInformation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOCUMENTINFORMATIONRELATIONSHIP] = (d) => {
  return IfcDocumentInformationRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOCUMENTREFERENCE] = (d) => {
  return IfcDocumentReference.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOOR] = (d) => {
  return IfcDoor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOORLININGPROPERTIES] = (d) => {
  return IfcDoorLiningProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOORPANELPROPERTIES] = (d) => {
  return IfcDoorPanelProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOORSTANDARDCASE] = (d) => {
  return IfcDoorStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOORSTYLE] = (d) => {
  return IfcDoorStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOORTYPE] = (d) => {
  return IfcDoorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDRAUGHTINGPREDEFINEDCOLOUR] = (d) => {
  return IfcDraughtingPreDefinedColour.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDRAUGHTINGPREDEFINEDCURVEFONT] = (d) => {
  return IfcDraughtingPreDefinedCurveFont.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDUCTFITTING] = (d) => {
  return IfcDuctFitting.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDUCTFITTINGTYPE] = (d) => {
  return IfcDuctFittingType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDUCTSEGMENT] = (d) => {
  return IfcDuctSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDUCTSEGMENTTYPE] = (d) => {
  return IfcDuctSegmentType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDUCTSILENCER] = (d) => {
  return IfcDuctSilencer.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDUCTSILENCERTYPE] = (d) => {
  return IfcDuctSilencerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEDGE] = (d) => {
  return IfcEdge.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEDGECURVE] = (d) => {
  return IfcEdgeCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEDGELOOP] = (d) => {
  return IfcEdgeLoop.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICAPPLIANCE] = (d) => {
  return IfcElectricAppliance.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICAPPLIANCETYPE] = (d) => {
  return IfcElectricApplianceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICDISTRIBUTIONBOARD] = (d) => {
  return IfcElectricDistributionBoard.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICDISTRIBUTIONBOARDTYPE] = (d) => {
  return IfcElectricDistributionBoardType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICFLOWSTORAGEDEVICE] = (d) => {
  return IfcElectricFlowStorageDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICFLOWSTORAGEDEVICETYPE] = (d) => {
  return IfcElectricFlowStorageDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICGENERATOR] = (d) => {
  return IfcElectricGenerator.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICGENERATORTYPE] = (d) => {
  return IfcElectricGeneratorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICMOTOR] = (d) => {
  return IfcElectricMotor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICMOTORTYPE] = (d) => {
  return IfcElectricMotorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICTIMECONTROL] = (d) => {
  return IfcElectricTimeControl.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICTIMECONTROLTYPE] = (d) => {
  return IfcElectricTimeControlType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELEMENT] = (d) => {
  return IfcElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELEMENTASSEMBLY] = (d) => {
  return IfcElementAssembly.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELEMENTASSEMBLYTYPE] = (d) => {
  return IfcElementAssemblyType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELEMENTCOMPONENT] = (d) => {
  return IfcElementComponent.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELEMENTCOMPONENTTYPE] = (d) => {
  return IfcElementComponentType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELEMENTQUANTITY] = (d) => {
  return IfcElementQuantity.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELEMENTTYPE] = (d) => {
  return IfcElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELEMENTARYSURFACE] = (d) => {
  return IfcElementarySurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELLIPSE] = (d) => {
  return IfcEllipse.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELLIPSEPROFILEDEF] = (d) => {
  return IfcEllipseProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCENERGYCONVERSIONDEVICE] = (d) => {
  return IfcEnergyConversionDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCENERGYCONVERSIONDEVICETYPE] = (d) => {
  return IfcEnergyConversionDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCENGINE] = (d) => {
  return IfcEngine.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCENGINETYPE] = (d) => {
  return IfcEngineType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEVAPORATIVECOOLER] = (d) => {
  return IfcEvaporativeCooler.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEVAPORATIVECOOLERTYPE] = (d) => {
  return IfcEvaporativeCoolerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEVAPORATOR] = (d) => {
  return IfcEvaporator.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEVAPORATORTYPE] = (d) => {
  return IfcEvaporatorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEVENT] = (d) => {
  return IfcEvent.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEVENTTIME] = (d) => {
  return IfcEventTime.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEVENTTYPE] = (d) => {
  return IfcEventType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTENDEDPROPERTIES] = (d) => {
  return IfcExtendedProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTERNALINFORMATION] = (d) => {
  return IfcExternalInformation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTERNALREFERENCE] = (d) => {
  return IfcExternalReference.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTERNALREFERENCERELATIONSHIP] = (d) => {
  return IfcExternalReferenceRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTERNALSPATIALELEMENT] = (d) => {
  return IfcExternalSpatialElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTERNALSPATIALSTRUCTUREELEMENT] = (d) => {
  return IfcExternalSpatialStructureElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTERNALLYDEFINEDHATCHSTYLE] = (d) => {
  return IfcExternallyDefinedHatchStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTERNALLYDEFINEDSURFACESTYLE] = (d) => {
  return IfcExternallyDefinedSurfaceStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTERNALLYDEFINEDTEXTFONT] = (d) => {
  return IfcExternallyDefinedTextFont.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTRUDEDAREASOLID] = (d) => {
  return IfcExtrudedAreaSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTRUDEDAREASOLIDTAPERED] = (d) => {
  return IfcExtrudedAreaSolidTapered.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACE] = (d) => {
  return IfcFace.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACEBASEDSURFACEMODEL] = (d) => {
  return IfcFaceBasedSurfaceModel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACEBOUND] = (d) => {
  return IfcFaceBound.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACEOUTERBOUND] = (d) => {
  return IfcFaceOuterBound.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACESURFACE] = (d) => {
  return IfcFaceSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACETEDBREP] = (d) => {
  return IfcFacetedBrep.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACETEDBREPWITHVOIDS] = (d) => {
  return IfcFacetedBrepWithVoids.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACILITY] = (d) => {
  return IfcFacility.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACILITYPART] = (d) => {
  return IfcFacilityPart.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFAILURECONNECTIONCONDITION] = (d) => {
  return IfcFailureConnectionCondition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFAN] = (d) => {
  return IfcFan.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFANTYPE] = (d) => {
  return IfcFanType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFASTENER] = (d) => {
  return IfcFastener.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFASTENERTYPE] = (d) => {
  return IfcFastenerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFEATUREELEMENT] = (d) => {
  return IfcFeatureElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFEATUREELEMENTADDITION] = (d) => {
  return IfcFeatureElementAddition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFEATUREELEMENTSUBTRACTION] = (d) => {
  return IfcFeatureElementSubtraction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFILLAREASTYLE] = (d) => {
  return IfcFillAreaStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFILLAREASTYLEHATCHING] = (d) => {
  return IfcFillAreaStyleHatching.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFILLAREASTYLETILES] = (d) => {
  return IfcFillAreaStyleTiles.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFILTER] = (d) => {
  return IfcFilter.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFILTERTYPE] = (d) => {
  return IfcFilterType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFIRESUPPRESSIONTERMINAL] = (d) => {
  return IfcFireSuppressionTerminal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFIRESUPPRESSIONTERMINALTYPE] = (d) => {
  return IfcFireSuppressionTerminalType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFIXEDREFERENCESWEPTAREASOLID] = (d) => {
  return IfcFixedReferenceSweptAreaSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWCONTROLLER] = (d) => {
  return IfcFlowController.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWCONTROLLERTYPE] = (d) => {
  return IfcFlowControllerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWFITTING] = (d) => {
  return IfcFlowFitting.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWFITTINGTYPE] = (d) => {
  return IfcFlowFittingType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWINSTRUMENT] = (d) => {
  return IfcFlowInstrument.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWINSTRUMENTTYPE] = (d) => {
  return IfcFlowInstrumentType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWMETER] = (d) => {
  return IfcFlowMeter.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWMETERTYPE] = (d) => {
  return IfcFlowMeterType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWMOVINGDEVICE] = (d) => {
  return IfcFlowMovingDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWMOVINGDEVICETYPE] = (d) => {
  return IfcFlowMovingDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWSEGMENT] = (d) => {
  return IfcFlowSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWSEGMENTTYPE] = (d) => {
  return IfcFlowSegmentType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWSTORAGEDEVICE] = (d) => {
  return IfcFlowStorageDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWSTORAGEDEVICETYPE] = (d) => {
  return IfcFlowStorageDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWTERMINAL] = (d) => {
  return IfcFlowTerminal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWTERMINALTYPE] = (d) => {
  return IfcFlowTerminalType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWTREATMENTDEVICE] = (d) => {
  return IfcFlowTreatmentDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWTREATMENTDEVICETYPE] = (d) => {
  return IfcFlowTreatmentDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFOOTING] = (d) => {
  return IfcFooting.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFOOTINGTYPE] = (d) => {
  return IfcFootingType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFURNISHINGELEMENT] = (d) => {
  return IfcFurnishingElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFURNISHINGELEMENTTYPE] = (d) => {
  return IfcFurnishingElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFURNITURE] = (d) => {
  return IfcFurniture.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFURNITURETYPE] = (d) => {
  return IfcFurnitureType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGEOGRAPHICELEMENT] = (d) => {
  return IfcGeographicElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGEOGRAPHICELEMENTTYPE] = (d) => {
  return IfcGeographicElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGEOMETRICCURVESET] = (d) => {
  return IfcGeometricCurveSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGEOMETRICREPRESENTATIONCONTEXT] = (d) => {
  return IfcGeometricRepresentationContext.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGEOMETRICREPRESENTATIONITEM] = (d) => {
  return IfcGeometricRepresentationItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGEOMETRICREPRESENTATIONSUBCONTEXT] = (d) => {
  return IfcGeometricRepresentationSubContext.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGEOMETRICSET] = (d) => {
  return IfcGeometricSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGRID] = (d) => {
  return IfcGrid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGRIDAXIS] = (d) => {
  return IfcGridAxis.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGRIDPLACEMENT] = (d) => {
  return IfcGridPlacement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGROUP] = (d) => {
  return IfcGroup.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCHALFSPACESOLID] = (d) => {
  return IfcHalfSpaceSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCHEATEXCHANGER] = (d) => {
  return IfcHeatExchanger.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCHEATEXCHANGERTYPE] = (d) => {
  return IfcHeatExchangerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCHUMIDIFIER] = (d) => {
  return IfcHumidifier.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCHUMIDIFIERTYPE] = (d) => {
  return IfcHumidifierType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCISHAPEPROFILEDEF] = (d) => {
  return IfcIShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCIMAGETEXTURE] = (d) => {
  return IfcImageTexture.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINDEXEDCOLOURMAP] = (d) => {
  return IfcIndexedColourMap.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINDEXEDPOLYCURVE] = (d) => {
  return IfcIndexedPolyCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINDEXEDPOLYGONALFACE] = (d) => {
  return IfcIndexedPolygonalFace.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINDEXEDPOLYGONALFACEWITHVOIDS] = (d) => {
  return IfcIndexedPolygonalFaceWithVoids.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINDEXEDTEXTUREMAP] = (d) => {
  return IfcIndexedTextureMap.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINDEXEDTRIANGLETEXTUREMAP] = (d) => {
  return IfcIndexedTriangleTextureMap.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINTERCEPTOR] = (d) => {
  return IfcInterceptor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINTERCEPTORTYPE] = (d) => {
  return IfcInterceptorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINTERSECTIONCURVE] = (d) => {
  return IfcIntersectionCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINVENTORY] = (d) => {
  return IfcInventory.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCIRREGULARTIMESERIES] = (d) => {
  return IfcIrregularTimeSeries.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCIRREGULARTIMESERIESVALUE] = (d) => {
  return IfcIrregularTimeSeriesValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCJUNCTIONBOX] = (d) => {
  return IfcJunctionBox.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCJUNCTIONBOXTYPE] = (d) => {
  return IfcJunctionBoxType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLSHAPEPROFILEDEF] = (d) => {
  return IfcLShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLABORRESOURCE] = (d) => {
  return IfcLaborResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLABORRESOURCETYPE] = (d) => {
  return IfcLaborResourceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLAGTIME] = (d) => {
  return IfcLagTime.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLAMP] = (d) => {
  return IfcLamp.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLAMPTYPE] = (d) => {
  return IfcLampType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIBRARYINFORMATION] = (d) => {
  return IfcLibraryInformation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIBRARYREFERENCE] = (d) => {
  return IfcLibraryReference.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTDISTRIBUTIONDATA] = (d) => {
  return IfcLightDistributionData.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTFIXTURE] = (d) => {
  return IfcLightFixture.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTFIXTURETYPE] = (d) => {
  return IfcLightFixtureType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTINTENSITYDISTRIBUTION] = (d) => {
  return IfcLightIntensityDistribution.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTSOURCE] = (d) => {
  return IfcLightSource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTSOURCEAMBIENT] = (d) => {
  return IfcLightSourceAmbient.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTSOURCEDIRECTIONAL] = (d) => {
  return IfcLightSourceDirectional.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTSOURCEGONIOMETRIC] = (d) => {
  return IfcLightSourceGoniometric.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTSOURCEPOSITIONAL] = (d) => {
  return IfcLightSourcePositional.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTSOURCESPOT] = (d) => {
  return IfcLightSourceSpot.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLINE] = (d) => {
  return IfcLine.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLINESEGMENT2D] = (d) => {
  return IfcLineSegment2D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLINEARPLACEMENT] = (d) => {
  return IfcLinearPlacement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLINEARPOSITIONINGELEMENT] = (d) => {
  return IfcLinearPositioningElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLOCALPLACEMENT] = (d) => {
  return IfcLocalPlacement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLOOP] = (d) => {
  return IfcLoop.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMANIFOLDSOLIDBREP] = (d) => {
  return IfcManifoldSolidBrep.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMAPCONVERSION] = (d) => {
  return IfcMapConversion.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMAPPEDITEM] = (d) => {
  return IfcMappedItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIAL] = (d) => {
  return IfcMaterial.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALCLASSIFICATIONRELATIONSHIP] = (d) => {
  return IfcMaterialClassificationRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALCONSTITUENT] = (d) => {
  return IfcMaterialConstituent.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALCONSTITUENTSET] = (d) => {
  return IfcMaterialConstituentSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALDEFINITION] = (d) => {
  return IfcMaterialDefinition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALDEFINITIONREPRESENTATION] = (d) => {
  return IfcMaterialDefinitionRepresentation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALLAYER] = (d) => {
  return IfcMaterialLayer.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALLAYERSET] = (d) => {
  return IfcMaterialLayerSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALLAYERSETUSAGE] = (d) => {
  return IfcMaterialLayerSetUsage.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALLAYERWITHOFFSETS] = (d) => {
  return IfcMaterialLayerWithOffsets.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALLIST] = (d) => {
  return IfcMaterialList.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALPROFILE] = (d) => {
  return IfcMaterialProfile.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALPROFILESET] = (d) => {
  return IfcMaterialProfileSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALPROFILESETUSAGE] = (d) => {
  return IfcMaterialProfileSetUsage.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALPROFILESETUSAGETAPERING] = (d) => {
  return IfcMaterialProfileSetUsageTapering.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALPROFILEWITHOFFSETS] = (d) => {
  return IfcMaterialProfileWithOffsets.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALPROPERTIES] = (d) => {
  return IfcMaterialProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALRELATIONSHIP] = (d) => {
  return IfcMaterialRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALUSAGEDEFINITION] = (d) => {
  return IfcMaterialUsageDefinition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMEASUREWITHUNIT] = (d) => {
  return IfcMeasureWithUnit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMECHANICALFASTENER] = (d) => {
  return IfcMechanicalFastener.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMECHANICALFASTENERTYPE] = (d) => {
  return IfcMechanicalFastenerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMEDICALDEVICE] = (d) => {
  return IfcMedicalDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMEDICALDEVICETYPE] = (d) => {
  return IfcMedicalDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMEMBER] = (d) => {
  return IfcMember.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMEMBERSTANDARDCASE] = (d) => {
  return IfcMemberStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMEMBERTYPE] = (d) => {
  return IfcMemberType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMETRIC] = (d) => {
  return IfcMetric.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMIRROREDPROFILEDEF] = (d) => {
  return IfcMirroredProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMONETARYUNIT] = (d) => {
  return IfcMonetaryUnit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMOTORCONNECTION] = (d) => {
  return IfcMotorConnection.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMOTORCONNECTIONTYPE] = (d) => {
  return IfcMotorConnectionType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCNAMEDUNIT] = (d) => {
  return IfcNamedUnit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOBJECT] = (d) => {
  return IfcObject.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOBJECTDEFINITION] = (d) => {
  return IfcObjectDefinition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOBJECTPLACEMENT] = (d) => {
  return IfcObjectPlacement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOBJECTIVE] = (d) => {
  return IfcObjective.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOCCUPANT] = (d) => {
  return IfcOccupant.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOFFSETCURVE] = (d) => {
  return IfcOffsetCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOFFSETCURVE2D] = (d) => {
  return IfcOffsetCurve2D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOFFSETCURVE3D] = (d) => {
  return IfcOffsetCurve3D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOFFSETCURVEBYDISTANCES] = (d) => {
  return IfcOffsetCurveByDistances.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOPENSHELL] = (d) => {
  return IfcOpenShell.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOPENINGELEMENT] = (d) => {
  return IfcOpeningElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOPENINGSTANDARDCASE] = (d) => {
  return IfcOpeningStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCORGANIZATION] = (d) => {
  return IfcOrganization.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCORGANIZATIONRELATIONSHIP] = (d) => {
  return IfcOrganizationRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCORIENTATIONEXPRESSION] = (d) => {
  return IfcOrientationExpression.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCORIENTEDEDGE] = (d) => {
  return IfcOrientedEdge.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOUTERBOUNDARYCURVE] = (d) => {
  return IfcOuterBoundaryCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOUTLET] = (d) => {
  return IfcOutlet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOUTLETTYPE] = (d) => {
  return IfcOutletType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOWNERHISTORY] = (d) => {
  return IfcOwnerHistory.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPARAMETERIZEDPROFILEDEF] = (d) => {
  return IfcParameterizedProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPATH] = (d) => {
  return IfcPath.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPCURVE] = (d) => {
  return IfcPcurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPERFORMANCEHISTORY] = (d) => {
  return IfcPerformanceHistory.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPERMEABLECOVERINGPROPERTIES] = (d) => {
  return IfcPermeableCoveringProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPERMIT] = (d) => {
  return IfcPermit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPERSON] = (d) => {
  return IfcPerson.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPERSONANDORGANIZATION] = (d) => {
  return IfcPersonAndOrganization.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPHYSICALCOMPLEXQUANTITY] = (d) => {
  return IfcPhysicalComplexQuantity.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPHYSICALQUANTITY] = (d) => {
  return IfcPhysicalQuantity.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPHYSICALSIMPLEQUANTITY] = (d) => {
  return IfcPhysicalSimpleQuantity.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPILE] = (d) => {
  return IfcPile.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPILETYPE] = (d) => {
  return IfcPileType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPIPEFITTING] = (d) => {
  return IfcPipeFitting.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPIPEFITTINGTYPE] = (d) => {
  return IfcPipeFittingType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPIPESEGMENT] = (d) => {
  return IfcPipeSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPIPESEGMENTTYPE] = (d) => {
  return IfcPipeSegmentType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPIXELTEXTURE] = (d) => {
  return IfcPixelTexture.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPLACEMENT] = (d) => {
  return IfcPlacement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPLANARBOX] = (d) => {
  return IfcPlanarBox.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPLANAREXTENT] = (d) => {
  return IfcPlanarExtent.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPLANE] = (d) => {
  return IfcPlane.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPLATE] = (d) => {
  return IfcPlate.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPLATESTANDARDCASE] = (d) => {
  return IfcPlateStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPLATETYPE] = (d) => {
  return IfcPlateType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOINT] = (d) => {
  return IfcPoint.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOINTONCURVE] = (d) => {
  return IfcPointOnCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOINTONSURFACE] = (d) => {
  return IfcPointOnSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOLYLOOP] = (d) => {
  return IfcPolyLoop.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOLYGONALBOUNDEDHALFSPACE] = (d) => {
  return IfcPolygonalBoundedHalfSpace.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOLYGONALFACESET] = (d) => {
  return IfcPolygonalFaceSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOLYLINE] = (d) => {
  return IfcPolyline.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPORT] = (d) => {
  return IfcPort.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOSITIONINGELEMENT] = (d) => {
  return IfcPositioningElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOSTALADDRESS] = (d) => {
  return IfcPostalAddress.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPREDEFINEDCOLOUR] = (d) => {
  return IfcPreDefinedColour.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPREDEFINEDCURVEFONT] = (d) => {
  return IfcPreDefinedCurveFont.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPREDEFINEDITEM] = (d) => {
  return IfcPreDefinedItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPREDEFINEDPROPERTIES] = (d) => {
  return IfcPreDefinedProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPREDEFINEDPROPERTYSET] = (d) => {
  return IfcPreDefinedPropertySet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPREDEFINEDTEXTFONT] = (d) => {
  return IfcPreDefinedTextFont.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPRESENTATIONITEM] = (d) => {
  return IfcPresentationItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPRESENTATIONLAYERASSIGNMENT] = (d) => {
  return IfcPresentationLayerAssignment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPRESENTATIONLAYERWITHSTYLE] = (d) => {
  return IfcPresentationLayerWithStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPRESENTATIONSTYLE] = (d) => {
  return IfcPresentationStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPRESENTATIONSTYLEASSIGNMENT] = (d) => {
  return IfcPresentationStyleAssignment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROCEDURE] = (d) => {
  return IfcProcedure.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROCEDURETYPE] = (d) => {
  return IfcProcedureType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROCESS] = (d) => {
  return IfcProcess.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPRODUCT] = (d) => {
  return IfcProduct.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPRODUCTDEFINITIONSHAPE] = (d) => {
  return IfcProductDefinitionShape.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPRODUCTREPRESENTATION] = (d) => {
  return IfcProductRepresentation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROFILEDEF] = (d) => {
  return IfcProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROFILEPROPERTIES] = (d) => {
  return IfcProfileProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROJECT] = (d) => {
  return IfcProject.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROJECTLIBRARY] = (d) => {
  return IfcProjectLibrary.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROJECTORDER] = (d) => {
  return IfcProjectOrder.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROJECTEDCRS] = (d) => {
  return IfcProjectedCRS.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROJECTIONELEMENT] = (d) => {
  return IfcProjectionElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTY] = (d) => {
  return IfcProperty.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYABSTRACTION] = (d) => {
  return IfcPropertyAbstraction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYBOUNDEDVALUE] = (d) => {
  return IfcPropertyBoundedValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYDEFINITION] = (d) => {
  return IfcPropertyDefinition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYDEPENDENCYRELATIONSHIP] = (d) => {
  return IfcPropertyDependencyRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYENUMERATEDVALUE] = (d) => {
  return IfcPropertyEnumeratedValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYENUMERATION] = (d) => {
  return IfcPropertyEnumeration.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYLISTVALUE] = (d) => {
  return IfcPropertyListValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYREFERENCEVALUE] = (d) => {
  return IfcPropertyReferenceValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYSET] = (d) => {
  return IfcPropertySet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYSETDEFINITION] = (d) => {
  return IfcPropertySetDefinition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYSETTEMPLATE] = (d) => {
  return IfcPropertySetTemplate.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYSINGLEVALUE] = (d) => {
  return IfcPropertySingleValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYTABLEVALUE] = (d) => {
  return IfcPropertyTableValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYTEMPLATE] = (d) => {
  return IfcPropertyTemplate.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYTEMPLATEDEFINITION] = (d) => {
  return IfcPropertyTemplateDefinition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROTECTIVEDEVICE] = (d) => {
  return IfcProtectiveDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROTECTIVEDEVICETRIPPINGUNIT] = (d) => {
  return IfcProtectiveDeviceTrippingUnit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROTECTIVEDEVICETRIPPINGUNITTYPE] = (d) => {
  return IfcProtectiveDeviceTrippingUnitType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROTECTIVEDEVICETYPE] = (d) => {
  return IfcProtectiveDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROXY] = (d) => {
  return IfcProxy.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPUMP] = (d) => {
  return IfcPump.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPUMPTYPE] = (d) => {
  return IfcPumpType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCQUANTITYAREA] = (d) => {
  return IfcQuantityArea.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCQUANTITYCOUNT] = (d) => {
  return IfcQuantityCount.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCQUANTITYLENGTH] = (d) => {
  return IfcQuantityLength.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCQUANTITYSET] = (d) => {
  return IfcQuantitySet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCQUANTITYTIME] = (d) => {
  return IfcQuantityTime.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCQUANTITYVOLUME] = (d) => {
  return IfcQuantityVolume.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCQUANTITYWEIGHT] = (d) => {
  return IfcQuantityWeight.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRAILING] = (d) => {
  return IfcRailing.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRAILINGTYPE] = (d) => {
  return IfcRailingType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRAMP] = (d) => {
  return IfcRamp.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRAMPFLIGHT] = (d) => {
  return IfcRampFlight.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRAMPFLIGHTTYPE] = (d) => {
  return IfcRampFlightType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRAMPTYPE] = (d) => {
  return IfcRampType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRATIONALBSPLINECURVEWITHKNOTS] = (d) => {
  return IfcRationalBSplineCurveWithKnots.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRATIONALBSPLINESURFACEWITHKNOTS] = (d) => {
  return IfcRationalBSplineSurfaceWithKnots.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRECTANGLEHOLLOWPROFILEDEF] = (d) => {
  return IfcRectangleHollowProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRECTANGLEPROFILEDEF] = (d) => {
  return IfcRectangleProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRECTANGULARPYRAMID] = (d) => {
  return IfcRectangularPyramid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRECTANGULARTRIMMEDSURFACE] = (d) => {
  return IfcRectangularTrimmedSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRECURRENCEPATTERN] = (d) => {
  return IfcRecurrencePattern.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREFERENCE] = (d) => {
  return IfcReference.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREFERENT] = (d) => {
  return IfcReferent.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREGULARTIMESERIES] = (d) => {
  return IfcRegularTimeSeries.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREINFORCEMENTBARPROPERTIES] = (d) => {
  return IfcReinforcementBarProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREINFORCEMENTDEFINITIONPROPERTIES] = (d) => {
  return IfcReinforcementDefinitionProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREINFORCINGBAR] = (d) => {
  return IfcReinforcingBar.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREINFORCINGBARTYPE] = (d) => {
  return IfcReinforcingBarType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREINFORCINGELEMENT] = (d) => {
  return IfcReinforcingElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREINFORCINGELEMENTTYPE] = (d) => {
  return IfcReinforcingElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREINFORCINGMESH] = (d) => {
  return IfcReinforcingMesh.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREINFORCINGMESHTYPE] = (d) => {
  return IfcReinforcingMeshType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELAGGREGATES] = (d) => {
  return IfcRelAggregates.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSIGNS] = (d) => {
  return IfcRelAssigns.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSIGNSTOACTOR] = (d) => {
  return IfcRelAssignsToActor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSIGNSTOCONTROL] = (d) => {
  return IfcRelAssignsToControl.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSIGNSTOGROUP] = (d) => {
  return IfcRelAssignsToGroup.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSIGNSTOGROUPBYFACTOR] = (d) => {
  return IfcRelAssignsToGroupByFactor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSIGNSTOPROCESS] = (d) => {
  return IfcRelAssignsToProcess.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSIGNSTOPRODUCT] = (d) => {
  return IfcRelAssignsToProduct.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSIGNSTORESOURCE] = (d) => {
  return IfcRelAssignsToResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSOCIATES] = (d) => {
  return IfcRelAssociates.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSOCIATESAPPROVAL] = (d) => {
  return IfcRelAssociatesApproval.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSOCIATESCLASSIFICATION] = (d) => {
  return IfcRelAssociatesClassification.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSOCIATESCONSTRAINT] = (d) => {
  return IfcRelAssociatesConstraint.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSOCIATESDOCUMENT] = (d) => {
  return IfcRelAssociatesDocument.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSOCIATESLIBRARY] = (d) => {
  return IfcRelAssociatesLibrary.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSOCIATESMATERIAL] = (d) => {
  return IfcRelAssociatesMaterial.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTS] = (d) => {
  return IfcRelConnects.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTSELEMENTS] = (d) => {
  return IfcRelConnectsElements.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTSPATHELEMENTS] = (d) => {
  return IfcRelConnectsPathElements.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTSPORTTOELEMENT] = (d) => {
  return IfcRelConnectsPortToElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTSPORTS] = (d) => {
  return IfcRelConnectsPorts.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTSSTRUCTURALACTIVITY] = (d) => {
  return IfcRelConnectsStructuralActivity.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTSSTRUCTURALMEMBER] = (d) => {
  return IfcRelConnectsStructuralMember.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTSWITHECCENTRICITY] = (d) => {
  return IfcRelConnectsWithEccentricity.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTSWITHREALIZINGELEMENTS] = (d) => {
  return IfcRelConnectsWithRealizingElements.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONTAINEDINSPATIALSTRUCTURE] = (d) => {
  return IfcRelContainedInSpatialStructure.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCOVERSBLDGELEMENTS] = (d) => {
  return IfcRelCoversBldgElements.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCOVERSSPACES] = (d) => {
  return IfcRelCoversSpaces.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELDECLARES] = (d) => {
  return IfcRelDeclares.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELDECOMPOSES] = (d) => {
  return IfcRelDecomposes.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELDEFINES] = (d) => {
  return IfcRelDefines.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELDEFINESBYOBJECT] = (d) => {
  return IfcRelDefinesByObject.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELDEFINESBYPROPERTIES] = (d) => {
  return IfcRelDefinesByProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELDEFINESBYTEMPLATE] = (d) => {
  return IfcRelDefinesByTemplate.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELDEFINESBYTYPE] = (d) => {
  return IfcRelDefinesByType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELFILLSELEMENT] = (d) => {
  return IfcRelFillsElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELFLOWCONTROLELEMENTS] = (d) => {
  return IfcRelFlowControlElements.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELINTERFERESELEMENTS] = (d) => {
  return IfcRelInterferesElements.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELNESTS] = (d) => {
  return IfcRelNests.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELPOSITIONS] = (d) => {
  return IfcRelPositions.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELPROJECTSELEMENT] = (d) => {
  return IfcRelProjectsElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELREFERENCEDINSPATIALSTRUCTURE] = (d) => {
  return IfcRelReferencedInSpatialStructure.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELSEQUENCE] = (d) => {
  return IfcRelSequence.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELSERVICESBUILDINGS] = (d) => {
  return IfcRelServicesBuildings.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELSPACEBOUNDARY] = (d) => {
  return IfcRelSpaceBoundary.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELSPACEBOUNDARY1STLEVEL] = (d) => {
  return IfcRelSpaceBoundary1stLevel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELSPACEBOUNDARY2NDLEVEL] = (d) => {
  return IfcRelSpaceBoundary2ndLevel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELVOIDSELEMENT] = (d) => {
  return IfcRelVoidsElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELATIONSHIP] = (d) => {
  return IfcRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREPARAMETRISEDCOMPOSITECURVESEGMENT] = (d) => {
  return IfcReparametrisedCompositeCurveSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREPRESENTATION] = (d) => {
  return IfcRepresentation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREPRESENTATIONCONTEXT] = (d) => {
  return IfcRepresentationContext.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREPRESENTATIONITEM] = (d) => {
  return IfcRepresentationItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREPRESENTATIONMAP] = (d) => {
  return IfcRepresentationMap.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRESOURCE] = (d) => {
  return IfcResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRESOURCEAPPROVALRELATIONSHIP] = (d) => {
  return IfcResourceApprovalRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRESOURCECONSTRAINTRELATIONSHIP] = (d) => {
  return IfcResourceConstraintRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRESOURCELEVELRELATIONSHIP] = (d) => {
  return IfcResourceLevelRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRESOURCETIME] = (d) => {
  return IfcResourceTime.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREVOLVEDAREASOLID] = (d) => {
  return IfcRevolvedAreaSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREVOLVEDAREASOLIDTAPERED] = (d) => {
  return IfcRevolvedAreaSolidTapered.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRIGHTCIRCULARCONE] = (d) => {
  return IfcRightCircularCone.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRIGHTCIRCULARCYLINDER] = (d) => {
  return IfcRightCircularCylinder.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCROOF] = (d) => {
  return IfcRoof.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCROOFTYPE] = (d) => {
  return IfcRoofType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCROOT] = (d) => {
  return IfcRoot.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCROUNDEDRECTANGLEPROFILEDEF] = (d) => {
  return IfcRoundedRectangleProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSIUNIT] = (d) => {
  return IfcSIUnit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSANITARYTERMINAL] = (d) => {
  return IfcSanitaryTerminal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSANITARYTERMINALTYPE] = (d) => {
  return IfcSanitaryTerminalType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSCHEDULINGTIME] = (d) => {
  return IfcSchedulingTime.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSEAMCURVE] = (d) => {
  return IfcSeamCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSECTIONPROPERTIES] = (d) => {
  return IfcSectionProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSECTIONREINFORCEMENTPROPERTIES] = (d) => {
  return IfcSectionReinforcementProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSECTIONEDSOLID] = (d) => {
  return IfcSectionedSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSECTIONEDSOLIDHORIZONTAL] = (d) => {
  return IfcSectionedSolidHorizontal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSECTIONEDSPINE] = (d) => {
  return IfcSectionedSpine.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSENSOR] = (d) => {
  return IfcSensor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSENSORTYPE] = (d) => {
  return IfcSensorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSHADINGDEVICE] = (d) => {
  return IfcShadingDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSHADINGDEVICETYPE] = (d) => {
  return IfcShadingDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSHAPEASPECT] = (d) => {
  return IfcShapeAspect.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSHAPEMODEL] = (d) => {
  return IfcShapeModel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSHAPEREPRESENTATION] = (d) => {
  return IfcShapeRepresentation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSHELLBASEDSURFACEMODEL] = (d) => {
  return IfcShellBasedSurfaceModel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSIMPLEPROPERTY] = (d) => {
  return IfcSimpleProperty.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSIMPLEPROPERTYTEMPLATE] = (d) => {
  return IfcSimplePropertyTemplate.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSITE] = (d) => {
  return IfcSite.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSLAB] = (d) => {
  return IfcSlab.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSLABELEMENTEDCASE] = (d) => {
  return IfcSlabElementedCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSLABSTANDARDCASE] = (d) => {
  return IfcSlabStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSLABTYPE] = (d) => {
  return IfcSlabType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSLIPPAGECONNECTIONCONDITION] = (d) => {
  return IfcSlippageConnectionCondition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSOLARDEVICE] = (d) => {
  return IfcSolarDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSOLARDEVICETYPE] = (d) => {
  return IfcSolarDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSOLIDMODEL] = (d) => {
  return IfcSolidModel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPACE] = (d) => {
  return IfcSpace.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPACEHEATER] = (d) => {
  return IfcSpaceHeater.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPACEHEATERTYPE] = (d) => {
  return IfcSpaceHeaterType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPACETYPE] = (d) => {
  return IfcSpaceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPATIALELEMENT] = (d) => {
  return IfcSpatialElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPATIALELEMENTTYPE] = (d) => {
  return IfcSpatialElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPATIALSTRUCTUREELEMENT] = (d) => {
  return IfcSpatialStructureElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPATIALSTRUCTUREELEMENTTYPE] = (d) => {
  return IfcSpatialStructureElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPATIALZONE] = (d) => {
  return IfcSpatialZone.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPATIALZONETYPE] = (d) => {
  return IfcSpatialZoneType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPHERE] = (d) => {
  return IfcSphere.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPHERICALSURFACE] = (d) => {
  return IfcSphericalSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTACKTERMINAL] = (d) => {
  return IfcStackTerminal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTACKTERMINALTYPE] = (d) => {
  return IfcStackTerminalType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTAIR] = (d) => {
  return IfcStair.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTAIRFLIGHT] = (d) => {
  return IfcStairFlight.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTAIRFLIGHTTYPE] = (d) => {
  return IfcStairFlightType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTAIRTYPE] = (d) => {
  return IfcStairType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALACTION] = (d) => {
  return IfcStructuralAction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALACTIVITY] = (d) => {
  return IfcStructuralActivity.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALANALYSISMODEL] = (d) => {
  return IfcStructuralAnalysisModel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALCONNECTION] = (d) => {
  return IfcStructuralConnection.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALCONNECTIONCONDITION] = (d) => {
  return IfcStructuralConnectionCondition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALCURVEACTION] = (d) => {
  return IfcStructuralCurveAction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALCURVECONNECTION] = (d) => {
  return IfcStructuralCurveConnection.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALCURVEMEMBER] = (d) => {
  return IfcStructuralCurveMember.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALCURVEMEMBERVARYING] = (d) => {
  return IfcStructuralCurveMemberVarying.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALCURVEREACTION] = (d) => {
  return IfcStructuralCurveReaction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALITEM] = (d) => {
  return IfcStructuralItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLINEARACTION] = (d) => {
  return IfcStructuralLinearAction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOAD] = (d) => {
  return IfcStructuralLoad.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADCASE] = (d) => {
  return IfcStructuralLoadCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADCONFIGURATION] = (d) => {
  return IfcStructuralLoadConfiguration.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADGROUP] = (d) => {
  return IfcStructuralLoadGroup.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADLINEARFORCE] = (d) => {
  return IfcStructuralLoadLinearForce.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADORRESULT] = (d) => {
  return IfcStructuralLoadOrResult.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADPLANARFORCE] = (d) => {
  return IfcStructuralLoadPlanarForce.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADSINGLEDISPLACEMENT] = (d) => {
  return IfcStructuralLoadSingleDisplacement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION] = (d) => {
  return IfcStructuralLoadSingleDisplacementDistortion.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADSINGLEFORCE] = (d) => {
  return IfcStructuralLoadSingleForce.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADSINGLEFORCEWARPING] = (d) => {
  return IfcStructuralLoadSingleForceWarping.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADSTATIC] = (d) => {
  return IfcStructuralLoadStatic.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADTEMPERATURE] = (d) => {
  return IfcStructuralLoadTemperature.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALMEMBER] = (d) => {
  return IfcStructuralMember.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALPLANARACTION] = (d) => {
  return IfcStructuralPlanarAction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALPOINTACTION] = (d) => {
  return IfcStructuralPointAction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALPOINTCONNECTION] = (d) => {
  return IfcStructuralPointConnection.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALPOINTREACTION] = (d) => {
  return IfcStructuralPointReaction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALREACTION] = (d) => {
  return IfcStructuralReaction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALRESULTGROUP] = (d) => {
  return IfcStructuralResultGroup.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALSURFACEACTION] = (d) => {
  return IfcStructuralSurfaceAction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALSURFACECONNECTION] = (d) => {
  return IfcStructuralSurfaceConnection.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALSURFACEMEMBER] = (d) => {
  return IfcStructuralSurfaceMember.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALSURFACEMEMBERVARYING] = (d) => {
  return IfcStructuralSurfaceMemberVarying.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALSURFACEREACTION] = (d) => {
  return IfcStructuralSurfaceReaction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTYLEMODEL] = (d) => {
  return IfcStyleModel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTYLEDITEM] = (d) => {
  return IfcStyledItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTYLEDREPRESENTATION] = (d) => {
  return IfcStyledRepresentation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSUBCONTRACTRESOURCE] = (d) => {
  return IfcSubContractResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSUBCONTRACTRESOURCETYPE] = (d) => {
  return IfcSubContractResourceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSUBEDGE] = (d) => {
  return IfcSubedge.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACE] = (d) => {
  return IfcSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACECURVE] = (d) => {
  return IfcSurfaceCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACECURVESWEPTAREASOLID] = (d) => {
  return IfcSurfaceCurveSweptAreaSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACEFEATURE] = (d) => {
  return IfcSurfaceFeature.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACEOFLINEAREXTRUSION] = (d) => {
  return IfcSurfaceOfLinearExtrusion.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACEOFREVOLUTION] = (d) => {
  return IfcSurfaceOfRevolution.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACEREINFORCEMENTAREA] = (d) => {
  return IfcSurfaceReinforcementArea.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACESTYLE] = (d) => {
  return IfcSurfaceStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACESTYLELIGHTING] = (d) => {
  return IfcSurfaceStyleLighting.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACESTYLEREFRACTION] = (d) => {
  return IfcSurfaceStyleRefraction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACESTYLERENDERING] = (d) => {
  return IfcSurfaceStyleRendering.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACESTYLESHADING] = (d) => {
  return IfcSurfaceStyleShading.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACESTYLEWITHTEXTURES] = (d) => {
  return IfcSurfaceStyleWithTextures.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACETEXTURE] = (d) => {
  return IfcSurfaceTexture.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSWEPTAREASOLID] = (d) => {
  return IfcSweptAreaSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSWEPTDISKSOLID] = (d) => {
  return IfcSweptDiskSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSWEPTDISKSOLIDPOLYGONAL] = (d) => {
  return IfcSweptDiskSolidPolygonal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSWEPTSURFACE] = (d) => {
  return IfcSweptSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSWITCHINGDEVICE] = (d) => {
  return IfcSwitchingDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSWITCHINGDEVICETYPE] = (d) => {
  return IfcSwitchingDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSYSTEM] = (d) => {
  return IfcSystem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSYSTEMFURNITUREELEMENT] = (d) => {
  return IfcSystemFurnitureElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSYSTEMFURNITUREELEMENTTYPE] = (d) => {
  return IfcSystemFurnitureElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTSHAPEPROFILEDEF] = (d) => {
  return IfcTShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTABLE] = (d) => {
  return IfcTable.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTABLECOLUMN] = (d) => {
  return IfcTableColumn.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTABLEROW] = (d) => {
  return IfcTableRow.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTANK] = (d) => {
  return IfcTank.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTANKTYPE] = (d) => {
  return IfcTankType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTASK] = (d) => {
  return IfcTask.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTASKTIME] = (d) => {
  return IfcTaskTime.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTASKTIMERECURRING] = (d) => {
  return IfcTaskTimeRecurring.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTASKTYPE] = (d) => {
  return IfcTaskType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTELECOMADDRESS] = (d) => {
  return IfcTelecomAddress.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTENDON] = (d) => {
  return IfcTendon.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTENDONANCHOR] = (d) => {
  return IfcTendonAnchor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTENDONANCHORTYPE] = (d) => {
  return IfcTendonAnchorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTENDONCONDUIT] = (d) => {
  return IfcTendonConduit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTENDONCONDUITTYPE] = (d) => {
  return IfcTendonConduitType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTENDONTYPE] = (d) => {
  return IfcTendonType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTESSELLATEDFACESET] = (d) => {
  return IfcTessellatedFaceSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTESSELLATEDITEM] = (d) => {
  return IfcTessellatedItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTLITERAL] = (d) => {
  return IfcTextLiteral.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTLITERALWITHEXTENT] = (d) => {
  return IfcTextLiteralWithExtent.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTSTYLE] = (d) => {
  return IfcTextStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTSTYLEFONTMODEL] = (d) => {
  return IfcTextStyleFontModel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTSTYLEFORDEFINEDFONT] = (d) => {
  return IfcTextStyleForDefinedFont.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTSTYLETEXTMODEL] = (d) => {
  return IfcTextStyleTextModel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTURECOORDINATE] = (d) => {
  return IfcTextureCoordinate.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTURECOORDINATEGENERATOR] = (d) => {
  return IfcTextureCoordinateGenerator.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTUREMAP] = (d) => {
  return IfcTextureMap.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTUREVERTEX] = (d) => {
  return IfcTextureVertex.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTUREVERTEXLIST] = (d) => {
  return IfcTextureVertexList.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTIMEPERIOD] = (d) => {
  return IfcTimePeriod.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTIMESERIES] = (d) => {
  return IfcTimeSeries.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTIMESERIESVALUE] = (d) => {
  return IfcTimeSeriesValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTOPOLOGICALREPRESENTATIONITEM] = (d) => {
  return IfcTopologicalRepresentationItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTOPOLOGYREPRESENTATION] = (d) => {
  return IfcTopologyRepresentation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTOROIDALSURFACE] = (d) => {
  return IfcToroidalSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRANSFORMER] = (d) => {
  return IfcTransformer.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRANSFORMERTYPE] = (d) => {
  return IfcTransformerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRANSITIONCURVESEGMENT2D] = (d) => {
  return IfcTransitionCurveSegment2D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRANSPORTELEMENT] = (d) => {
  return IfcTransportElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRANSPORTELEMENTTYPE] = (d) => {
  return IfcTransportElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRAPEZIUMPROFILEDEF] = (d) => {
  return IfcTrapeziumProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRIANGULATEDFACESET] = (d) => {
  return IfcTriangulatedFaceSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRIANGULATEDIRREGULARNETWORK] = (d) => {
  return IfcTriangulatedIrregularNetwork.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRIMMEDCURVE] = (d) => {
  return IfcTrimmedCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTUBEBUNDLE] = (d) => {
  return IfcTubeBundle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTUBEBUNDLETYPE] = (d) => {
  return IfcTubeBundleType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTYPEOBJECT] = (d) => {
  return IfcTypeObject.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTYPEPROCESS] = (d) => {
  return IfcTypeProcess.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTYPEPRODUCT] = (d) => {
  return IfcTypeProduct.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTYPERESOURCE] = (d) => {
  return IfcTypeResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCUSHAPEPROFILEDEF] = (d) => {
  return IfcUShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCUNITASSIGNMENT] = (d) => {
  return IfcUnitAssignment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCUNITARYCONTROLELEMENT] = (d) => {
  return IfcUnitaryControlElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCUNITARYCONTROLELEMENTTYPE] = (d) => {
  return IfcUnitaryControlElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCUNITARYEQUIPMENT] = (d) => {
  return IfcUnitaryEquipment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCUNITARYEQUIPMENTTYPE] = (d) => {
  return IfcUnitaryEquipmentType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVALVE] = (d) => {
  return IfcValve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVALVETYPE] = (d) => {
  return IfcValveType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVECTOR] = (d) => {
  return IfcVector.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVERTEX] = (d) => {
  return IfcVertex.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVERTEXLOOP] = (d) => {
  return IfcVertexLoop.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVERTEXPOINT] = (d) => {
  return IfcVertexPoint.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVIBRATIONDAMPER] = (d) => {
  return IfcVibrationDamper.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVIBRATIONDAMPERTYPE] = (d) => {
  return IfcVibrationDamperType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVIBRATIONISOLATOR] = (d) => {
  return IfcVibrationIsolator.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVIBRATIONISOLATORTYPE] = (d) => {
  return IfcVibrationIsolatorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVIRTUALELEMENT] = (d) => {
  return IfcVirtualElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVIRTUALGRIDINTERSECTION] = (d) => {
  return IfcVirtualGridIntersection.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVOIDINGFEATURE] = (d) => {
  return IfcVoidingFeature.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWALL] = (d) => {
  return IfcWall.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWALLELEMENTEDCASE] = (d) => {
  return IfcWallElementedCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWALLSTANDARDCASE] = (d) => {
  return IfcWallStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWALLTYPE] = (d) => {
  return IfcWallType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWASTETERMINAL] = (d) => {
  return IfcWasteTerminal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWASTETERMINALTYPE] = (d) => {
  return IfcWasteTerminalType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWINDOW] = (d) => {
  return IfcWindow.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWINDOWLININGPROPERTIES] = (d) => {
  return IfcWindowLiningProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWINDOWPANELPROPERTIES] = (d) => {
  return IfcWindowPanelProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWINDOWSTANDARDCASE] = (d) => {
  return IfcWindowStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWINDOWSTYLE] = (d) => {
  return IfcWindowStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWINDOWTYPE] = (d) => {
  return IfcWindowType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWORKCALENDAR] = (d) => {
  return IfcWorkCalendar.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWORKCONTROL] = (d) => {
  return IfcWorkControl.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWORKPLAN] = (d) => {
  return IfcWorkPlan.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWORKSCHEDULE] = (d) => {
  return IfcWorkSchedule.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWORKTIME] = (d) => {
  return IfcWorkTime.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCZSHAPEPROFILEDEF] = (d) => {
  return IfcZShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCZONE] = (d) => {
  return IfcZone.FromTape(d.ID, d.type, d.arguments);
};
var IfcActionRequestTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcActionRequestTypeEnum");
IfcActionRequestTypeEnum.EMAIL = "EMAIL";
IfcActionRequestTypeEnum.FAX = "FAX";
IfcActionRequestTypeEnum.PHONE = "PHONE";
IfcActionRequestTypeEnum.POST = "POST";
IfcActionRequestTypeEnum.VERBAL = "VERBAL";
IfcActionRequestTypeEnum.USERDEFINED = "USERDEFINED";
IfcActionRequestTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcActionSourceTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcActionSourceTypeEnum");
IfcActionSourceTypeEnum.DEAD_LOAD_G = "DEAD_LOAD_G";
IfcActionSourceTypeEnum.COMPLETION_G1 = "COMPLETION_G1";
IfcActionSourceTypeEnum.LIVE_LOAD_Q = "LIVE_LOAD_Q";
IfcActionSourceTypeEnum.SNOW_S = "SNOW_S";
IfcActionSourceTypeEnum.WIND_W = "WIND_W";
IfcActionSourceTypeEnum.PRESTRESSING_P = "PRESTRESSING_P";
IfcActionSourceTypeEnum.SETTLEMENT_U = "SETTLEMENT_U";
IfcActionSourceTypeEnum.TEMPERATURE_T = "TEMPERATURE_T";
IfcActionSourceTypeEnum.EARTHQUAKE_E = "EARTHQUAKE_E";
IfcActionSourceTypeEnum.FIRE = "FIRE";
IfcActionSourceTypeEnum.IMPULSE = "IMPULSE";
IfcActionSourceTypeEnum.IMPACT = "IMPACT";
IfcActionSourceTypeEnum.TRANSPORT = "TRANSPORT";
IfcActionSourceTypeEnum.ERECTION = "ERECTION";
IfcActionSourceTypeEnum.PROPPING = "PROPPING";
IfcActionSourceTypeEnum.SYSTEM_IMPERFECTION = "SYSTEM_IMPERFECTION";
IfcActionSourceTypeEnum.SHRINKAGE = "SHRINKAGE";
IfcActionSourceTypeEnum.CREEP = "CREEP";
IfcActionSourceTypeEnum.LACK_OF_FIT = "LACK_OF_FIT";
IfcActionSourceTypeEnum.BUOYANCY = "BUOYANCY";
IfcActionSourceTypeEnum.ICE = "ICE";
IfcActionSourceTypeEnum.CURRENT = "CURRENT";
IfcActionSourceTypeEnum.WAVE = "WAVE";
IfcActionSourceTypeEnum.RAIN = "RAIN";
IfcActionSourceTypeEnum.BRAKES = "BRAKES";
IfcActionSourceTypeEnum.USERDEFINED = "USERDEFINED";
IfcActionSourceTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcActionTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcActionTypeEnum");
IfcActionTypeEnum.PERMANENT_G = "PERMANENT_G";
IfcActionTypeEnum.VARIABLE_Q = "VARIABLE_Q";
IfcActionTypeEnum.EXTRAORDINARY_A = "EXTRAORDINARY_A";
IfcActionTypeEnum.USERDEFINED = "USERDEFINED";
IfcActionTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcActuatorTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcActuatorTypeEnum");
IfcActuatorTypeEnum.ELECTRICACTUATOR = "ELECTRICACTUATOR";
IfcActuatorTypeEnum.HANDOPERATEDACTUATOR = "HANDOPERATEDACTUATOR";
IfcActuatorTypeEnum.HYDRAULICACTUATOR = "HYDRAULICACTUATOR";
IfcActuatorTypeEnum.PNEUMATICACTUATOR = "PNEUMATICACTUATOR";
IfcActuatorTypeEnum.THERMOSTATICACTUATOR = "THERMOSTATICACTUATOR";
IfcActuatorTypeEnum.USERDEFINED = "USERDEFINED";
IfcActuatorTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcAddressTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcAddressTypeEnum");
IfcAddressTypeEnum.OFFICE = "OFFICE";
IfcAddressTypeEnum.SITE = "SITE";
IfcAddressTypeEnum.HOME = "HOME";
IfcAddressTypeEnum.DISTRIBUTIONPOINT = "DISTRIBUTIONPOINT";
IfcAddressTypeEnum.USERDEFINED = "USERDEFINED";
var IfcAirTerminalBoxTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcAirTerminalBoxTypeEnum");
IfcAirTerminalBoxTypeEnum.CONSTANTFLOW = "CONSTANTFLOW";
IfcAirTerminalBoxTypeEnum.VARIABLEFLOWPRESSUREDEPENDANT = "VARIABLEFLOWPRESSUREDEPENDANT";
IfcAirTerminalBoxTypeEnum.VARIABLEFLOWPRESSUREINDEPENDANT = "VARIABLEFLOWPRESSUREINDEPENDANT";
IfcAirTerminalBoxTypeEnum.USERDEFINED = "USERDEFINED";
IfcAirTerminalBoxTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcAirTerminalTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcAirTerminalTypeEnum");
IfcAirTerminalTypeEnum.DIFFUSER = "DIFFUSER";
IfcAirTerminalTypeEnum.GRILLE = "GRILLE";
IfcAirTerminalTypeEnum.LOUVRE = "LOUVRE";
IfcAirTerminalTypeEnum.REGISTER = "REGISTER";
IfcAirTerminalTypeEnum.USERDEFINED = "USERDEFINED";
IfcAirTerminalTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcAirToAirHeatRecoveryTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcAirToAirHeatRecoveryTypeEnum");
IfcAirToAirHeatRecoveryTypeEnum.FIXEDPLATECOUNTERFLOWEXCHANGER = "FIXEDPLATECOUNTERFLOWEXCHANGER";
IfcAirToAirHeatRecoveryTypeEnum.FIXEDPLATECROSSFLOWEXCHANGER = "FIXEDPLATECROSSFLOWEXCHANGER";
IfcAirToAirHeatRecoveryTypeEnum.FIXEDPLATEPARALLELFLOWEXCHANGER = "FIXEDPLATEPARALLELFLOWEXCHANGER";
IfcAirToAirHeatRecoveryTypeEnum.ROTARYWHEEL = "ROTARYWHEEL";
IfcAirToAirHeatRecoveryTypeEnum.RUNAROUNDCOILLOOP = "RUNAROUNDCOILLOOP";
IfcAirToAirHeatRecoveryTypeEnum.HEATPIPE = "HEATPIPE";
IfcAirToAirHeatRecoveryTypeEnum.TWINTOWERENTHALPYRECOVERYLOOPS = "TWINTOWERENTHALPYRECOVERYLOOPS";
IfcAirToAirHeatRecoveryTypeEnum.THERMOSIPHONSEALEDTUBEHEATEXCHANGERS = "THERMOSIPHONSEALEDTUBEHEATEXCHANGERS";
IfcAirToAirHeatRecoveryTypeEnum.THERMOSIPHONCOILTYPEHEATEXCHANGERS = "THERMOSIPHONCOILTYPEHEATEXCHANGERS";
IfcAirToAirHeatRecoveryTypeEnum.USERDEFINED = "USERDEFINED";
IfcAirToAirHeatRecoveryTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcAlarmTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcAlarmTypeEnum");
IfcAlarmTypeEnum.BELL = "BELL";
IfcAlarmTypeEnum.BREAKGLASSBUTTON = "BREAKGLASSBUTTON";
IfcAlarmTypeEnum.LIGHT = "LIGHT";
IfcAlarmTypeEnum.MANUALPULLBOX = "MANUALPULLBOX";
IfcAlarmTypeEnum.SIREN = "SIREN";
IfcAlarmTypeEnum.WHISTLE = "WHISTLE";
IfcAlarmTypeEnum.USERDEFINED = "USERDEFINED";
IfcAlarmTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcAlignmentTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcAlignmentTypeEnum");
IfcAlignmentTypeEnum.USERDEFINED = "USERDEFINED";
IfcAlignmentTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcAnalysisModelTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcAnalysisModelTypeEnum");
IfcAnalysisModelTypeEnum.IN_PLANE_LOADING_2D = "IN_PLANE_LOADING_2D";
IfcAnalysisModelTypeEnum.OUT_PLANE_LOADING_2D = "OUT_PLANE_LOADING_2D";
IfcAnalysisModelTypeEnum.LOADING_3D = "LOADING_3D";
IfcAnalysisModelTypeEnum.USERDEFINED = "USERDEFINED";
IfcAnalysisModelTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcAnalysisTheoryTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcAnalysisTheoryTypeEnum");
IfcAnalysisTheoryTypeEnum.FIRST_ORDER_THEORY = "FIRST_ORDER_THEORY";
IfcAnalysisTheoryTypeEnum.SECOND_ORDER_THEORY = "SECOND_ORDER_THEORY";
IfcAnalysisTheoryTypeEnum.THIRD_ORDER_THEORY = "THIRD_ORDER_THEORY";
IfcAnalysisTheoryTypeEnum.FULL_NONLINEAR_THEORY = "FULL_NONLINEAR_THEORY";
IfcAnalysisTheoryTypeEnum.USERDEFINED = "USERDEFINED";
IfcAnalysisTheoryTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcArithmeticOperatorEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcArithmeticOperatorEnum");
IfcArithmeticOperatorEnum.ADD = "ADD";
IfcArithmeticOperatorEnum.DIVIDE = "DIVIDE";
IfcArithmeticOperatorEnum.MULTIPLY = "MULTIPLY";
IfcArithmeticOperatorEnum.SUBTRACT = "SUBTRACT";
var IfcAssemblyPlaceEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcAssemblyPlaceEnum");
IfcAssemblyPlaceEnum.SITE = "SITE";
IfcAssemblyPlaceEnum.FACTORY = "FACTORY";
IfcAssemblyPlaceEnum.NOTDEFINED = "NOTDEFINED";
var IfcAudioVisualApplianceTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcAudioVisualApplianceTypeEnum");
IfcAudioVisualApplianceTypeEnum.AMPLIFIER = "AMPLIFIER";
IfcAudioVisualApplianceTypeEnum.CAMERA = "CAMERA";
IfcAudioVisualApplianceTypeEnum.DISPLAY = "DISPLAY";
IfcAudioVisualApplianceTypeEnum.MICROPHONE = "MICROPHONE";
IfcAudioVisualApplianceTypeEnum.PLAYER = "PLAYER";
IfcAudioVisualApplianceTypeEnum.PROJECTOR = "PROJECTOR";
IfcAudioVisualApplianceTypeEnum.RECEIVER = "RECEIVER";
IfcAudioVisualApplianceTypeEnum.SPEAKER = "SPEAKER";
IfcAudioVisualApplianceTypeEnum.SWITCHER = "SWITCHER";
IfcAudioVisualApplianceTypeEnum.TELEPHONE = "TELEPHONE";
IfcAudioVisualApplianceTypeEnum.TUNER = "TUNER";
IfcAudioVisualApplianceTypeEnum.USERDEFINED = "USERDEFINED";
IfcAudioVisualApplianceTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcBSplineCurveForm = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcBSplineCurveForm");
IfcBSplineCurveForm.POLYLINE_FORM = "POLYLINE_FORM";
IfcBSplineCurveForm.CIRCULAR_ARC = "CIRCULAR_ARC";
IfcBSplineCurveForm.ELLIPTIC_ARC = "ELLIPTIC_ARC";
IfcBSplineCurveForm.PARABOLIC_ARC = "PARABOLIC_ARC";
IfcBSplineCurveForm.HYPERBOLIC_ARC = "HYPERBOLIC_ARC";
IfcBSplineCurveForm.UNSPECIFIED = "UNSPECIFIED";
var IfcBSplineSurfaceForm = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcBSplineSurfaceForm");
IfcBSplineSurfaceForm.PLANE_SURF = "PLANE_SURF";
IfcBSplineSurfaceForm.CYLINDRICAL_SURF = "CYLINDRICAL_SURF";
IfcBSplineSurfaceForm.CONICAL_SURF = "CONICAL_SURF";
IfcBSplineSurfaceForm.SPHERICAL_SURF = "SPHERICAL_SURF";
IfcBSplineSurfaceForm.TOROIDAL_SURF = "TOROIDAL_SURF";
IfcBSplineSurfaceForm.SURF_OF_REVOLUTION = "SURF_OF_REVOLUTION";
IfcBSplineSurfaceForm.RULED_SURF = "RULED_SURF";
IfcBSplineSurfaceForm.GENERALISED_CONE = "GENERALISED_CONE";
IfcBSplineSurfaceForm.QUADRIC_SURF = "QUADRIC_SURF";
IfcBSplineSurfaceForm.SURF_OF_LINEAR_EXTRUSION = "SURF_OF_LINEAR_EXTRUSION";
IfcBSplineSurfaceForm.UNSPECIFIED = "UNSPECIFIED";
var IfcBeamTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcBeamTypeEnum");
IfcBeamTypeEnum.BEAM = "BEAM";
IfcBeamTypeEnum.JOIST = "JOIST";
IfcBeamTypeEnum.HOLLOWCORE = "HOLLOWCORE";
IfcBeamTypeEnum.LINTEL = "LINTEL";
IfcBeamTypeEnum.SPANDREL = "SPANDREL";
IfcBeamTypeEnum.T_BEAM = "T_BEAM";
IfcBeamTypeEnum.GIRDER_SEGMENT = "GIRDER_SEGMENT";
IfcBeamTypeEnum.DIAPHRAGM = "DIAPHRAGM";
IfcBeamTypeEnum.PIERCAP = "PIERCAP";
IfcBeamTypeEnum.HATSTONE = "HATSTONE";
IfcBeamTypeEnum.CORNICE = "CORNICE";
IfcBeamTypeEnum.EDGEBEAM = "EDGEBEAM";
IfcBeamTypeEnum.USERDEFINED = "USERDEFINED";
IfcBeamTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcBearingTypeDisplacementEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcBearingTypeDisplacementEnum");
IfcBearingTypeDisplacementEnum.FIXED_MOVEMENT = "FIXED_MOVEMENT";
IfcBearingTypeDisplacementEnum.GUIDED_LONGITUDINAL = "GUIDED_LONGITUDINAL";
IfcBearingTypeDisplacementEnum.GUIDED_TRANSVERSAL = "GUIDED_TRANSVERSAL";
IfcBearingTypeDisplacementEnum.FREE_MOVEMENT = "FREE_MOVEMENT";
IfcBearingTypeDisplacementEnum.NOTDEFINED = "NOTDEFINED";
var IfcBearingTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcBearingTypeEnum");
IfcBearingTypeEnum.CYLINDRICAL = "CYLINDRICAL";
IfcBearingTypeEnum.SPHERICAL = "SPHERICAL";
IfcBearingTypeEnum.ELASTOMERIC = "ELASTOMERIC";
IfcBearingTypeEnum.POT = "POT";
IfcBearingTypeEnum.GUIDE = "GUIDE";
IfcBearingTypeEnum.ROCKER = "ROCKER";
IfcBearingTypeEnum.ROLLER = "ROLLER";
IfcBearingTypeEnum.DISK = "DISK";
IfcBearingTypeEnum.USERDEFINED = "USERDEFINED";
IfcBearingTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcBenchmarkEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcBenchmarkEnum");
IfcBenchmarkEnum.GREATERTHAN = "GREATERTHAN";
IfcBenchmarkEnum.GREATERTHANOREQUALTO = "GREATERTHANOREQUALTO";
IfcBenchmarkEnum.LESSTHAN = "LESSTHAN";
IfcBenchmarkEnum.LESSTHANOREQUALTO = "LESSTHANOREQUALTO";
IfcBenchmarkEnum.EQUALTO = "EQUALTO";
IfcBenchmarkEnum.NOTEQUALTO = "NOTEQUALTO";
IfcBenchmarkEnum.INCLUDES = "INCLUDES";
IfcBenchmarkEnum.NOTINCLUDES = "NOTINCLUDES";
IfcBenchmarkEnum.INCLUDEDIN = "INCLUDEDIN";
IfcBenchmarkEnum.NOTINCLUDEDIN = "NOTINCLUDEDIN";
var IfcBoilerTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcBoilerTypeEnum");
IfcBoilerTypeEnum.WATER = "WATER";
IfcBoilerTypeEnum.STEAM = "STEAM";
IfcBoilerTypeEnum.USERDEFINED = "USERDEFINED";
IfcBoilerTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcBooleanOperator = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcBooleanOperator");
IfcBooleanOperator.UNION = "UNION";
IfcBooleanOperator.INTERSECTION = "INTERSECTION";
IfcBooleanOperator.DIFFERENCE = "DIFFERENCE";
var IfcBridgePartTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcBridgePartTypeEnum");
IfcBridgePartTypeEnum.ABUTMENT = "ABUTMENT";
IfcBridgePartTypeEnum.DECK = "DECK";
IfcBridgePartTypeEnum.DECK_SEGMENT = "DECK_SEGMENT";
IfcBridgePartTypeEnum.FOUNDATION = "FOUNDATION";
IfcBridgePartTypeEnum.PIER = "PIER";
IfcBridgePartTypeEnum.PIER_SEGMENT = "PIER_SEGMENT";
IfcBridgePartTypeEnum.PYLON = "PYLON";
IfcBridgePartTypeEnum.SUBSTRUCTURE = "SUBSTRUCTURE";
IfcBridgePartTypeEnum.SUPERSTRUCTURE = "SUPERSTRUCTURE";
IfcBridgePartTypeEnum.SURFACESTRUCTURE = "SURFACESTRUCTURE";
IfcBridgePartTypeEnum.USERDEFINED = "USERDEFINED";
IfcBridgePartTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcBridgeTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcBridgeTypeEnum");
IfcBridgeTypeEnum.ARCHED = "ARCHED";
IfcBridgeTypeEnum.CABLE_STAYED = "CABLE_STAYED";
IfcBridgeTypeEnum.CANTILEVER = "CANTILEVER";
IfcBridgeTypeEnum.CULVERT = "CULVERT";
IfcBridgeTypeEnum.FRAMEWORK = "FRAMEWORK";
IfcBridgeTypeEnum.GIRDER = "GIRDER";
IfcBridgeTypeEnum.SUSPENSION = "SUSPENSION";
IfcBridgeTypeEnum.TRUSS = "TRUSS";
IfcBridgeTypeEnum.USERDEFINED = "USERDEFINED";
IfcBridgeTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcBuildingElementPartTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcBuildingElementPartTypeEnum");
IfcBuildingElementPartTypeEnum.INSULATION = "INSULATION";
IfcBuildingElementPartTypeEnum.PRECASTPANEL = "PRECASTPANEL";
IfcBuildingElementPartTypeEnum.APRON = "APRON";
IfcBuildingElementPartTypeEnum.USERDEFINED = "USERDEFINED";
IfcBuildingElementPartTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcBuildingElementProxyTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcBuildingElementProxyTypeEnum");
IfcBuildingElementProxyTypeEnum.COMPLEX = "COMPLEX";
IfcBuildingElementProxyTypeEnum.ELEMENT = "ELEMENT";
IfcBuildingElementProxyTypeEnum.PARTIAL = "PARTIAL";
IfcBuildingElementProxyTypeEnum.PROVISIONFORVOID = "PROVISIONFORVOID";
IfcBuildingElementProxyTypeEnum.PROVISIONFORSPACE = "PROVISIONFORSPACE";
IfcBuildingElementProxyTypeEnum.USERDEFINED = "USERDEFINED";
IfcBuildingElementProxyTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcBuildingSystemTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcBuildingSystemTypeEnum");
IfcBuildingSystemTypeEnum.FENESTRATION = "FENESTRATION";
IfcBuildingSystemTypeEnum.FOUNDATION = "FOUNDATION";
IfcBuildingSystemTypeEnum.LOADBEARING = "LOADBEARING";
IfcBuildingSystemTypeEnum.OUTERSHELL = "OUTERSHELL";
IfcBuildingSystemTypeEnum.SHADING = "SHADING";
IfcBuildingSystemTypeEnum.TRANSPORT = "TRANSPORT";
IfcBuildingSystemTypeEnum.REINFORCING = "REINFORCING";
IfcBuildingSystemTypeEnum.PRESTRESSING = "PRESTRESSING";
IfcBuildingSystemTypeEnum.USERDEFINED = "USERDEFINED";
IfcBuildingSystemTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcBurnerTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcBurnerTypeEnum");
IfcBurnerTypeEnum.USERDEFINED = "USERDEFINED";
IfcBurnerTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcCableCarrierFittingTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcCableCarrierFittingTypeEnum");
IfcCableCarrierFittingTypeEnum.BEND = "BEND";
IfcCableCarrierFittingTypeEnum.CROSS = "CROSS";
IfcCableCarrierFittingTypeEnum.REDUCER = "REDUCER";
IfcCableCarrierFittingTypeEnum.TEE = "TEE";
IfcCableCarrierFittingTypeEnum.USERDEFINED = "USERDEFINED";
IfcCableCarrierFittingTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcCableCarrierSegmentTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcCableCarrierSegmentTypeEnum");
IfcCableCarrierSegmentTypeEnum.CABLELADDERSEGMENT = "CABLELADDERSEGMENT";
IfcCableCarrierSegmentTypeEnum.CABLETRAYSEGMENT = "CABLETRAYSEGMENT";
IfcCableCarrierSegmentTypeEnum.CABLETRUNKINGSEGMENT = "CABLETRUNKINGSEGMENT";
IfcCableCarrierSegmentTypeEnum.CONDUITSEGMENT = "CONDUITSEGMENT";
IfcCableCarrierSegmentTypeEnum.USERDEFINED = "USERDEFINED";
IfcCableCarrierSegmentTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcCableFittingTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcCableFittingTypeEnum");
IfcCableFittingTypeEnum.CONNECTOR = "CONNECTOR";
IfcCableFittingTypeEnum.ENTRY = "ENTRY";
IfcCableFittingTypeEnum.EXIT = "EXIT";
IfcCableFittingTypeEnum.JUNCTION = "JUNCTION";
IfcCableFittingTypeEnum.TRANSITION = "TRANSITION";
IfcCableFittingTypeEnum.USERDEFINED = "USERDEFINED";
IfcCableFittingTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcCableSegmentTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcCableSegmentTypeEnum");
IfcCableSegmentTypeEnum.BUSBARSEGMENT = "BUSBARSEGMENT";
IfcCableSegmentTypeEnum.CABLESEGMENT = "CABLESEGMENT";
IfcCableSegmentTypeEnum.CONDUCTORSEGMENT = "CONDUCTORSEGMENT";
IfcCableSegmentTypeEnum.CORESEGMENT = "CORESEGMENT";
IfcCableSegmentTypeEnum.USERDEFINED = "USERDEFINED";
IfcCableSegmentTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcCaissonFoundationTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcCaissonFoundationTypeEnum");
IfcCaissonFoundationTypeEnum.WELL = "WELL";
IfcCaissonFoundationTypeEnum.CAISSON = "CAISSON";
IfcCaissonFoundationTypeEnum.USERDEFINED = "USERDEFINED";
IfcCaissonFoundationTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcChangeActionEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcChangeActionEnum");
IfcChangeActionEnum.NOCHANGE = "NOCHANGE";
IfcChangeActionEnum.MODIFIED = "MODIFIED";
IfcChangeActionEnum.ADDED = "ADDED";
IfcChangeActionEnum.DELETED = "DELETED";
IfcChangeActionEnum.NOTDEFINED = "NOTDEFINED";
var IfcChillerTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcChillerTypeEnum");
IfcChillerTypeEnum.AIRCOOLED = "AIRCOOLED";
IfcChillerTypeEnum.WATERCOOLED = "WATERCOOLED";
IfcChillerTypeEnum.HEATRECOVERY = "HEATRECOVERY";
IfcChillerTypeEnum.USERDEFINED = "USERDEFINED";
IfcChillerTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcChimneyTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcChimneyTypeEnum");
IfcChimneyTypeEnum.USERDEFINED = "USERDEFINED";
IfcChimneyTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcCoilTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcCoilTypeEnum");
IfcCoilTypeEnum.DXCOOLINGCOIL = "DXCOOLINGCOIL";
IfcCoilTypeEnum.ELECTRICHEATINGCOIL = "ELECTRICHEATINGCOIL";
IfcCoilTypeEnum.GASHEATINGCOIL = "GASHEATINGCOIL";
IfcCoilTypeEnum.HYDRONICCOIL = "HYDRONICCOIL";
IfcCoilTypeEnum.STEAMHEATINGCOIL = "STEAMHEATINGCOIL";
IfcCoilTypeEnum.WATERCOOLINGCOIL = "WATERCOOLINGCOIL";
IfcCoilTypeEnum.WATERHEATINGCOIL = "WATERHEATINGCOIL";
IfcCoilTypeEnum.USERDEFINED = "USERDEFINED";
IfcCoilTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcColumnTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcColumnTypeEnum");
IfcColumnTypeEnum.COLUMN = "COLUMN";
IfcColumnTypeEnum.PILASTER = "PILASTER";
IfcColumnTypeEnum.PIERSTEM = "PIERSTEM";
IfcColumnTypeEnum.PIERSTEM_SEGMENT = "PIERSTEM_SEGMENT";
IfcColumnTypeEnum.STANDCOLUMN = "STANDCOLUMN";
IfcColumnTypeEnum.USERDEFINED = "USERDEFINED";
IfcColumnTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcCommunicationsApplianceTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcCommunicationsApplianceTypeEnum");
IfcCommunicationsApplianceTypeEnum.ANTENNA = "ANTENNA";
IfcCommunicationsApplianceTypeEnum.COMPUTER = "COMPUTER";
IfcCommunicationsApplianceTypeEnum.FAX = "FAX";
IfcCommunicationsApplianceTypeEnum.GATEWAY = "GATEWAY";
IfcCommunicationsApplianceTypeEnum.MODEM = "MODEM";
IfcCommunicationsApplianceTypeEnum.NETWORKAPPLIANCE = "NETWORKAPPLIANCE";
IfcCommunicationsApplianceTypeEnum.NETWORKBRIDGE = "NETWORKBRIDGE";
IfcCommunicationsApplianceTypeEnum.NETWORKHUB = "NETWORKHUB";
IfcCommunicationsApplianceTypeEnum.PRINTER = "PRINTER";
IfcCommunicationsApplianceTypeEnum.REPEATER = "REPEATER";
IfcCommunicationsApplianceTypeEnum.ROUTER = "ROUTER";
IfcCommunicationsApplianceTypeEnum.SCANNER = "SCANNER";
IfcCommunicationsApplianceTypeEnum.USERDEFINED = "USERDEFINED";
IfcCommunicationsApplianceTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcComplexPropertyTemplateTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcComplexPropertyTemplateTypeEnum");
IfcComplexPropertyTemplateTypeEnum.P_COMPLEX = "P_COMPLEX";
IfcComplexPropertyTemplateTypeEnum.Q_COMPLEX = "Q_COMPLEX";
var IfcCompressorTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcCompressorTypeEnum");
IfcCompressorTypeEnum.DYNAMIC = "DYNAMIC";
IfcCompressorTypeEnum.RECIPROCATING = "RECIPROCATING";
IfcCompressorTypeEnum.ROTARY = "ROTARY";
IfcCompressorTypeEnum.SCROLL = "SCROLL";
IfcCompressorTypeEnum.TROCHOIDAL = "TROCHOIDAL";
IfcCompressorTypeEnum.SINGLESTAGE = "SINGLESTAGE";
IfcCompressorTypeEnum.BOOSTER = "BOOSTER";
IfcCompressorTypeEnum.OPENTYPE = "OPENTYPE";
IfcCompressorTypeEnum.HERMETIC = "HERMETIC";
IfcCompressorTypeEnum.SEMIHERMETIC = "SEMIHERMETIC";
IfcCompressorTypeEnum.WELDEDSHELLHERMETIC = "WELDEDSHELLHERMETIC";
IfcCompressorTypeEnum.ROLLINGPISTON = "ROLLINGPISTON";
IfcCompressorTypeEnum.ROTARYVANE = "ROTARYVANE";
IfcCompressorTypeEnum.SINGLESCREW = "SINGLESCREW";
IfcCompressorTypeEnum.TWINSCREW = "TWINSCREW";
IfcCompressorTypeEnum.USERDEFINED = "USERDEFINED";
IfcCompressorTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcCondenserTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcCondenserTypeEnum");
IfcCondenserTypeEnum.AIRCOOLED = "AIRCOOLED";
IfcCondenserTypeEnum.EVAPORATIVECOOLED = "EVAPORATIVECOOLED";
IfcCondenserTypeEnum.WATERCOOLED = "WATERCOOLED";
IfcCondenserTypeEnum.WATERCOOLEDBRAZEDPLATE = "WATERCOOLEDBRAZEDPLATE";
IfcCondenserTypeEnum.WATERCOOLEDSHELLCOIL = "WATERCOOLEDSHELLCOIL";
IfcCondenserTypeEnum.WATERCOOLEDSHELLTUBE = "WATERCOOLEDSHELLTUBE";
IfcCondenserTypeEnum.WATERCOOLEDTUBEINTUBE = "WATERCOOLEDTUBEINTUBE";
IfcCondenserTypeEnum.USERDEFINED = "USERDEFINED";
IfcCondenserTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcConnectionTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcConnectionTypeEnum");
IfcConnectionTypeEnum.ATPATH = "ATPATH";
IfcConnectionTypeEnum.ATSTART = "ATSTART";
IfcConnectionTypeEnum.ATEND = "ATEND";
IfcConnectionTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcConstraintEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcConstraintEnum");
IfcConstraintEnum.HARD = "HARD";
IfcConstraintEnum.SOFT = "SOFT";
IfcConstraintEnum.ADVISORY = "ADVISORY";
IfcConstraintEnum.USERDEFINED = "USERDEFINED";
IfcConstraintEnum.NOTDEFINED = "NOTDEFINED";
var IfcConstructionEquipmentResourceTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcConstructionEquipmentResourceTypeEnum");
IfcConstructionEquipmentResourceTypeEnum.DEMOLISHING = "DEMOLISHING";
IfcConstructionEquipmentResourceTypeEnum.EARTHMOVING = "EARTHMOVING";
IfcConstructionEquipmentResourceTypeEnum.ERECTING = "ERECTING";
IfcConstructionEquipmentResourceTypeEnum.HEATING = "HEATING";
IfcConstructionEquipmentResourceTypeEnum.LIGHTING = "LIGHTING";
IfcConstructionEquipmentResourceTypeEnum.PAVING = "PAVING";
IfcConstructionEquipmentResourceTypeEnum.PUMPING = "PUMPING";
IfcConstructionEquipmentResourceTypeEnum.TRANSPORTING = "TRANSPORTING";
IfcConstructionEquipmentResourceTypeEnum.USERDEFINED = "USERDEFINED";
IfcConstructionEquipmentResourceTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcConstructionMaterialResourceTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcConstructionMaterialResourceTypeEnum");
IfcConstructionMaterialResourceTypeEnum.AGGREGATES = "AGGREGATES";
IfcConstructionMaterialResourceTypeEnum.CONCRETE = "CONCRETE";
IfcConstructionMaterialResourceTypeEnum.DRYWALL = "DRYWALL";
IfcConstructionMaterialResourceTypeEnum.FUEL = "FUEL";
IfcConstructionMaterialResourceTypeEnum.GYPSUM = "GYPSUM";
IfcConstructionMaterialResourceTypeEnum.MASONRY = "MASONRY";
IfcConstructionMaterialResourceTypeEnum.METAL = "METAL";
IfcConstructionMaterialResourceTypeEnum.PLASTIC = "PLASTIC";
IfcConstructionMaterialResourceTypeEnum.WOOD = "WOOD";
IfcConstructionMaterialResourceTypeEnum.NOTDEFINED = "NOTDEFINED";
IfcConstructionMaterialResourceTypeEnum.USERDEFINED = "USERDEFINED";
var IfcConstructionProductResourceTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcConstructionProductResourceTypeEnum");
IfcConstructionProductResourceTypeEnum.ASSEMBLY = "ASSEMBLY";
IfcConstructionProductResourceTypeEnum.FORMWORK = "FORMWORK";
IfcConstructionProductResourceTypeEnum.USERDEFINED = "USERDEFINED";
IfcConstructionProductResourceTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcControllerTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcControllerTypeEnum");
IfcControllerTypeEnum.FLOATING = "FLOATING";
IfcControllerTypeEnum.PROGRAMMABLE = "PROGRAMMABLE";
IfcControllerTypeEnum.PROPORTIONAL = "PROPORTIONAL";
IfcControllerTypeEnum.MULTIPOSITION = "MULTIPOSITION";
IfcControllerTypeEnum.TWOPOSITION = "TWOPOSITION";
IfcControllerTypeEnum.USERDEFINED = "USERDEFINED";
IfcControllerTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcCooledBeamTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcCooledBeamTypeEnum");
IfcCooledBeamTypeEnum.ACTIVE = "ACTIVE";
IfcCooledBeamTypeEnum.PASSIVE = "PASSIVE";
IfcCooledBeamTypeEnum.USERDEFINED = "USERDEFINED";
IfcCooledBeamTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcCoolingTowerTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcCoolingTowerTypeEnum");
IfcCoolingTowerTypeEnum.NATURALDRAFT = "NATURALDRAFT";
IfcCoolingTowerTypeEnum.MECHANICALINDUCEDDRAFT = "MECHANICALINDUCEDDRAFT";
IfcCoolingTowerTypeEnum.MECHANICALFORCEDDRAFT = "MECHANICALFORCEDDRAFT";
IfcCoolingTowerTypeEnum.USERDEFINED = "USERDEFINED";
IfcCoolingTowerTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcCostItemTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcCostItemTypeEnum");
IfcCostItemTypeEnum.USERDEFINED = "USERDEFINED";
IfcCostItemTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcCostScheduleTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcCostScheduleTypeEnum");
IfcCostScheduleTypeEnum.BUDGET = "BUDGET";
IfcCostScheduleTypeEnum.COSTPLAN = "COSTPLAN";
IfcCostScheduleTypeEnum.ESTIMATE = "ESTIMATE";
IfcCostScheduleTypeEnum.TENDER = "TENDER";
IfcCostScheduleTypeEnum.PRICEDBILLOFQUANTITIES = "PRICEDBILLOFQUANTITIES";
IfcCostScheduleTypeEnum.UNPRICEDBILLOFQUANTITIES = "UNPRICEDBILLOFQUANTITIES";
IfcCostScheduleTypeEnum.SCHEDULEOFRATES = "SCHEDULEOFRATES";
IfcCostScheduleTypeEnum.USERDEFINED = "USERDEFINED";
IfcCostScheduleTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcCoveringTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcCoveringTypeEnum");
IfcCoveringTypeEnum.CEILING = "CEILING";
IfcCoveringTypeEnum.FLOORING = "FLOORING";
IfcCoveringTypeEnum.CLADDING = "CLADDING";
IfcCoveringTypeEnum.ROOFING = "ROOFING";
IfcCoveringTypeEnum.MOLDING = "MOLDING";
IfcCoveringTypeEnum.SKIRTINGBOARD = "SKIRTINGBOARD";
IfcCoveringTypeEnum.INSULATION = "INSULATION";
IfcCoveringTypeEnum.MEMBRANE = "MEMBRANE";
IfcCoveringTypeEnum.SLEEVING = "SLEEVING";
IfcCoveringTypeEnum.WRAPPING = "WRAPPING";
IfcCoveringTypeEnum.COPING = "COPING";
IfcCoveringTypeEnum.USERDEFINED = "USERDEFINED";
IfcCoveringTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcCrewResourceTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcCrewResourceTypeEnum");
IfcCrewResourceTypeEnum.OFFICE = "OFFICE";
IfcCrewResourceTypeEnum.SITE = "SITE";
IfcCrewResourceTypeEnum.USERDEFINED = "USERDEFINED";
IfcCrewResourceTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcCurtainWallTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcCurtainWallTypeEnum");
IfcCurtainWallTypeEnum.USERDEFINED = "USERDEFINED";
IfcCurtainWallTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcCurveInterpolationEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcCurveInterpolationEnum");
IfcCurveInterpolationEnum.LINEAR = "LINEAR";
IfcCurveInterpolationEnum.LOG_LINEAR = "LOG_LINEAR";
IfcCurveInterpolationEnum.LOG_LOG = "LOG_LOG";
IfcCurveInterpolationEnum.NOTDEFINED = "NOTDEFINED";
var IfcDamperTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcDamperTypeEnum");
IfcDamperTypeEnum.BACKDRAFTDAMPER = "BACKDRAFTDAMPER";
IfcDamperTypeEnum.BALANCINGDAMPER = "BALANCINGDAMPER";
IfcDamperTypeEnum.BLASTDAMPER = "BLASTDAMPER";
IfcDamperTypeEnum.CONTROLDAMPER = "CONTROLDAMPER";
IfcDamperTypeEnum.FIREDAMPER = "FIREDAMPER";
IfcDamperTypeEnum.FIRESMOKEDAMPER = "FIRESMOKEDAMPER";
IfcDamperTypeEnum.FUMEHOODEXHAUST = "FUMEHOODEXHAUST";
IfcDamperTypeEnum.GRAVITYDAMPER = "GRAVITYDAMPER";
IfcDamperTypeEnum.GRAVITYRELIEFDAMPER = "GRAVITYRELIEFDAMPER";
IfcDamperTypeEnum.RELIEFDAMPER = "RELIEFDAMPER";
IfcDamperTypeEnum.SMOKEDAMPER = "SMOKEDAMPER";
IfcDamperTypeEnum.USERDEFINED = "USERDEFINED";
IfcDamperTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcDataOriginEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcDataOriginEnum");
IfcDataOriginEnum.MEASURED = "MEASURED";
IfcDataOriginEnum.PREDICTED = "PREDICTED";
IfcDataOriginEnum.SIMULATED = "SIMULATED";
IfcDataOriginEnum.USERDEFINED = "USERDEFINED";
IfcDataOriginEnum.NOTDEFINED = "NOTDEFINED";
var IfcDerivedUnitEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcDerivedUnitEnum");
IfcDerivedUnitEnum.ANGULARVELOCITYUNIT = "ANGULARVELOCITYUNIT";
IfcDerivedUnitEnum.AREADENSITYUNIT = "AREADENSITYUNIT";
IfcDerivedUnitEnum.COMPOUNDPLANEANGLEUNIT = "COMPOUNDPLANEANGLEUNIT";
IfcDerivedUnitEnum.DYNAMICVISCOSITYUNIT = "DYNAMICVISCOSITYUNIT";
IfcDerivedUnitEnum.HEATFLUXDENSITYUNIT = "HEATFLUXDENSITYUNIT";
IfcDerivedUnitEnum.INTEGERCOUNTRATEUNIT = "INTEGERCOUNTRATEUNIT";
IfcDerivedUnitEnum.ISOTHERMALMOISTURECAPACITYUNIT = "ISOTHERMALMOISTURECAPACITYUNIT";
IfcDerivedUnitEnum.KINEMATICVISCOSITYUNIT = "KINEMATICVISCOSITYUNIT";
IfcDerivedUnitEnum.LINEARVELOCITYUNIT = "LINEARVELOCITYUNIT";
IfcDerivedUnitEnum.MASSDENSITYUNIT = "MASSDENSITYUNIT";
IfcDerivedUnitEnum.MASSFLOWRATEUNIT = "MASSFLOWRATEUNIT";
IfcDerivedUnitEnum.MOISTUREDIFFUSIVITYUNIT = "MOISTUREDIFFUSIVITYUNIT";
IfcDerivedUnitEnum.MOLECULARWEIGHTUNIT = "MOLECULARWEIGHTUNIT";
IfcDerivedUnitEnum.SPECIFICHEATCAPACITYUNIT = "SPECIFICHEATCAPACITYUNIT";
IfcDerivedUnitEnum.THERMALADMITTANCEUNIT = "THERMALADMITTANCEUNIT";
IfcDerivedUnitEnum.THERMALCONDUCTANCEUNIT = "THERMALCONDUCTANCEUNIT";
IfcDerivedUnitEnum.THERMALRESISTANCEUNIT = "THERMALRESISTANCEUNIT";
IfcDerivedUnitEnum.THERMALTRANSMITTANCEUNIT = "THERMALTRANSMITTANCEUNIT";
IfcDerivedUnitEnum.VAPORPERMEABILITYUNIT = "VAPORPERMEABILITYUNIT";
IfcDerivedUnitEnum.VOLUMETRICFLOWRATEUNIT = "VOLUMETRICFLOWRATEUNIT";
IfcDerivedUnitEnum.ROTATIONALFREQUENCYUNIT = "ROTATIONALFREQUENCYUNIT";
IfcDerivedUnitEnum.TORQUEUNIT = "TORQUEUNIT";
IfcDerivedUnitEnum.MOMENTOFINERTIAUNIT = "MOMENTOFINERTIAUNIT";
IfcDerivedUnitEnum.LINEARMOMENTUNIT = "LINEARMOMENTUNIT";
IfcDerivedUnitEnum.LINEARFORCEUNIT = "LINEARFORCEUNIT";
IfcDerivedUnitEnum.PLANARFORCEUNIT = "PLANARFORCEUNIT";
IfcDerivedUnitEnum.MODULUSOFELASTICITYUNIT = "MODULUSOFELASTICITYUNIT";
IfcDerivedUnitEnum.SHEARMODULUSUNIT = "SHEARMODULUSUNIT";
IfcDerivedUnitEnum.LINEARSTIFFNESSUNIT = "LINEARSTIFFNESSUNIT";
IfcDerivedUnitEnum.ROTATIONALSTIFFNESSUNIT = "ROTATIONALSTIFFNESSUNIT";
IfcDerivedUnitEnum.MODULUSOFSUBGRADEREACTIONUNIT = "MODULUSOFSUBGRADEREACTIONUNIT";
IfcDerivedUnitEnum.ACCELERATIONUNIT = "ACCELERATIONUNIT";
IfcDerivedUnitEnum.CURVATUREUNIT = "CURVATUREUNIT";
IfcDerivedUnitEnum.HEATINGVALUEUNIT = "HEATINGVALUEUNIT";
IfcDerivedUnitEnum.IONCONCENTRATIONUNIT = "IONCONCENTRATIONUNIT";
IfcDerivedUnitEnum.LUMINOUSINTENSITYDISTRIBUTIONUNIT = "LUMINOUSINTENSITYDISTRIBUTIONUNIT";
IfcDerivedUnitEnum.MASSPERLENGTHUNIT = "MASSPERLENGTHUNIT";
IfcDerivedUnitEnum.MODULUSOFLINEARSUBGRADEREACTIONUNIT = "MODULUSOFLINEARSUBGRADEREACTIONUNIT";
IfcDerivedUnitEnum.MODULUSOFROTATIONALSUBGRADEREACTIONUNIT = "MODULUSOFROTATIONALSUBGRADEREACTIONUNIT";
IfcDerivedUnitEnum.PHUNIT = "PHUNIT";
IfcDerivedUnitEnum.ROTATIONALMASSUNIT = "ROTATIONALMASSUNIT";
IfcDerivedUnitEnum.SECTIONAREAINTEGRALUNIT = "SECTIONAREAINTEGRALUNIT";
IfcDerivedUnitEnum.SECTIONMODULUSUNIT = "SECTIONMODULUSUNIT";
IfcDerivedUnitEnum.SOUNDPOWERLEVELUNIT = "SOUNDPOWERLEVELUNIT";
IfcDerivedUnitEnum.SOUNDPOWERUNIT = "SOUNDPOWERUNIT";
IfcDerivedUnitEnum.SOUNDPRESSURELEVELUNIT = "SOUNDPRESSURELEVELUNIT";
IfcDerivedUnitEnum.SOUNDPRESSUREUNIT = "SOUNDPRESSUREUNIT";
IfcDerivedUnitEnum.TEMPERATUREGRADIENTUNIT = "TEMPERATUREGRADIENTUNIT";
IfcDerivedUnitEnum.TEMPERATURERATEOFCHANGEUNIT = "TEMPERATURERATEOFCHANGEUNIT";
IfcDerivedUnitEnum.THERMALEXPANSIONCOEFFICIENTUNIT = "THERMALEXPANSIONCOEFFICIENTUNIT";
IfcDerivedUnitEnum.WARPINGCONSTANTUNIT = "WARPINGCONSTANTUNIT";
IfcDerivedUnitEnum.WARPINGMOMENTUNIT = "WARPINGMOMENTUNIT";
IfcDerivedUnitEnum.USERDEFINED = "USERDEFINED";
var IfcDirectionSenseEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcDirectionSenseEnum");
IfcDirectionSenseEnum.POSITIVE = "POSITIVE";
IfcDirectionSenseEnum.NEGATIVE = "NEGATIVE";
var IfcDiscreteAccessoryTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcDiscreteAccessoryTypeEnum");
IfcDiscreteAccessoryTypeEnum.ANCHORPLATE = "ANCHORPLATE";
IfcDiscreteAccessoryTypeEnum.BRACKET = "BRACKET";
IfcDiscreteAccessoryTypeEnum.SHOE = "SHOE";
IfcDiscreteAccessoryTypeEnum.EXPANSION_JOINT_DEVICE = "EXPANSION_JOINT_DEVICE";
IfcDiscreteAccessoryTypeEnum.USERDEFINED = "USERDEFINED";
IfcDiscreteAccessoryTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcDistributionChamberElementTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcDistributionChamberElementTypeEnum");
IfcDistributionChamberElementTypeEnum.FORMEDDUCT = "FORMEDDUCT";
IfcDistributionChamberElementTypeEnum.INSPECTIONCHAMBER = "INSPECTIONCHAMBER";
IfcDistributionChamberElementTypeEnum.INSPECTIONPIT = "INSPECTIONPIT";
IfcDistributionChamberElementTypeEnum.MANHOLE = "MANHOLE";
IfcDistributionChamberElementTypeEnum.METERCHAMBER = "METERCHAMBER";
IfcDistributionChamberElementTypeEnum.SUMP = "SUMP";
IfcDistributionChamberElementTypeEnum.TRENCH = "TRENCH";
IfcDistributionChamberElementTypeEnum.VALVECHAMBER = "VALVECHAMBER";
IfcDistributionChamberElementTypeEnum.USERDEFINED = "USERDEFINED";
IfcDistributionChamberElementTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcDistributionPortTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcDistributionPortTypeEnum");
IfcDistributionPortTypeEnum.CABLE = "CABLE";
IfcDistributionPortTypeEnum.CABLECARRIER = "CABLECARRIER";
IfcDistributionPortTypeEnum.DUCT = "DUCT";
IfcDistributionPortTypeEnum.PIPE = "PIPE";
IfcDistributionPortTypeEnum.USERDEFINED = "USERDEFINED";
IfcDistributionPortTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcDistributionSystemEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcDistributionSystemEnum");
IfcDistributionSystemEnum.AIRCONDITIONING = "AIRCONDITIONING";
IfcDistributionSystemEnum.AUDIOVISUAL = "AUDIOVISUAL";
IfcDistributionSystemEnum.CHEMICAL = "CHEMICAL";
IfcDistributionSystemEnum.CHILLEDWATER = "CHILLEDWATER";
IfcDistributionSystemEnum.COMMUNICATION = "COMMUNICATION";
IfcDistributionSystemEnum.COMPRESSEDAIR = "COMPRESSEDAIR";
IfcDistributionSystemEnum.CONDENSERWATER = "CONDENSERWATER";
IfcDistributionSystemEnum.CONTROL = "CONTROL";
IfcDistributionSystemEnum.CONVEYING = "CONVEYING";
IfcDistributionSystemEnum.DATA = "DATA";
IfcDistributionSystemEnum.DISPOSAL = "DISPOSAL";
IfcDistributionSystemEnum.DOMESTICCOLDWATER = "DOMESTICCOLDWATER";
IfcDistributionSystemEnum.DOMESTICHOTWATER = "DOMESTICHOTWATER";
IfcDistributionSystemEnum.DRAINAGE = "DRAINAGE";
IfcDistributionSystemEnum.EARTHING = "EARTHING";
IfcDistributionSystemEnum.ELECTRICAL = "ELECTRICAL";
IfcDistributionSystemEnum.ELECTROACOUSTIC = "ELECTROACOUSTIC";
IfcDistributionSystemEnum.EXHAUST = "EXHAUST";
IfcDistributionSystemEnum.FIREPROTECTION = "FIREPROTECTION";
IfcDistributionSystemEnum.FUEL = "FUEL";
IfcDistributionSystemEnum.GAS = "GAS";
IfcDistributionSystemEnum.HAZARDOUS = "HAZARDOUS";
IfcDistributionSystemEnum.HEATING = "HEATING";
IfcDistributionSystemEnum.LIGHTING = "LIGHTING";
IfcDistributionSystemEnum.LIGHTNINGPROTECTION = "LIGHTNINGPROTECTION";
IfcDistributionSystemEnum.MUNICIPALSOLIDWASTE = "MUNICIPALSOLIDWASTE";
IfcDistributionSystemEnum.OIL = "OIL";
IfcDistributionSystemEnum.OPERATIONAL = "OPERATIONAL";
IfcDistributionSystemEnum.POWERGENERATION = "POWERGENERATION";
IfcDistributionSystemEnum.RAINWATER = "RAINWATER";
IfcDistributionSystemEnum.REFRIGERATION = "REFRIGERATION";
IfcDistributionSystemEnum.SECURITY = "SECURITY";
IfcDistributionSystemEnum.SEWAGE = "SEWAGE";
IfcDistributionSystemEnum.SIGNAL = "SIGNAL";
IfcDistributionSystemEnum.STORMWATER = "STORMWATER";
IfcDistributionSystemEnum.TELEPHONE = "TELEPHONE";
IfcDistributionSystemEnum.TV = "TV";
IfcDistributionSystemEnum.VACUUM = "VACUUM";
IfcDistributionSystemEnum.VENT = "VENT";
IfcDistributionSystemEnum.VENTILATION = "VENTILATION";
IfcDistributionSystemEnum.WASTEWATER = "WASTEWATER";
IfcDistributionSystemEnum.WATERSUPPLY = "WATERSUPPLY";
IfcDistributionSystemEnum.USERDEFINED = "USERDEFINED";
IfcDistributionSystemEnum.NOTDEFINED = "NOTDEFINED";
var IfcDocumentConfidentialityEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcDocumentConfidentialityEnum");
IfcDocumentConfidentialityEnum.PUBLIC = "PUBLIC";
IfcDocumentConfidentialityEnum.RESTRICTED = "RESTRICTED";
IfcDocumentConfidentialityEnum.CONFIDENTIAL = "CONFIDENTIAL";
IfcDocumentConfidentialityEnum.PERSONAL = "PERSONAL";
IfcDocumentConfidentialityEnum.USERDEFINED = "USERDEFINED";
IfcDocumentConfidentialityEnum.NOTDEFINED = "NOTDEFINED";
var IfcDocumentStatusEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcDocumentStatusEnum");
IfcDocumentStatusEnum.DRAFT = "DRAFT";
IfcDocumentStatusEnum.FINALDRAFT = "FINALDRAFT";
IfcDocumentStatusEnum.FINAL = "FINAL";
IfcDocumentStatusEnum.REVISION = "REVISION";
IfcDocumentStatusEnum.NOTDEFINED = "NOTDEFINED";
var IfcDoorPanelOperationEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcDoorPanelOperationEnum");
IfcDoorPanelOperationEnum.SWINGING = "SWINGING";
IfcDoorPanelOperationEnum.DOUBLE_ACTING = "DOUBLE_ACTING";
IfcDoorPanelOperationEnum.SLIDING = "SLIDING";
IfcDoorPanelOperationEnum.FOLDING = "FOLDING";
IfcDoorPanelOperationEnum.REVOLVING = "REVOLVING";
IfcDoorPanelOperationEnum.ROLLINGUP = "ROLLINGUP";
IfcDoorPanelOperationEnum.FIXEDPANEL = "FIXEDPANEL";
IfcDoorPanelOperationEnum.USERDEFINED = "USERDEFINED";
IfcDoorPanelOperationEnum.NOTDEFINED = "NOTDEFINED";
var IfcDoorPanelPositionEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcDoorPanelPositionEnum");
IfcDoorPanelPositionEnum.LEFT = "LEFT";
IfcDoorPanelPositionEnum.MIDDLE = "MIDDLE";
IfcDoorPanelPositionEnum.RIGHT = "RIGHT";
IfcDoorPanelPositionEnum.NOTDEFINED = "NOTDEFINED";
var IfcDoorStyleConstructionEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcDoorStyleConstructionEnum");
IfcDoorStyleConstructionEnum.ALUMINIUM = "ALUMINIUM";
IfcDoorStyleConstructionEnum.HIGH_GRADE_STEEL = "HIGH_GRADE_STEEL";
IfcDoorStyleConstructionEnum.STEEL = "STEEL";
IfcDoorStyleConstructionEnum.WOOD = "WOOD";
IfcDoorStyleConstructionEnum.ALUMINIUM_WOOD = "ALUMINIUM_WOOD";
IfcDoorStyleConstructionEnum.ALUMINIUM_PLASTIC = "ALUMINIUM_PLASTIC";
IfcDoorStyleConstructionEnum.PLASTIC = "PLASTIC";
IfcDoorStyleConstructionEnum.USERDEFINED = "USERDEFINED";
IfcDoorStyleConstructionEnum.NOTDEFINED = "NOTDEFINED";
var IfcDoorStyleOperationEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcDoorStyleOperationEnum");
IfcDoorStyleOperationEnum.SINGLE_SWING_LEFT = "SINGLE_SWING_LEFT";
IfcDoorStyleOperationEnum.SINGLE_SWING_RIGHT = "SINGLE_SWING_RIGHT";
IfcDoorStyleOperationEnum.DOUBLE_DOOR_SINGLE_SWING = "DOUBLE_DOOR_SINGLE_SWING";
IfcDoorStyleOperationEnum.DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT = "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT";
IfcDoorStyleOperationEnum.DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT = "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT";
IfcDoorStyleOperationEnum.DOUBLE_SWING_LEFT = "DOUBLE_SWING_LEFT";
IfcDoorStyleOperationEnum.DOUBLE_SWING_RIGHT = "DOUBLE_SWING_RIGHT";
IfcDoorStyleOperationEnum.DOUBLE_DOOR_DOUBLE_SWING = "DOUBLE_DOOR_DOUBLE_SWING";
IfcDoorStyleOperationEnum.SLIDING_TO_LEFT = "SLIDING_TO_LEFT";
IfcDoorStyleOperationEnum.SLIDING_TO_RIGHT = "SLIDING_TO_RIGHT";
IfcDoorStyleOperationEnum.DOUBLE_DOOR_SLIDING = "DOUBLE_DOOR_SLIDING";
IfcDoorStyleOperationEnum.FOLDING_TO_LEFT = "FOLDING_TO_LEFT";
IfcDoorStyleOperationEnum.FOLDING_TO_RIGHT = "FOLDING_TO_RIGHT";
IfcDoorStyleOperationEnum.DOUBLE_DOOR_FOLDING = "DOUBLE_DOOR_FOLDING";
IfcDoorStyleOperationEnum.REVOLVING = "REVOLVING";
IfcDoorStyleOperationEnum.ROLLINGUP = "ROLLINGUP";
IfcDoorStyleOperationEnum.USERDEFINED = "USERDEFINED";
IfcDoorStyleOperationEnum.NOTDEFINED = "NOTDEFINED";
var IfcDoorTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcDoorTypeEnum");
IfcDoorTypeEnum.DOOR = "DOOR";
IfcDoorTypeEnum.GATE = "GATE";
IfcDoorTypeEnum.TRAPDOOR = "TRAPDOOR";
IfcDoorTypeEnum.USERDEFINED = "USERDEFINED";
IfcDoorTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcDoorTypeOperationEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcDoorTypeOperationEnum");
IfcDoorTypeOperationEnum.SINGLE_SWING_LEFT = "SINGLE_SWING_LEFT";
IfcDoorTypeOperationEnum.SINGLE_SWING_RIGHT = "SINGLE_SWING_RIGHT";
IfcDoorTypeOperationEnum.DOUBLE_DOOR_SINGLE_SWING = "DOUBLE_DOOR_SINGLE_SWING";
IfcDoorTypeOperationEnum.DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT = "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT";
IfcDoorTypeOperationEnum.DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT = "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT";
IfcDoorTypeOperationEnum.DOUBLE_SWING_LEFT = "DOUBLE_SWING_LEFT";
IfcDoorTypeOperationEnum.DOUBLE_SWING_RIGHT = "DOUBLE_SWING_RIGHT";
IfcDoorTypeOperationEnum.DOUBLE_DOOR_DOUBLE_SWING = "DOUBLE_DOOR_DOUBLE_SWING";
IfcDoorTypeOperationEnum.SLIDING_TO_LEFT = "SLIDING_TO_LEFT";
IfcDoorTypeOperationEnum.SLIDING_TO_RIGHT = "SLIDING_TO_RIGHT";
IfcDoorTypeOperationEnum.DOUBLE_DOOR_SLIDING = "DOUBLE_DOOR_SLIDING";
IfcDoorTypeOperationEnum.FOLDING_TO_LEFT = "FOLDING_TO_LEFT";
IfcDoorTypeOperationEnum.FOLDING_TO_RIGHT = "FOLDING_TO_RIGHT";
IfcDoorTypeOperationEnum.DOUBLE_DOOR_FOLDING = "DOUBLE_DOOR_FOLDING";
IfcDoorTypeOperationEnum.REVOLVING = "REVOLVING";
IfcDoorTypeOperationEnum.ROLLINGUP = "ROLLINGUP";
IfcDoorTypeOperationEnum.SWING_FIXED_LEFT = "SWING_FIXED_LEFT";
IfcDoorTypeOperationEnum.SWING_FIXED_RIGHT = "SWING_FIXED_RIGHT";
IfcDoorTypeOperationEnum.USERDEFINED = "USERDEFINED";
IfcDoorTypeOperationEnum.NOTDEFINED = "NOTDEFINED";
var IfcDuctFittingTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcDuctFittingTypeEnum");
IfcDuctFittingTypeEnum.BEND = "BEND";
IfcDuctFittingTypeEnum.CONNECTOR = "CONNECTOR";
IfcDuctFittingTypeEnum.ENTRY = "ENTRY";
IfcDuctFittingTypeEnum.EXIT = "EXIT";
IfcDuctFittingTypeEnum.JUNCTION = "JUNCTION";
IfcDuctFittingTypeEnum.OBSTRUCTION = "OBSTRUCTION";
IfcDuctFittingTypeEnum.TRANSITION = "TRANSITION";
IfcDuctFittingTypeEnum.USERDEFINED = "USERDEFINED";
IfcDuctFittingTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcDuctSegmentTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcDuctSegmentTypeEnum");
IfcDuctSegmentTypeEnum.RIGIDSEGMENT = "RIGIDSEGMENT";
IfcDuctSegmentTypeEnum.FLEXIBLESEGMENT = "FLEXIBLESEGMENT";
IfcDuctSegmentTypeEnum.USERDEFINED = "USERDEFINED";
IfcDuctSegmentTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcDuctSilencerTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcDuctSilencerTypeEnum");
IfcDuctSilencerTypeEnum.FLATOVAL = "FLATOVAL";
IfcDuctSilencerTypeEnum.RECTANGULAR = "RECTANGULAR";
IfcDuctSilencerTypeEnum.ROUND = "ROUND";
IfcDuctSilencerTypeEnum.USERDEFINED = "USERDEFINED";
IfcDuctSilencerTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcElectricApplianceTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcElectricApplianceTypeEnum");
IfcElectricApplianceTypeEnum.DISHWASHER = "DISHWASHER";
IfcElectricApplianceTypeEnum.ELECTRICCOOKER = "ELECTRICCOOKER";
IfcElectricApplianceTypeEnum.FREESTANDINGELECTRICHEATER = "FREESTANDINGELECTRICHEATER";
IfcElectricApplianceTypeEnum.FREESTANDINGFAN = "FREESTANDINGFAN";
IfcElectricApplianceTypeEnum.FREESTANDINGWATERHEATER = "FREESTANDINGWATERHEATER";
IfcElectricApplianceTypeEnum.FREESTANDINGWATERCOOLER = "FREESTANDINGWATERCOOLER";
IfcElectricApplianceTypeEnum.FREEZER = "FREEZER";
IfcElectricApplianceTypeEnum.FRIDGE_FREEZER = "FRIDGE_FREEZER";
IfcElectricApplianceTypeEnum.HANDDRYER = "HANDDRYER";
IfcElectricApplianceTypeEnum.KITCHENMACHINE = "KITCHENMACHINE";
IfcElectricApplianceTypeEnum.MICROWAVE = "MICROWAVE";
IfcElectricApplianceTypeEnum.PHOTOCOPIER = "PHOTOCOPIER";
IfcElectricApplianceTypeEnum.REFRIGERATOR = "REFRIGERATOR";
IfcElectricApplianceTypeEnum.TUMBLEDRYER = "TUMBLEDRYER";
IfcElectricApplianceTypeEnum.VENDINGMACHINE = "VENDINGMACHINE";
IfcElectricApplianceTypeEnum.WASHINGMACHINE = "WASHINGMACHINE";
IfcElectricApplianceTypeEnum.USERDEFINED = "USERDEFINED";
IfcElectricApplianceTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcElectricDistributionBoardTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcElectricDistributionBoardTypeEnum");
IfcElectricDistributionBoardTypeEnum.CONSUMERUNIT = "CONSUMERUNIT";
IfcElectricDistributionBoardTypeEnum.DISTRIBUTIONBOARD = "DISTRIBUTIONBOARD";
IfcElectricDistributionBoardTypeEnum.MOTORCONTROLCENTRE = "MOTORCONTROLCENTRE";
IfcElectricDistributionBoardTypeEnum.SWITCHBOARD = "SWITCHBOARD";
IfcElectricDistributionBoardTypeEnum.USERDEFINED = "USERDEFINED";
IfcElectricDistributionBoardTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcElectricFlowStorageDeviceTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcElectricFlowStorageDeviceTypeEnum");
IfcElectricFlowStorageDeviceTypeEnum.BATTERY = "BATTERY";
IfcElectricFlowStorageDeviceTypeEnum.CAPACITORBANK = "CAPACITORBANK";
IfcElectricFlowStorageDeviceTypeEnum.HARMONICFILTER = "HARMONICFILTER";
IfcElectricFlowStorageDeviceTypeEnum.INDUCTORBANK = "INDUCTORBANK";
IfcElectricFlowStorageDeviceTypeEnum.UPS = "UPS";
IfcElectricFlowStorageDeviceTypeEnum.USERDEFINED = "USERDEFINED";
IfcElectricFlowStorageDeviceTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcElectricGeneratorTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcElectricGeneratorTypeEnum");
IfcElectricGeneratorTypeEnum.CHP = "CHP";
IfcElectricGeneratorTypeEnum.ENGINEGENERATOR = "ENGINEGENERATOR";
IfcElectricGeneratorTypeEnum.STANDALONE = "STANDALONE";
IfcElectricGeneratorTypeEnum.USERDEFINED = "USERDEFINED";
IfcElectricGeneratorTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcElectricMotorTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcElectricMotorTypeEnum");
IfcElectricMotorTypeEnum.DC = "DC";
IfcElectricMotorTypeEnum.INDUCTION = "INDUCTION";
IfcElectricMotorTypeEnum.POLYPHASE = "POLYPHASE";
IfcElectricMotorTypeEnum.RELUCTANCESYNCHRONOUS = "RELUCTANCESYNCHRONOUS";
IfcElectricMotorTypeEnum.SYNCHRONOUS = "SYNCHRONOUS";
IfcElectricMotorTypeEnum.USERDEFINED = "USERDEFINED";
IfcElectricMotorTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcElectricTimeControlTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcElectricTimeControlTypeEnum");
IfcElectricTimeControlTypeEnum.TIMECLOCK = "TIMECLOCK";
IfcElectricTimeControlTypeEnum.TIMEDELAY = "TIMEDELAY";
IfcElectricTimeControlTypeEnum.RELAY = "RELAY";
IfcElectricTimeControlTypeEnum.USERDEFINED = "USERDEFINED";
IfcElectricTimeControlTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcElementAssemblyTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcElementAssemblyTypeEnum");
IfcElementAssemblyTypeEnum.ACCESSORY_ASSEMBLY = "ACCESSORY_ASSEMBLY";
IfcElementAssemblyTypeEnum.ARCH = "ARCH";
IfcElementAssemblyTypeEnum.BEAM_GRID = "BEAM_GRID";
IfcElementAssemblyTypeEnum.BRACED_FRAME = "BRACED_FRAME";
IfcElementAssemblyTypeEnum.GIRDER = "GIRDER";
IfcElementAssemblyTypeEnum.REINFORCEMENT_UNIT = "REINFORCEMENT_UNIT";
IfcElementAssemblyTypeEnum.RIGID_FRAME = "RIGID_FRAME";
IfcElementAssemblyTypeEnum.SLAB_FIELD = "SLAB_FIELD";
IfcElementAssemblyTypeEnum.TRUSS = "TRUSS";
IfcElementAssemblyTypeEnum.ABUTMENT = "ABUTMENT";
IfcElementAssemblyTypeEnum.PIER = "PIER";
IfcElementAssemblyTypeEnum.PYLON = "PYLON";
IfcElementAssemblyTypeEnum.CROSS_BRACING = "CROSS_BRACING";
IfcElementAssemblyTypeEnum.DECK = "DECK";
IfcElementAssemblyTypeEnum.USERDEFINED = "USERDEFINED";
IfcElementAssemblyTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcElementCompositionEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcElementCompositionEnum");
IfcElementCompositionEnum.COMPLEX = "COMPLEX";
IfcElementCompositionEnum.ELEMENT = "ELEMENT";
IfcElementCompositionEnum.PARTIAL = "PARTIAL";
var IfcEngineTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcEngineTypeEnum");
IfcEngineTypeEnum.EXTERNALCOMBUSTION = "EXTERNALCOMBUSTION";
IfcEngineTypeEnum.INTERNALCOMBUSTION = "INTERNALCOMBUSTION";
IfcEngineTypeEnum.USERDEFINED = "USERDEFINED";
IfcEngineTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcEvaporativeCoolerTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcEvaporativeCoolerTypeEnum");
IfcEvaporativeCoolerTypeEnum.DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER = "DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER";
IfcEvaporativeCoolerTypeEnum.DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER = "DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER";
IfcEvaporativeCoolerTypeEnum.DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER = "DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER";
IfcEvaporativeCoolerTypeEnum.DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER = "DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER";
IfcEvaporativeCoolerTypeEnum.DIRECTEVAPORATIVEAIRWASHER = "DIRECTEVAPORATIVEAIRWASHER";
IfcEvaporativeCoolerTypeEnum.INDIRECTEVAPORATIVEPACKAGEAIRCOOLER = "INDIRECTEVAPORATIVEPACKAGEAIRCOOLER";
IfcEvaporativeCoolerTypeEnum.INDIRECTEVAPORATIVEWETCOIL = "INDIRECTEVAPORATIVEWETCOIL";
IfcEvaporativeCoolerTypeEnum.INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER = "INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER";
IfcEvaporativeCoolerTypeEnum.INDIRECTDIRECTCOMBINATION = "INDIRECTDIRECTCOMBINATION";
IfcEvaporativeCoolerTypeEnum.USERDEFINED = "USERDEFINED";
IfcEvaporativeCoolerTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcEvaporatorTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcEvaporatorTypeEnum");
IfcEvaporatorTypeEnum.DIRECTEXPANSION = "DIRECTEXPANSION";
IfcEvaporatorTypeEnum.DIRECTEXPANSIONSHELLANDTUBE = "DIRECTEXPANSIONSHELLANDTUBE";
IfcEvaporatorTypeEnum.DIRECTEXPANSIONTUBEINTUBE = "DIRECTEXPANSIONTUBEINTUBE";
IfcEvaporatorTypeEnum.DIRECTEXPANSIONBRAZEDPLATE = "DIRECTEXPANSIONBRAZEDPLATE";
IfcEvaporatorTypeEnum.FLOODEDSHELLANDTUBE = "FLOODEDSHELLANDTUBE";
IfcEvaporatorTypeEnum.SHELLANDCOIL = "SHELLANDCOIL";
IfcEvaporatorTypeEnum.USERDEFINED = "USERDEFINED";
IfcEvaporatorTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcEventTriggerTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcEventTriggerTypeEnum");
IfcEventTriggerTypeEnum.EVENTRULE = "EVENTRULE";
IfcEventTriggerTypeEnum.EVENTMESSAGE = "EVENTMESSAGE";
IfcEventTriggerTypeEnum.EVENTTIME = "EVENTTIME";
IfcEventTriggerTypeEnum.EVENTCOMPLEX = "EVENTCOMPLEX";
IfcEventTriggerTypeEnum.USERDEFINED = "USERDEFINED";
IfcEventTriggerTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcEventTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcEventTypeEnum");
IfcEventTypeEnum.STARTEVENT = "STARTEVENT";
IfcEventTypeEnum.ENDEVENT = "ENDEVENT";
IfcEventTypeEnum.INTERMEDIATEEVENT = "INTERMEDIATEEVENT";
IfcEventTypeEnum.USERDEFINED = "USERDEFINED";
IfcEventTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcExternalSpatialElementTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcExternalSpatialElementTypeEnum");
IfcExternalSpatialElementTypeEnum.EXTERNAL = "EXTERNAL";
IfcExternalSpatialElementTypeEnum.EXTERNAL_EARTH = "EXTERNAL_EARTH";
IfcExternalSpatialElementTypeEnum.EXTERNAL_WATER = "EXTERNAL_WATER";
IfcExternalSpatialElementTypeEnum.EXTERNAL_FIRE = "EXTERNAL_FIRE";
IfcExternalSpatialElementTypeEnum.USERDEFINED = "USERDEFINED";
IfcExternalSpatialElementTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcFanTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcFanTypeEnum");
IfcFanTypeEnum.CENTRIFUGALFORWARDCURVED = "CENTRIFUGALFORWARDCURVED";
IfcFanTypeEnum.CENTRIFUGALRADIAL = "CENTRIFUGALRADIAL";
IfcFanTypeEnum.CENTRIFUGALBACKWARDINCLINEDCURVED = "CENTRIFUGALBACKWARDINCLINEDCURVED";
IfcFanTypeEnum.CENTRIFUGALAIRFOIL = "CENTRIFUGALAIRFOIL";
IfcFanTypeEnum.TUBEAXIAL = "TUBEAXIAL";
IfcFanTypeEnum.VANEAXIAL = "VANEAXIAL";
IfcFanTypeEnum.PROPELLORAXIAL = "PROPELLORAXIAL";
IfcFanTypeEnum.USERDEFINED = "USERDEFINED";
IfcFanTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcFastenerTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcFastenerTypeEnum");
IfcFastenerTypeEnum.GLUE = "GLUE";
IfcFastenerTypeEnum.MORTAR = "MORTAR";
IfcFastenerTypeEnum.WELD = "WELD";
IfcFastenerTypeEnum.USERDEFINED = "USERDEFINED";
IfcFastenerTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcFilterTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcFilterTypeEnum");
IfcFilterTypeEnum.AIRPARTICLEFILTER = "AIRPARTICLEFILTER";
IfcFilterTypeEnum.COMPRESSEDAIRFILTER = "COMPRESSEDAIRFILTER";
IfcFilterTypeEnum.ODORFILTER = "ODORFILTER";
IfcFilterTypeEnum.OILFILTER = "OILFILTER";
IfcFilterTypeEnum.STRAINER = "STRAINER";
IfcFilterTypeEnum.WATERFILTER = "WATERFILTER";
IfcFilterTypeEnum.USERDEFINED = "USERDEFINED";
IfcFilterTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcFireSuppressionTerminalTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcFireSuppressionTerminalTypeEnum");
IfcFireSuppressionTerminalTypeEnum.BREECHINGINLET = "BREECHINGINLET";
IfcFireSuppressionTerminalTypeEnum.FIREHYDRANT = "FIREHYDRANT";
IfcFireSuppressionTerminalTypeEnum.HOSEREEL = "HOSEREEL";
IfcFireSuppressionTerminalTypeEnum.SPRINKLER = "SPRINKLER";
IfcFireSuppressionTerminalTypeEnum.SPRINKLERDEFLECTOR = "SPRINKLERDEFLECTOR";
IfcFireSuppressionTerminalTypeEnum.USERDEFINED = "USERDEFINED";
IfcFireSuppressionTerminalTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcFlowDirectionEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcFlowDirectionEnum");
IfcFlowDirectionEnum.SOURCE = "SOURCE";
IfcFlowDirectionEnum.SINK = "SINK";
IfcFlowDirectionEnum.SOURCEANDSINK = "SOURCEANDSINK";
IfcFlowDirectionEnum.NOTDEFINED = "NOTDEFINED";
var IfcFlowInstrumentTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcFlowInstrumentTypeEnum");
IfcFlowInstrumentTypeEnum.PRESSUREGAUGE = "PRESSUREGAUGE";
IfcFlowInstrumentTypeEnum.THERMOMETER = "THERMOMETER";
IfcFlowInstrumentTypeEnum.AMMETER = "AMMETER";
IfcFlowInstrumentTypeEnum.FREQUENCYMETER = "FREQUENCYMETER";
IfcFlowInstrumentTypeEnum.POWERFACTORMETER = "POWERFACTORMETER";
IfcFlowInstrumentTypeEnum.PHASEANGLEMETER = "PHASEANGLEMETER";
IfcFlowInstrumentTypeEnum.VOLTMETER_PEAK = "VOLTMETER_PEAK";
IfcFlowInstrumentTypeEnum.VOLTMETER_RMS = "VOLTMETER_RMS";
IfcFlowInstrumentTypeEnum.USERDEFINED = "USERDEFINED";
IfcFlowInstrumentTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcFlowMeterTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcFlowMeterTypeEnum");
IfcFlowMeterTypeEnum.ENERGYMETER = "ENERGYMETER";
IfcFlowMeterTypeEnum.GASMETER = "GASMETER";
IfcFlowMeterTypeEnum.OILMETER = "OILMETER";
IfcFlowMeterTypeEnum.WATERMETER = "WATERMETER";
IfcFlowMeterTypeEnum.USERDEFINED = "USERDEFINED";
IfcFlowMeterTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcFootingTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcFootingTypeEnum");
IfcFootingTypeEnum.CAISSON_FOUNDATION = "CAISSON_FOUNDATION";
IfcFootingTypeEnum.FOOTING_BEAM = "FOOTING_BEAM";
IfcFootingTypeEnum.PAD_FOOTING = "PAD_FOOTING";
IfcFootingTypeEnum.PILE_CAP = "PILE_CAP";
IfcFootingTypeEnum.STRIP_FOOTING = "STRIP_FOOTING";
IfcFootingTypeEnum.USERDEFINED = "USERDEFINED";
IfcFootingTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcFurnitureTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcFurnitureTypeEnum");
IfcFurnitureTypeEnum.CHAIR = "CHAIR";
IfcFurnitureTypeEnum.TABLE = "TABLE";
IfcFurnitureTypeEnum.DESK = "DESK";
IfcFurnitureTypeEnum.BED = "BED";
IfcFurnitureTypeEnum.FILECABINET = "FILECABINET";
IfcFurnitureTypeEnum.SHELF = "SHELF";
IfcFurnitureTypeEnum.SOFA = "SOFA";
IfcFurnitureTypeEnum.USERDEFINED = "USERDEFINED";
IfcFurnitureTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcGeographicElementTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcGeographicElementTypeEnum");
IfcGeographicElementTypeEnum.TERRAIN = "TERRAIN";
IfcGeographicElementTypeEnum.SOIL_BORING_POINT = "SOIL_BORING_POINT";
IfcGeographicElementTypeEnum.USERDEFINED = "USERDEFINED";
IfcGeographicElementTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcGeometricProjectionEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcGeometricProjectionEnum");
IfcGeometricProjectionEnum.GRAPH_VIEW = "GRAPH_VIEW";
IfcGeometricProjectionEnum.SKETCH_VIEW = "SKETCH_VIEW";
IfcGeometricProjectionEnum.MODEL_VIEW = "MODEL_VIEW";
IfcGeometricProjectionEnum.PLAN_VIEW = "PLAN_VIEW";
IfcGeometricProjectionEnum.REFLECTED_PLAN_VIEW = "REFLECTED_PLAN_VIEW";
IfcGeometricProjectionEnum.SECTION_VIEW = "SECTION_VIEW";
IfcGeometricProjectionEnum.ELEVATION_VIEW = "ELEVATION_VIEW";
IfcGeometricProjectionEnum.USERDEFINED = "USERDEFINED";
IfcGeometricProjectionEnum.NOTDEFINED = "NOTDEFINED";
var IfcGlobalOrLocalEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcGlobalOrLocalEnum");
IfcGlobalOrLocalEnum.GLOBAL_COORDS = "GLOBAL_COORDS";
IfcGlobalOrLocalEnum.LOCAL_COORDS = "LOCAL_COORDS";
var IfcGridTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcGridTypeEnum");
IfcGridTypeEnum.RECTANGULAR = "RECTANGULAR";
IfcGridTypeEnum.RADIAL = "RADIAL";
IfcGridTypeEnum.TRIANGULAR = "TRIANGULAR";
IfcGridTypeEnum.IRREGULAR = "IRREGULAR";
IfcGridTypeEnum.USERDEFINED = "USERDEFINED";
IfcGridTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcHeatExchangerTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcHeatExchangerTypeEnum");
IfcHeatExchangerTypeEnum.PLATE = "PLATE";
IfcHeatExchangerTypeEnum.SHELLANDTUBE = "SHELLANDTUBE";
IfcHeatExchangerTypeEnum.USERDEFINED = "USERDEFINED";
IfcHeatExchangerTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcHumidifierTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcHumidifierTypeEnum");
IfcHumidifierTypeEnum.STEAMINJECTION = "STEAMINJECTION";
IfcHumidifierTypeEnum.ADIABATICAIRWASHER = "ADIABATICAIRWASHER";
IfcHumidifierTypeEnum.ADIABATICPAN = "ADIABATICPAN";
IfcHumidifierTypeEnum.ADIABATICWETTEDELEMENT = "ADIABATICWETTEDELEMENT";
IfcHumidifierTypeEnum.ADIABATICATOMIZING = "ADIABATICATOMIZING";
IfcHumidifierTypeEnum.ADIABATICULTRASONIC = "ADIABATICULTRASONIC";
IfcHumidifierTypeEnum.ADIABATICRIGIDMEDIA = "ADIABATICRIGIDMEDIA";
IfcHumidifierTypeEnum.ADIABATICCOMPRESSEDAIRNOZZLE = "ADIABATICCOMPRESSEDAIRNOZZLE";
IfcHumidifierTypeEnum.ASSISTEDELECTRIC = "ASSISTEDELECTRIC";
IfcHumidifierTypeEnum.ASSISTEDNATURALGAS = "ASSISTEDNATURALGAS";
IfcHumidifierTypeEnum.ASSISTEDPROPANE = "ASSISTEDPROPANE";
IfcHumidifierTypeEnum.ASSISTEDBUTANE = "ASSISTEDBUTANE";
IfcHumidifierTypeEnum.ASSISTEDSTEAM = "ASSISTEDSTEAM";
IfcHumidifierTypeEnum.USERDEFINED = "USERDEFINED";
IfcHumidifierTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcInterceptorTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcInterceptorTypeEnum");
IfcInterceptorTypeEnum.CYCLONIC = "CYCLONIC";
IfcInterceptorTypeEnum.GREASE = "GREASE";
IfcInterceptorTypeEnum.OIL = "OIL";
IfcInterceptorTypeEnum.PETROL = "PETROL";
IfcInterceptorTypeEnum.USERDEFINED = "USERDEFINED";
IfcInterceptorTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcInternalOrExternalEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcInternalOrExternalEnum");
IfcInternalOrExternalEnum.INTERNAL = "INTERNAL";
IfcInternalOrExternalEnum.EXTERNAL = "EXTERNAL";
IfcInternalOrExternalEnum.EXTERNAL_EARTH = "EXTERNAL_EARTH";
IfcInternalOrExternalEnum.EXTERNAL_WATER = "EXTERNAL_WATER";
IfcInternalOrExternalEnum.EXTERNAL_FIRE = "EXTERNAL_FIRE";
IfcInternalOrExternalEnum.NOTDEFINED = "NOTDEFINED";
var IfcInventoryTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcInventoryTypeEnum");
IfcInventoryTypeEnum.ASSETINVENTORY = "ASSETINVENTORY";
IfcInventoryTypeEnum.SPACEINVENTORY = "SPACEINVENTORY";
IfcInventoryTypeEnum.FURNITUREINVENTORY = "FURNITUREINVENTORY";
IfcInventoryTypeEnum.USERDEFINED = "USERDEFINED";
IfcInventoryTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcJunctionBoxTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcJunctionBoxTypeEnum");
IfcJunctionBoxTypeEnum.DATA = "DATA";
IfcJunctionBoxTypeEnum.POWER = "POWER";
IfcJunctionBoxTypeEnum.USERDEFINED = "USERDEFINED";
IfcJunctionBoxTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcKnotType = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcKnotType");
IfcKnotType.UNIFORM_KNOTS = "UNIFORM_KNOTS";
IfcKnotType.QUASI_UNIFORM_KNOTS = "QUASI_UNIFORM_KNOTS";
IfcKnotType.PIECEWISE_BEZIER_KNOTS = "PIECEWISE_BEZIER_KNOTS";
IfcKnotType.UNSPECIFIED = "UNSPECIFIED";
var IfcLaborResourceTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcLaborResourceTypeEnum");
IfcLaborResourceTypeEnum.ADMINISTRATION = "ADMINISTRATION";
IfcLaborResourceTypeEnum.CARPENTRY = "CARPENTRY";
IfcLaborResourceTypeEnum.CLEANING = "CLEANING";
IfcLaborResourceTypeEnum.CONCRETE = "CONCRETE";
IfcLaborResourceTypeEnum.DRYWALL = "DRYWALL";
IfcLaborResourceTypeEnum.ELECTRIC = "ELECTRIC";
IfcLaborResourceTypeEnum.FINISHING = "FINISHING";
IfcLaborResourceTypeEnum.FLOORING = "FLOORING";
IfcLaborResourceTypeEnum.GENERAL = "GENERAL";
IfcLaborResourceTypeEnum.HVAC = "HVAC";
IfcLaborResourceTypeEnum.LANDSCAPING = "LANDSCAPING";
IfcLaborResourceTypeEnum.MASONRY = "MASONRY";
IfcLaborResourceTypeEnum.PAINTING = "PAINTING";
IfcLaborResourceTypeEnum.PAVING = "PAVING";
IfcLaborResourceTypeEnum.PLUMBING = "PLUMBING";
IfcLaborResourceTypeEnum.ROOFING = "ROOFING";
IfcLaborResourceTypeEnum.SITEGRADING = "SITEGRADING";
IfcLaborResourceTypeEnum.STEELWORK = "STEELWORK";
IfcLaborResourceTypeEnum.SURVEYING = "SURVEYING";
IfcLaborResourceTypeEnum.USERDEFINED = "USERDEFINED";
IfcLaborResourceTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcLampTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcLampTypeEnum");
IfcLampTypeEnum.COMPACTFLUORESCENT = "COMPACTFLUORESCENT";
IfcLampTypeEnum.FLUORESCENT = "FLUORESCENT";
IfcLampTypeEnum.HALOGEN = "HALOGEN";
IfcLampTypeEnum.HIGHPRESSUREMERCURY = "HIGHPRESSUREMERCURY";
IfcLampTypeEnum.HIGHPRESSURESODIUM = "HIGHPRESSURESODIUM";
IfcLampTypeEnum.LED = "LED";
IfcLampTypeEnum.METALHALIDE = "METALHALIDE";
IfcLampTypeEnum.OLED = "OLED";
IfcLampTypeEnum.TUNGSTENFILAMENT = "TUNGSTENFILAMENT";
IfcLampTypeEnum.USERDEFINED = "USERDEFINED";
IfcLampTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcLayerSetDirectionEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcLayerSetDirectionEnum");
IfcLayerSetDirectionEnum.AXIS1 = "AXIS1";
IfcLayerSetDirectionEnum.AXIS2 = "AXIS2";
IfcLayerSetDirectionEnum.AXIS3 = "AXIS3";
var IfcLightDistributionCurveEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcLightDistributionCurveEnum");
IfcLightDistributionCurveEnum.TYPE_A = "TYPE_A";
IfcLightDistributionCurveEnum.TYPE_B = "TYPE_B";
IfcLightDistributionCurveEnum.TYPE_C = "TYPE_C";
IfcLightDistributionCurveEnum.NOTDEFINED = "NOTDEFINED";
var IfcLightEmissionSourceEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcLightEmissionSourceEnum");
IfcLightEmissionSourceEnum.COMPACTFLUORESCENT = "COMPACTFLUORESCENT";
IfcLightEmissionSourceEnum.FLUORESCENT = "FLUORESCENT";
IfcLightEmissionSourceEnum.HIGHPRESSUREMERCURY = "HIGHPRESSUREMERCURY";
IfcLightEmissionSourceEnum.HIGHPRESSURESODIUM = "HIGHPRESSURESODIUM";
IfcLightEmissionSourceEnum.LIGHTEMITTINGDIODE = "LIGHTEMITTINGDIODE";
IfcLightEmissionSourceEnum.LOWPRESSURESODIUM = "LOWPRESSURESODIUM";
IfcLightEmissionSourceEnum.LOWVOLTAGEHALOGEN = "LOWVOLTAGEHALOGEN";
IfcLightEmissionSourceEnum.MAINVOLTAGEHALOGEN = "MAINVOLTAGEHALOGEN";
IfcLightEmissionSourceEnum.METALHALIDE = "METALHALIDE";
IfcLightEmissionSourceEnum.TUNGSTENFILAMENT = "TUNGSTENFILAMENT";
IfcLightEmissionSourceEnum.NOTDEFINED = "NOTDEFINED";
var IfcLightFixtureTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcLightFixtureTypeEnum");
IfcLightFixtureTypeEnum.POINTSOURCE = "POINTSOURCE";
IfcLightFixtureTypeEnum.DIRECTIONSOURCE = "DIRECTIONSOURCE";
IfcLightFixtureTypeEnum.SECURITYLIGHTING = "SECURITYLIGHTING";
IfcLightFixtureTypeEnum.USERDEFINED = "USERDEFINED";
IfcLightFixtureTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcLoadGroupTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcLoadGroupTypeEnum");
IfcLoadGroupTypeEnum.LOAD_GROUP = "LOAD_GROUP";
IfcLoadGroupTypeEnum.LOAD_CASE = "LOAD_CASE";
IfcLoadGroupTypeEnum.LOAD_COMBINATION = "LOAD_COMBINATION";
IfcLoadGroupTypeEnum.USERDEFINED = "USERDEFINED";
IfcLoadGroupTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcLogicalOperatorEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcLogicalOperatorEnum");
IfcLogicalOperatorEnum.LOGICALAND = "LOGICALAND";
IfcLogicalOperatorEnum.LOGICALOR = "LOGICALOR";
IfcLogicalOperatorEnum.LOGICALXOR = "LOGICALXOR";
IfcLogicalOperatorEnum.LOGICALNOTAND = "LOGICALNOTAND";
IfcLogicalOperatorEnum.LOGICALNOTOR = "LOGICALNOTOR";
var IfcMechanicalFastenerTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcMechanicalFastenerTypeEnum");
IfcMechanicalFastenerTypeEnum.ANCHORBOLT = "ANCHORBOLT";
IfcMechanicalFastenerTypeEnum.BOLT = "BOLT";
IfcMechanicalFastenerTypeEnum.DOWEL = "DOWEL";
IfcMechanicalFastenerTypeEnum.NAIL = "NAIL";
IfcMechanicalFastenerTypeEnum.NAILPLATE = "NAILPLATE";
IfcMechanicalFastenerTypeEnum.RIVET = "RIVET";
IfcMechanicalFastenerTypeEnum.SCREW = "SCREW";
IfcMechanicalFastenerTypeEnum.SHEARCONNECTOR = "SHEARCONNECTOR";
IfcMechanicalFastenerTypeEnum.STAPLE = "STAPLE";
IfcMechanicalFastenerTypeEnum.STUDSHEARCONNECTOR = "STUDSHEARCONNECTOR";
IfcMechanicalFastenerTypeEnum.COUPLER = "COUPLER";
IfcMechanicalFastenerTypeEnum.USERDEFINED = "USERDEFINED";
IfcMechanicalFastenerTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcMedicalDeviceTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcMedicalDeviceTypeEnum");
IfcMedicalDeviceTypeEnum.AIRSTATION = "AIRSTATION";
IfcMedicalDeviceTypeEnum.FEEDAIRUNIT = "FEEDAIRUNIT";
IfcMedicalDeviceTypeEnum.OXYGENGENERATOR = "OXYGENGENERATOR";
IfcMedicalDeviceTypeEnum.OXYGENPLANT = "OXYGENPLANT";
IfcMedicalDeviceTypeEnum.VACUUMSTATION = "VACUUMSTATION";
IfcMedicalDeviceTypeEnum.USERDEFINED = "USERDEFINED";
IfcMedicalDeviceTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcMemberTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcMemberTypeEnum");
IfcMemberTypeEnum.BRACE = "BRACE";
IfcMemberTypeEnum.CHORD = "CHORD";
IfcMemberTypeEnum.COLLAR = "COLLAR";
IfcMemberTypeEnum.MEMBER = "MEMBER";
IfcMemberTypeEnum.MULLION = "MULLION";
IfcMemberTypeEnum.PLATE = "PLATE";
IfcMemberTypeEnum.POST = "POST";
IfcMemberTypeEnum.PURLIN = "PURLIN";
IfcMemberTypeEnum.RAFTER = "RAFTER";
IfcMemberTypeEnum.STRINGER = "STRINGER";
IfcMemberTypeEnum.STRUT = "STRUT";
IfcMemberTypeEnum.STUD = "STUD";
IfcMemberTypeEnum.STIFFENING_RIB = "STIFFENING_RIB";
IfcMemberTypeEnum.ARCH_SEGMENT = "ARCH_SEGMENT";
IfcMemberTypeEnum.SUSPENSION_CABLE = "SUSPENSION_CABLE";
IfcMemberTypeEnum.SUSPENDER = "SUSPENDER";
IfcMemberTypeEnum.STAY_CABLE = "STAY_CABLE";
IfcMemberTypeEnum.USERDEFINED = "USERDEFINED";
IfcMemberTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcMotorConnectionTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcMotorConnectionTypeEnum");
IfcMotorConnectionTypeEnum.BELTDRIVE = "BELTDRIVE";
IfcMotorConnectionTypeEnum.COUPLING = "COUPLING";
IfcMotorConnectionTypeEnum.DIRECTDRIVE = "DIRECTDRIVE";
IfcMotorConnectionTypeEnum.USERDEFINED = "USERDEFINED";
IfcMotorConnectionTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcNullStyle = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcNullStyle");
IfcNullStyle.NULL = "NULL";
var IfcObjectTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcObjectTypeEnum");
IfcObjectTypeEnum.PRODUCT = "PRODUCT";
IfcObjectTypeEnum.PROCESS = "PROCESS";
IfcObjectTypeEnum.CONTROL = "CONTROL";
IfcObjectTypeEnum.RESOURCE = "RESOURCE";
IfcObjectTypeEnum.ACTOR = "ACTOR";
IfcObjectTypeEnum.GROUP = "GROUP";
IfcObjectTypeEnum.PROJECT = "PROJECT";
IfcObjectTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcObjectiveEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcObjectiveEnum");
IfcObjectiveEnum.CODECOMPLIANCE = "CODECOMPLIANCE";
IfcObjectiveEnum.CODEWAIVER = "CODEWAIVER";
IfcObjectiveEnum.DESIGNINTENT = "DESIGNINTENT";
IfcObjectiveEnum.EXTERNAL = "EXTERNAL";
IfcObjectiveEnum.HEALTHANDSAFETY = "HEALTHANDSAFETY";
IfcObjectiveEnum.MERGECONFLICT = "MERGECONFLICT";
IfcObjectiveEnum.MODELVIEW = "MODELVIEW";
IfcObjectiveEnum.PARAMETER = "PARAMETER";
IfcObjectiveEnum.REQUIREMENT = "REQUIREMENT";
IfcObjectiveEnum.SPECIFICATION = "SPECIFICATION";
IfcObjectiveEnum.TRIGGERCONDITION = "TRIGGERCONDITION";
IfcObjectiveEnum.USERDEFINED = "USERDEFINED";
IfcObjectiveEnum.NOTDEFINED = "NOTDEFINED";
var IfcOccupantTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcOccupantTypeEnum");
IfcOccupantTypeEnum.ASSIGNEE = "ASSIGNEE";
IfcOccupantTypeEnum.ASSIGNOR = "ASSIGNOR";
IfcOccupantTypeEnum.LESSEE = "LESSEE";
IfcOccupantTypeEnum.LESSOR = "LESSOR";
IfcOccupantTypeEnum.LETTINGAGENT = "LETTINGAGENT";
IfcOccupantTypeEnum.OWNER = "OWNER";
IfcOccupantTypeEnum.TENANT = "TENANT";
IfcOccupantTypeEnum.USERDEFINED = "USERDEFINED";
IfcOccupantTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcOpeningElementTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcOpeningElementTypeEnum");
IfcOpeningElementTypeEnum.OPENING = "OPENING";
IfcOpeningElementTypeEnum.RECESS = "RECESS";
IfcOpeningElementTypeEnum.USERDEFINED = "USERDEFINED";
IfcOpeningElementTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcOutletTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcOutletTypeEnum");
IfcOutletTypeEnum.AUDIOVISUALOUTLET = "AUDIOVISUALOUTLET";
IfcOutletTypeEnum.COMMUNICATIONSOUTLET = "COMMUNICATIONSOUTLET";
IfcOutletTypeEnum.POWEROUTLET = "POWEROUTLET";
IfcOutletTypeEnum.DATAOUTLET = "DATAOUTLET";
IfcOutletTypeEnum.TELEPHONEOUTLET = "TELEPHONEOUTLET";
IfcOutletTypeEnum.USERDEFINED = "USERDEFINED";
IfcOutletTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcPerformanceHistoryTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcPerformanceHistoryTypeEnum");
IfcPerformanceHistoryTypeEnum.USERDEFINED = "USERDEFINED";
IfcPerformanceHistoryTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcPermeableCoveringOperationEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcPermeableCoveringOperationEnum");
IfcPermeableCoveringOperationEnum.GRILL = "GRILL";
IfcPermeableCoveringOperationEnum.LOUVER = "LOUVER";
IfcPermeableCoveringOperationEnum.SCREEN = "SCREEN";
IfcPermeableCoveringOperationEnum.USERDEFINED = "USERDEFINED";
IfcPermeableCoveringOperationEnum.NOTDEFINED = "NOTDEFINED";
var IfcPermitTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcPermitTypeEnum");
IfcPermitTypeEnum.ACCESS = "ACCESS";
IfcPermitTypeEnum.BUILDING = "BUILDING";
IfcPermitTypeEnum.WORK = "WORK";
IfcPermitTypeEnum.USERDEFINED = "USERDEFINED";
IfcPermitTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcPhysicalOrVirtualEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcPhysicalOrVirtualEnum");
IfcPhysicalOrVirtualEnum.PHYSICAL = "PHYSICAL";
IfcPhysicalOrVirtualEnum.VIRTUAL = "VIRTUAL";
IfcPhysicalOrVirtualEnum.NOTDEFINED = "NOTDEFINED";
var IfcPileConstructionEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcPileConstructionEnum");
IfcPileConstructionEnum.CAST_IN_PLACE = "CAST_IN_PLACE";
IfcPileConstructionEnum.COMPOSITE = "COMPOSITE";
IfcPileConstructionEnum.PRECAST_CONCRETE = "PRECAST_CONCRETE";
IfcPileConstructionEnum.PREFAB_STEEL = "PREFAB_STEEL";
IfcPileConstructionEnum.USERDEFINED = "USERDEFINED";
IfcPileConstructionEnum.NOTDEFINED = "NOTDEFINED";
var IfcPileTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcPileTypeEnum");
IfcPileTypeEnum.BORED = "BORED";
IfcPileTypeEnum.DRIVEN = "DRIVEN";
IfcPileTypeEnum.JETGROUTING = "JETGROUTING";
IfcPileTypeEnum.COHESION = "COHESION";
IfcPileTypeEnum.FRICTION = "FRICTION";
IfcPileTypeEnum.SUPPORT = "SUPPORT";
IfcPileTypeEnum.USERDEFINED = "USERDEFINED";
IfcPileTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcPipeFittingTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcPipeFittingTypeEnum");
IfcPipeFittingTypeEnum.BEND = "BEND";
IfcPipeFittingTypeEnum.CONNECTOR = "CONNECTOR";
IfcPipeFittingTypeEnum.ENTRY = "ENTRY";
IfcPipeFittingTypeEnum.EXIT = "EXIT";
IfcPipeFittingTypeEnum.JUNCTION = "JUNCTION";
IfcPipeFittingTypeEnum.OBSTRUCTION = "OBSTRUCTION";
IfcPipeFittingTypeEnum.TRANSITION = "TRANSITION";
IfcPipeFittingTypeEnum.USERDEFINED = "USERDEFINED";
IfcPipeFittingTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcPipeSegmentTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcPipeSegmentTypeEnum");
IfcPipeSegmentTypeEnum.CULVERT = "CULVERT";
IfcPipeSegmentTypeEnum.FLEXIBLESEGMENT = "FLEXIBLESEGMENT";
IfcPipeSegmentTypeEnum.RIGIDSEGMENT = "RIGIDSEGMENT";
IfcPipeSegmentTypeEnum.GUTTER = "GUTTER";
IfcPipeSegmentTypeEnum.SPOOL = "SPOOL";
IfcPipeSegmentTypeEnum.USERDEFINED = "USERDEFINED";
IfcPipeSegmentTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcPlateTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcPlateTypeEnum");
IfcPlateTypeEnum.CURTAIN_PANEL = "CURTAIN_PANEL";
IfcPlateTypeEnum.SHEET = "SHEET";
IfcPlateTypeEnum.FLANGE_PLATE = "FLANGE_PLATE";
IfcPlateTypeEnum.WEB_PLATE = "WEB_PLATE";
IfcPlateTypeEnum.STIFFENER_PLATE = "STIFFENER_PLATE";
IfcPlateTypeEnum.GUSSET_PLATE = "GUSSET_PLATE";
IfcPlateTypeEnum.COVER_PLATE = "COVER_PLATE";
IfcPlateTypeEnum.SPLICE_PLATE = "SPLICE_PLATE";
IfcPlateTypeEnum.BASE_PLATE = "BASE_PLATE";
IfcPlateTypeEnum.USERDEFINED = "USERDEFINED";
IfcPlateTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcPreferredSurfaceCurveRepresentation = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcPreferredSurfaceCurveRepresentation");
IfcPreferredSurfaceCurveRepresentation.CURVE3D = "CURVE3D";
IfcPreferredSurfaceCurveRepresentation.PCURVE_S1 = "PCURVE_S1";
IfcPreferredSurfaceCurveRepresentation.PCURVE_S2 = "PCURVE_S2";
var IfcProcedureTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcProcedureTypeEnum");
IfcProcedureTypeEnum.ADVICE_CAUTION = "ADVICE_CAUTION";
IfcProcedureTypeEnum.ADVICE_NOTE = "ADVICE_NOTE";
IfcProcedureTypeEnum.ADVICE_WARNING = "ADVICE_WARNING";
IfcProcedureTypeEnum.CALIBRATION = "CALIBRATION";
IfcProcedureTypeEnum.DIAGNOSTIC = "DIAGNOSTIC";
IfcProcedureTypeEnum.SHUTDOWN = "SHUTDOWN";
IfcProcedureTypeEnum.STARTUP = "STARTUP";
IfcProcedureTypeEnum.USERDEFINED = "USERDEFINED";
IfcProcedureTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcProfileTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcProfileTypeEnum");
IfcProfileTypeEnum.CURVE = "CURVE";
IfcProfileTypeEnum.AREA = "AREA";
var IfcProjectOrderTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcProjectOrderTypeEnum");
IfcProjectOrderTypeEnum.CHANGEORDER = "CHANGEORDER";
IfcProjectOrderTypeEnum.MAINTENANCEWORKORDER = "MAINTENANCEWORKORDER";
IfcProjectOrderTypeEnum.MOVEORDER = "MOVEORDER";
IfcProjectOrderTypeEnum.PURCHASEORDER = "PURCHASEORDER";
IfcProjectOrderTypeEnum.WORKORDER = "WORKORDER";
IfcProjectOrderTypeEnum.USERDEFINED = "USERDEFINED";
IfcProjectOrderTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcProjectedOrTrueLengthEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcProjectedOrTrueLengthEnum");
IfcProjectedOrTrueLengthEnum.PROJECTED_LENGTH = "PROJECTED_LENGTH";
IfcProjectedOrTrueLengthEnum.TRUE_LENGTH = "TRUE_LENGTH";
var IfcProjectionElementTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcProjectionElementTypeEnum");
IfcProjectionElementTypeEnum.BLISTER = "BLISTER";
IfcProjectionElementTypeEnum.DEVIATOR = "DEVIATOR";
IfcProjectionElementTypeEnum.USERDEFINED = "USERDEFINED";
IfcProjectionElementTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcPropertySetTemplateTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcPropertySetTemplateTypeEnum");
IfcPropertySetTemplateTypeEnum.PSET_TYPEDRIVENONLY = "PSET_TYPEDRIVENONLY";
IfcPropertySetTemplateTypeEnum.PSET_TYPEDRIVENOVERRIDE = "PSET_TYPEDRIVENOVERRIDE";
IfcPropertySetTemplateTypeEnum.PSET_OCCURRENCEDRIVEN = "PSET_OCCURRENCEDRIVEN";
IfcPropertySetTemplateTypeEnum.PSET_PERFORMANCEDRIVEN = "PSET_PERFORMANCEDRIVEN";
IfcPropertySetTemplateTypeEnum.QTO_TYPEDRIVENONLY = "QTO_TYPEDRIVENONLY";
IfcPropertySetTemplateTypeEnum.QTO_TYPEDRIVENOVERRIDE = "QTO_TYPEDRIVENOVERRIDE";
IfcPropertySetTemplateTypeEnum.QTO_OCCURRENCEDRIVEN = "QTO_OCCURRENCEDRIVEN";
IfcPropertySetTemplateTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcProtectiveDeviceTrippingUnitTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcProtectiveDeviceTrippingUnitTypeEnum");
IfcProtectiveDeviceTrippingUnitTypeEnum.ELECTRONIC = "ELECTRONIC";
IfcProtectiveDeviceTrippingUnitTypeEnum.ELECTROMAGNETIC = "ELECTROMAGNETIC";
IfcProtectiveDeviceTrippingUnitTypeEnum.RESIDUALCURRENT = "RESIDUALCURRENT";
IfcProtectiveDeviceTrippingUnitTypeEnum.THERMAL = "THERMAL";
IfcProtectiveDeviceTrippingUnitTypeEnum.USERDEFINED = "USERDEFINED";
IfcProtectiveDeviceTrippingUnitTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcProtectiveDeviceTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcProtectiveDeviceTypeEnum");
IfcProtectiveDeviceTypeEnum.CIRCUITBREAKER = "CIRCUITBREAKER";
IfcProtectiveDeviceTypeEnum.EARTHLEAKAGECIRCUITBREAKER = "EARTHLEAKAGECIRCUITBREAKER";
IfcProtectiveDeviceTypeEnum.EARTHINGSWITCH = "EARTHINGSWITCH";
IfcProtectiveDeviceTypeEnum.FUSEDISCONNECTOR = "FUSEDISCONNECTOR";
IfcProtectiveDeviceTypeEnum.RESIDUALCURRENTCIRCUITBREAKER = "RESIDUALCURRENTCIRCUITBREAKER";
IfcProtectiveDeviceTypeEnum.RESIDUALCURRENTSWITCH = "RESIDUALCURRENTSWITCH";
IfcProtectiveDeviceTypeEnum.VARISTOR = "VARISTOR";
IfcProtectiveDeviceTypeEnum.USERDEFINED = "USERDEFINED";
IfcProtectiveDeviceTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcPumpTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcPumpTypeEnum");
IfcPumpTypeEnum.CIRCULATOR = "CIRCULATOR";
IfcPumpTypeEnum.ENDSUCTION = "ENDSUCTION";
IfcPumpTypeEnum.SPLITCASE = "SPLITCASE";
IfcPumpTypeEnum.SUBMERSIBLEPUMP = "SUBMERSIBLEPUMP";
IfcPumpTypeEnum.SUMPPUMP = "SUMPPUMP";
IfcPumpTypeEnum.VERTICALINLINE = "VERTICALINLINE";
IfcPumpTypeEnum.VERTICALTURBINE = "VERTICALTURBINE";
IfcPumpTypeEnum.USERDEFINED = "USERDEFINED";
IfcPumpTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcRailingTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcRailingTypeEnum");
IfcRailingTypeEnum.HANDRAIL = "HANDRAIL";
IfcRailingTypeEnum.GUARDRAIL = "GUARDRAIL";
IfcRailingTypeEnum.BALUSTRADE = "BALUSTRADE";
IfcRailingTypeEnum.USERDEFINED = "USERDEFINED";
IfcRailingTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcRampFlightTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcRampFlightTypeEnum");
IfcRampFlightTypeEnum.STRAIGHT = "STRAIGHT";
IfcRampFlightTypeEnum.SPIRAL = "SPIRAL";
IfcRampFlightTypeEnum.USERDEFINED = "USERDEFINED";
IfcRampFlightTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcRampTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcRampTypeEnum");
IfcRampTypeEnum.STRAIGHT_RUN_RAMP = "STRAIGHT_RUN_RAMP";
IfcRampTypeEnum.TWO_STRAIGHT_RUN_RAMP = "TWO_STRAIGHT_RUN_RAMP";
IfcRampTypeEnum.QUARTER_TURN_RAMP = "QUARTER_TURN_RAMP";
IfcRampTypeEnum.TWO_QUARTER_TURN_RAMP = "TWO_QUARTER_TURN_RAMP";
IfcRampTypeEnum.HALF_TURN_RAMP = "HALF_TURN_RAMP";
IfcRampTypeEnum.SPIRAL_RAMP = "SPIRAL_RAMP";
IfcRampTypeEnum.USERDEFINED = "USERDEFINED";
IfcRampTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcRecurrenceTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcRecurrenceTypeEnum");
IfcRecurrenceTypeEnum.DAILY = "DAILY";
IfcRecurrenceTypeEnum.WEEKLY = "WEEKLY";
IfcRecurrenceTypeEnum.MONTHLY_BY_DAY_OF_MONTH = "MONTHLY_BY_DAY_OF_MONTH";
IfcRecurrenceTypeEnum.MONTHLY_BY_POSITION = "MONTHLY_BY_POSITION";
IfcRecurrenceTypeEnum.BY_DAY_COUNT = "BY_DAY_COUNT";
IfcRecurrenceTypeEnum.BY_WEEKDAY_COUNT = "BY_WEEKDAY_COUNT";
IfcRecurrenceTypeEnum.YEARLY_BY_DAY_OF_MONTH = "YEARLY_BY_DAY_OF_MONTH";
IfcRecurrenceTypeEnum.YEARLY_BY_POSITION = "YEARLY_BY_POSITION";
var IfcReferentTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcReferentTypeEnum");
IfcReferentTypeEnum.KILOPOINT = "KILOPOINT";
IfcReferentTypeEnum.MILEPOINT = "MILEPOINT";
IfcReferentTypeEnum.STATION = "STATION";
IfcReferentTypeEnum.USERDEFINED = "USERDEFINED";
IfcReferentTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcReflectanceMethodEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcReflectanceMethodEnum");
IfcReflectanceMethodEnum.BLINN = "BLINN";
IfcReflectanceMethodEnum.FLAT = "FLAT";
IfcReflectanceMethodEnum.GLASS = "GLASS";
IfcReflectanceMethodEnum.MATT = "MATT";
IfcReflectanceMethodEnum.METAL = "METAL";
IfcReflectanceMethodEnum.MIRROR = "MIRROR";
IfcReflectanceMethodEnum.PHONG = "PHONG";
IfcReflectanceMethodEnum.PLASTIC = "PLASTIC";
IfcReflectanceMethodEnum.STRAUSS = "STRAUSS";
IfcReflectanceMethodEnum.NOTDEFINED = "NOTDEFINED";
var IfcReinforcingBarRoleEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcReinforcingBarRoleEnum");
IfcReinforcingBarRoleEnum.MAIN = "MAIN";
IfcReinforcingBarRoleEnum.SHEAR = "SHEAR";
IfcReinforcingBarRoleEnum.LIGATURE = "LIGATURE";
IfcReinforcingBarRoleEnum.STUD = "STUD";
IfcReinforcingBarRoleEnum.PUNCHING = "PUNCHING";
IfcReinforcingBarRoleEnum.EDGE = "EDGE";
IfcReinforcingBarRoleEnum.RING = "RING";
IfcReinforcingBarRoleEnum.ANCHORING = "ANCHORING";
IfcReinforcingBarRoleEnum.USERDEFINED = "USERDEFINED";
IfcReinforcingBarRoleEnum.NOTDEFINED = "NOTDEFINED";
var IfcReinforcingBarSurfaceEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcReinforcingBarSurfaceEnum");
IfcReinforcingBarSurfaceEnum.PLAIN = "PLAIN";
IfcReinforcingBarSurfaceEnum.TEXTURED = "TEXTURED";
var IfcReinforcingBarTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcReinforcingBarTypeEnum");
IfcReinforcingBarTypeEnum.ANCHORING = "ANCHORING";
IfcReinforcingBarTypeEnum.EDGE = "EDGE";
IfcReinforcingBarTypeEnum.LIGATURE = "LIGATURE";
IfcReinforcingBarTypeEnum.MAIN = "MAIN";
IfcReinforcingBarTypeEnum.PUNCHING = "PUNCHING";
IfcReinforcingBarTypeEnum.RING = "RING";
IfcReinforcingBarTypeEnum.SHEAR = "SHEAR";
IfcReinforcingBarTypeEnum.STUD = "STUD";
IfcReinforcingBarTypeEnum.SPACEBAR = "SPACEBAR";
IfcReinforcingBarTypeEnum.USERDEFINED = "USERDEFINED";
IfcReinforcingBarTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcReinforcingMeshTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcReinforcingMeshTypeEnum");
IfcReinforcingMeshTypeEnum.USERDEFINED = "USERDEFINED";
IfcReinforcingMeshTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcRoleEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcRoleEnum");
IfcRoleEnum.SUPPLIER = "SUPPLIER";
IfcRoleEnum.MANUFACTURER = "MANUFACTURER";
IfcRoleEnum.CONTRACTOR = "CONTRACTOR";
IfcRoleEnum.SUBCONTRACTOR = "SUBCONTRACTOR";
IfcRoleEnum.ARCHITECT = "ARCHITECT";
IfcRoleEnum.STRUCTURALENGINEER = "STRUCTURALENGINEER";
IfcRoleEnum.COSTENGINEER = "COSTENGINEER";
IfcRoleEnum.CLIENT = "CLIENT";
IfcRoleEnum.BUILDINGOWNER = "BUILDINGOWNER";
IfcRoleEnum.BUILDINGOPERATOR = "BUILDINGOPERATOR";
IfcRoleEnum.MECHANICALENGINEER = "MECHANICALENGINEER";
IfcRoleEnum.ELECTRICALENGINEER = "ELECTRICALENGINEER";
IfcRoleEnum.PROJECTMANAGER = "PROJECTMANAGER";
IfcRoleEnum.FACILITIESMANAGER = "FACILITIESMANAGER";
IfcRoleEnum.CIVILENGINEER = "CIVILENGINEER";
IfcRoleEnum.COMMISSIONINGENGINEER = "COMMISSIONINGENGINEER";
IfcRoleEnum.ENGINEER = "ENGINEER";
IfcRoleEnum.OWNER = "OWNER";
IfcRoleEnum.CONSULTANT = "CONSULTANT";
IfcRoleEnum.CONSTRUCTIONMANAGER = "CONSTRUCTIONMANAGER";
IfcRoleEnum.FIELDCONSTRUCTIONMANAGER = "FIELDCONSTRUCTIONMANAGER";
IfcRoleEnum.RESELLER = "RESELLER";
IfcRoleEnum.USERDEFINED = "USERDEFINED";
var IfcRoofTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcRoofTypeEnum");
IfcRoofTypeEnum.FLAT_ROOF = "FLAT_ROOF";
IfcRoofTypeEnum.SHED_ROOF = "SHED_ROOF";
IfcRoofTypeEnum.GABLE_ROOF = "GABLE_ROOF";
IfcRoofTypeEnum.HIP_ROOF = "HIP_ROOF";
IfcRoofTypeEnum.HIPPED_GABLE_ROOF = "HIPPED_GABLE_ROOF";
IfcRoofTypeEnum.GAMBREL_ROOF = "GAMBREL_ROOF";
IfcRoofTypeEnum.MANSARD_ROOF = "MANSARD_ROOF";
IfcRoofTypeEnum.BARREL_ROOF = "BARREL_ROOF";
IfcRoofTypeEnum.RAINBOW_ROOF = "RAINBOW_ROOF";
IfcRoofTypeEnum.BUTTERFLY_ROOF = "BUTTERFLY_ROOF";
IfcRoofTypeEnum.PAVILION_ROOF = "PAVILION_ROOF";
IfcRoofTypeEnum.DOME_ROOF = "DOME_ROOF";
IfcRoofTypeEnum.FREEFORM = "FREEFORM";
IfcRoofTypeEnum.USERDEFINED = "USERDEFINED";
IfcRoofTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcSIPrefix = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcSIPrefix");
IfcSIPrefix.EXA = "EXA";
IfcSIPrefix.PETA = "PETA";
IfcSIPrefix.TERA = "TERA";
IfcSIPrefix.GIGA = "GIGA";
IfcSIPrefix.MEGA = "MEGA";
IfcSIPrefix.KILO = "KILO";
IfcSIPrefix.HECTO = "HECTO";
IfcSIPrefix.DECA = "DECA";
IfcSIPrefix.DECI = "DECI";
IfcSIPrefix.CENTI = "CENTI";
IfcSIPrefix.MILLI = "MILLI";
IfcSIPrefix.MICRO = "MICRO";
IfcSIPrefix.NANO = "NANO";
IfcSIPrefix.PICO = "PICO";
IfcSIPrefix.FEMTO = "FEMTO";
IfcSIPrefix.ATTO = "ATTO";
var IfcSIUnitName = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcSIUnitName");
IfcSIUnitName.AMPERE = "AMPERE";
IfcSIUnitName.BECQUEREL = "BECQUEREL";
IfcSIUnitName.CANDELA = "CANDELA";
IfcSIUnitName.COULOMB = "COULOMB";
IfcSIUnitName.CUBIC_METRE = "CUBIC_METRE";
IfcSIUnitName.DEGREE_CELSIUS = "DEGREE_CELSIUS";
IfcSIUnitName.FARAD = "FARAD";
IfcSIUnitName.GRAM = "GRAM";
IfcSIUnitName.GRAY = "GRAY";
IfcSIUnitName.HENRY = "HENRY";
IfcSIUnitName.HERTZ = "HERTZ";
IfcSIUnitName.JOULE = "JOULE";
IfcSIUnitName.KELVIN = "KELVIN";
IfcSIUnitName.LUMEN = "LUMEN";
IfcSIUnitName.LUX = "LUX";
IfcSIUnitName.METRE = "METRE";
IfcSIUnitName.MOLE = "MOLE";
IfcSIUnitName.NEWTON = "NEWTON";
IfcSIUnitName.OHM = "OHM";
IfcSIUnitName.PASCAL = "PASCAL";
IfcSIUnitName.RADIAN = "RADIAN";
IfcSIUnitName.SECOND = "SECOND";
IfcSIUnitName.SIEMENS = "SIEMENS";
IfcSIUnitName.SIEVERT = "SIEVERT";
IfcSIUnitName.SQUARE_METRE = "SQUARE_METRE";
IfcSIUnitName.STERADIAN = "STERADIAN";
IfcSIUnitName.TESLA = "TESLA";
IfcSIUnitName.VOLT = "VOLT";
IfcSIUnitName.WATT = "WATT";
IfcSIUnitName.WEBER = "WEBER";
var IfcSanitaryTerminalTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcSanitaryTerminalTypeEnum");
IfcSanitaryTerminalTypeEnum.BATH = "BATH";
IfcSanitaryTerminalTypeEnum.BIDET = "BIDET";
IfcSanitaryTerminalTypeEnum.CISTERN = "CISTERN";
IfcSanitaryTerminalTypeEnum.SHOWER = "SHOWER";
IfcSanitaryTerminalTypeEnum.SINK = "SINK";
IfcSanitaryTerminalTypeEnum.SANITARYFOUNTAIN = "SANITARYFOUNTAIN";
IfcSanitaryTerminalTypeEnum.TOILETPAN = "TOILETPAN";
IfcSanitaryTerminalTypeEnum.URINAL = "URINAL";
IfcSanitaryTerminalTypeEnum.WASHHANDBASIN = "WASHHANDBASIN";
IfcSanitaryTerminalTypeEnum.WCSEAT = "WCSEAT";
IfcSanitaryTerminalTypeEnum.USERDEFINED = "USERDEFINED";
IfcSanitaryTerminalTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcSectionTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcSectionTypeEnum");
IfcSectionTypeEnum.UNIFORM = "UNIFORM";
IfcSectionTypeEnum.TAPERED = "TAPERED";
var IfcSensorTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcSensorTypeEnum");
IfcSensorTypeEnum.COSENSOR = "COSENSOR";
IfcSensorTypeEnum.CO2SENSOR = "CO2SENSOR";
IfcSensorTypeEnum.CONDUCTANCESENSOR = "CONDUCTANCESENSOR";
IfcSensorTypeEnum.CONTACTSENSOR = "CONTACTSENSOR";
IfcSensorTypeEnum.FIRESENSOR = "FIRESENSOR";
IfcSensorTypeEnum.FLOWSENSOR = "FLOWSENSOR";
IfcSensorTypeEnum.FROSTSENSOR = "FROSTSENSOR";
IfcSensorTypeEnum.GASSENSOR = "GASSENSOR";
IfcSensorTypeEnum.HEATSENSOR = "HEATSENSOR";
IfcSensorTypeEnum.HUMIDITYSENSOR = "HUMIDITYSENSOR";
IfcSensorTypeEnum.IDENTIFIERSENSOR = "IDENTIFIERSENSOR";
IfcSensorTypeEnum.IONCONCENTRATIONSENSOR = "IONCONCENTRATIONSENSOR";
IfcSensorTypeEnum.LEVELSENSOR = "LEVELSENSOR";
IfcSensorTypeEnum.LIGHTSENSOR = "LIGHTSENSOR";
IfcSensorTypeEnum.MOISTURESENSOR = "MOISTURESENSOR";
IfcSensorTypeEnum.MOVEMENTSENSOR = "MOVEMENTSENSOR";
IfcSensorTypeEnum.PHSENSOR = "PHSENSOR";
IfcSensorTypeEnum.PRESSURESENSOR = "PRESSURESENSOR";
IfcSensorTypeEnum.RADIATIONSENSOR = "RADIATIONSENSOR";
IfcSensorTypeEnum.RADIOACTIVITYSENSOR = "RADIOACTIVITYSENSOR";
IfcSensorTypeEnum.SMOKESENSOR = "SMOKESENSOR";
IfcSensorTypeEnum.SOUNDSENSOR = "SOUNDSENSOR";
IfcSensorTypeEnum.TEMPERATURESENSOR = "TEMPERATURESENSOR";
IfcSensorTypeEnum.WINDSENSOR = "WINDSENSOR";
IfcSensorTypeEnum.USERDEFINED = "USERDEFINED";
IfcSensorTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcSequenceEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcSequenceEnum");
IfcSequenceEnum.START_START = "START_START";
IfcSequenceEnum.START_FINISH = "START_FINISH";
IfcSequenceEnum.FINISH_START = "FINISH_START";
IfcSequenceEnum.FINISH_FINISH = "FINISH_FINISH";
IfcSequenceEnum.USERDEFINED = "USERDEFINED";
IfcSequenceEnum.NOTDEFINED = "NOTDEFINED";
var IfcShadingDeviceTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcShadingDeviceTypeEnum");
IfcShadingDeviceTypeEnum.JALOUSIE = "JALOUSIE";
IfcShadingDeviceTypeEnum.SHUTTER = "SHUTTER";
IfcShadingDeviceTypeEnum.AWNING = "AWNING";
IfcShadingDeviceTypeEnum.USERDEFINED = "USERDEFINED";
IfcShadingDeviceTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcSimplePropertyTemplateTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcSimplePropertyTemplateTypeEnum");
IfcSimplePropertyTemplateTypeEnum.P_SINGLEVALUE = "P_SINGLEVALUE";
IfcSimplePropertyTemplateTypeEnum.P_ENUMERATEDVALUE = "P_ENUMERATEDVALUE";
IfcSimplePropertyTemplateTypeEnum.P_BOUNDEDVALUE = "P_BOUNDEDVALUE";
IfcSimplePropertyTemplateTypeEnum.P_LISTVALUE = "P_LISTVALUE";
IfcSimplePropertyTemplateTypeEnum.P_TABLEVALUE = "P_TABLEVALUE";
IfcSimplePropertyTemplateTypeEnum.P_REFERENCEVALUE = "P_REFERENCEVALUE";
IfcSimplePropertyTemplateTypeEnum.Q_LENGTH = "Q_LENGTH";
IfcSimplePropertyTemplateTypeEnum.Q_AREA = "Q_AREA";
IfcSimplePropertyTemplateTypeEnum.Q_VOLUME = "Q_VOLUME";
IfcSimplePropertyTemplateTypeEnum.Q_COUNT = "Q_COUNT";
IfcSimplePropertyTemplateTypeEnum.Q_WEIGHT = "Q_WEIGHT";
IfcSimplePropertyTemplateTypeEnum.Q_TIME = "Q_TIME";
var IfcSlabTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcSlabTypeEnum");
IfcSlabTypeEnum.FLOOR = "FLOOR";
IfcSlabTypeEnum.ROOF = "ROOF";
IfcSlabTypeEnum.LANDING = "LANDING";
IfcSlabTypeEnum.BASESLAB = "BASESLAB";
IfcSlabTypeEnum.APPROACH_SLAB = "APPROACH_SLAB";
IfcSlabTypeEnum.PAVING = "PAVING";
IfcSlabTypeEnum.WEARING = "WEARING";
IfcSlabTypeEnum.SIDEWALK = "SIDEWALK";
IfcSlabTypeEnum.USERDEFINED = "USERDEFINED";
IfcSlabTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcSolarDeviceTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcSolarDeviceTypeEnum");
IfcSolarDeviceTypeEnum.SOLARCOLLECTOR = "SOLARCOLLECTOR";
IfcSolarDeviceTypeEnum.SOLARPANEL = "SOLARPANEL";
IfcSolarDeviceTypeEnum.USERDEFINED = "USERDEFINED";
IfcSolarDeviceTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcSpaceHeaterTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcSpaceHeaterTypeEnum");
IfcSpaceHeaterTypeEnum.CONVECTOR = "CONVECTOR";
IfcSpaceHeaterTypeEnum.RADIATOR = "RADIATOR";
IfcSpaceHeaterTypeEnum.USERDEFINED = "USERDEFINED";
IfcSpaceHeaterTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcSpaceTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcSpaceTypeEnum");
IfcSpaceTypeEnum.SPACE = "SPACE";
IfcSpaceTypeEnum.PARKING = "PARKING";
IfcSpaceTypeEnum.GFA = "GFA";
IfcSpaceTypeEnum.INTERNAL = "INTERNAL";
IfcSpaceTypeEnum.EXTERNAL = "EXTERNAL";
IfcSpaceTypeEnum.USERDEFINED = "USERDEFINED";
IfcSpaceTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcSpatialZoneTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcSpatialZoneTypeEnum");
IfcSpatialZoneTypeEnum.CONSTRUCTION = "CONSTRUCTION";
IfcSpatialZoneTypeEnum.FIRESAFETY = "FIRESAFETY";
IfcSpatialZoneTypeEnum.LIGHTING = "LIGHTING";
IfcSpatialZoneTypeEnum.OCCUPANCY = "OCCUPANCY";
IfcSpatialZoneTypeEnum.SECURITY = "SECURITY";
IfcSpatialZoneTypeEnum.THERMAL = "THERMAL";
IfcSpatialZoneTypeEnum.TRANSPORT = "TRANSPORT";
IfcSpatialZoneTypeEnum.VENTILATION = "VENTILATION";
IfcSpatialZoneTypeEnum.USERDEFINED = "USERDEFINED";
IfcSpatialZoneTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcStackTerminalTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcStackTerminalTypeEnum");
IfcStackTerminalTypeEnum.BIRDCAGE = "BIRDCAGE";
IfcStackTerminalTypeEnum.COWL = "COWL";
IfcStackTerminalTypeEnum.RAINWATERHOPPER = "RAINWATERHOPPER";
IfcStackTerminalTypeEnum.USERDEFINED = "USERDEFINED";
IfcStackTerminalTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcStairFlightTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcStairFlightTypeEnum");
IfcStairFlightTypeEnum.STRAIGHT = "STRAIGHT";
IfcStairFlightTypeEnum.WINDER = "WINDER";
IfcStairFlightTypeEnum.SPIRAL = "SPIRAL";
IfcStairFlightTypeEnum.CURVED = "CURVED";
IfcStairFlightTypeEnum.FREEFORM = "FREEFORM";
IfcStairFlightTypeEnum.USERDEFINED = "USERDEFINED";
IfcStairFlightTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcStairTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcStairTypeEnum");
IfcStairTypeEnum.STRAIGHT_RUN_STAIR = "STRAIGHT_RUN_STAIR";
IfcStairTypeEnum.TWO_STRAIGHT_RUN_STAIR = "TWO_STRAIGHT_RUN_STAIR";
IfcStairTypeEnum.QUARTER_WINDING_STAIR = "QUARTER_WINDING_STAIR";
IfcStairTypeEnum.QUARTER_TURN_STAIR = "QUARTER_TURN_STAIR";
IfcStairTypeEnum.HALF_WINDING_STAIR = "HALF_WINDING_STAIR";
IfcStairTypeEnum.HALF_TURN_STAIR = "HALF_TURN_STAIR";
IfcStairTypeEnum.TWO_QUARTER_WINDING_STAIR = "TWO_QUARTER_WINDING_STAIR";
IfcStairTypeEnum.TWO_QUARTER_TURN_STAIR = "TWO_QUARTER_TURN_STAIR";
IfcStairTypeEnum.THREE_QUARTER_WINDING_STAIR = "THREE_QUARTER_WINDING_STAIR";
IfcStairTypeEnum.THREE_QUARTER_TURN_STAIR = "THREE_QUARTER_TURN_STAIR";
IfcStairTypeEnum.SPIRAL_STAIR = "SPIRAL_STAIR";
IfcStairTypeEnum.DOUBLE_RETURN_STAIR = "DOUBLE_RETURN_STAIR";
IfcStairTypeEnum.CURVED_RUN_STAIR = "CURVED_RUN_STAIR";
IfcStairTypeEnum.TWO_CURVED_RUN_STAIR = "TWO_CURVED_RUN_STAIR";
IfcStairTypeEnum.USERDEFINED = "USERDEFINED";
IfcStairTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcStateEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcStateEnum");
IfcStateEnum.READWRITE = "READWRITE";
IfcStateEnum.READONLY = "READONLY";
IfcStateEnum.LOCKED = "LOCKED";
IfcStateEnum.READWRITELOCKED = "READWRITELOCKED";
IfcStateEnum.READONLYLOCKED = "READONLYLOCKED";
var IfcStructuralCurveActivityTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcStructuralCurveActivityTypeEnum");
IfcStructuralCurveActivityTypeEnum.CONST = "CONST";
IfcStructuralCurveActivityTypeEnum.LINEAR = "LINEAR";
IfcStructuralCurveActivityTypeEnum.POLYGONAL = "POLYGONAL";
IfcStructuralCurveActivityTypeEnum.EQUIDISTANT = "EQUIDISTANT";
IfcStructuralCurveActivityTypeEnum.SINUS = "SINUS";
IfcStructuralCurveActivityTypeEnum.PARABOLA = "PARABOLA";
IfcStructuralCurveActivityTypeEnum.DISCRETE = "DISCRETE";
IfcStructuralCurveActivityTypeEnum.USERDEFINED = "USERDEFINED";
IfcStructuralCurveActivityTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcStructuralCurveMemberTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcStructuralCurveMemberTypeEnum");
IfcStructuralCurveMemberTypeEnum.RIGID_JOINED_MEMBER = "RIGID_JOINED_MEMBER";
IfcStructuralCurveMemberTypeEnum.PIN_JOINED_MEMBER = "PIN_JOINED_MEMBER";
IfcStructuralCurveMemberTypeEnum.CABLE = "CABLE";
IfcStructuralCurveMemberTypeEnum.TENSION_MEMBER = "TENSION_MEMBER";
IfcStructuralCurveMemberTypeEnum.COMPRESSION_MEMBER = "COMPRESSION_MEMBER";
IfcStructuralCurveMemberTypeEnum.USERDEFINED = "USERDEFINED";
IfcStructuralCurveMemberTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcStructuralSurfaceActivityTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcStructuralSurfaceActivityTypeEnum");
IfcStructuralSurfaceActivityTypeEnum.CONST = "CONST";
IfcStructuralSurfaceActivityTypeEnum.BILINEAR = "BILINEAR";
IfcStructuralSurfaceActivityTypeEnum.DISCRETE = "DISCRETE";
IfcStructuralSurfaceActivityTypeEnum.ISOCONTOUR = "ISOCONTOUR";
IfcStructuralSurfaceActivityTypeEnum.USERDEFINED = "USERDEFINED";
IfcStructuralSurfaceActivityTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcStructuralSurfaceMemberTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcStructuralSurfaceMemberTypeEnum");
IfcStructuralSurfaceMemberTypeEnum.BENDING_ELEMENT = "BENDING_ELEMENT";
IfcStructuralSurfaceMemberTypeEnum.MEMBRANE_ELEMENT = "MEMBRANE_ELEMENT";
IfcStructuralSurfaceMemberTypeEnum.SHELL = "SHELL";
IfcStructuralSurfaceMemberTypeEnum.USERDEFINED = "USERDEFINED";
IfcStructuralSurfaceMemberTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcSubContractResourceTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcSubContractResourceTypeEnum");
IfcSubContractResourceTypeEnum.PURCHASE = "PURCHASE";
IfcSubContractResourceTypeEnum.WORK = "WORK";
IfcSubContractResourceTypeEnum.USERDEFINED = "USERDEFINED";
IfcSubContractResourceTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcSurfaceFeatureTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcSurfaceFeatureTypeEnum");
IfcSurfaceFeatureTypeEnum.MARK = "MARK";
IfcSurfaceFeatureTypeEnum.TAG = "TAG";
IfcSurfaceFeatureTypeEnum.TREATMENT = "TREATMENT";
IfcSurfaceFeatureTypeEnum.DEFECT = "DEFECT";
IfcSurfaceFeatureTypeEnum.USERDEFINED = "USERDEFINED";
IfcSurfaceFeatureTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcSurfaceSide = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcSurfaceSide");
IfcSurfaceSide.POSITIVE = "POSITIVE";
IfcSurfaceSide.NEGATIVE = "NEGATIVE";
IfcSurfaceSide.BOTH = "BOTH";
var IfcSwitchingDeviceTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcSwitchingDeviceTypeEnum");
IfcSwitchingDeviceTypeEnum.CONTACTOR = "CONTACTOR";
IfcSwitchingDeviceTypeEnum.DIMMERSWITCH = "DIMMERSWITCH";
IfcSwitchingDeviceTypeEnum.EMERGENCYSTOP = "EMERGENCYSTOP";
IfcSwitchingDeviceTypeEnum.KEYPAD = "KEYPAD";
IfcSwitchingDeviceTypeEnum.MOMENTARYSWITCH = "MOMENTARYSWITCH";
IfcSwitchingDeviceTypeEnum.SELECTORSWITCH = "SELECTORSWITCH";
IfcSwitchingDeviceTypeEnum.STARTER = "STARTER";
IfcSwitchingDeviceTypeEnum.SWITCHDISCONNECTOR = "SWITCHDISCONNECTOR";
IfcSwitchingDeviceTypeEnum.TOGGLESWITCH = "TOGGLESWITCH";
IfcSwitchingDeviceTypeEnum.USERDEFINED = "USERDEFINED";
IfcSwitchingDeviceTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcSystemFurnitureElementTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcSystemFurnitureElementTypeEnum");
IfcSystemFurnitureElementTypeEnum.PANEL = "PANEL";
IfcSystemFurnitureElementTypeEnum.WORKSURFACE = "WORKSURFACE";
IfcSystemFurnitureElementTypeEnum.USERDEFINED = "USERDEFINED";
IfcSystemFurnitureElementTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcTankTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcTankTypeEnum");
IfcTankTypeEnum.BASIN = "BASIN";
IfcTankTypeEnum.BREAKPRESSURE = "BREAKPRESSURE";
IfcTankTypeEnum.EXPANSION = "EXPANSION";
IfcTankTypeEnum.FEEDANDEXPANSION = "FEEDANDEXPANSION";
IfcTankTypeEnum.PRESSUREVESSEL = "PRESSUREVESSEL";
IfcTankTypeEnum.STORAGE = "STORAGE";
IfcTankTypeEnum.VESSEL = "VESSEL";
IfcTankTypeEnum.USERDEFINED = "USERDEFINED";
IfcTankTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcTaskDurationEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcTaskDurationEnum");
IfcTaskDurationEnum.ELAPSEDTIME = "ELAPSEDTIME";
IfcTaskDurationEnum.WORKTIME = "WORKTIME";
IfcTaskDurationEnum.NOTDEFINED = "NOTDEFINED";
var IfcTaskTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcTaskTypeEnum");
IfcTaskTypeEnum.ATTENDANCE = "ATTENDANCE";
IfcTaskTypeEnum.CONSTRUCTION = "CONSTRUCTION";
IfcTaskTypeEnum.DEMOLITION = "DEMOLITION";
IfcTaskTypeEnum.DISMANTLE = "DISMANTLE";
IfcTaskTypeEnum.DISPOSAL = "DISPOSAL";
IfcTaskTypeEnum.INSTALLATION = "INSTALLATION";
IfcTaskTypeEnum.LOGISTIC = "LOGISTIC";
IfcTaskTypeEnum.MAINTENANCE = "MAINTENANCE";
IfcTaskTypeEnum.MOVE = "MOVE";
IfcTaskTypeEnum.OPERATION = "OPERATION";
IfcTaskTypeEnum.REMOVAL = "REMOVAL";
IfcTaskTypeEnum.RENOVATION = "RENOVATION";
IfcTaskTypeEnum.USERDEFINED = "USERDEFINED";
IfcTaskTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcTendonAnchorTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcTendonAnchorTypeEnum");
IfcTendonAnchorTypeEnum.COUPLER = "COUPLER";
IfcTendonAnchorTypeEnum.FIXED_END = "FIXED_END";
IfcTendonAnchorTypeEnum.TENSIONING_END = "TENSIONING_END";
IfcTendonAnchorTypeEnum.USERDEFINED = "USERDEFINED";
IfcTendonAnchorTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcTendonConduitTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcTendonConduitTypeEnum");
IfcTendonConduitTypeEnum.DUCT = "DUCT";
IfcTendonConduitTypeEnum.COUPLER = "COUPLER";
IfcTendonConduitTypeEnum.GROUTING_DUCT = "GROUTING_DUCT";
IfcTendonConduitTypeEnum.TRUMPET = "TRUMPET";
IfcTendonConduitTypeEnum.DIABOLO = "DIABOLO";
IfcTendonConduitTypeEnum.USERDEFINED = "USERDEFINED";
IfcTendonConduitTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcTendonTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcTendonTypeEnum");
IfcTendonTypeEnum.BAR = "BAR";
IfcTendonTypeEnum.COATED = "COATED";
IfcTendonTypeEnum.STRAND = "STRAND";
IfcTendonTypeEnum.WIRE = "WIRE";
IfcTendonTypeEnum.USERDEFINED = "USERDEFINED";
IfcTendonTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcTextPath = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcTextPath");
IfcTextPath.LEFT = "LEFT";
IfcTextPath.RIGHT = "RIGHT";
IfcTextPath.UP = "UP";
IfcTextPath.DOWN = "DOWN";
var IfcTimeSeriesDataTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcTimeSeriesDataTypeEnum");
IfcTimeSeriesDataTypeEnum.CONTINUOUS = "CONTINUOUS";
IfcTimeSeriesDataTypeEnum.DISCRETE = "DISCRETE";
IfcTimeSeriesDataTypeEnum.DISCRETEBINARY = "DISCRETEBINARY";
IfcTimeSeriesDataTypeEnum.PIECEWISEBINARY = "PIECEWISEBINARY";
IfcTimeSeriesDataTypeEnum.PIECEWISECONSTANT = "PIECEWISECONSTANT";
IfcTimeSeriesDataTypeEnum.PIECEWISECONTINUOUS = "PIECEWISECONTINUOUS";
IfcTimeSeriesDataTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcTransformerTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcTransformerTypeEnum");
IfcTransformerTypeEnum.CURRENT = "CURRENT";
IfcTransformerTypeEnum.FREQUENCY = "FREQUENCY";
IfcTransformerTypeEnum.INVERTER = "INVERTER";
IfcTransformerTypeEnum.RECTIFIER = "RECTIFIER";
IfcTransformerTypeEnum.VOLTAGE = "VOLTAGE";
IfcTransformerTypeEnum.USERDEFINED = "USERDEFINED";
IfcTransformerTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcTransitionCode = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcTransitionCode");
IfcTransitionCode.DISCONTINUOUS = "DISCONTINUOUS";
IfcTransitionCode.CONTINUOUS = "CONTINUOUS";
IfcTransitionCode.CONTSAMEGRADIENT = "CONTSAMEGRADIENT";
IfcTransitionCode.CONTSAMEGRADIENTSAMECURVATURE = "CONTSAMEGRADIENTSAMECURVATURE";
var IfcTransitionCurveType = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcTransitionCurveType");
IfcTransitionCurveType.BIQUADRATICPARABOLA = "BIQUADRATICPARABOLA";
IfcTransitionCurveType.BLOSSCURVE = "BLOSSCURVE";
IfcTransitionCurveType.CLOTHOIDCURVE = "CLOTHOIDCURVE";
IfcTransitionCurveType.COSINECURVE = "COSINECURVE";
IfcTransitionCurveType.CUBICPARABOLA = "CUBICPARABOLA";
IfcTransitionCurveType.SINECURVE = "SINECURVE";
var IfcTransportElementTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcTransportElementTypeEnum");
IfcTransportElementTypeEnum.ELEVATOR = "ELEVATOR";
IfcTransportElementTypeEnum.ESCALATOR = "ESCALATOR";
IfcTransportElementTypeEnum.MOVINGWALKWAY = "MOVINGWALKWAY";
IfcTransportElementTypeEnum.CRANEWAY = "CRANEWAY";
IfcTransportElementTypeEnum.LIFTINGGEAR = "LIFTINGGEAR";
IfcTransportElementTypeEnum.USERDEFINED = "USERDEFINED";
IfcTransportElementTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcTrimmingPreference = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcTrimmingPreference");
IfcTrimmingPreference.CARTESIAN = "CARTESIAN";
IfcTrimmingPreference.PARAMETER = "PARAMETER";
IfcTrimmingPreference.UNSPECIFIED = "UNSPECIFIED";
var IfcTubeBundleTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcTubeBundleTypeEnum");
IfcTubeBundleTypeEnum.FINNED = "FINNED";
IfcTubeBundleTypeEnum.USERDEFINED = "USERDEFINED";
IfcTubeBundleTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcUnitEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcUnitEnum");
IfcUnitEnum.ABSORBEDDOSEUNIT = "ABSORBEDDOSEUNIT";
IfcUnitEnum.AMOUNTOFSUBSTANCEUNIT = "AMOUNTOFSUBSTANCEUNIT";
IfcUnitEnum.AREAUNIT = "AREAUNIT";
IfcUnitEnum.DOSEEQUIVALENTUNIT = "DOSEEQUIVALENTUNIT";
IfcUnitEnum.ELECTRICCAPACITANCEUNIT = "ELECTRICCAPACITANCEUNIT";
IfcUnitEnum.ELECTRICCHARGEUNIT = "ELECTRICCHARGEUNIT";
IfcUnitEnum.ELECTRICCONDUCTANCEUNIT = "ELECTRICCONDUCTANCEUNIT";
IfcUnitEnum.ELECTRICCURRENTUNIT = "ELECTRICCURRENTUNIT";
IfcUnitEnum.ELECTRICRESISTANCEUNIT = "ELECTRICRESISTANCEUNIT";
IfcUnitEnum.ELECTRICVOLTAGEUNIT = "ELECTRICVOLTAGEUNIT";
IfcUnitEnum.ENERGYUNIT = "ENERGYUNIT";
IfcUnitEnum.FORCEUNIT = "FORCEUNIT";
IfcUnitEnum.FREQUENCYUNIT = "FREQUENCYUNIT";
IfcUnitEnum.ILLUMINANCEUNIT = "ILLUMINANCEUNIT";
IfcUnitEnum.INDUCTANCEUNIT = "INDUCTANCEUNIT";
IfcUnitEnum.LENGTHUNIT = "LENGTHUNIT";
IfcUnitEnum.LUMINOUSFLUXUNIT = "LUMINOUSFLUXUNIT";
IfcUnitEnum.LUMINOUSINTENSITYUNIT = "LUMINOUSINTENSITYUNIT";
IfcUnitEnum.MAGNETICFLUXDENSITYUNIT = "MAGNETICFLUXDENSITYUNIT";
IfcUnitEnum.MAGNETICFLUXUNIT = "MAGNETICFLUXUNIT";
IfcUnitEnum.MASSUNIT = "MASSUNIT";
IfcUnitEnum.PLANEANGLEUNIT = "PLANEANGLEUNIT";
IfcUnitEnum.POWERUNIT = "POWERUNIT";
IfcUnitEnum.PRESSUREUNIT = "PRESSUREUNIT";
IfcUnitEnum.RADIOACTIVITYUNIT = "RADIOACTIVITYUNIT";
IfcUnitEnum.SOLIDANGLEUNIT = "SOLIDANGLEUNIT";
IfcUnitEnum.THERMODYNAMICTEMPERATUREUNIT = "THERMODYNAMICTEMPERATUREUNIT";
IfcUnitEnum.TIMEUNIT = "TIMEUNIT";
IfcUnitEnum.VOLUMEUNIT = "VOLUMEUNIT";
IfcUnitEnum.USERDEFINED = "USERDEFINED";
var IfcUnitaryControlElementTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcUnitaryControlElementTypeEnum");
IfcUnitaryControlElementTypeEnum.ALARMPANEL = "ALARMPANEL";
IfcUnitaryControlElementTypeEnum.CONTROLPANEL = "CONTROLPANEL";
IfcUnitaryControlElementTypeEnum.GASDETECTIONPANEL = "GASDETECTIONPANEL";
IfcUnitaryControlElementTypeEnum.INDICATORPANEL = "INDICATORPANEL";
IfcUnitaryControlElementTypeEnum.MIMICPANEL = "MIMICPANEL";
IfcUnitaryControlElementTypeEnum.HUMIDISTAT = "HUMIDISTAT";
IfcUnitaryControlElementTypeEnum.THERMOSTAT = "THERMOSTAT";
IfcUnitaryControlElementTypeEnum.WEATHERSTATION = "WEATHERSTATION";
IfcUnitaryControlElementTypeEnum.USERDEFINED = "USERDEFINED";
IfcUnitaryControlElementTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcUnitaryEquipmentTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcUnitaryEquipmentTypeEnum");
IfcUnitaryEquipmentTypeEnum.AIRHANDLER = "AIRHANDLER";
IfcUnitaryEquipmentTypeEnum.AIRCONDITIONINGUNIT = "AIRCONDITIONINGUNIT";
IfcUnitaryEquipmentTypeEnum.DEHUMIDIFIER = "DEHUMIDIFIER";
IfcUnitaryEquipmentTypeEnum.SPLITSYSTEM = "SPLITSYSTEM";
IfcUnitaryEquipmentTypeEnum.ROOFTOPUNIT = "ROOFTOPUNIT";
IfcUnitaryEquipmentTypeEnum.USERDEFINED = "USERDEFINED";
IfcUnitaryEquipmentTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcValveTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcValveTypeEnum");
IfcValveTypeEnum.AIRRELEASE = "AIRRELEASE";
IfcValveTypeEnum.ANTIVACUUM = "ANTIVACUUM";
IfcValveTypeEnum.CHANGEOVER = "CHANGEOVER";
IfcValveTypeEnum.CHECK = "CHECK";
IfcValveTypeEnum.COMMISSIONING = "COMMISSIONING";
IfcValveTypeEnum.DIVERTING = "DIVERTING";
IfcValveTypeEnum.DRAWOFFCOCK = "DRAWOFFCOCK";
IfcValveTypeEnum.DOUBLECHECK = "DOUBLECHECK";
IfcValveTypeEnum.DOUBLEREGULATING = "DOUBLEREGULATING";
IfcValveTypeEnum.FAUCET = "FAUCET";
IfcValveTypeEnum.FLUSHING = "FLUSHING";
IfcValveTypeEnum.GASCOCK = "GASCOCK";
IfcValveTypeEnum.GASTAP = "GASTAP";
IfcValveTypeEnum.ISOLATING = "ISOLATING";
IfcValveTypeEnum.MIXING = "MIXING";
IfcValveTypeEnum.PRESSUREREDUCING = "PRESSUREREDUCING";
IfcValveTypeEnum.PRESSURERELIEF = "PRESSURERELIEF";
IfcValveTypeEnum.REGULATING = "REGULATING";
IfcValveTypeEnum.SAFETYCUTOFF = "SAFETYCUTOFF";
IfcValveTypeEnum.STEAMTRAP = "STEAMTRAP";
IfcValveTypeEnum.STOPCOCK = "STOPCOCK";
IfcValveTypeEnum.USERDEFINED = "USERDEFINED";
IfcValveTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcVibrationDamperTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcVibrationDamperTypeEnum");
IfcVibrationDamperTypeEnum.BENDING_YIELD = "BENDING_YIELD";
IfcVibrationDamperTypeEnum.SHEAR_YIELD = "SHEAR_YIELD";
IfcVibrationDamperTypeEnum.AXIAL_YIELD = "AXIAL_YIELD";
IfcVibrationDamperTypeEnum.FRICTION = "FRICTION";
IfcVibrationDamperTypeEnum.VISCOUS = "VISCOUS";
IfcVibrationDamperTypeEnum.RUBBER = "RUBBER";
IfcVibrationDamperTypeEnum.USERDEFINED = "USERDEFINED";
IfcVibrationDamperTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcVibrationIsolatorTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcVibrationIsolatorTypeEnum");
IfcVibrationIsolatorTypeEnum.COMPRESSION = "COMPRESSION";
IfcVibrationIsolatorTypeEnum.SPRING = "SPRING";
IfcVibrationIsolatorTypeEnum.BASE = "BASE";
IfcVibrationIsolatorTypeEnum.USERDEFINED = "USERDEFINED";
IfcVibrationIsolatorTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcVoidingFeatureTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcVoidingFeatureTypeEnum");
IfcVoidingFeatureTypeEnum.CUTOUT = "CUTOUT";
IfcVoidingFeatureTypeEnum.NOTCH = "NOTCH";
IfcVoidingFeatureTypeEnum.HOLE = "HOLE";
IfcVoidingFeatureTypeEnum.MITER = "MITER";
IfcVoidingFeatureTypeEnum.CHAMFER = "CHAMFER";
IfcVoidingFeatureTypeEnum.EDGE = "EDGE";
IfcVoidingFeatureTypeEnum.USERDEFINED = "USERDEFINED";
IfcVoidingFeatureTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcWallTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcWallTypeEnum");
IfcWallTypeEnum.MOVABLE = "MOVABLE";
IfcWallTypeEnum.PARAPET = "PARAPET";
IfcWallTypeEnum.PARTITIONING = "PARTITIONING";
IfcWallTypeEnum.PLUMBINGWALL = "PLUMBINGWALL";
IfcWallTypeEnum.SHEAR = "SHEAR";
IfcWallTypeEnum.SOLIDWALL = "SOLIDWALL";
IfcWallTypeEnum.STANDARD = "STANDARD";
IfcWallTypeEnum.POLYGONAL = "POLYGONAL";
IfcWallTypeEnum.ELEMENTEDWALL = "ELEMENTEDWALL";
IfcWallTypeEnum.RETAININGWALL = "RETAININGWALL";
IfcWallTypeEnum.USERDEFINED = "USERDEFINED";
IfcWallTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcWasteTerminalTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcWasteTerminalTypeEnum");
IfcWasteTerminalTypeEnum.FLOORTRAP = "FLOORTRAP";
IfcWasteTerminalTypeEnum.FLOORWASTE = "FLOORWASTE";
IfcWasteTerminalTypeEnum.GULLYSUMP = "GULLYSUMP";
IfcWasteTerminalTypeEnum.GULLYTRAP = "GULLYTRAP";
IfcWasteTerminalTypeEnum.ROOFDRAIN = "ROOFDRAIN";
IfcWasteTerminalTypeEnum.WASTEDISPOSALUNIT = "WASTEDISPOSALUNIT";
IfcWasteTerminalTypeEnum.WASTETRAP = "WASTETRAP";
IfcWasteTerminalTypeEnum.USERDEFINED = "USERDEFINED";
IfcWasteTerminalTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcWindowPanelOperationEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcWindowPanelOperationEnum");
IfcWindowPanelOperationEnum.SIDEHUNGRIGHTHAND = "SIDEHUNGRIGHTHAND";
IfcWindowPanelOperationEnum.SIDEHUNGLEFTHAND = "SIDEHUNGLEFTHAND";
IfcWindowPanelOperationEnum.TILTANDTURNRIGHTHAND = "TILTANDTURNRIGHTHAND";
IfcWindowPanelOperationEnum.TILTANDTURNLEFTHAND = "TILTANDTURNLEFTHAND";
IfcWindowPanelOperationEnum.TOPHUNG = "TOPHUNG";
IfcWindowPanelOperationEnum.BOTTOMHUNG = "BOTTOMHUNG";
IfcWindowPanelOperationEnum.PIVOTHORIZONTAL = "PIVOTHORIZONTAL";
IfcWindowPanelOperationEnum.PIVOTVERTICAL = "PIVOTVERTICAL";
IfcWindowPanelOperationEnum.SLIDINGHORIZONTAL = "SLIDINGHORIZONTAL";
IfcWindowPanelOperationEnum.SLIDINGVERTICAL = "SLIDINGVERTICAL";
IfcWindowPanelOperationEnum.REMOVABLECASEMENT = "REMOVABLECASEMENT";
IfcWindowPanelOperationEnum.FIXEDCASEMENT = "FIXEDCASEMENT";
IfcWindowPanelOperationEnum.OTHEROPERATION = "OTHEROPERATION";
IfcWindowPanelOperationEnum.NOTDEFINED = "NOTDEFINED";
var IfcWindowPanelPositionEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcWindowPanelPositionEnum");
IfcWindowPanelPositionEnum.LEFT = "LEFT";
IfcWindowPanelPositionEnum.MIDDLE = "MIDDLE";
IfcWindowPanelPositionEnum.RIGHT = "RIGHT";
IfcWindowPanelPositionEnum.BOTTOM = "BOTTOM";
IfcWindowPanelPositionEnum.TOP = "TOP";
IfcWindowPanelPositionEnum.NOTDEFINED = "NOTDEFINED";
var IfcWindowStyleConstructionEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcWindowStyleConstructionEnum");
IfcWindowStyleConstructionEnum.ALUMINIUM = "ALUMINIUM";
IfcWindowStyleConstructionEnum.HIGH_GRADE_STEEL = "HIGH_GRADE_STEEL";
IfcWindowStyleConstructionEnum.STEEL = "STEEL";
IfcWindowStyleConstructionEnum.WOOD = "WOOD";
IfcWindowStyleConstructionEnum.ALUMINIUM_WOOD = "ALUMINIUM_WOOD";
IfcWindowStyleConstructionEnum.PLASTIC = "PLASTIC";
IfcWindowStyleConstructionEnum.OTHER_CONSTRUCTION = "OTHER_CONSTRUCTION";
IfcWindowStyleConstructionEnum.NOTDEFINED = "NOTDEFINED";
var IfcWindowStyleOperationEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcWindowStyleOperationEnum");
IfcWindowStyleOperationEnum.SINGLE_PANEL = "SINGLE_PANEL";
IfcWindowStyleOperationEnum.DOUBLE_PANEL_VERTICAL = "DOUBLE_PANEL_VERTICAL";
IfcWindowStyleOperationEnum.DOUBLE_PANEL_HORIZONTAL = "DOUBLE_PANEL_HORIZONTAL";
IfcWindowStyleOperationEnum.TRIPLE_PANEL_VERTICAL = "TRIPLE_PANEL_VERTICAL";
IfcWindowStyleOperationEnum.TRIPLE_PANEL_BOTTOM = "TRIPLE_PANEL_BOTTOM";
IfcWindowStyleOperationEnum.TRIPLE_PANEL_TOP = "TRIPLE_PANEL_TOP";
IfcWindowStyleOperationEnum.TRIPLE_PANEL_LEFT = "TRIPLE_PANEL_LEFT";
IfcWindowStyleOperationEnum.TRIPLE_PANEL_RIGHT = "TRIPLE_PANEL_RIGHT";
IfcWindowStyleOperationEnum.TRIPLE_PANEL_HORIZONTAL = "TRIPLE_PANEL_HORIZONTAL";
IfcWindowStyleOperationEnum.USERDEFINED = "USERDEFINED";
IfcWindowStyleOperationEnum.NOTDEFINED = "NOTDEFINED";
var IfcWindowTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcWindowTypeEnum");
IfcWindowTypeEnum.WINDOW = "WINDOW";
IfcWindowTypeEnum.SKYLIGHT = "SKYLIGHT";
IfcWindowTypeEnum.LIGHTDOME = "LIGHTDOME";
IfcWindowTypeEnum.USERDEFINED = "USERDEFINED";
IfcWindowTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcWindowTypePartitioningEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcWindowTypePartitioningEnum");
IfcWindowTypePartitioningEnum.SINGLE_PANEL = "SINGLE_PANEL";
IfcWindowTypePartitioningEnum.DOUBLE_PANEL_VERTICAL = "DOUBLE_PANEL_VERTICAL";
IfcWindowTypePartitioningEnum.DOUBLE_PANEL_HORIZONTAL = "DOUBLE_PANEL_HORIZONTAL";
IfcWindowTypePartitioningEnum.TRIPLE_PANEL_VERTICAL = "TRIPLE_PANEL_VERTICAL";
IfcWindowTypePartitioningEnum.TRIPLE_PANEL_BOTTOM = "TRIPLE_PANEL_BOTTOM";
IfcWindowTypePartitioningEnum.TRIPLE_PANEL_TOP = "TRIPLE_PANEL_TOP";
IfcWindowTypePartitioningEnum.TRIPLE_PANEL_LEFT = "TRIPLE_PANEL_LEFT";
IfcWindowTypePartitioningEnum.TRIPLE_PANEL_RIGHT = "TRIPLE_PANEL_RIGHT";
IfcWindowTypePartitioningEnum.TRIPLE_PANEL_HORIZONTAL = "TRIPLE_PANEL_HORIZONTAL";
IfcWindowTypePartitioningEnum.USERDEFINED = "USERDEFINED";
IfcWindowTypePartitioningEnum.NOTDEFINED = "NOTDEFINED";
var IfcWorkCalendarTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcWorkCalendarTypeEnum");
IfcWorkCalendarTypeEnum.FIRSTSHIFT = "FIRSTSHIFT";
IfcWorkCalendarTypeEnum.SECONDSHIFT = "SECONDSHIFT";
IfcWorkCalendarTypeEnum.THIRDSHIFT = "THIRDSHIFT";
IfcWorkCalendarTypeEnum.USERDEFINED = "USERDEFINED";
IfcWorkCalendarTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcWorkPlanTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcWorkPlanTypeEnum");
IfcWorkPlanTypeEnum.ACTUAL = "ACTUAL";
IfcWorkPlanTypeEnum.BASELINE = "BASELINE";
IfcWorkPlanTypeEnum.PLANNED = "PLANNED";
IfcWorkPlanTypeEnum.USERDEFINED = "USERDEFINED";
IfcWorkPlanTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcWorkScheduleTypeEnum = /* @__PURE__ */ __name(class {
  constructor(v) {
    this.value = v;
  }
}, "IfcWorkScheduleTypeEnum");
IfcWorkScheduleTypeEnum.ACTUAL = "ACTUAL";
IfcWorkScheduleTypeEnum.BASELINE = "BASELINE";
IfcWorkScheduleTypeEnum.PLANNED = "PLANNED";
IfcWorkScheduleTypeEnum.USERDEFINED = "USERDEFINED";
IfcWorkScheduleTypeEnum.NOTDEFINED = "NOTDEFINED";
var IfcActionRequest = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.PredefinedType = PredefinedType;
    this.Status = Status;
    this.LongDescription = LongDescription;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Status = tape[ptr++];
    let LongDescription = tape[ptr++];
    return new IfcActionRequest(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.Status);
    ;
    args.push(this.LongDescription);
    ;
    return args;
  }
}, "IfcActionRequest");
var IfcActor = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheActor) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.TheActor = TheActor;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let TheActor = tape[ptr++];
    return new IfcActor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheActor);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.TheActor);
    ;
    return args;
  }
}, "IfcActor");
var IfcActorRole = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Role, UserDefinedRole, Description) {
    this.expressID = expressID;
    this.type = type;
    this.Role = Role;
    this.UserDefinedRole = UserDefinedRole;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Role = tape[ptr++];
    let UserDefinedRole = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcActorRole(expressID, type, Role, UserDefinedRole, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.Role);
    ;
    args.push(this.UserDefinedRole);
    ;
    args.push(this.Description);
    ;
    return args;
  }
}, "IfcActorRole");
var IfcActuator = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcActuator(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcActuator");
var IfcActuatorType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcActuatorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcActuatorType");
var IfcAddress = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Purpose, Description, UserDefinedPurpose) {
    this.expressID = expressID;
    this.type = type;
    this.Purpose = Purpose;
    this.Description = Description;
    this.UserDefinedPurpose = UserDefinedPurpose;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Purpose = tape[ptr++];
    let Description = tape[ptr++];
    let UserDefinedPurpose = tape[ptr++];
    return new IfcAddress(expressID, type, Purpose, Description, UserDefinedPurpose);
  }
  ToTape() {
    let args = [];
    args.push(this.Purpose);
    ;
    args.push(this.Description);
    ;
    args.push(this.UserDefinedPurpose);
    ;
    return args;
  }
}, "IfcAddress");
var IfcAdvancedBrep = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Outer) {
    this.expressID = expressID;
    this.type = type;
    this.Outer = Outer;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Outer = tape[ptr++];
    return new IfcAdvancedBrep(expressID, type, Outer);
  }
  ToTape() {
    let args = [];
    args.push(this.Outer);
    ;
    return args;
  }
}, "IfcAdvancedBrep");
var IfcAdvancedBrepWithVoids = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Outer, Voids) {
    this.expressID = expressID;
    this.type = type;
    this.Outer = Outer;
    this.Voids = Voids;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Outer = tape[ptr++];
    let Voids = tape[ptr++];
    return new IfcAdvancedBrepWithVoids(expressID, type, Outer, Voids);
  }
  ToTape() {
    let args = [];
    args.push(this.Outer);
    ;
    args.push(this.Voids);
    ;
    return args;
  }
}, "IfcAdvancedBrepWithVoids");
var IfcAdvancedFace = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Bounds, FaceSurface, SameSense) {
    this.expressID = expressID;
    this.type = type;
    this.Bounds = Bounds;
    this.FaceSurface = FaceSurface;
    this.SameSense = SameSense;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Bounds = tape[ptr++];
    let FaceSurface = tape[ptr++];
    let SameSense = tape[ptr++];
    return new IfcAdvancedFace(expressID, type, Bounds, FaceSurface, SameSense);
  }
  ToTape() {
    let args = [];
    args.push(this.Bounds);
    ;
    args.push(this.FaceSurface);
    ;
    args.push(this.SameSense);
    ;
    return args;
  }
}, "IfcAdvancedFace");
var IfcAirTerminal = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAirTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcAirTerminal");
var IfcAirTerminalBox = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAirTerminalBox(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcAirTerminalBox");
var IfcAirTerminalBoxType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAirTerminalBoxType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcAirTerminalBoxType");
var IfcAirTerminalType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAirTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcAirTerminalType");
var IfcAirToAirHeatRecovery = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAirToAirHeatRecovery(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcAirToAirHeatRecovery");
var IfcAirToAirHeatRecoveryType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAirToAirHeatRecoveryType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcAirToAirHeatRecoveryType");
var IfcAlarm = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAlarm(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcAlarm");
var IfcAlarmType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAlarmType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcAlarmType");
var IfcAlignment = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Axis, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Axis = Axis;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Axis = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAlignment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Axis, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Axis);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcAlignment");
var IfcAlignment2DHorizontal = /* @__PURE__ */ __name(class {
  constructor(expressID, type, StartDistAlong, Segments) {
    this.expressID = expressID;
    this.type = type;
    this.StartDistAlong = StartDistAlong;
    this.Segments = Segments;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let StartDistAlong = tape[ptr++];
    let Segments = tape[ptr++];
    return new IfcAlignment2DHorizontal(expressID, type, StartDistAlong, Segments);
  }
  ToTape() {
    let args = [];
    args.push(this.StartDistAlong);
    ;
    args.push(this.Segments);
    ;
    return args;
  }
}, "IfcAlignment2DHorizontal");
var IfcAlignment2DHorizontalSegment = /* @__PURE__ */ __name(class {
  constructor(expressID, type, TangentialContinuity, StartTag, EndTag, CurveGeometry) {
    this.expressID = expressID;
    this.type = type;
    this.TangentialContinuity = TangentialContinuity;
    this.StartTag = StartTag;
    this.EndTag = EndTag;
    this.CurveGeometry = CurveGeometry;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TangentialContinuity = tape[ptr++];
    let StartTag = tape[ptr++];
    let EndTag = tape[ptr++];
    let CurveGeometry = tape[ptr++];
    return new IfcAlignment2DHorizontalSegment(expressID, type, TangentialContinuity, StartTag, EndTag, CurveGeometry);
  }
  ToTape() {
    let args = [];
    args.push(this.TangentialContinuity);
    ;
    args.push(this.StartTag);
    ;
    args.push(this.EndTag);
    ;
    args.push(this.CurveGeometry);
    ;
    return args;
  }
}, "IfcAlignment2DHorizontalSegment");
var IfcAlignment2DSegment = /* @__PURE__ */ __name(class {
  constructor(expressID, type, TangentialContinuity, StartTag, EndTag) {
    this.expressID = expressID;
    this.type = type;
    this.TangentialContinuity = TangentialContinuity;
    this.StartTag = StartTag;
    this.EndTag = EndTag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TangentialContinuity = tape[ptr++];
    let StartTag = tape[ptr++];
    let EndTag = tape[ptr++];
    return new IfcAlignment2DSegment(expressID, type, TangentialContinuity, StartTag, EndTag);
  }
  ToTape() {
    let args = [];
    args.push(this.TangentialContinuity);
    ;
    args.push(this.StartTag);
    ;
    args.push(this.EndTag);
    ;
    return args;
  }
}, "IfcAlignment2DSegment");
var IfcAlignment2DVerSegCircularArc = /* @__PURE__ */ __name(class {
  constructor(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient, Radius, IsConvex) {
    this.expressID = expressID;
    this.type = type;
    this.TangentialContinuity = TangentialContinuity;
    this.StartTag = StartTag;
    this.EndTag = EndTag;
    this.StartDistAlong = StartDistAlong;
    this.HorizontalLength = HorizontalLength;
    this.StartHeight = StartHeight;
    this.StartGradient = StartGradient;
    this.Radius = Radius;
    this.IsConvex = IsConvex;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TangentialContinuity = tape[ptr++];
    let StartTag = tape[ptr++];
    let EndTag = tape[ptr++];
    let StartDistAlong = tape[ptr++];
    let HorizontalLength = tape[ptr++];
    let StartHeight = tape[ptr++];
    let StartGradient = tape[ptr++];
    let Radius = tape[ptr++];
    let IsConvex = tape[ptr++];
    return new IfcAlignment2DVerSegCircularArc(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient, Radius, IsConvex);
  }
  ToTape() {
    let args = [];
    args.push(this.TangentialContinuity);
    ;
    args.push(this.StartTag);
    ;
    args.push(this.EndTag);
    ;
    args.push(this.StartDistAlong);
    ;
    args.push(this.HorizontalLength);
    ;
    args.push(this.StartHeight);
    ;
    args.push(this.StartGradient);
    ;
    args.push(this.Radius);
    ;
    args.push(this.IsConvex);
    ;
    return args;
  }
}, "IfcAlignment2DVerSegCircularArc");
var IfcAlignment2DVerSegLine = /* @__PURE__ */ __name(class {
  constructor(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient) {
    this.expressID = expressID;
    this.type = type;
    this.TangentialContinuity = TangentialContinuity;
    this.StartTag = StartTag;
    this.EndTag = EndTag;
    this.StartDistAlong = StartDistAlong;
    this.HorizontalLength = HorizontalLength;
    this.StartHeight = StartHeight;
    this.StartGradient = StartGradient;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TangentialContinuity = tape[ptr++];
    let StartTag = tape[ptr++];
    let EndTag = tape[ptr++];
    let StartDistAlong = tape[ptr++];
    let HorizontalLength = tape[ptr++];
    let StartHeight = tape[ptr++];
    let StartGradient = tape[ptr++];
    return new IfcAlignment2DVerSegLine(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient);
  }
  ToTape() {
    let args = [];
    args.push(this.TangentialContinuity);
    ;
    args.push(this.StartTag);
    ;
    args.push(this.EndTag);
    ;
    args.push(this.StartDistAlong);
    ;
    args.push(this.HorizontalLength);
    ;
    args.push(this.StartHeight);
    ;
    args.push(this.StartGradient);
    ;
    return args;
  }
}, "IfcAlignment2DVerSegLine");
var IfcAlignment2DVerSegParabolicArc = /* @__PURE__ */ __name(class {
  constructor(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient, ParabolaConstant, IsConvex) {
    this.expressID = expressID;
    this.type = type;
    this.TangentialContinuity = TangentialContinuity;
    this.StartTag = StartTag;
    this.EndTag = EndTag;
    this.StartDistAlong = StartDistAlong;
    this.HorizontalLength = HorizontalLength;
    this.StartHeight = StartHeight;
    this.StartGradient = StartGradient;
    this.ParabolaConstant = ParabolaConstant;
    this.IsConvex = IsConvex;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TangentialContinuity = tape[ptr++];
    let StartTag = tape[ptr++];
    let EndTag = tape[ptr++];
    let StartDistAlong = tape[ptr++];
    let HorizontalLength = tape[ptr++];
    let StartHeight = tape[ptr++];
    let StartGradient = tape[ptr++];
    let ParabolaConstant = tape[ptr++];
    let IsConvex = tape[ptr++];
    return new IfcAlignment2DVerSegParabolicArc(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient, ParabolaConstant, IsConvex);
  }
  ToTape() {
    let args = [];
    args.push(this.TangentialContinuity);
    ;
    args.push(this.StartTag);
    ;
    args.push(this.EndTag);
    ;
    args.push(this.StartDistAlong);
    ;
    args.push(this.HorizontalLength);
    ;
    args.push(this.StartHeight);
    ;
    args.push(this.StartGradient);
    ;
    args.push(this.ParabolaConstant);
    ;
    args.push(this.IsConvex);
    ;
    return args;
  }
}, "IfcAlignment2DVerSegParabolicArc");
var IfcAlignment2DVertical = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Segments) {
    this.expressID = expressID;
    this.type = type;
    this.Segments = Segments;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Segments = tape[ptr++];
    return new IfcAlignment2DVertical(expressID, type, Segments);
  }
  ToTape() {
    let args = [];
    args.push(this.Segments);
    ;
    return args;
  }
}, "IfcAlignment2DVertical");
var IfcAlignment2DVerticalSegment = /* @__PURE__ */ __name(class {
  constructor(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient) {
    this.expressID = expressID;
    this.type = type;
    this.TangentialContinuity = TangentialContinuity;
    this.StartTag = StartTag;
    this.EndTag = EndTag;
    this.StartDistAlong = StartDistAlong;
    this.HorizontalLength = HorizontalLength;
    this.StartHeight = StartHeight;
    this.StartGradient = StartGradient;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TangentialContinuity = tape[ptr++];
    let StartTag = tape[ptr++];
    let EndTag = tape[ptr++];
    let StartDistAlong = tape[ptr++];
    let HorizontalLength = tape[ptr++];
    let StartHeight = tape[ptr++];
    let StartGradient = tape[ptr++];
    return new IfcAlignment2DVerticalSegment(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient);
  }
  ToTape() {
    let args = [];
    args.push(this.TangentialContinuity);
    ;
    args.push(this.StartTag);
    ;
    args.push(this.EndTag);
    ;
    args.push(this.StartDistAlong);
    ;
    args.push(this.HorizontalLength);
    ;
    args.push(this.StartHeight);
    ;
    args.push(this.StartGradient);
    ;
    return args;
  }
}, "IfcAlignment2DVerticalSegment");
var IfcAlignmentCurve = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Horizontal, Vertical, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.Horizontal = Horizontal;
    this.Vertical = Vertical;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Horizontal = tape[ptr++];
    let Vertical = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcAlignmentCurve(expressID, type, Horizontal, Vertical, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.Horizontal);
    ;
    args.push(this.Vertical);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
}, "IfcAlignmentCurve");
var IfcAnnotation = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    return new IfcAnnotation(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    return args;
  }
}, "IfcAnnotation");
var IfcAnnotationFillArea = /* @__PURE__ */ __name(class {
  constructor(expressID, type, OuterBoundary, InnerBoundaries) {
    this.expressID = expressID;
    this.type = type;
    this.OuterBoundary = OuterBoundary;
    this.InnerBoundaries = InnerBoundaries;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let OuterBoundary = tape[ptr++];
    let InnerBoundaries = tape[ptr++];
    return new IfcAnnotationFillArea(expressID, type, OuterBoundary, InnerBoundaries);
  }
  ToTape() {
    let args = [];
    args.push(this.OuterBoundary);
    ;
    args.push(this.InnerBoundaries);
    ;
    return args;
  }
}, "IfcAnnotationFillArea");
var IfcApplication = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ApplicationDeveloper, Version, ApplicationFullName, ApplicationIdentifier) {
    this.expressID = expressID;
    this.type = type;
    this.ApplicationDeveloper = ApplicationDeveloper;
    this.Version = Version;
    this.ApplicationFullName = ApplicationFullName;
    this.ApplicationIdentifier = ApplicationIdentifier;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ApplicationDeveloper = tape[ptr++];
    let Version = tape[ptr++];
    let ApplicationFullName = tape[ptr++];
    let ApplicationIdentifier = tape[ptr++];
    return new IfcApplication(expressID, type, ApplicationDeveloper, Version, ApplicationFullName, ApplicationIdentifier);
  }
  ToTape() {
    let args = [];
    args.push(this.ApplicationDeveloper);
    ;
    args.push(this.Version);
    ;
    args.push(this.ApplicationFullName);
    ;
    args.push(this.ApplicationIdentifier);
    ;
    return args;
  }
}, "IfcApplication");
var IfcAppliedValue = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, AppliedValue, UnitBasis, ApplicableDate, FixedUntilDate, Category, Condition, ArithmeticOperator, Components) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.AppliedValue = AppliedValue;
    this.UnitBasis = UnitBasis;
    this.ApplicableDate = ApplicableDate;
    this.FixedUntilDate = FixedUntilDate;
    this.Category = Category;
    this.Condition = Condition;
    this.ArithmeticOperator = ArithmeticOperator;
    this.Components = Components;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let AppliedValue = tape[ptr++];
    let UnitBasis = tape[ptr++];
    let ApplicableDate = tape[ptr++];
    let FixedUntilDate = tape[ptr++];
    let Category = tape[ptr++];
    let Condition = tape[ptr++];
    let ArithmeticOperator = tape[ptr++];
    let Components = tape[ptr++];
    return new IfcAppliedValue(expressID, type, Name, Description, AppliedValue, UnitBasis, ApplicableDate, FixedUntilDate, Category, Condition, ArithmeticOperator, Components);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.AppliedValue);
    ;
    args.push(this.UnitBasis);
    ;
    args.push(this.ApplicableDate);
    ;
    args.push(this.FixedUntilDate);
    ;
    args.push(this.Category);
    ;
    args.push(this.Condition);
    ;
    args.push(this.ArithmeticOperator);
    ;
    args.push(this.Components);
    ;
    return args;
  }
}, "IfcAppliedValue");
var IfcApproval = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Identifier, Name, Description, TimeOfApproval, Status, Level, Qualifier, RequestingApproval, GivingApproval) {
    this.expressID = expressID;
    this.type = type;
    this.Identifier = Identifier;
    this.Name = Name;
    this.Description = Description;
    this.TimeOfApproval = TimeOfApproval;
    this.Status = Status;
    this.Level = Level;
    this.Qualifier = Qualifier;
    this.RequestingApproval = RequestingApproval;
    this.GivingApproval = GivingApproval;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Identifier = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let TimeOfApproval = tape[ptr++];
    let Status = tape[ptr++];
    let Level = tape[ptr++];
    let Qualifier = tape[ptr++];
    let RequestingApproval = tape[ptr++];
    let GivingApproval = tape[ptr++];
    return new IfcApproval(expressID, type, Identifier, Name, Description, TimeOfApproval, Status, Level, Qualifier, RequestingApproval, GivingApproval);
  }
  ToTape() {
    let args = [];
    args.push(this.Identifier);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.TimeOfApproval);
    ;
    args.push(this.Status);
    ;
    args.push(this.Level);
    ;
    args.push(this.Qualifier);
    ;
    args.push(this.RequestingApproval);
    ;
    args.push(this.GivingApproval);
    ;
    return args;
  }
}, "IfcApproval");
var IfcApprovalRelationship = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, RelatingApproval, RelatedApprovals) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.RelatingApproval = RelatingApproval;
    this.RelatedApprovals = RelatedApprovals;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingApproval = tape[ptr++];
    let RelatedApprovals = tape[ptr++];
    return new IfcApprovalRelationship(expressID, type, Name, Description, RelatingApproval, RelatedApprovals);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingApproval);
    ;
    args.push(this.RelatedApprovals);
    ;
    return args;
  }
}, "IfcApprovalRelationship");
var IfcArbitraryClosedProfileDef = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ProfileType, ProfileName, OuterCurve) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.OuterCurve = OuterCurve;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let OuterCurve = tape[ptr++];
    return new IfcArbitraryClosedProfileDef(expressID, type, ProfileType, ProfileName, OuterCurve);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.OuterCurve);
    ;
    return args;
  }
}, "IfcArbitraryClosedProfileDef");
var IfcArbitraryOpenProfileDef = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ProfileType, ProfileName, Curve) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Curve = Curve;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Curve = tape[ptr++];
    return new IfcArbitraryOpenProfileDef(expressID, type, ProfileType, ProfileName, Curve);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Curve);
    ;
    return args;
  }
}, "IfcArbitraryOpenProfileDef");
var IfcArbitraryProfileDefWithVoids = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ProfileType, ProfileName, OuterCurve, InnerCurves) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.OuterCurve = OuterCurve;
    this.InnerCurves = InnerCurves;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let OuterCurve = tape[ptr++];
    let InnerCurves = tape[ptr++];
    return new IfcArbitraryProfileDefWithVoids(expressID, type, ProfileType, ProfileName, OuterCurve, InnerCurves);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.OuterCurve);
    ;
    args.push(this.InnerCurves);
    ;
    return args;
  }
}, "IfcArbitraryProfileDefWithVoids");
var IfcAsset = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, OriginalValue, CurrentValue, TotalReplacementCost, Owner, User, ResponsiblePerson, IncorporationDate, DepreciatedValue) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.OriginalValue = OriginalValue;
    this.CurrentValue = CurrentValue;
    this.TotalReplacementCost = TotalReplacementCost;
    this.Owner = Owner;
    this.User = User;
    this.ResponsiblePerson = ResponsiblePerson;
    this.IncorporationDate = IncorporationDate;
    this.DepreciatedValue = DepreciatedValue;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let OriginalValue = tape[ptr++];
    let CurrentValue = tape[ptr++];
    let TotalReplacementCost = tape[ptr++];
    let Owner = tape[ptr++];
    let User = tape[ptr++];
    let ResponsiblePerson = tape[ptr++];
    let IncorporationDate = tape[ptr++];
    let DepreciatedValue = tape[ptr++];
    return new IfcAsset(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, OriginalValue, CurrentValue, TotalReplacementCost, Owner, User, ResponsiblePerson, IncorporationDate, DepreciatedValue);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.OriginalValue);
    ;
    args.push(this.CurrentValue);
    ;
    args.push(this.TotalReplacementCost);
    ;
    args.push(this.Owner);
    ;
    args.push(this.User);
    ;
    args.push(this.ResponsiblePerson);
    ;
    args.push(this.IncorporationDate);
    ;
    args.push(this.DepreciatedValue);
    ;
    return args;
  }
}, "IfcAsset");
var IfcAsymmetricIShapeProfileDef = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ProfileType, ProfileName, Position, BottomFlangeWidth, OverallDepth, WebThickness, BottomFlangeThickness, BottomFlangeFilletRadius, TopFlangeWidth, TopFlangeThickness, TopFlangeFilletRadius, BottomFlangeEdgeRadius, BottomFlangeSlope, TopFlangeEdgeRadius, TopFlangeSlope) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.BottomFlangeWidth = BottomFlangeWidth;
    this.OverallDepth = OverallDepth;
    this.WebThickness = WebThickness;
    this.BottomFlangeThickness = BottomFlangeThickness;
    this.BottomFlangeFilletRadius = BottomFlangeFilletRadius;
    this.TopFlangeWidth = TopFlangeWidth;
    this.TopFlangeThickness = TopFlangeThickness;
    this.TopFlangeFilletRadius = TopFlangeFilletRadius;
    this.BottomFlangeEdgeRadius = BottomFlangeEdgeRadius;
    this.BottomFlangeSlope = BottomFlangeSlope;
    this.TopFlangeEdgeRadius = TopFlangeEdgeRadius;
    this.TopFlangeSlope = TopFlangeSlope;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let BottomFlangeWidth = tape[ptr++];
    let OverallDepth = tape[ptr++];
    let WebThickness = tape[ptr++];
    let BottomFlangeThickness = tape[ptr++];
    let BottomFlangeFilletRadius = tape[ptr++];
    let TopFlangeWidth = tape[ptr++];
    let TopFlangeThickness = tape[ptr++];
    let TopFlangeFilletRadius = tape[ptr++];
    let BottomFlangeEdgeRadius = tape[ptr++];
    let BottomFlangeSlope = tape[ptr++];
    let TopFlangeEdgeRadius = tape[ptr++];
    let TopFlangeSlope = tape[ptr++];
    return new IfcAsymmetricIShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, BottomFlangeWidth, OverallDepth, WebThickness, BottomFlangeThickness, BottomFlangeFilletRadius, TopFlangeWidth, TopFlangeThickness, TopFlangeFilletRadius, BottomFlangeEdgeRadius, BottomFlangeSlope, TopFlangeEdgeRadius, TopFlangeSlope);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Position);
    ;
    args.push(this.BottomFlangeWidth);
    ;
    args.push(this.OverallDepth);
    ;
    args.push(this.WebThickness);
    ;
    args.push(this.BottomFlangeThickness);
    ;
    args.push(this.BottomFlangeFilletRadius);
    ;
    args.push(this.TopFlangeWidth);
    ;
    args.push(this.TopFlangeThickness);
    ;
    args.push(this.TopFlangeFilletRadius);
    ;
    args.push(this.BottomFlangeEdgeRadius);
    ;
    args.push(this.BottomFlangeSlope);
    ;
    args.push(this.TopFlangeEdgeRadius);
    ;
    args.push(this.TopFlangeSlope);
    ;
    return args;
  }
}, "IfcAsymmetricIShapeProfileDef");
var IfcAudioVisualAppliance = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAudioVisualAppliance(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcAudioVisualAppliance");
var IfcAudioVisualApplianceType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAudioVisualApplianceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcAudioVisualApplianceType");
var IfcAxis1Placement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Location, Axis) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Axis = Axis;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Axis = tape[ptr++];
    return new IfcAxis1Placement(expressID, type, Location, Axis);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    ;
    args.push(this.Axis);
    ;
    return args;
  }
}, "IfcAxis1Placement");
var IfcAxis2Placement2D = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Location, RefDirection) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.RefDirection = RefDirection;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let RefDirection = tape[ptr++];
    return new IfcAxis2Placement2D(expressID, type, Location, RefDirection);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    ;
    args.push(this.RefDirection);
    ;
    return args;
  }
}, "IfcAxis2Placement2D");
var IfcAxis2Placement3D = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Location, Axis, RefDirection) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Axis = Axis;
    this.RefDirection = RefDirection;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Axis = tape[ptr++];
    let RefDirection = tape[ptr++];
    return new IfcAxis2Placement3D(expressID, type, Location, Axis, RefDirection);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    ;
    args.push(this.Axis);
    ;
    args.push(this.RefDirection);
    ;
    return args;
  }
}, "IfcAxis2Placement3D");
var IfcBSplineCurve = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect) {
    this.expressID = expressID;
    this.type = type;
    this.Degree = Degree;
    this.ControlPointsList = ControlPointsList;
    this.CurveForm = CurveForm;
    this.ClosedCurve = ClosedCurve;
    this.SelfIntersect = SelfIntersect;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Degree = tape[ptr++];
    let ControlPointsList = tape[ptr++];
    let CurveForm = tape[ptr++];
    let ClosedCurve = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    return new IfcBSplineCurve(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect);
  }
  ToTape() {
    let args = [];
    args.push(this.Degree);
    ;
    args.push(this.ControlPointsList);
    ;
    args.push(this.CurveForm);
    ;
    args.push(this.ClosedCurve);
    ;
    args.push(this.SelfIntersect);
    ;
    return args;
  }
}, "IfcBSplineCurve");
var IfcBSplineCurveWithKnots = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect, KnotMultiplicities, Knots, KnotSpec) {
    this.expressID = expressID;
    this.type = type;
    this.Degree = Degree;
    this.ControlPointsList = ControlPointsList;
    this.CurveForm = CurveForm;
    this.ClosedCurve = ClosedCurve;
    this.SelfIntersect = SelfIntersect;
    this.KnotMultiplicities = KnotMultiplicities;
    this.Knots = Knots;
    this.KnotSpec = KnotSpec;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Degree = tape[ptr++];
    let ControlPointsList = tape[ptr++];
    let CurveForm = tape[ptr++];
    let ClosedCurve = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    let KnotMultiplicities = tape[ptr++];
    let Knots = tape[ptr++];
    let KnotSpec = tape[ptr++];
    return new IfcBSplineCurveWithKnots(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect, KnotMultiplicities, Knots, KnotSpec);
  }
  ToTape() {
    let args = [];
    args.push(this.Degree);
    ;
    args.push(this.ControlPointsList);
    ;
    args.push(this.CurveForm);
    ;
    args.push(this.ClosedCurve);
    ;
    args.push(this.SelfIntersect);
    ;
    args.push(this.KnotMultiplicities);
    ;
    args.push(this.Knots);
    ;
    args.push(this.KnotSpec);
    ;
    return args;
  }
}, "IfcBSplineCurveWithKnots");
var IfcBSplineSurface = /* @__PURE__ */ __name(class {
  constructor(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect) {
    this.expressID = expressID;
    this.type = type;
    this.UDegree = UDegree;
    this.VDegree = VDegree;
    this.ControlPointsList = ControlPointsList;
    this.SurfaceForm = SurfaceForm;
    this.UClosed = UClosed;
    this.VClosed = VClosed;
    this.SelfIntersect = SelfIntersect;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let UDegree = tape[ptr++];
    let VDegree = tape[ptr++];
    let ControlPointsList = tape[ptr++];
    let SurfaceForm = tape[ptr++];
    let UClosed = tape[ptr++];
    let VClosed = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    return new IfcBSplineSurface(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect);
  }
  ToTape() {
    let args = [];
    args.push(this.UDegree);
    ;
    args.push(this.VDegree);
    ;
    args.push(this.ControlPointsList);
    ;
    args.push(this.SurfaceForm);
    ;
    args.push(this.UClosed);
    ;
    args.push(this.VClosed);
    ;
    args.push(this.SelfIntersect);
    ;
    return args;
  }
}, "IfcBSplineSurface");
var IfcBSplineSurfaceWithKnots = /* @__PURE__ */ __name(class {
  constructor(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect, UMultiplicities, VMultiplicities, UKnots, VKnots, KnotSpec) {
    this.expressID = expressID;
    this.type = type;
    this.UDegree = UDegree;
    this.VDegree = VDegree;
    this.ControlPointsList = ControlPointsList;
    this.SurfaceForm = SurfaceForm;
    this.UClosed = UClosed;
    this.VClosed = VClosed;
    this.SelfIntersect = SelfIntersect;
    this.UMultiplicities = UMultiplicities;
    this.VMultiplicities = VMultiplicities;
    this.UKnots = UKnots;
    this.VKnots = VKnots;
    this.KnotSpec = KnotSpec;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let UDegree = tape[ptr++];
    let VDegree = tape[ptr++];
    let ControlPointsList = tape[ptr++];
    let SurfaceForm = tape[ptr++];
    let UClosed = tape[ptr++];
    let VClosed = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    let UMultiplicities = tape[ptr++];
    let VMultiplicities = tape[ptr++];
    let UKnots = tape[ptr++];
    let VKnots = tape[ptr++];
    let KnotSpec = tape[ptr++];
    return new IfcBSplineSurfaceWithKnots(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect, UMultiplicities, VMultiplicities, UKnots, VKnots, KnotSpec);
  }
  ToTape() {
    let args = [];
    args.push(this.UDegree);
    ;
    args.push(this.VDegree);
    ;
    args.push(this.ControlPointsList);
    ;
    args.push(this.SurfaceForm);
    ;
    args.push(this.UClosed);
    ;
    args.push(this.VClosed);
    ;
    args.push(this.SelfIntersect);
    ;
    args.push(this.UMultiplicities);
    ;
    args.push(this.VMultiplicities);
    ;
    args.push(this.UKnots);
    ;
    args.push(this.VKnots);
    ;
    args.push(this.KnotSpec);
    ;
    return args;
  }
}, "IfcBSplineSurfaceWithKnots");
var IfcBeam = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBeam(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcBeam");
var IfcBeamStandardCase = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBeamStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcBeamStandardCase");
var IfcBeamType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBeamType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcBeamType");
var IfcBearing = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBearing(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcBearing");
var IfcBearingType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBearingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcBearingType");
var IfcBlobTexture = /* @__PURE__ */ __name(class {
  constructor(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, RasterFormat, RasterCode) {
    this.expressID = expressID;
    this.type = type;
    this.RepeatS = RepeatS;
    this.RepeatT = RepeatT;
    this.Mode = Mode;
    this.TextureTransform = TextureTransform;
    this.Parameter = Parameter;
    this.RasterFormat = RasterFormat;
    this.RasterCode = RasterCode;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let RepeatS = tape[ptr++];
    let RepeatT = tape[ptr++];
    let Mode = tape[ptr++];
    let TextureTransform = tape[ptr++];
    let Parameter = tape[ptr++];
    let RasterFormat = tape[ptr++];
    let RasterCode = tape[ptr++];
    return new IfcBlobTexture(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, RasterFormat, RasterCode);
  }
  ToTape() {
    let args = [];
    args.push(this.RepeatS);
    ;
    args.push(this.RepeatT);
    ;
    args.push(this.Mode);
    ;
    args.push(this.TextureTransform);
    ;
    args.push(this.Parameter);
    ;
    args.push(this.RasterFormat);
    ;
    args.push(this.RasterCode);
    ;
    return args;
  }
}, "IfcBlobTexture");
var IfcBlock = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Position, XLength, YLength, ZLength) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.XLength = XLength;
    this.YLength = YLength;
    this.ZLength = ZLength;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let XLength = tape[ptr++];
    let YLength = tape[ptr++];
    let ZLength = tape[ptr++];
    return new IfcBlock(expressID, type, Position, XLength, YLength, ZLength);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    ;
    args.push(this.XLength);
    ;
    args.push(this.YLength);
    ;
    args.push(this.ZLength);
    ;
    return args;
  }
}, "IfcBlock");
var IfcBoiler = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBoiler(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcBoiler");
var IfcBoilerType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBoilerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcBoilerType");
var IfcBooleanClippingResult = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Operator, FirstOperand, SecondOperand) {
    this.expressID = expressID;
    this.type = type;
    this.Operator = Operator;
    this.FirstOperand = FirstOperand;
    this.SecondOperand = SecondOperand;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Operator = tape[ptr++];
    let FirstOperand = tape[ptr++];
    let SecondOperand = tape[ptr++];
    return new IfcBooleanClippingResult(expressID, type, Operator, FirstOperand, SecondOperand);
  }
  ToTape() {
    let args = [];
    args.push(this.Operator);
    ;
    args.push(this.FirstOperand);
    ;
    args.push(this.SecondOperand);
    ;
    return args;
  }
}, "IfcBooleanClippingResult");
var IfcBooleanResult = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Operator, FirstOperand, SecondOperand) {
    this.expressID = expressID;
    this.type = type;
    this.Operator = Operator;
    this.FirstOperand = FirstOperand;
    this.SecondOperand = SecondOperand;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Operator = tape[ptr++];
    let FirstOperand = tape[ptr++];
    let SecondOperand = tape[ptr++];
    return new IfcBooleanResult(expressID, type, Operator, FirstOperand, SecondOperand);
  }
  ToTape() {
    let args = [];
    args.push(this.Operator);
    ;
    args.push(this.FirstOperand);
    ;
    args.push(this.SecondOperand);
    ;
    return args;
  }
}, "IfcBooleanResult");
var IfcBoundaryCondition = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcBoundaryCondition(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    return args;
  }
}, "IfcBoundaryCondition");
var IfcBoundaryCurve = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Segments, SelfIntersect) {
    this.expressID = expressID;
    this.type = type;
    this.Segments = Segments;
    this.SelfIntersect = SelfIntersect;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Segments = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    return new IfcBoundaryCurve(expressID, type, Segments, SelfIntersect);
  }
  ToTape() {
    let args = [];
    args.push(this.Segments);
    ;
    args.push(this.SelfIntersect);
    ;
    return args;
  }
}, "IfcBoundaryCurve");
var IfcBoundaryEdgeCondition = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, TranslationalStiffnessByLengthX, TranslationalStiffnessByLengthY, TranslationalStiffnessByLengthZ, RotationalStiffnessByLengthX, RotationalStiffnessByLengthY, RotationalStiffnessByLengthZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.TranslationalStiffnessByLengthX = TranslationalStiffnessByLengthX;
    this.TranslationalStiffnessByLengthY = TranslationalStiffnessByLengthY;
    this.TranslationalStiffnessByLengthZ = TranslationalStiffnessByLengthZ;
    this.RotationalStiffnessByLengthX = RotationalStiffnessByLengthX;
    this.RotationalStiffnessByLengthY = RotationalStiffnessByLengthY;
    this.RotationalStiffnessByLengthZ = RotationalStiffnessByLengthZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let TranslationalStiffnessByLengthX = tape[ptr++];
    let TranslationalStiffnessByLengthY = tape[ptr++];
    let TranslationalStiffnessByLengthZ = tape[ptr++];
    let RotationalStiffnessByLengthX = tape[ptr++];
    let RotationalStiffnessByLengthY = tape[ptr++];
    let RotationalStiffnessByLengthZ = tape[ptr++];
    return new IfcBoundaryEdgeCondition(expressID, type, Name, TranslationalStiffnessByLengthX, TranslationalStiffnessByLengthY, TranslationalStiffnessByLengthZ, RotationalStiffnessByLengthX, RotationalStiffnessByLengthY, RotationalStiffnessByLengthZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.TranslationalStiffnessByLengthX);
    ;
    args.push(this.TranslationalStiffnessByLengthY);
    ;
    args.push(this.TranslationalStiffnessByLengthZ);
    ;
    args.push(this.RotationalStiffnessByLengthX);
    ;
    args.push(this.RotationalStiffnessByLengthY);
    ;
    args.push(this.RotationalStiffnessByLengthZ);
    ;
    return args;
  }
}, "IfcBoundaryEdgeCondition");
var IfcBoundaryFaceCondition = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, TranslationalStiffnessByAreaX, TranslationalStiffnessByAreaY, TranslationalStiffnessByAreaZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.TranslationalStiffnessByAreaX = TranslationalStiffnessByAreaX;
    this.TranslationalStiffnessByAreaY = TranslationalStiffnessByAreaY;
    this.TranslationalStiffnessByAreaZ = TranslationalStiffnessByAreaZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let TranslationalStiffnessByAreaX = tape[ptr++];
    let TranslationalStiffnessByAreaY = tape[ptr++];
    let TranslationalStiffnessByAreaZ = tape[ptr++];
    return new IfcBoundaryFaceCondition(expressID, type, Name, TranslationalStiffnessByAreaX, TranslationalStiffnessByAreaY, TranslationalStiffnessByAreaZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.TranslationalStiffnessByAreaX);
    ;
    args.push(this.TranslationalStiffnessByAreaY);
    ;
    args.push(this.TranslationalStiffnessByAreaZ);
    ;
    return args;
  }
}, "IfcBoundaryFaceCondition");
var IfcBoundaryNodeCondition = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, TranslationalStiffnessX, TranslationalStiffnessY, TranslationalStiffnessZ, RotationalStiffnessX, RotationalStiffnessY, RotationalStiffnessZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.TranslationalStiffnessX = TranslationalStiffnessX;
    this.TranslationalStiffnessY = TranslationalStiffnessY;
    this.TranslationalStiffnessZ = TranslationalStiffnessZ;
    this.RotationalStiffnessX = RotationalStiffnessX;
    this.RotationalStiffnessY = RotationalStiffnessY;
    this.RotationalStiffnessZ = RotationalStiffnessZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let TranslationalStiffnessX = tape[ptr++];
    let TranslationalStiffnessY = tape[ptr++];
    let TranslationalStiffnessZ = tape[ptr++];
    let RotationalStiffnessX = tape[ptr++];
    let RotationalStiffnessY = tape[ptr++];
    let RotationalStiffnessZ = tape[ptr++];
    return new IfcBoundaryNodeCondition(expressID, type, Name, TranslationalStiffnessX, TranslationalStiffnessY, TranslationalStiffnessZ, RotationalStiffnessX, RotationalStiffnessY, RotationalStiffnessZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.TranslationalStiffnessX);
    ;
    args.push(this.TranslationalStiffnessY);
    ;
    args.push(this.TranslationalStiffnessZ);
    ;
    args.push(this.RotationalStiffnessX);
    ;
    args.push(this.RotationalStiffnessY);
    ;
    args.push(this.RotationalStiffnessZ);
    ;
    return args;
  }
}, "IfcBoundaryNodeCondition");
var IfcBoundaryNodeConditionWarping = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, TranslationalStiffnessX, TranslationalStiffnessY, TranslationalStiffnessZ, RotationalStiffnessX, RotationalStiffnessY, RotationalStiffnessZ, WarpingStiffness) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.TranslationalStiffnessX = TranslationalStiffnessX;
    this.TranslationalStiffnessY = TranslationalStiffnessY;
    this.TranslationalStiffnessZ = TranslationalStiffnessZ;
    this.RotationalStiffnessX = RotationalStiffnessX;
    this.RotationalStiffnessY = RotationalStiffnessY;
    this.RotationalStiffnessZ = RotationalStiffnessZ;
    this.WarpingStiffness = WarpingStiffness;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let TranslationalStiffnessX = tape[ptr++];
    let TranslationalStiffnessY = tape[ptr++];
    let TranslationalStiffnessZ = tape[ptr++];
    let RotationalStiffnessX = tape[ptr++];
    let RotationalStiffnessY = tape[ptr++];
    let RotationalStiffnessZ = tape[ptr++];
    let WarpingStiffness = tape[ptr++];
    return new IfcBoundaryNodeConditionWarping(expressID, type, Name, TranslationalStiffnessX, TranslationalStiffnessY, TranslationalStiffnessZ, RotationalStiffnessX, RotationalStiffnessY, RotationalStiffnessZ, WarpingStiffness);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.TranslationalStiffnessX);
    ;
    args.push(this.TranslationalStiffnessY);
    ;
    args.push(this.TranslationalStiffnessZ);
    ;
    args.push(this.RotationalStiffnessX);
    ;
    args.push(this.RotationalStiffnessY);
    ;
    args.push(this.RotationalStiffnessZ);
    ;
    args.push(this.WarpingStiffness);
    ;
    return args;
  }
}, "IfcBoundaryNodeConditionWarping");
var IfcBoundedCurve = /* @__PURE__ */ __name(class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcBoundedCurve(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
}, "IfcBoundedCurve");
var IfcBoundedSurface = /* @__PURE__ */ __name(class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcBoundedSurface(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
}, "IfcBoundedSurface");
var IfcBoundingBox = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Corner, XDim, YDim, ZDim) {
    this.expressID = expressID;
    this.type = type;
    this.Corner = Corner;
    this.XDim = XDim;
    this.YDim = YDim;
    this.ZDim = ZDim;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Corner = tape[ptr++];
    let XDim = tape[ptr++];
    let YDim = tape[ptr++];
    let ZDim = tape[ptr++];
    return new IfcBoundingBox(expressID, type, Corner, XDim, YDim, ZDim);
  }
  ToTape() {
    let args = [];
    args.push(this.Corner);
    ;
    args.push(this.XDim);
    ;
    args.push(this.YDim);
    ;
    args.push(this.ZDim);
    ;
    return args;
  }
}, "IfcBoundingBox");
var IfcBoxedHalfSpace = /* @__PURE__ */ __name(class {
  constructor(expressID, type, BaseSurface, AgreementFlag, Enclosure) {
    this.expressID = expressID;
    this.type = type;
    this.BaseSurface = BaseSurface;
    this.AgreementFlag = AgreementFlag;
    this.Enclosure = Enclosure;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BaseSurface = tape[ptr++];
    let AgreementFlag = tape[ptr++];
    let Enclosure = tape[ptr++];
    return new IfcBoxedHalfSpace(expressID, type, BaseSurface, AgreementFlag, Enclosure);
  }
  ToTape() {
    let args = [];
    args.push(this.BaseSurface);
    ;
    args.push(this.AgreementFlag);
    ;
    args.push(this.Enclosure);
    ;
    return args;
  }
}, "IfcBoxedHalfSpace");
var IfcBridge = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBridge(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.LongName);
    ;
    args.push(this.CompositionType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcBridge");
var IfcBridgePart = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBridgePart(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.LongName);
    ;
    args.push(this.CompositionType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcBridgePart");
var IfcBuilding = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, ElevationOfRefHeight, ElevationOfTerrain, BuildingAddress) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
    this.ElevationOfRefHeight = ElevationOfRefHeight;
    this.ElevationOfTerrain = ElevationOfTerrain;
    this.BuildingAddress = BuildingAddress;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    let ElevationOfRefHeight = tape[ptr++];
    let ElevationOfTerrain = tape[ptr++];
    let BuildingAddress = tape[ptr++];
    return new IfcBuilding(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, ElevationOfRefHeight, ElevationOfTerrain, BuildingAddress);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.LongName);
    ;
    args.push(this.CompositionType);
    ;
    args.push(this.ElevationOfRefHeight);
    ;
    args.push(this.ElevationOfTerrain);
    ;
    args.push(this.BuildingAddress);
    ;
    return args;
  }
}, "IfcBuilding");
var IfcBuildingElement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcBuildingElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
}, "IfcBuildingElement");
var IfcBuildingElementPart = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBuildingElementPart(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcBuildingElementPart");
var IfcBuildingElementPartType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBuildingElementPartType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcBuildingElementPartType");
var IfcBuildingElementProxy = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBuildingElementProxy(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcBuildingElementProxy");
var IfcBuildingElementProxyType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBuildingElementProxyType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcBuildingElementProxyType");
var IfcBuildingElementType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcBuildingElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
}, "IfcBuildingElementType");
var IfcBuildingStorey = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, Elevation) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
    this.Elevation = Elevation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    let Elevation = tape[ptr++];
    return new IfcBuildingStorey(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, Elevation);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.LongName);
    ;
    args.push(this.CompositionType);
    ;
    args.push(this.Elevation);
    ;
    return args;
  }
}, "IfcBuildingStorey");
var IfcBuildingSystem = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, LongName) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.PredefinedType = PredefinedType;
    this.LongName = LongName;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let LongName = tape[ptr++];
    return new IfcBuildingSystem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, LongName);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.LongName);
    ;
    return args;
  }
}, "IfcBuildingSystem");
var IfcBurner = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBurner(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcBurner");
var IfcBurnerType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBurnerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcBurnerType");
var IfcCShapeProfileDef = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ProfileType, ProfileName, Position, Depth, Width, WallThickness, Girth, InternalFilletRadius) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.Depth = Depth;
    this.Width = Width;
    this.WallThickness = WallThickness;
    this.Girth = Girth;
    this.InternalFilletRadius = InternalFilletRadius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let Depth = tape[ptr++];
    let Width = tape[ptr++];
    let WallThickness = tape[ptr++];
    let Girth = tape[ptr++];
    let InternalFilletRadius = tape[ptr++];
    return new IfcCShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, Width, WallThickness, Girth, InternalFilletRadius);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Position);
    ;
    args.push(this.Depth);
    ;
    args.push(this.Width);
    ;
    args.push(this.WallThickness);
    ;
    args.push(this.Girth);
    ;
    args.push(this.InternalFilletRadius);
    ;
    return args;
  }
}, "IfcCShapeProfileDef");
var IfcCableCarrierFitting = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCableCarrierFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcCableCarrierFitting");
var IfcCableCarrierFittingType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCableCarrierFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcCableCarrierFittingType");
var IfcCableCarrierSegment = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCableCarrierSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcCableCarrierSegment");
var IfcCableCarrierSegmentType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCableCarrierSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcCableCarrierSegmentType");
var IfcCableFitting = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCableFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcCableFitting");
var IfcCableFittingType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCableFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcCableFittingType");
var IfcCableSegment = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCableSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcCableSegment");
var IfcCableSegmentType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCableSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcCableSegmentType");
var IfcCaissonFoundation = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCaissonFoundation(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcCaissonFoundation");
var IfcCaissonFoundationType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCaissonFoundationType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcCaissonFoundationType");
var IfcCartesianPoint = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Coordinates) {
    this.expressID = expressID;
    this.type = type;
    this.Coordinates = Coordinates;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Coordinates = tape[ptr++];
    return new IfcCartesianPoint(expressID, type, Coordinates);
  }
  ToTape() {
    let args = [];
    args.push(this.Coordinates);
    ;
    return args;
  }
}, "IfcCartesianPoint");
var IfcCartesianPointList = /* @__PURE__ */ __name(class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcCartesianPointList(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
}, "IfcCartesianPointList");
var IfcCartesianPointList2D = /* @__PURE__ */ __name(class {
  constructor(expressID, type, CoordList, TagList) {
    this.expressID = expressID;
    this.type = type;
    this.CoordList = CoordList;
    this.TagList = TagList;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let CoordList = tape[ptr++];
    let TagList = tape[ptr++];
    return new IfcCartesianPointList2D(expressID, type, CoordList, TagList);
  }
  ToTape() {
    let args = [];
    args.push(this.CoordList);
    ;
    args.push(this.TagList);
    ;
    return args;
  }
}, "IfcCartesianPointList2D");
var IfcCartesianPointList3D = /* @__PURE__ */ __name(class {
  constructor(expressID, type, CoordList, TagList) {
    this.expressID = expressID;
    this.type = type;
    this.CoordList = CoordList;
    this.TagList = TagList;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let CoordList = tape[ptr++];
    let TagList = tape[ptr++];
    return new IfcCartesianPointList3D(expressID, type, CoordList, TagList);
  }
  ToTape() {
    let args = [];
    args.push(this.CoordList);
    ;
    args.push(this.TagList);
    ;
    return args;
  }
}, "IfcCartesianPointList3D");
var IfcCartesianTransformationOperator = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Axis1, Axis2, LocalOrigin, Scale) {
    this.expressID = expressID;
    this.type = type;
    this.Axis1 = Axis1;
    this.Axis2 = Axis2;
    this.LocalOrigin = LocalOrigin;
    this.Scale = Scale;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Axis1 = tape[ptr++];
    let Axis2 = tape[ptr++];
    let LocalOrigin = tape[ptr++];
    let Scale = tape[ptr++];
    return new IfcCartesianTransformationOperator(expressID, type, Axis1, Axis2, LocalOrigin, Scale);
  }
  ToTape() {
    let args = [];
    args.push(this.Axis1);
    ;
    args.push(this.Axis2);
    ;
    args.push(this.LocalOrigin);
    ;
    args.push(this.Scale);
    ;
    return args;
  }
}, "IfcCartesianTransformationOperator");
var IfcCartesianTransformationOperator2D = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Axis1, Axis2, LocalOrigin, Scale) {
    this.expressID = expressID;
    this.type = type;
    this.Axis1 = Axis1;
    this.Axis2 = Axis2;
    this.LocalOrigin = LocalOrigin;
    this.Scale = Scale;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Axis1 = tape[ptr++];
    let Axis2 = tape[ptr++];
    let LocalOrigin = tape[ptr++];
    let Scale = tape[ptr++];
    return new IfcCartesianTransformationOperator2D(expressID, type, Axis1, Axis2, LocalOrigin, Scale);
  }
  ToTape() {
    let args = [];
    args.push(this.Axis1);
    ;
    args.push(this.Axis2);
    ;
    args.push(this.LocalOrigin);
    ;
    args.push(this.Scale);
    ;
    return args;
  }
}, "IfcCartesianTransformationOperator2D");
var IfcCartesianTransformationOperator2DnonUniform = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Scale2) {
    this.expressID = expressID;
    this.type = type;
    this.Axis1 = Axis1;
    this.Axis2 = Axis2;
    this.LocalOrigin = LocalOrigin;
    this.Scale = Scale;
    this.Scale2 = Scale2;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Axis1 = tape[ptr++];
    let Axis2 = tape[ptr++];
    let LocalOrigin = tape[ptr++];
    let Scale = tape[ptr++];
    let Scale2 = tape[ptr++];
    return new IfcCartesianTransformationOperator2DnonUniform(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Scale2);
  }
  ToTape() {
    let args = [];
    args.push(this.Axis1);
    ;
    args.push(this.Axis2);
    ;
    args.push(this.LocalOrigin);
    ;
    args.push(this.Scale);
    ;
    args.push(this.Scale2);
    ;
    return args;
  }
}, "IfcCartesianTransformationOperator2DnonUniform");
var IfcCartesianTransformationOperator3D = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Axis3) {
    this.expressID = expressID;
    this.type = type;
    this.Axis1 = Axis1;
    this.Axis2 = Axis2;
    this.LocalOrigin = LocalOrigin;
    this.Scale = Scale;
    this.Axis3 = Axis3;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Axis1 = tape[ptr++];
    let Axis2 = tape[ptr++];
    let LocalOrigin = tape[ptr++];
    let Scale = tape[ptr++];
    let Axis3 = tape[ptr++];
    return new IfcCartesianTransformationOperator3D(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Axis3);
  }
  ToTape() {
    let args = [];
    args.push(this.Axis1);
    ;
    args.push(this.Axis2);
    ;
    args.push(this.LocalOrigin);
    ;
    args.push(this.Scale);
    ;
    args.push(this.Axis3);
    ;
    return args;
  }
}, "IfcCartesianTransformationOperator3D");
var IfcCartesianTransformationOperator3DnonUniform = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Axis3, Scale2, Scale3) {
    this.expressID = expressID;
    this.type = type;
    this.Axis1 = Axis1;
    this.Axis2 = Axis2;
    this.LocalOrigin = LocalOrigin;
    this.Scale = Scale;
    this.Axis3 = Axis3;
    this.Scale2 = Scale2;
    this.Scale3 = Scale3;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Axis1 = tape[ptr++];
    let Axis2 = tape[ptr++];
    let LocalOrigin = tape[ptr++];
    let Scale = tape[ptr++];
    let Axis3 = tape[ptr++];
    let Scale2 = tape[ptr++];
    let Scale3 = tape[ptr++];
    return new IfcCartesianTransformationOperator3DnonUniform(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Axis3, Scale2, Scale3);
  }
  ToTape() {
    let args = [];
    args.push(this.Axis1);
    ;
    args.push(this.Axis2);
    ;
    args.push(this.LocalOrigin);
    ;
    args.push(this.Scale);
    ;
    args.push(this.Axis3);
    ;
    args.push(this.Scale2);
    ;
    args.push(this.Scale3);
    ;
    return args;
  }
}, "IfcCartesianTransformationOperator3DnonUniform");
var IfcCenterLineProfileDef = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ProfileType, ProfileName, Curve, Thickness) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Curve = Curve;
    this.Thickness = Thickness;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Curve = tape[ptr++];
    let Thickness = tape[ptr++];
    return new IfcCenterLineProfileDef(expressID, type, ProfileType, ProfileName, Curve, Thickness);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Curve);
    ;
    args.push(this.Thickness);
    ;
    return args;
  }
}, "IfcCenterLineProfileDef");
var IfcChiller = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcChiller(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcChiller");
var IfcChillerType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcChillerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcChillerType");
var IfcChimney = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcChimney(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcChimney");
var IfcChimneyType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcChimneyType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcChimneyType");
var IfcCircle = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Position, Radius) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.Radius = Radius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let Radius = tape[ptr++];
    return new IfcCircle(expressID, type, Position, Radius);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    ;
    args.push(this.Radius);
    ;
    return args;
  }
}, "IfcCircle");
var IfcCircleHollowProfileDef = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ProfileType, ProfileName, Position, Radius, WallThickness) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.Radius = Radius;
    this.WallThickness = WallThickness;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let Radius = tape[ptr++];
    let WallThickness = tape[ptr++];
    return new IfcCircleHollowProfileDef(expressID, type, ProfileType, ProfileName, Position, Radius, WallThickness);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Position);
    ;
    args.push(this.Radius);
    ;
    args.push(this.WallThickness);
    ;
    return args;
  }
}, "IfcCircleHollowProfileDef");
var IfcCircleProfileDef = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ProfileType, ProfileName, Position, Radius) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.Radius = Radius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let Radius = tape[ptr++];
    return new IfcCircleProfileDef(expressID, type, ProfileType, ProfileName, Position, Radius);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Position);
    ;
    args.push(this.Radius);
    ;
    return args;
  }
}, "IfcCircleProfileDef");
var IfcCircularArcSegment2D = /* @__PURE__ */ __name(class {
  constructor(expressID, type, StartPoint, StartDirection, SegmentLength, Radius, IsCCW) {
    this.expressID = expressID;
    this.type = type;
    this.StartPoint = StartPoint;
    this.StartDirection = StartDirection;
    this.SegmentLength = SegmentLength;
    this.Radius = Radius;
    this.IsCCW = IsCCW;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let StartPoint = tape[ptr++];
    let StartDirection = tape[ptr++];
    let SegmentLength = tape[ptr++];
    let Radius = tape[ptr++];
    let IsCCW = tape[ptr++];
    return new IfcCircularArcSegment2D(expressID, type, StartPoint, StartDirection, SegmentLength, Radius, IsCCW);
  }
  ToTape() {
    let args = [];
    args.push(this.StartPoint);
    ;
    args.push(this.StartDirection);
    ;
    args.push(this.SegmentLength);
    ;
    args.push(this.Radius);
    ;
    args.push(this.IsCCW);
    ;
    return args;
  }
}, "IfcCircularArcSegment2D");
var IfcCivilElement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcCivilElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
}, "IfcCivilElement");
var IfcCivilElementType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcCivilElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
}, "IfcCivilElementType");
var IfcClassification = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Source, Edition, EditionDate, Name, Description, Location, ReferenceTokens) {
    this.expressID = expressID;
    this.type = type;
    this.Source = Source;
    this.Edition = Edition;
    this.EditionDate = EditionDate;
    this.Name = Name;
    this.Description = Description;
    this.Location = Location;
    this.ReferenceTokens = ReferenceTokens;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Source = tape[ptr++];
    let Edition = tape[ptr++];
    let EditionDate = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Location = tape[ptr++];
    let ReferenceTokens = tape[ptr++];
    return new IfcClassification(expressID, type, Source, Edition, EditionDate, Name, Description, Location, ReferenceTokens);
  }
  ToTape() {
    let args = [];
    args.push(this.Source);
    ;
    args.push(this.Edition);
    ;
    args.push(this.EditionDate);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Location);
    ;
    args.push(this.ReferenceTokens);
    ;
    return args;
  }
}, "IfcClassification");
var IfcClassificationReference = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Location, Identification, Name, ReferencedSource, Description, Sort) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Identification = Identification;
    this.Name = Name;
    this.ReferencedSource = ReferencedSource;
    this.Description = Description;
    this.Sort = Sort;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    let ReferencedSource = tape[ptr++];
    let Description = tape[ptr++];
    let Sort = tape[ptr++];
    return new IfcClassificationReference(expressID, type, Location, Identification, Name, ReferencedSource, Description, Sort);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    ;
    args.push(this.Identification);
    ;
    args.push(this.Name);
    ;
    args.push(this.ReferencedSource);
    ;
    args.push(this.Description);
    ;
    args.push(this.Sort);
    ;
    return args;
  }
}, "IfcClassificationReference");
var IfcClosedShell = /* @__PURE__ */ __name(class {
  constructor(expressID, type, CfsFaces) {
    this.expressID = expressID;
    this.type = type;
    this.CfsFaces = CfsFaces;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let CfsFaces = tape[ptr++];
    return new IfcClosedShell(expressID, type, CfsFaces);
  }
  ToTape() {
    let args = [];
    args.push(this.CfsFaces);
    ;
    return args;
  }
}, "IfcClosedShell");
var IfcCoil = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCoil(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcCoil");
var IfcCoilType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCoilType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcCoilType");
var IfcColourRgb = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Red, Green, Blue) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Red = Red;
    this.Green = Green;
    this.Blue = Blue;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Red = tape[ptr++];
    let Green = tape[ptr++];
    let Blue = tape[ptr++];
    return new IfcColourRgb(expressID, type, Name, Red, Green, Blue);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Red);
    ;
    args.push(this.Green);
    ;
    args.push(this.Blue);
    ;
    return args;
  }
}, "IfcColourRgb");
var IfcColourRgbList = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ColourList) {
    this.expressID = expressID;
    this.type = type;
    this.ColourList = ColourList;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ColourList = tape[ptr++];
    return new IfcColourRgbList(expressID, type, ColourList);
  }
  ToTape() {
    let args = [];
    args.push(this.ColourList);
    ;
    return args;
  }
}, "IfcColourRgbList");
var IfcColourSpecification = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcColourSpecification(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    return args;
  }
}, "IfcColourSpecification");
var IfcColumn = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcColumn(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcColumn");
var IfcColumnStandardCase = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcColumnStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcColumnStandardCase");
var IfcColumnType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcColumnType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcColumnType");
var IfcCommunicationsAppliance = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCommunicationsAppliance(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcCommunicationsAppliance");
var IfcCommunicationsApplianceType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCommunicationsApplianceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcCommunicationsApplianceType");
var IfcComplexProperty = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, UsageName, HasProperties) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.UsageName = UsageName;
    this.HasProperties = HasProperties;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let UsageName = tape[ptr++];
    let HasProperties = tape[ptr++];
    return new IfcComplexProperty(expressID, type, Name, Description, UsageName, HasProperties);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.UsageName);
    ;
    args.push(this.HasProperties);
    ;
    return args;
  }
}, "IfcComplexProperty");
var IfcComplexPropertyTemplate = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, UsageName, TemplateType, HasPropertyTemplates) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.UsageName = UsageName;
    this.TemplateType = TemplateType;
    this.HasPropertyTemplates = HasPropertyTemplates;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let UsageName = tape[ptr++];
    let TemplateType = tape[ptr++];
    let HasPropertyTemplates = tape[ptr++];
    return new IfcComplexPropertyTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description, UsageName, TemplateType, HasPropertyTemplates);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.UsageName);
    ;
    args.push(this.TemplateType);
    ;
    args.push(this.HasPropertyTemplates);
    ;
    return args;
  }
}, "IfcComplexPropertyTemplate");
var IfcCompositeCurve = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Segments, SelfIntersect) {
    this.expressID = expressID;
    this.type = type;
    this.Segments = Segments;
    this.SelfIntersect = SelfIntersect;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Segments = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    return new IfcCompositeCurve(expressID, type, Segments, SelfIntersect);
  }
  ToTape() {
    let args = [];
    args.push(this.Segments);
    ;
    args.push(this.SelfIntersect);
    ;
    return args;
  }
}, "IfcCompositeCurve");
var IfcCompositeCurveOnSurface = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Segments, SelfIntersect) {
    this.expressID = expressID;
    this.type = type;
    this.Segments = Segments;
    this.SelfIntersect = SelfIntersect;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Segments = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    return new IfcCompositeCurveOnSurface(expressID, type, Segments, SelfIntersect);
  }
  ToTape() {
    let args = [];
    args.push(this.Segments);
    ;
    args.push(this.SelfIntersect);
    ;
    return args;
  }
}, "IfcCompositeCurveOnSurface");
var IfcCompositeCurveSegment = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Transition, SameSense, ParentCurve) {
    this.expressID = expressID;
    this.type = type;
    this.Transition = Transition;
    this.SameSense = SameSense;
    this.ParentCurve = ParentCurve;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Transition = tape[ptr++];
    let SameSense = tape[ptr++];
    let ParentCurve = tape[ptr++];
    return new IfcCompositeCurveSegment(expressID, type, Transition, SameSense, ParentCurve);
  }
  ToTape() {
    let args = [];
    args.push(this.Transition);
    ;
    args.push(this.SameSense);
    ;
    args.push(this.ParentCurve);
    ;
    return args;
  }
}, "IfcCompositeCurveSegment");
var IfcCompositeProfileDef = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ProfileType, ProfileName, Profiles, Label) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Profiles = Profiles;
    this.Label = Label;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Profiles = tape[ptr++];
    let Label = tape[ptr++];
    return new IfcCompositeProfileDef(expressID, type, ProfileType, ProfileName, Profiles, Label);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Profiles);
    ;
    args.push(this.Label);
    ;
    return args;
  }
}, "IfcCompositeProfileDef");
var IfcCompressor = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCompressor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcCompressor");
var IfcCompressorType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCompressorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcCompressorType");
var IfcCondenser = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCondenser(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcCondenser");
var IfcCondenserType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCondenserType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcCondenserType");
var IfcConic = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Position) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    return new IfcConic(expressID, type, Position);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    ;
    return args;
  }
}, "IfcConic");
var IfcConnectedFaceSet = /* @__PURE__ */ __name(class {
  constructor(expressID, type, CfsFaces) {
    this.expressID = expressID;
    this.type = type;
    this.CfsFaces = CfsFaces;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let CfsFaces = tape[ptr++];
    return new IfcConnectedFaceSet(expressID, type, CfsFaces);
  }
  ToTape() {
    let args = [];
    args.push(this.CfsFaces);
    ;
    return args;
  }
}, "IfcConnectedFaceSet");
var IfcConnectionCurveGeometry = /* @__PURE__ */ __name(class {
  constructor(expressID, type, CurveOnRelatingElement, CurveOnRelatedElement) {
    this.expressID = expressID;
    this.type = type;
    this.CurveOnRelatingElement = CurveOnRelatingElement;
    this.CurveOnRelatedElement = CurveOnRelatedElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let CurveOnRelatingElement = tape[ptr++];
    let CurveOnRelatedElement = tape[ptr++];
    return new IfcConnectionCurveGeometry(expressID, type, CurveOnRelatingElement, CurveOnRelatedElement);
  }
  ToTape() {
    let args = [];
    args.push(this.CurveOnRelatingElement);
    ;
    args.push(this.CurveOnRelatedElement);
    ;
    return args;
  }
}, "IfcConnectionCurveGeometry");
var IfcConnectionGeometry = /* @__PURE__ */ __name(class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcConnectionGeometry(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
}, "IfcConnectionGeometry");
var IfcConnectionPointEccentricity = /* @__PURE__ */ __name(class {
  constructor(expressID, type, PointOnRelatingElement, PointOnRelatedElement, EccentricityInX, EccentricityInY, EccentricityInZ) {
    this.expressID = expressID;
    this.type = type;
    this.PointOnRelatingElement = PointOnRelatingElement;
    this.PointOnRelatedElement = PointOnRelatedElement;
    this.EccentricityInX = EccentricityInX;
    this.EccentricityInY = EccentricityInY;
    this.EccentricityInZ = EccentricityInZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let PointOnRelatingElement = tape[ptr++];
    let PointOnRelatedElement = tape[ptr++];
    let EccentricityInX = tape[ptr++];
    let EccentricityInY = tape[ptr++];
    let EccentricityInZ = tape[ptr++];
    return new IfcConnectionPointEccentricity(expressID, type, PointOnRelatingElement, PointOnRelatedElement, EccentricityInX, EccentricityInY, EccentricityInZ);
  }
  ToTape() {
    let args = [];
    args.push(this.PointOnRelatingElement);
    ;
    args.push(this.PointOnRelatedElement);
    ;
    args.push(this.EccentricityInX);
    ;
    args.push(this.EccentricityInY);
    ;
    args.push(this.EccentricityInZ);
    ;
    return args;
  }
}, "IfcConnectionPointEccentricity");
var IfcConnectionPointGeometry = /* @__PURE__ */ __name(class {
  constructor(expressID, type, PointOnRelatingElement, PointOnRelatedElement) {
    this.expressID = expressID;
    this.type = type;
    this.PointOnRelatingElement = PointOnRelatingElement;
    this.PointOnRelatedElement = PointOnRelatedElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let PointOnRelatingElement = tape[ptr++];
    let PointOnRelatedElement = tape[ptr++];
    return new IfcConnectionPointGeometry(expressID, type, PointOnRelatingElement, PointOnRelatedElement);
  }
  ToTape() {
    let args = [];
    args.push(this.PointOnRelatingElement);
    ;
    args.push(this.PointOnRelatedElement);
    ;
    return args;
  }
}, "IfcConnectionPointGeometry");
var IfcConnectionSurfaceGeometry = /* @__PURE__ */ __name(class {
  constructor(expressID, type, SurfaceOnRelatingElement, SurfaceOnRelatedElement) {
    this.expressID = expressID;
    this.type = type;
    this.SurfaceOnRelatingElement = SurfaceOnRelatingElement;
    this.SurfaceOnRelatedElement = SurfaceOnRelatedElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SurfaceOnRelatingElement = tape[ptr++];
    let SurfaceOnRelatedElement = tape[ptr++];
    return new IfcConnectionSurfaceGeometry(expressID, type, SurfaceOnRelatingElement, SurfaceOnRelatedElement);
  }
  ToTape() {
    let args = [];
    args.push(this.SurfaceOnRelatingElement);
    ;
    args.push(this.SurfaceOnRelatedElement);
    ;
    return args;
  }
}, "IfcConnectionSurfaceGeometry");
var IfcConnectionVolumeGeometry = /* @__PURE__ */ __name(class {
  constructor(expressID, type, VolumeOnRelatingElement, VolumeOnRelatedElement) {
    this.expressID = expressID;
    this.type = type;
    this.VolumeOnRelatingElement = VolumeOnRelatingElement;
    this.VolumeOnRelatedElement = VolumeOnRelatedElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let VolumeOnRelatingElement = tape[ptr++];
    let VolumeOnRelatedElement = tape[ptr++];
    return new IfcConnectionVolumeGeometry(expressID, type, VolumeOnRelatingElement, VolumeOnRelatedElement);
  }
  ToTape() {
    let args = [];
    args.push(this.VolumeOnRelatingElement);
    ;
    args.push(this.VolumeOnRelatedElement);
    ;
    return args;
  }
}, "IfcConnectionVolumeGeometry");
var IfcConstraint = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.ConstraintGrade = ConstraintGrade;
    this.ConstraintSource = ConstraintSource;
    this.CreatingActor = CreatingActor;
    this.CreationTime = CreationTime;
    this.UserDefinedGrade = UserDefinedGrade;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ConstraintGrade = tape[ptr++];
    let ConstraintSource = tape[ptr++];
    let CreatingActor = tape[ptr++];
    let CreationTime = tape[ptr++];
    let UserDefinedGrade = tape[ptr++];
    return new IfcConstraint(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ConstraintGrade);
    ;
    args.push(this.ConstraintSource);
    ;
    args.push(this.CreatingActor);
    ;
    args.push(this.CreationTime);
    ;
    args.push(this.UserDefinedGrade);
    ;
    return args;
  }
}, "IfcConstraint");
var IfcConstructionEquipmentResource = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.Usage = Usage;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let Usage = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcConstructionEquipmentResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.Usage);
    ;
    args.push(this.BaseCosts);
    ;
    args.push(this.BaseQuantity);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcConstructionEquipmentResource");
var IfcConstructionEquipmentResourceType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ResourceType = ResourceType;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ResourceType = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcConstructionEquipmentResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.ResourceType);
    ;
    args.push(this.BaseCosts);
    ;
    args.push(this.BaseQuantity);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcConstructionEquipmentResourceType");
var IfcConstructionMaterialResource = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.Usage = Usage;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let Usage = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcConstructionMaterialResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.Usage);
    ;
    args.push(this.BaseCosts);
    ;
    args.push(this.BaseQuantity);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcConstructionMaterialResource");
var IfcConstructionMaterialResourceType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ResourceType = ResourceType;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ResourceType = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcConstructionMaterialResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.ResourceType);
    ;
    args.push(this.BaseCosts);
    ;
    args.push(this.BaseQuantity);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcConstructionMaterialResourceType");
var IfcConstructionProductResource = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.Usage = Usage;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let Usage = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcConstructionProductResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.Usage);
    ;
    args.push(this.BaseCosts);
    ;
    args.push(this.BaseQuantity);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcConstructionProductResource");
var IfcConstructionProductResourceType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ResourceType = ResourceType;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ResourceType = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcConstructionProductResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.ResourceType);
    ;
    args.push(this.BaseCosts);
    ;
    args.push(this.BaseQuantity);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcConstructionProductResourceType");
var IfcConstructionResource = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.Usage = Usage;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let Usage = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    return new IfcConstructionResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.Usage);
    ;
    args.push(this.BaseCosts);
    ;
    args.push(this.BaseQuantity);
    ;
    return args;
  }
}, "IfcConstructionResource");
var IfcConstructionResourceType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ResourceType = ResourceType;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ResourceType = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    return new IfcConstructionResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.ResourceType);
    ;
    args.push(this.BaseCosts);
    ;
    args.push(this.BaseQuantity);
    ;
    return args;
  }
}, "IfcConstructionResourceType");
var IfcContext = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.LongName = LongName;
    this.Phase = Phase;
    this.RepresentationContexts = RepresentationContexts;
    this.UnitsInContext = UnitsInContext;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let LongName = tape[ptr++];
    let Phase = tape[ptr++];
    let RepresentationContexts = tape[ptr++];
    let UnitsInContext = tape[ptr++];
    return new IfcContext(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.LongName);
    ;
    args.push(this.Phase);
    ;
    args.push(this.RepresentationContexts);
    ;
    args.push(this.UnitsInContext);
    ;
    return args;
  }
}, "IfcContext");
var IfcContextDependentUnit = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Dimensions, UnitType, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Dimensions = Dimensions;
    this.UnitType = UnitType;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Dimensions = tape[ptr++];
    let UnitType = tape[ptr++];
    let Name = tape[ptr++];
    return new IfcContextDependentUnit(expressID, type, Dimensions, UnitType, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Dimensions);
    ;
    args.push(this.UnitType);
    ;
    args.push(this.Name);
    ;
    return args;
  }
}, "IfcContextDependentUnit");
var IfcControl = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    return new IfcControl(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    return args;
  }
}, "IfcControl");
var IfcController = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcController(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcController");
var IfcControllerType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcControllerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcControllerType");
var IfcConversionBasedUnit = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Dimensions, UnitType, Name, ConversionFactor) {
    this.expressID = expressID;
    this.type = type;
    this.Dimensions = Dimensions;
    this.UnitType = UnitType;
    this.Name = Name;
    this.ConversionFactor = ConversionFactor;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Dimensions = tape[ptr++];
    let UnitType = tape[ptr++];
    let Name = tape[ptr++];
    let ConversionFactor = tape[ptr++];
    return new IfcConversionBasedUnit(expressID, type, Dimensions, UnitType, Name, ConversionFactor);
  }
  ToTape() {
    let args = [];
    args.push(this.Dimensions);
    ;
    args.push(this.UnitType);
    ;
    args.push(this.Name);
    ;
    args.push(this.ConversionFactor);
    ;
    return args;
  }
}, "IfcConversionBasedUnit");
var IfcConversionBasedUnitWithOffset = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Dimensions, UnitType, Name, ConversionFactor, ConversionOffset) {
    this.expressID = expressID;
    this.type = type;
    this.Dimensions = Dimensions;
    this.UnitType = UnitType;
    this.Name = Name;
    this.ConversionFactor = ConversionFactor;
    this.ConversionOffset = ConversionOffset;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Dimensions = tape[ptr++];
    let UnitType = tape[ptr++];
    let Name = tape[ptr++];
    let ConversionFactor = tape[ptr++];
    let ConversionOffset = tape[ptr++];
    return new IfcConversionBasedUnitWithOffset(expressID, type, Dimensions, UnitType, Name, ConversionFactor, ConversionOffset);
  }
  ToTape() {
    let args = [];
    args.push(this.Dimensions);
    ;
    args.push(this.UnitType);
    ;
    args.push(this.Name);
    ;
    args.push(this.ConversionFactor);
    ;
    args.push(this.ConversionOffset);
    ;
    return args;
  }
}, "IfcConversionBasedUnitWithOffset");
var IfcCooledBeam = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCooledBeam(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcCooledBeam");
var IfcCooledBeamType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCooledBeamType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcCooledBeamType");
var IfcCoolingTower = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCoolingTower(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcCoolingTower");
var IfcCoolingTowerType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCoolingTowerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcCoolingTowerType");
var IfcCoordinateOperation = /* @__PURE__ */ __name(class {
  constructor(expressID, type, SourceCRS, TargetCRS) {
    this.expressID = expressID;
    this.type = type;
    this.SourceCRS = SourceCRS;
    this.TargetCRS = TargetCRS;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SourceCRS = tape[ptr++];
    let TargetCRS = tape[ptr++];
    return new IfcCoordinateOperation(expressID, type, SourceCRS, TargetCRS);
  }
  ToTape() {
    let args = [];
    args.push(this.SourceCRS);
    ;
    args.push(this.TargetCRS);
    ;
    return args;
  }
}, "IfcCoordinateOperation");
var IfcCoordinateReferenceSystem = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, GeodeticDatum, VerticalDatum) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.GeodeticDatum = GeodeticDatum;
    this.VerticalDatum = VerticalDatum;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let GeodeticDatum = tape[ptr++];
    let VerticalDatum = tape[ptr++];
    return new IfcCoordinateReferenceSystem(expressID, type, Name, Description, GeodeticDatum, VerticalDatum);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.GeodeticDatum);
    ;
    args.push(this.VerticalDatum);
    ;
    return args;
  }
}, "IfcCoordinateReferenceSystem");
var IfcCostItem = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, CostValues, CostQuantities) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.PredefinedType = PredefinedType;
    this.CostValues = CostValues;
    this.CostQuantities = CostQuantities;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let CostValues = tape[ptr++];
    let CostQuantities = tape[ptr++];
    return new IfcCostItem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, CostValues, CostQuantities);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.CostValues);
    ;
    args.push(this.CostQuantities);
    ;
    return args;
  }
}, "IfcCostItem");
var IfcCostSchedule = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, SubmittedOn, UpdateDate) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.PredefinedType = PredefinedType;
    this.Status = Status;
    this.SubmittedOn = SubmittedOn;
    this.UpdateDate = UpdateDate;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Status = tape[ptr++];
    let SubmittedOn = tape[ptr++];
    let UpdateDate = tape[ptr++];
    return new IfcCostSchedule(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, SubmittedOn, UpdateDate);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.Status);
    ;
    args.push(this.SubmittedOn);
    ;
    args.push(this.UpdateDate);
    ;
    return args;
  }
}, "IfcCostSchedule");
var IfcCostValue = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, AppliedValue, UnitBasis, ApplicableDate, FixedUntilDate, Category, Condition, ArithmeticOperator, Components) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.AppliedValue = AppliedValue;
    this.UnitBasis = UnitBasis;
    this.ApplicableDate = ApplicableDate;
    this.FixedUntilDate = FixedUntilDate;
    this.Category = Category;
    this.Condition = Condition;
    this.ArithmeticOperator = ArithmeticOperator;
    this.Components = Components;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let AppliedValue = tape[ptr++];
    let UnitBasis = tape[ptr++];
    let ApplicableDate = tape[ptr++];
    let FixedUntilDate = tape[ptr++];
    let Category = tape[ptr++];
    let Condition = tape[ptr++];
    let ArithmeticOperator = tape[ptr++];
    let Components = tape[ptr++];
    return new IfcCostValue(expressID, type, Name, Description, AppliedValue, UnitBasis, ApplicableDate, FixedUntilDate, Category, Condition, ArithmeticOperator, Components);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.AppliedValue);
    ;
    args.push(this.UnitBasis);
    ;
    args.push(this.ApplicableDate);
    ;
    args.push(this.FixedUntilDate);
    ;
    args.push(this.Category);
    ;
    args.push(this.Condition);
    ;
    args.push(this.ArithmeticOperator);
    ;
    args.push(this.Components);
    ;
    return args;
  }
}, "IfcCostValue");
var IfcCovering = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCovering(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcCovering");
var IfcCoveringType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCoveringType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcCoveringType");
var IfcCrewResource = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.Usage = Usage;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let Usage = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCrewResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.Usage);
    ;
    args.push(this.BaseCosts);
    ;
    args.push(this.BaseQuantity);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcCrewResource");
var IfcCrewResourceType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ResourceType = ResourceType;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ResourceType = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCrewResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.ResourceType);
    ;
    args.push(this.BaseCosts);
    ;
    args.push(this.BaseQuantity);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcCrewResourceType");
var IfcCsgPrimitive3D = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Position) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    return new IfcCsgPrimitive3D(expressID, type, Position);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    ;
    return args;
  }
}, "IfcCsgPrimitive3D");
var IfcCsgSolid = /* @__PURE__ */ __name(class {
  constructor(expressID, type, TreeRootExpression) {
    this.expressID = expressID;
    this.type = type;
    this.TreeRootExpression = TreeRootExpression;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TreeRootExpression = tape[ptr++];
    return new IfcCsgSolid(expressID, type, TreeRootExpression);
  }
  ToTape() {
    let args = [];
    args.push(this.TreeRootExpression);
    ;
    return args;
  }
}, "IfcCsgSolid");
var IfcCurrencyRelationship = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, RelatingMonetaryUnit, RelatedMonetaryUnit, ExchangeRate, RateDateTime, RateSource) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.RelatingMonetaryUnit = RelatingMonetaryUnit;
    this.RelatedMonetaryUnit = RelatedMonetaryUnit;
    this.ExchangeRate = ExchangeRate;
    this.RateDateTime = RateDateTime;
    this.RateSource = RateSource;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingMonetaryUnit = tape[ptr++];
    let RelatedMonetaryUnit = tape[ptr++];
    let ExchangeRate = tape[ptr++];
    let RateDateTime = tape[ptr++];
    let RateSource = tape[ptr++];
    return new IfcCurrencyRelationship(expressID, type, Name, Description, RelatingMonetaryUnit, RelatedMonetaryUnit, ExchangeRate, RateDateTime, RateSource);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingMonetaryUnit);
    ;
    args.push(this.RelatedMonetaryUnit);
    ;
    args.push(this.ExchangeRate);
    ;
    args.push(this.RateDateTime);
    ;
    args.push(this.RateSource);
    ;
    return args;
  }
}, "IfcCurrencyRelationship");
var IfcCurtainWall = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCurtainWall(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcCurtainWall");
var IfcCurtainWallType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCurtainWallType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcCurtainWallType");
var IfcCurve = /* @__PURE__ */ __name(class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcCurve(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
}, "IfcCurve");
var IfcCurveBoundedPlane = /* @__PURE__ */ __name(class {
  constructor(expressID, type, BasisSurface, OuterBoundary, InnerBoundaries) {
    this.expressID = expressID;
    this.type = type;
    this.BasisSurface = BasisSurface;
    this.OuterBoundary = OuterBoundary;
    this.InnerBoundaries = InnerBoundaries;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisSurface = tape[ptr++];
    let OuterBoundary = tape[ptr++];
    let InnerBoundaries = tape[ptr++];
    return new IfcCurveBoundedPlane(expressID, type, BasisSurface, OuterBoundary, InnerBoundaries);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisSurface);
    ;
    args.push(this.OuterBoundary);
    ;
    args.push(this.InnerBoundaries);
    ;
    return args;
  }
}, "IfcCurveBoundedPlane");
var IfcCurveBoundedSurface = /* @__PURE__ */ __name(class {
  constructor(expressID, type, BasisSurface, Boundaries, ImplicitOuter) {
    this.expressID = expressID;
    this.type = type;
    this.BasisSurface = BasisSurface;
    this.Boundaries = Boundaries;
    this.ImplicitOuter = ImplicitOuter;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisSurface = tape[ptr++];
    let Boundaries = tape[ptr++];
    let ImplicitOuter = tape[ptr++];
    return new IfcCurveBoundedSurface(expressID, type, BasisSurface, Boundaries, ImplicitOuter);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisSurface);
    ;
    args.push(this.Boundaries);
    ;
    args.push(this.ImplicitOuter);
    ;
    return args;
  }
}, "IfcCurveBoundedSurface");
var IfcCurveSegment2D = /* @__PURE__ */ __name(class {
  constructor(expressID, type, StartPoint, StartDirection, SegmentLength) {
    this.expressID = expressID;
    this.type = type;
    this.StartPoint = StartPoint;
    this.StartDirection = StartDirection;
    this.SegmentLength = SegmentLength;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let StartPoint = tape[ptr++];
    let StartDirection = tape[ptr++];
    let SegmentLength = tape[ptr++];
    return new IfcCurveSegment2D(expressID, type, StartPoint, StartDirection, SegmentLength);
  }
  ToTape() {
    let args = [];
    args.push(this.StartPoint);
    ;
    args.push(this.StartDirection);
    ;
    args.push(this.SegmentLength);
    ;
    return args;
  }
}, "IfcCurveSegment2D");
var IfcCurveStyle = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, CurveFont, CurveWidth, CurveColour, ModelOrDraughting) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.CurveFont = CurveFont;
    this.CurveWidth = CurveWidth;
    this.CurveColour = CurveColour;
    this.ModelOrDraughting = ModelOrDraughting;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let CurveFont = tape[ptr++];
    let CurveWidth = tape[ptr++];
    let CurveColour = tape[ptr++];
    let ModelOrDraughting = tape[ptr++];
    return new IfcCurveStyle(expressID, type, Name, CurveFont, CurveWidth, CurveColour, ModelOrDraughting);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.CurveFont);
    ;
    args.push(this.CurveWidth);
    ;
    args.push(this.CurveColour);
    ;
    args.push(this.ModelOrDraughting);
    ;
    return args;
  }
}, "IfcCurveStyle");
var IfcCurveStyleFont = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, PatternList) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.PatternList = PatternList;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let PatternList = tape[ptr++];
    return new IfcCurveStyleFont(expressID, type, Name, PatternList);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.PatternList);
    ;
    return args;
  }
}, "IfcCurveStyleFont");
var IfcCurveStyleFontAndScaling = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, CurveFont, CurveFontScaling) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.CurveFont = CurveFont;
    this.CurveFontScaling = CurveFontScaling;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let CurveFont = tape[ptr++];
    let CurveFontScaling = tape[ptr++];
    return new IfcCurveStyleFontAndScaling(expressID, type, Name, CurveFont, CurveFontScaling);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.CurveFont);
    ;
    args.push(this.CurveFontScaling);
    ;
    return args;
  }
}, "IfcCurveStyleFontAndScaling");
var IfcCurveStyleFontPattern = /* @__PURE__ */ __name(class {
  constructor(expressID, type, VisibleSegmentLength, InvisibleSegmentLength) {
    this.expressID = expressID;
    this.type = type;
    this.VisibleSegmentLength = VisibleSegmentLength;
    this.InvisibleSegmentLength = InvisibleSegmentLength;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let VisibleSegmentLength = tape[ptr++];
    let InvisibleSegmentLength = tape[ptr++];
    return new IfcCurveStyleFontPattern(expressID, type, VisibleSegmentLength, InvisibleSegmentLength);
  }
  ToTape() {
    let args = [];
    args.push(this.VisibleSegmentLength);
    ;
    args.push(this.InvisibleSegmentLength);
    ;
    return args;
  }
}, "IfcCurveStyleFontPattern");
var IfcCylindricalSurface = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Position, Radius) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.Radius = Radius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let Radius = tape[ptr++];
    return new IfcCylindricalSurface(expressID, type, Position, Radius);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    ;
    args.push(this.Radius);
    ;
    return args;
  }
}, "IfcCylindricalSurface");
var IfcDamper = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDamper(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcDamper");
var IfcDamperType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDamperType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcDamperType");
var IfcDeepFoundation = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcDeepFoundation(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
}, "IfcDeepFoundation");
var IfcDeepFoundationType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcDeepFoundationType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
}, "IfcDeepFoundationType");
var IfcDerivedProfileDef = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ProfileType, ProfileName, ParentProfile, Operator, Label) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.ParentProfile = ParentProfile;
    this.Operator = Operator;
    this.Label = Label;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let ParentProfile = tape[ptr++];
    let Operator = tape[ptr++];
    let Label = tape[ptr++];
    return new IfcDerivedProfileDef(expressID, type, ProfileType, ProfileName, ParentProfile, Operator, Label);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.ParentProfile);
    ;
    args.push(this.Operator);
    ;
    args.push(this.Label);
    ;
    return args;
  }
}, "IfcDerivedProfileDef");
var IfcDerivedUnit = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Elements, UnitType, UserDefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.Elements = Elements;
    this.UnitType = UnitType;
    this.UserDefinedType = UserDefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Elements = tape[ptr++];
    let UnitType = tape[ptr++];
    let UserDefinedType = tape[ptr++];
    return new IfcDerivedUnit(expressID, type, Elements, UnitType, UserDefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.Elements);
    ;
    args.push(this.UnitType);
    ;
    args.push(this.UserDefinedType);
    ;
    return args;
  }
}, "IfcDerivedUnit");
var IfcDerivedUnitElement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Unit, Exponent) {
    this.expressID = expressID;
    this.type = type;
    this.Unit = Unit;
    this.Exponent = Exponent;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Unit = tape[ptr++];
    let Exponent = tape[ptr++];
    return new IfcDerivedUnitElement(expressID, type, Unit, Exponent);
  }
  ToTape() {
    let args = [];
    args.push(this.Unit);
    ;
    args.push(this.Exponent);
    ;
    return args;
  }
}, "IfcDerivedUnitElement");
var IfcDimensionalExponents = /* @__PURE__ */ __name(class {
  constructor(expressID, type, LengthExponent, MassExponent, TimeExponent, ElectricCurrentExponent, ThermodynamicTemperatureExponent, AmountOfSubstanceExponent, LuminousIntensityExponent) {
    this.expressID = expressID;
    this.type = type;
    this.LengthExponent = LengthExponent;
    this.MassExponent = MassExponent;
    this.TimeExponent = TimeExponent;
    this.ElectricCurrentExponent = ElectricCurrentExponent;
    this.ThermodynamicTemperatureExponent = ThermodynamicTemperatureExponent;
    this.AmountOfSubstanceExponent = AmountOfSubstanceExponent;
    this.LuminousIntensityExponent = LuminousIntensityExponent;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let LengthExponent = tape[ptr++];
    let MassExponent = tape[ptr++];
    let TimeExponent = tape[ptr++];
    let ElectricCurrentExponent = tape[ptr++];
    let ThermodynamicTemperatureExponent = tape[ptr++];
    let AmountOfSubstanceExponent = tape[ptr++];
    let LuminousIntensityExponent = tape[ptr++];
    return new IfcDimensionalExponents(expressID, type, LengthExponent, MassExponent, TimeExponent, ElectricCurrentExponent, ThermodynamicTemperatureExponent, AmountOfSubstanceExponent, LuminousIntensityExponent);
  }
  ToTape() {
    let args = [];
    args.push(this.LengthExponent);
    ;
    args.push(this.MassExponent);
    ;
    args.push(this.TimeExponent);
    ;
    args.push(this.ElectricCurrentExponent);
    ;
    args.push(this.ThermodynamicTemperatureExponent);
    ;
    args.push(this.AmountOfSubstanceExponent);
    ;
    args.push(this.LuminousIntensityExponent);
    ;
    return args;
  }
}, "IfcDimensionalExponents");
var IfcDirection = /* @__PURE__ */ __name(class {
  constructor(expressID, type, DirectionRatios) {
    this.expressID = expressID;
    this.type = type;
    this.DirectionRatios = DirectionRatios;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let DirectionRatios = tape[ptr++];
    return new IfcDirection(expressID, type, DirectionRatios);
  }
  ToTape() {
    let args = [];
    args.push(this.DirectionRatios);
    ;
    return args;
  }
}, "IfcDirection");
var IfcDiscreteAccessory = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDiscreteAccessory(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcDiscreteAccessory");
var IfcDiscreteAccessoryType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDiscreteAccessoryType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcDiscreteAccessoryType");
var IfcDistanceExpression = /* @__PURE__ */ __name(class {
  constructor(expressID, type, DistanceAlong, OffsetLateral, OffsetVertical, OffsetLongitudinal, AlongHorizontal) {
    this.expressID = expressID;
    this.type = type;
    this.DistanceAlong = DistanceAlong;
    this.OffsetLateral = OffsetLateral;
    this.OffsetVertical = OffsetVertical;
    this.OffsetLongitudinal = OffsetLongitudinal;
    this.AlongHorizontal = AlongHorizontal;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let DistanceAlong = tape[ptr++];
    let OffsetLateral = tape[ptr++];
    let OffsetVertical = tape[ptr++];
    let OffsetLongitudinal = tape[ptr++];
    let AlongHorizontal = tape[ptr++];
    return new IfcDistanceExpression(expressID, type, DistanceAlong, OffsetLateral, OffsetVertical, OffsetLongitudinal, AlongHorizontal);
  }
  ToTape() {
    let args = [];
    args.push(this.DistanceAlong);
    ;
    args.push(this.OffsetLateral);
    ;
    args.push(this.OffsetVertical);
    ;
    args.push(this.OffsetLongitudinal);
    ;
    args.push(this.AlongHorizontal);
    ;
    return args;
  }
}, "IfcDistanceExpression");
var IfcDistributionChamberElement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDistributionChamberElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcDistributionChamberElement");
var IfcDistributionChamberElementType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDistributionChamberElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcDistributionChamberElementType");
var IfcDistributionCircuit = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.LongName = LongName;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let LongName = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDistributionCircuit(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.LongName);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcDistributionCircuit");
var IfcDistributionControlElement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcDistributionControlElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
}, "IfcDistributionControlElement");
var IfcDistributionControlElementType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcDistributionControlElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
}, "IfcDistributionControlElementType");
var IfcDistributionElement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcDistributionElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
}, "IfcDistributionElement");
var IfcDistributionElementType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcDistributionElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
}, "IfcDistributionElementType");
var IfcDistributionFlowElement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcDistributionFlowElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
}, "IfcDistributionFlowElement");
var IfcDistributionFlowElementType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcDistributionFlowElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
}, "IfcDistributionFlowElementType");
var IfcDistributionPort = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, FlowDirection, PredefinedType, SystemType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.FlowDirection = FlowDirection;
    this.PredefinedType = PredefinedType;
    this.SystemType = SystemType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let FlowDirection = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let SystemType = tape[ptr++];
    return new IfcDistributionPort(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, FlowDirection, PredefinedType, SystemType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.FlowDirection);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.SystemType);
    ;
    return args;
  }
}, "IfcDistributionPort");
var IfcDistributionSystem = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.LongName = LongName;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let LongName = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDistributionSystem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.LongName);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcDistributionSystem");
var IfcDocumentInformation = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Identification, Name, Description, Location, Purpose, IntendedUse, Scope, Revision, DocumentOwner, Editors, CreationTime, LastRevisionTime, ElectronicFormat, ValidFrom, ValidUntil, Confidentiality, Status) {
    this.expressID = expressID;
    this.type = type;
    this.Identification = Identification;
    this.Name = Name;
    this.Description = Description;
    this.Location = Location;
    this.Purpose = Purpose;
    this.IntendedUse = IntendedUse;
    this.Scope = Scope;
    this.Revision = Revision;
    this.DocumentOwner = DocumentOwner;
    this.Editors = Editors;
    this.CreationTime = CreationTime;
    this.LastRevisionTime = LastRevisionTime;
    this.ElectronicFormat = ElectronicFormat;
    this.ValidFrom = ValidFrom;
    this.ValidUntil = ValidUntil;
    this.Confidentiality = Confidentiality;
    this.Status = Status;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Location = tape[ptr++];
    let Purpose = tape[ptr++];
    let IntendedUse = tape[ptr++];
    let Scope = tape[ptr++];
    let Revision = tape[ptr++];
    let DocumentOwner = tape[ptr++];
    let Editors = tape[ptr++];
    let CreationTime = tape[ptr++];
    let LastRevisionTime = tape[ptr++];
    let ElectronicFormat = tape[ptr++];
    let ValidFrom = tape[ptr++];
    let ValidUntil = tape[ptr++];
    let Confidentiality = tape[ptr++];
    let Status = tape[ptr++];
    return new IfcDocumentInformation(expressID, type, Identification, Name, Description, Location, Purpose, IntendedUse, Scope, Revision, DocumentOwner, Editors, CreationTime, LastRevisionTime, ElectronicFormat, ValidFrom, ValidUntil, Confidentiality, Status);
  }
  ToTape() {
    let args = [];
    args.push(this.Identification);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Location);
    ;
    args.push(this.Purpose);
    ;
    args.push(this.IntendedUse);
    ;
    args.push(this.Scope);
    ;
    args.push(this.Revision);
    ;
    args.push(this.DocumentOwner);
    ;
    args.push(this.Editors);
    ;
    args.push(this.CreationTime);
    ;
    args.push(this.LastRevisionTime);
    ;
    args.push(this.ElectronicFormat);
    ;
    args.push(this.ValidFrom);
    ;
    args.push(this.ValidUntil);
    ;
    args.push(this.Confidentiality);
    ;
    args.push(this.Status);
    ;
    return args;
  }
}, "IfcDocumentInformation");
var IfcDocumentInformationRelationship = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, RelatingDocument, RelatedDocuments, RelationshipType) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.RelatingDocument = RelatingDocument;
    this.RelatedDocuments = RelatedDocuments;
    this.RelationshipType = RelationshipType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingDocument = tape[ptr++];
    let RelatedDocuments = tape[ptr++];
    let RelationshipType = tape[ptr++];
    return new IfcDocumentInformationRelationship(expressID, type, Name, Description, RelatingDocument, RelatedDocuments, RelationshipType);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingDocument);
    ;
    args.push(this.RelatedDocuments);
    ;
    args.push(this.RelationshipType);
    ;
    return args;
  }
}, "IfcDocumentInformationRelationship");
var IfcDocumentReference = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Location, Identification, Name, Description, ReferencedDocument) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Identification = Identification;
    this.Name = Name;
    this.Description = Description;
    this.ReferencedDocument = ReferencedDocument;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ReferencedDocument = tape[ptr++];
    return new IfcDocumentReference(expressID, type, Location, Identification, Name, Description, ReferencedDocument);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    ;
    args.push(this.Identification);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ReferencedDocument);
    ;
    return args;
  }
}, "IfcDocumentReference");
var IfcDoor = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, OperationType, UserDefinedOperationType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.OverallHeight = OverallHeight;
    this.OverallWidth = OverallWidth;
    this.PredefinedType = PredefinedType;
    this.OperationType = OperationType;
    this.UserDefinedOperationType = UserDefinedOperationType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let OverallHeight = tape[ptr++];
    let OverallWidth = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let OperationType = tape[ptr++];
    let UserDefinedOperationType = tape[ptr++];
    return new IfcDoor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, OperationType, UserDefinedOperationType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.OverallHeight);
    ;
    args.push(this.OverallWidth);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.OperationType);
    ;
    args.push(this.UserDefinedOperationType);
    ;
    return args;
  }
}, "IfcDoor");
var IfcDoorLiningProperties = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, LiningDepth, LiningThickness, ThresholdDepth, ThresholdThickness, TransomThickness, TransomOffset, LiningOffset, ThresholdOffset, CasingThickness, CasingDepth, ShapeAspectStyle, LiningToPanelOffsetX, LiningToPanelOffsetY) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.LiningDepth = LiningDepth;
    this.LiningThickness = LiningThickness;
    this.ThresholdDepth = ThresholdDepth;
    this.ThresholdThickness = ThresholdThickness;
    this.TransomThickness = TransomThickness;
    this.TransomOffset = TransomOffset;
    this.LiningOffset = LiningOffset;
    this.ThresholdOffset = ThresholdOffset;
    this.CasingThickness = CasingThickness;
    this.CasingDepth = CasingDepth;
    this.ShapeAspectStyle = ShapeAspectStyle;
    this.LiningToPanelOffsetX = LiningToPanelOffsetX;
    this.LiningToPanelOffsetY = LiningToPanelOffsetY;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let LiningDepth = tape[ptr++];
    let LiningThickness = tape[ptr++];
    let ThresholdDepth = tape[ptr++];
    let ThresholdThickness = tape[ptr++];
    let TransomThickness = tape[ptr++];
    let TransomOffset = tape[ptr++];
    let LiningOffset = tape[ptr++];
    let ThresholdOffset = tape[ptr++];
    let CasingThickness = tape[ptr++];
    let CasingDepth = tape[ptr++];
    let ShapeAspectStyle = tape[ptr++];
    let LiningToPanelOffsetX = tape[ptr++];
    let LiningToPanelOffsetY = tape[ptr++];
    return new IfcDoorLiningProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, LiningDepth, LiningThickness, ThresholdDepth, ThresholdThickness, TransomThickness, TransomOffset, LiningOffset, ThresholdOffset, CasingThickness, CasingDepth, ShapeAspectStyle, LiningToPanelOffsetX, LiningToPanelOffsetY);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.LiningDepth);
    ;
    args.push(this.LiningThickness);
    ;
    args.push(this.ThresholdDepth);
    ;
    args.push(this.ThresholdThickness);
    ;
    args.push(this.TransomThickness);
    ;
    args.push(this.TransomOffset);
    ;
    args.push(this.LiningOffset);
    ;
    args.push(this.ThresholdOffset);
    ;
    args.push(this.CasingThickness);
    ;
    args.push(this.CasingDepth);
    ;
    args.push(this.ShapeAspectStyle);
    ;
    args.push(this.LiningToPanelOffsetX);
    ;
    args.push(this.LiningToPanelOffsetY);
    ;
    return args;
  }
}, "IfcDoorLiningProperties");
var IfcDoorPanelProperties = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, PanelDepth, PanelOperation, PanelWidth, PanelPosition, ShapeAspectStyle) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.PanelDepth = PanelDepth;
    this.PanelOperation = PanelOperation;
    this.PanelWidth = PanelWidth;
    this.PanelPosition = PanelPosition;
    this.ShapeAspectStyle = ShapeAspectStyle;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let PanelDepth = tape[ptr++];
    let PanelOperation = tape[ptr++];
    let PanelWidth = tape[ptr++];
    let PanelPosition = tape[ptr++];
    let ShapeAspectStyle = tape[ptr++];
    return new IfcDoorPanelProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, PanelDepth, PanelOperation, PanelWidth, PanelPosition, ShapeAspectStyle);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.PanelDepth);
    ;
    args.push(this.PanelOperation);
    ;
    args.push(this.PanelWidth);
    ;
    args.push(this.PanelPosition);
    ;
    args.push(this.ShapeAspectStyle);
    ;
    return args;
  }
}, "IfcDoorPanelProperties");
var IfcDoorStandardCase = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, OperationType, UserDefinedOperationType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.OverallHeight = OverallHeight;
    this.OverallWidth = OverallWidth;
    this.PredefinedType = PredefinedType;
    this.OperationType = OperationType;
    this.UserDefinedOperationType = UserDefinedOperationType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let OverallHeight = tape[ptr++];
    let OverallWidth = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let OperationType = tape[ptr++];
    let UserDefinedOperationType = tape[ptr++];
    return new IfcDoorStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, OperationType, UserDefinedOperationType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.OverallHeight);
    ;
    args.push(this.OverallWidth);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.OperationType);
    ;
    args.push(this.UserDefinedOperationType);
    ;
    return args;
  }
}, "IfcDoorStandardCase");
var IfcDoorStyle = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, OperationType, ConstructionType, ParameterTakesPrecedence, Sizeable) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.OperationType = OperationType;
    this.ConstructionType = ConstructionType;
    this.ParameterTakesPrecedence = ParameterTakesPrecedence;
    this.Sizeable = Sizeable;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let OperationType = tape[ptr++];
    let ConstructionType = tape[ptr++];
    let ParameterTakesPrecedence = tape[ptr++];
    let Sizeable = tape[ptr++];
    return new IfcDoorStyle(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, OperationType, ConstructionType, ParameterTakesPrecedence, Sizeable);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.OperationType);
    ;
    args.push(this.ConstructionType);
    ;
    args.push(this.ParameterTakesPrecedence);
    ;
    args.push(this.Sizeable);
    ;
    return args;
  }
}, "IfcDoorStyle");
var IfcDoorType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, OperationType, ParameterTakesPrecedence, UserDefinedOperationType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
    this.OperationType = OperationType;
    this.ParameterTakesPrecedence = ParameterTakesPrecedence;
    this.UserDefinedOperationType = UserDefinedOperationType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let OperationType = tape[ptr++];
    let ParameterTakesPrecedence = tape[ptr++];
    let UserDefinedOperationType = tape[ptr++];
    return new IfcDoorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, OperationType, ParameterTakesPrecedence, UserDefinedOperationType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.OperationType);
    ;
    args.push(this.ParameterTakesPrecedence);
    ;
    args.push(this.UserDefinedOperationType);
    ;
    return args;
  }
}, "IfcDoorType");
var IfcDraughtingPreDefinedColour = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcDraughtingPreDefinedColour(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    return args;
  }
}, "IfcDraughtingPreDefinedColour");
var IfcDraughtingPreDefinedCurveFont = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcDraughtingPreDefinedCurveFont(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    return args;
  }
}, "IfcDraughtingPreDefinedCurveFont");
var IfcDuctFitting = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDuctFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcDuctFitting");
var IfcDuctFittingType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDuctFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcDuctFittingType");
var IfcDuctSegment = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDuctSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcDuctSegment");
var IfcDuctSegmentType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDuctSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcDuctSegmentType");
var IfcDuctSilencer = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDuctSilencer(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcDuctSilencer");
var IfcDuctSilencerType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDuctSilencerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcDuctSilencerType");
var IfcEdge = /* @__PURE__ */ __name(class {
  constructor(expressID, type, EdgeStart, EdgeEnd) {
    this.expressID = expressID;
    this.type = type;
    this.EdgeStart = EdgeStart;
    this.EdgeEnd = EdgeEnd;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let EdgeStart = tape[ptr++];
    let EdgeEnd = tape[ptr++];
    return new IfcEdge(expressID, type, EdgeStart, EdgeEnd);
  }
  ToTape() {
    let args = [];
    args.push(this.EdgeStart);
    ;
    args.push(this.EdgeEnd);
    ;
    return args;
  }
}, "IfcEdge");
var IfcEdgeCurve = /* @__PURE__ */ __name(class {
  constructor(expressID, type, EdgeStart, EdgeEnd, EdgeGeometry, SameSense) {
    this.expressID = expressID;
    this.type = type;
    this.EdgeStart = EdgeStart;
    this.EdgeEnd = EdgeEnd;
    this.EdgeGeometry = EdgeGeometry;
    this.SameSense = SameSense;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let EdgeStart = tape[ptr++];
    let EdgeEnd = tape[ptr++];
    let EdgeGeometry = tape[ptr++];
    let SameSense = tape[ptr++];
    return new IfcEdgeCurve(expressID, type, EdgeStart, EdgeEnd, EdgeGeometry, SameSense);
  }
  ToTape() {
    let args = [];
    args.push(this.EdgeStart);
    ;
    args.push(this.EdgeEnd);
    ;
    args.push(this.EdgeGeometry);
    ;
    args.push(this.SameSense);
    ;
    return args;
  }
}, "IfcEdgeCurve");
var IfcEdgeLoop = /* @__PURE__ */ __name(class {
  constructor(expressID, type, EdgeList) {
    this.expressID = expressID;
    this.type = type;
    this.EdgeList = EdgeList;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let EdgeList = tape[ptr++];
    return new IfcEdgeLoop(expressID, type, EdgeList);
  }
  ToTape() {
    let args = [];
    args.push(this.EdgeList);
    ;
    return args;
  }
}, "IfcEdgeLoop");
var IfcElectricAppliance = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricAppliance(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcElectricAppliance");
var IfcElectricApplianceType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricApplianceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcElectricApplianceType");
var IfcElectricDistributionBoard = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricDistributionBoard(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcElectricDistributionBoard");
var IfcElectricDistributionBoardType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricDistributionBoardType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcElectricDistributionBoardType");
var IfcElectricFlowStorageDevice = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricFlowStorageDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcElectricFlowStorageDevice");
var IfcElectricFlowStorageDeviceType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricFlowStorageDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcElectricFlowStorageDeviceType");
var IfcElectricGenerator = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricGenerator(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcElectricGenerator");
var IfcElectricGeneratorType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricGeneratorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcElectricGeneratorType");
var IfcElectricMotor = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricMotor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcElectricMotor");
var IfcElectricMotorType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricMotorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcElectricMotorType");
var IfcElectricTimeControl = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricTimeControl(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcElectricTimeControl");
var IfcElectricTimeControlType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricTimeControlType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcElectricTimeControlType");
var IfcElement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
}, "IfcElement");
var IfcElementAssembly = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, AssemblyPlace, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.AssemblyPlace = AssemblyPlace;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let AssemblyPlace = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElementAssembly(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, AssemblyPlace, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.AssemblyPlace);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcElementAssembly");
var IfcElementAssemblyType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElementAssemblyType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcElementAssemblyType");
var IfcElementComponent = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcElementComponent(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
}, "IfcElementComponent");
var IfcElementComponentType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcElementComponentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
}, "IfcElementComponentType");
var IfcElementQuantity = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, MethodOfMeasurement, Quantities) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.MethodOfMeasurement = MethodOfMeasurement;
    this.Quantities = Quantities;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let MethodOfMeasurement = tape[ptr++];
    let Quantities = tape[ptr++];
    return new IfcElementQuantity(expressID, type, GlobalId, OwnerHistory, Name, Description, MethodOfMeasurement, Quantities);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.MethodOfMeasurement);
    ;
    args.push(this.Quantities);
    ;
    return args;
  }
}, "IfcElementQuantity");
var IfcElementType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
}, "IfcElementType");
var IfcElementarySurface = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Position) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    return new IfcElementarySurface(expressID, type, Position);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    ;
    return args;
  }
}, "IfcElementarySurface");
var IfcEllipse = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Position, SemiAxis1, SemiAxis2) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.SemiAxis1 = SemiAxis1;
    this.SemiAxis2 = SemiAxis2;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let SemiAxis1 = tape[ptr++];
    let SemiAxis2 = tape[ptr++];
    return new IfcEllipse(expressID, type, Position, SemiAxis1, SemiAxis2);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    ;
    args.push(this.SemiAxis1);
    ;
    args.push(this.SemiAxis2);
    ;
    return args;
  }
}, "IfcEllipse");
var IfcEllipseProfileDef = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ProfileType, ProfileName, Position, SemiAxis1, SemiAxis2) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.SemiAxis1 = SemiAxis1;
    this.SemiAxis2 = SemiAxis2;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let SemiAxis1 = tape[ptr++];
    let SemiAxis2 = tape[ptr++];
    return new IfcEllipseProfileDef(expressID, type, ProfileType, ProfileName, Position, SemiAxis1, SemiAxis2);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Position);
    ;
    args.push(this.SemiAxis1);
    ;
    args.push(this.SemiAxis2);
    ;
    return args;
  }
}, "IfcEllipseProfileDef");
var IfcEnergyConversionDevice = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcEnergyConversionDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
}, "IfcEnergyConversionDevice");
var IfcEnergyConversionDeviceType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcEnergyConversionDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
}, "IfcEnergyConversionDeviceType");
var IfcEngine = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcEngine(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcEngine");
var IfcEngineType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcEngineType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcEngineType");
var IfcEvaporativeCooler = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcEvaporativeCooler(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcEvaporativeCooler");
var IfcEvaporativeCoolerType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcEvaporativeCoolerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcEvaporativeCoolerType");
var IfcEvaporator = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcEvaporator(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcEvaporator");
var IfcEvaporatorType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcEvaporatorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcEvaporatorType");
var IfcEvent = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, PredefinedType, EventTriggerType, UserDefinedEventTriggerType, EventOccurenceTime) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.PredefinedType = PredefinedType;
    this.EventTriggerType = EventTriggerType;
    this.UserDefinedEventTriggerType = UserDefinedEventTriggerType;
    this.EventOccurenceTime = EventOccurenceTime;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let EventTriggerType = tape[ptr++];
    let UserDefinedEventTriggerType = tape[ptr++];
    let EventOccurenceTime = tape[ptr++];
    return new IfcEvent(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, PredefinedType, EventTriggerType, UserDefinedEventTriggerType, EventOccurenceTime);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.EventTriggerType);
    ;
    args.push(this.UserDefinedEventTriggerType);
    ;
    args.push(this.EventOccurenceTime);
    ;
    return args;
  }
}, "IfcEvent");
var IfcEventTime = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, ActualDate, EarlyDate, LateDate, ScheduleDate) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.ActualDate = ActualDate;
    this.EarlyDate = EarlyDate;
    this.LateDate = LateDate;
    this.ScheduleDate = ScheduleDate;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let ActualDate = tape[ptr++];
    let EarlyDate = tape[ptr++];
    let LateDate = tape[ptr++];
    let ScheduleDate = tape[ptr++];
    return new IfcEventTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, ActualDate, EarlyDate, LateDate, ScheduleDate);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.DataOrigin);
    ;
    args.push(this.UserDefinedDataOrigin);
    ;
    args.push(this.ActualDate);
    ;
    args.push(this.EarlyDate);
    ;
    args.push(this.LateDate);
    ;
    args.push(this.ScheduleDate);
    ;
    return args;
  }
}, "IfcEventTime");
var IfcEventType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType, EventTriggerType, UserDefinedEventTriggerType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ProcessType = ProcessType;
    this.PredefinedType = PredefinedType;
    this.EventTriggerType = EventTriggerType;
    this.UserDefinedEventTriggerType = UserDefinedEventTriggerType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ProcessType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let EventTriggerType = tape[ptr++];
    let UserDefinedEventTriggerType = tape[ptr++];
    return new IfcEventType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType, EventTriggerType, UserDefinedEventTriggerType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.ProcessType);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.EventTriggerType);
    ;
    args.push(this.UserDefinedEventTriggerType);
    ;
    return args;
  }
}, "IfcEventType");
var IfcExtendedProperties = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, Properties2) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Properties = Properties2;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Properties2 = tape[ptr++];
    return new IfcExtendedProperties(expressID, type, Name, Description, Properties2);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Properties);
    ;
    return args;
  }
}, "IfcExtendedProperties");
var IfcExternalInformation = /* @__PURE__ */ __name(class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcExternalInformation(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
}, "IfcExternalInformation");
var IfcExternalReference = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Location, Identification, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Identification = Identification;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    return new IfcExternalReference(expressID, type, Location, Identification, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    ;
    args.push(this.Identification);
    ;
    args.push(this.Name);
    ;
    return args;
  }
}, "IfcExternalReference");
var IfcExternalReferenceRelationship = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, RelatingReference, RelatedResourceObjects) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.RelatingReference = RelatingReference;
    this.RelatedResourceObjects = RelatedResourceObjects;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingReference = tape[ptr++];
    let RelatedResourceObjects = tape[ptr++];
    return new IfcExternalReferenceRelationship(expressID, type, Name, Description, RelatingReference, RelatedResourceObjects);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingReference);
    ;
    args.push(this.RelatedResourceObjects);
    ;
    return args;
  }
}, "IfcExternalReferenceRelationship");
var IfcExternalSpatialElement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcExternalSpatialElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.LongName);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcExternalSpatialElement");
var IfcExternalSpatialStructureElement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    return new IfcExternalSpatialStructureElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.LongName);
    ;
    return args;
  }
}, "IfcExternalSpatialStructureElement");
var IfcExternallyDefinedHatchStyle = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Location, Identification, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Identification = Identification;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    return new IfcExternallyDefinedHatchStyle(expressID, type, Location, Identification, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    ;
    args.push(this.Identification);
    ;
    args.push(this.Name);
    ;
    return args;
  }
}, "IfcExternallyDefinedHatchStyle");
var IfcExternallyDefinedSurfaceStyle = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Location, Identification, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Identification = Identification;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    return new IfcExternallyDefinedSurfaceStyle(expressID, type, Location, Identification, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    ;
    args.push(this.Identification);
    ;
    args.push(this.Name);
    ;
    return args;
  }
}, "IfcExternallyDefinedSurfaceStyle");
var IfcExternallyDefinedTextFont = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Location, Identification, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Identification = Identification;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    return new IfcExternallyDefinedTextFont(expressID, type, Location, Identification, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    ;
    args.push(this.Identification);
    ;
    args.push(this.Name);
    ;
    return args;
  }
}, "IfcExternallyDefinedTextFont");
var IfcExtrudedAreaSolid = /* @__PURE__ */ __name(class {
  constructor(expressID, type, SweptArea, Position, ExtrudedDirection, Depth) {
    this.expressID = expressID;
    this.type = type;
    this.SweptArea = SweptArea;
    this.Position = Position;
    this.ExtrudedDirection = ExtrudedDirection;
    this.Depth = Depth;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptArea = tape[ptr++];
    let Position = tape[ptr++];
    let ExtrudedDirection = tape[ptr++];
    let Depth = tape[ptr++];
    return new IfcExtrudedAreaSolid(expressID, type, SweptArea, Position, ExtrudedDirection, Depth);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptArea);
    ;
    args.push(this.Position);
    ;
    args.push(this.ExtrudedDirection);
    ;
    args.push(this.Depth);
    ;
    return args;
  }
}, "IfcExtrudedAreaSolid");
var IfcExtrudedAreaSolidTapered = /* @__PURE__ */ __name(class {
  constructor(expressID, type, SweptArea, Position, ExtrudedDirection, Depth, EndSweptArea) {
    this.expressID = expressID;
    this.type = type;
    this.SweptArea = SweptArea;
    this.Position = Position;
    this.ExtrudedDirection = ExtrudedDirection;
    this.Depth = Depth;
    this.EndSweptArea = EndSweptArea;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptArea = tape[ptr++];
    let Position = tape[ptr++];
    let ExtrudedDirection = tape[ptr++];
    let Depth = tape[ptr++];
    let EndSweptArea = tape[ptr++];
    return new IfcExtrudedAreaSolidTapered(expressID, type, SweptArea, Position, ExtrudedDirection, Depth, EndSweptArea);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptArea);
    ;
    args.push(this.Position);
    ;
    args.push(this.ExtrudedDirection);
    ;
    args.push(this.Depth);
    ;
    args.push(this.EndSweptArea);
    ;
    return args;
  }
}, "IfcExtrudedAreaSolidTapered");
var IfcFace = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Bounds) {
    this.expressID = expressID;
    this.type = type;
    this.Bounds = Bounds;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Bounds = tape[ptr++];
    return new IfcFace(expressID, type, Bounds);
  }
  ToTape() {
    let args = [];
    args.push(this.Bounds);
    ;
    return args;
  }
}, "IfcFace");
var IfcFaceBasedSurfaceModel = /* @__PURE__ */ __name(class {
  constructor(expressID, type, FbsmFaces) {
    this.expressID = expressID;
    this.type = type;
    this.FbsmFaces = FbsmFaces;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let FbsmFaces = tape[ptr++];
    return new IfcFaceBasedSurfaceModel(expressID, type, FbsmFaces);
  }
  ToTape() {
    let args = [];
    args.push(this.FbsmFaces);
    ;
    return args;
  }
}, "IfcFaceBasedSurfaceModel");
var IfcFaceBound = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Bound, Orientation) {
    this.expressID = expressID;
    this.type = type;
    this.Bound = Bound;
    this.Orientation = Orientation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Bound = tape[ptr++];
    let Orientation = tape[ptr++];
    return new IfcFaceBound(expressID, type, Bound, Orientation);
  }
  ToTape() {
    let args = [];
    args.push(this.Bound);
    ;
    args.push(this.Orientation);
    ;
    return args;
  }
}, "IfcFaceBound");
var IfcFaceOuterBound = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Bound, Orientation) {
    this.expressID = expressID;
    this.type = type;
    this.Bound = Bound;
    this.Orientation = Orientation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Bound = tape[ptr++];
    let Orientation = tape[ptr++];
    return new IfcFaceOuterBound(expressID, type, Bound, Orientation);
  }
  ToTape() {
    let args = [];
    args.push(this.Bound);
    ;
    args.push(this.Orientation);
    ;
    return args;
  }
}, "IfcFaceOuterBound");
var IfcFaceSurface = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Bounds, FaceSurface, SameSense) {
    this.expressID = expressID;
    this.type = type;
    this.Bounds = Bounds;
    this.FaceSurface = FaceSurface;
    this.SameSense = SameSense;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Bounds = tape[ptr++];
    let FaceSurface = tape[ptr++];
    let SameSense = tape[ptr++];
    return new IfcFaceSurface(expressID, type, Bounds, FaceSurface, SameSense);
  }
  ToTape() {
    let args = [];
    args.push(this.Bounds);
    ;
    args.push(this.FaceSurface);
    ;
    args.push(this.SameSense);
    ;
    return args;
  }
}, "IfcFaceSurface");
var IfcFacetedBrep = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Outer) {
    this.expressID = expressID;
    this.type = type;
    this.Outer = Outer;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Outer = tape[ptr++];
    return new IfcFacetedBrep(expressID, type, Outer);
  }
  ToTape() {
    let args = [];
    args.push(this.Outer);
    ;
    return args;
  }
}, "IfcFacetedBrep");
var IfcFacetedBrepWithVoids = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Outer, Voids) {
    this.expressID = expressID;
    this.type = type;
    this.Outer = Outer;
    this.Voids = Voids;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Outer = tape[ptr++];
    let Voids = tape[ptr++];
    return new IfcFacetedBrepWithVoids(expressID, type, Outer, Voids);
  }
  ToTape() {
    let args = [];
    args.push(this.Outer);
    ;
    args.push(this.Voids);
    ;
    return args;
  }
}, "IfcFacetedBrepWithVoids");
var IfcFacility = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    return new IfcFacility(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.LongName);
    ;
    args.push(this.CompositionType);
    ;
    return args;
  }
}, "IfcFacility");
var IfcFacilityPart = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    return new IfcFacilityPart(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.LongName);
    ;
    args.push(this.CompositionType);
    ;
    return args;
  }
}, "IfcFacilityPart");
var IfcFailureConnectionCondition = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, TensionFailureX, TensionFailureY, TensionFailureZ, CompressionFailureX, CompressionFailureY, CompressionFailureZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.TensionFailureX = TensionFailureX;
    this.TensionFailureY = TensionFailureY;
    this.TensionFailureZ = TensionFailureZ;
    this.CompressionFailureX = CompressionFailureX;
    this.CompressionFailureY = CompressionFailureY;
    this.CompressionFailureZ = CompressionFailureZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let TensionFailureX = tape[ptr++];
    let TensionFailureY = tape[ptr++];
    let TensionFailureZ = tape[ptr++];
    let CompressionFailureX = tape[ptr++];
    let CompressionFailureY = tape[ptr++];
    let CompressionFailureZ = tape[ptr++];
    return new IfcFailureConnectionCondition(expressID, type, Name, TensionFailureX, TensionFailureY, TensionFailureZ, CompressionFailureX, CompressionFailureY, CompressionFailureZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.TensionFailureX);
    ;
    args.push(this.TensionFailureY);
    ;
    args.push(this.TensionFailureZ);
    ;
    args.push(this.CompressionFailureX);
    ;
    args.push(this.CompressionFailureY);
    ;
    args.push(this.CompressionFailureZ);
    ;
    return args;
  }
}, "IfcFailureConnectionCondition");
var IfcFan = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFan(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcFan");
var IfcFanType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFanType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcFanType");
var IfcFastener = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFastener(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcFastener");
var IfcFastenerType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFastenerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcFastenerType");
var IfcFeatureElement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFeatureElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
}, "IfcFeatureElement");
var IfcFeatureElementAddition = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFeatureElementAddition(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
}, "IfcFeatureElementAddition");
var IfcFeatureElementSubtraction = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFeatureElementSubtraction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
}, "IfcFeatureElementSubtraction");
var IfcFillAreaStyle = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, FillStyles, ModelorDraughting) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.FillStyles = FillStyles;
    this.ModelorDraughting = ModelorDraughting;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let FillStyles = tape[ptr++];
    let ModelorDraughting = tape[ptr++];
    return new IfcFillAreaStyle(expressID, type, Name, FillStyles, ModelorDraughting);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.FillStyles);
    ;
    args.push(this.ModelorDraughting);
    ;
    return args;
  }
}, "IfcFillAreaStyle");
var IfcFillAreaStyleHatching = /* @__PURE__ */ __name(class {
  constructor(expressID, type, HatchLineAppearance, StartOfNextHatchLine, PointOfReferenceHatchLine, PatternStart, HatchLineAngle) {
    this.expressID = expressID;
    this.type = type;
    this.HatchLineAppearance = HatchLineAppearance;
    this.StartOfNextHatchLine = StartOfNextHatchLine;
    this.PointOfReferenceHatchLine = PointOfReferenceHatchLine;
    this.PatternStart = PatternStart;
    this.HatchLineAngle = HatchLineAngle;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let HatchLineAppearance = tape[ptr++];
    let StartOfNextHatchLine = tape[ptr++];
    let PointOfReferenceHatchLine = tape[ptr++];
    let PatternStart = tape[ptr++];
    let HatchLineAngle = tape[ptr++];
    return new IfcFillAreaStyleHatching(expressID, type, HatchLineAppearance, StartOfNextHatchLine, PointOfReferenceHatchLine, PatternStart, HatchLineAngle);
  }
  ToTape() {
    let args = [];
    args.push(this.HatchLineAppearance);
    ;
    args.push(this.StartOfNextHatchLine);
    ;
    args.push(this.PointOfReferenceHatchLine);
    ;
    args.push(this.PatternStart);
    ;
    args.push(this.HatchLineAngle);
    ;
    return args;
  }
}, "IfcFillAreaStyleHatching");
var IfcFillAreaStyleTiles = /* @__PURE__ */ __name(class {
  constructor(expressID, type, TilingPattern, Tiles, TilingScale) {
    this.expressID = expressID;
    this.type = type;
    this.TilingPattern = TilingPattern;
    this.Tiles = Tiles;
    this.TilingScale = TilingScale;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TilingPattern = tape[ptr++];
    let Tiles = tape[ptr++];
    let TilingScale = tape[ptr++];
    return new IfcFillAreaStyleTiles(expressID, type, TilingPattern, Tiles, TilingScale);
  }
  ToTape() {
    let args = [];
    args.push(this.TilingPattern);
    ;
    args.push(this.Tiles);
    ;
    args.push(this.TilingScale);
    ;
    return args;
  }
}, "IfcFillAreaStyleTiles");
var IfcFilter = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFilter(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcFilter");
var IfcFilterType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFilterType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcFilterType");
var IfcFireSuppressionTerminal = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFireSuppressionTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcFireSuppressionTerminal");
var IfcFireSuppressionTerminalType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFireSuppressionTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcFireSuppressionTerminalType");
var IfcFixedReferenceSweptAreaSolid = /* @__PURE__ */ __name(class {
  constructor(expressID, type, SweptArea, Position, Directrix, StartParam, EndParam, FixedReference) {
    this.expressID = expressID;
    this.type = type;
    this.SweptArea = SweptArea;
    this.Position = Position;
    this.Directrix = Directrix;
    this.StartParam = StartParam;
    this.EndParam = EndParam;
    this.FixedReference = FixedReference;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptArea = tape[ptr++];
    let Position = tape[ptr++];
    let Directrix = tape[ptr++];
    let StartParam = tape[ptr++];
    let EndParam = tape[ptr++];
    let FixedReference = tape[ptr++];
    return new IfcFixedReferenceSweptAreaSolid(expressID, type, SweptArea, Position, Directrix, StartParam, EndParam, FixedReference);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptArea);
    ;
    args.push(this.Position);
    ;
    args.push(this.Directrix);
    ;
    args.push(this.StartParam);
    ;
    args.push(this.EndParam);
    ;
    args.push(this.FixedReference);
    ;
    return args;
  }
}, "IfcFixedReferenceSweptAreaSolid");
var IfcFlowController = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFlowController(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
}, "IfcFlowController");
var IfcFlowControllerType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcFlowControllerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
}, "IfcFlowControllerType");
var IfcFlowFitting = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFlowFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
}, "IfcFlowFitting");
var IfcFlowFittingType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcFlowFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
}, "IfcFlowFittingType");
var IfcFlowInstrument = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFlowInstrument(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcFlowInstrument");
var IfcFlowInstrumentType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFlowInstrumentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcFlowInstrumentType");
var IfcFlowMeter = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFlowMeter(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcFlowMeter");
var IfcFlowMeterType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFlowMeterType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcFlowMeterType");
var IfcFlowMovingDevice = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFlowMovingDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
}, "IfcFlowMovingDevice");
var IfcFlowMovingDeviceType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcFlowMovingDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
}, "IfcFlowMovingDeviceType");
var IfcFlowSegment = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFlowSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
}, "IfcFlowSegment");
var IfcFlowSegmentType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcFlowSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
}, "IfcFlowSegmentType");
var IfcFlowStorageDevice = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFlowStorageDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
}, "IfcFlowStorageDevice");
var IfcFlowStorageDeviceType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcFlowStorageDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
}, "IfcFlowStorageDeviceType");
var IfcFlowTerminal = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFlowTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
}, "IfcFlowTerminal");
var IfcFlowTerminalType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcFlowTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
}, "IfcFlowTerminalType");
var IfcFlowTreatmentDevice = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFlowTreatmentDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
}, "IfcFlowTreatmentDevice");
var IfcFlowTreatmentDeviceType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcFlowTreatmentDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
}, "IfcFlowTreatmentDeviceType");
var IfcFooting = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFooting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcFooting");
var IfcFootingType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFootingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcFootingType");
var IfcFurnishingElement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFurnishingElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
}, "IfcFurnishingElement");
var IfcFurnishingElementType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcFurnishingElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
}, "IfcFurnishingElementType");
var IfcFurniture = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFurniture(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcFurniture");
var IfcFurnitureType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, AssemblyPlace, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.AssemblyPlace = AssemblyPlace;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let AssemblyPlace = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFurnitureType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, AssemblyPlace, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.AssemblyPlace);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcFurnitureType");
var IfcGeographicElement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcGeographicElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcGeographicElement");
var IfcGeographicElementType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcGeographicElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcGeographicElementType");
var IfcGeometricCurveSet = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Elements) {
    this.expressID = expressID;
    this.type = type;
    this.Elements = Elements;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Elements = tape[ptr++];
    return new IfcGeometricCurveSet(expressID, type, Elements);
  }
  ToTape() {
    let args = [];
    args.push(this.Elements);
    ;
    return args;
  }
}, "IfcGeometricCurveSet");
var IfcGeometricRepresentationContext = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ContextIdentifier, ContextType, CoordinateSpaceDimension, Precision, WorldCoordinateSystem, TrueNorth) {
    this.expressID = expressID;
    this.type = type;
    this.ContextIdentifier = ContextIdentifier;
    this.ContextType = ContextType;
    this.CoordinateSpaceDimension = CoordinateSpaceDimension;
    this.Precision = Precision;
    this.WorldCoordinateSystem = WorldCoordinateSystem;
    this.TrueNorth = TrueNorth;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextIdentifier = tape[ptr++];
    let ContextType = tape[ptr++];
    let CoordinateSpaceDimension = tape[ptr++];
    let Precision = tape[ptr++];
    let WorldCoordinateSystem = tape[ptr++];
    let TrueNorth = tape[ptr++];
    return new IfcGeometricRepresentationContext(expressID, type, ContextIdentifier, ContextType, CoordinateSpaceDimension, Precision, WorldCoordinateSystem, TrueNorth);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextIdentifier);
    ;
    args.push(this.ContextType);
    ;
    args.push(this.CoordinateSpaceDimension);
    ;
    args.push(this.Precision);
    ;
    args.push(this.WorldCoordinateSystem);
    ;
    args.push(this.TrueNorth);
    ;
    return args;
  }
}, "IfcGeometricRepresentationContext");
var IfcGeometricRepresentationItem = /* @__PURE__ */ __name(class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcGeometricRepresentationItem(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
}, "IfcGeometricRepresentationItem");
var IfcGeometricRepresentationSubContext = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ContextIdentifier, ContextType, CoordinateSpaceDimension, Precision, WorldCoordinateSystem, TrueNorth, ParentContext, TargetScale, TargetView, UserDefinedTargetView) {
    this.expressID = expressID;
    this.type = type;
    this.ContextIdentifier = ContextIdentifier;
    this.ContextType = ContextType;
    this.CoordinateSpaceDimension = CoordinateSpaceDimension;
    this.Precision = Precision;
    this.WorldCoordinateSystem = WorldCoordinateSystem;
    this.TrueNorth = TrueNorth;
    this.ParentContext = ParentContext;
    this.TargetScale = TargetScale;
    this.TargetView = TargetView;
    this.UserDefinedTargetView = UserDefinedTargetView;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextIdentifier = tape[ptr++];
    let ContextType = tape[ptr++];
    let CoordinateSpaceDimension = tape[ptr++];
    let Precision = tape[ptr++];
    let WorldCoordinateSystem = tape[ptr++];
    let TrueNorth = tape[ptr++];
    let ParentContext = tape[ptr++];
    let TargetScale = tape[ptr++];
    let TargetView = tape[ptr++];
    let UserDefinedTargetView = tape[ptr++];
    return new IfcGeometricRepresentationSubContext(expressID, type, ContextIdentifier, ContextType, CoordinateSpaceDimension, Precision, WorldCoordinateSystem, TrueNorth, ParentContext, TargetScale, TargetView, UserDefinedTargetView);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextIdentifier);
    ;
    args.push(this.ContextType);
    ;
    args.push(this.CoordinateSpaceDimension);
    ;
    args.push(this.Precision);
    ;
    args.push(this.WorldCoordinateSystem);
    ;
    args.push(this.TrueNorth);
    ;
    args.push(this.ParentContext);
    ;
    args.push(this.TargetScale);
    ;
    args.push(this.TargetView);
    ;
    args.push(this.UserDefinedTargetView);
    ;
    return args;
  }
}, "IfcGeometricRepresentationSubContext");
var IfcGeometricSet = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Elements) {
    this.expressID = expressID;
    this.type = type;
    this.Elements = Elements;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Elements = tape[ptr++];
    return new IfcGeometricSet(expressID, type, Elements);
  }
  ToTape() {
    let args = [];
    args.push(this.Elements);
    ;
    return args;
  }
}, "IfcGeometricSet");
var IfcGrid = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, UAxes, VAxes, WAxes, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.UAxes = UAxes;
    this.VAxes = VAxes;
    this.WAxes = WAxes;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let UAxes = tape[ptr++];
    let VAxes = tape[ptr++];
    let WAxes = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcGrid(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, UAxes, VAxes, WAxes, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.UAxes);
    ;
    args.push(this.VAxes);
    ;
    args.push(this.WAxes);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcGrid");
var IfcGridAxis = /* @__PURE__ */ __name(class {
  constructor(expressID, type, AxisTag, AxisCurve, SameSense) {
    this.expressID = expressID;
    this.type = type;
    this.AxisTag = AxisTag;
    this.AxisCurve = AxisCurve;
    this.SameSense = SameSense;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let AxisTag = tape[ptr++];
    let AxisCurve = tape[ptr++];
    let SameSense = tape[ptr++];
    return new IfcGridAxis(expressID, type, AxisTag, AxisCurve, SameSense);
  }
  ToTape() {
    let args = [];
    args.push(this.AxisTag);
    ;
    args.push(this.AxisCurve);
    ;
    args.push(this.SameSense);
    ;
    return args;
  }
}, "IfcGridAxis");
var IfcGridPlacement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, PlacementRelTo, PlacementLocation, PlacementRefDirection) {
    this.expressID = expressID;
    this.type = type;
    this.PlacementRelTo = PlacementRelTo;
    this.PlacementLocation = PlacementLocation;
    this.PlacementRefDirection = PlacementRefDirection;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let PlacementRelTo = tape[ptr++];
    let PlacementLocation = tape[ptr++];
    let PlacementRefDirection = tape[ptr++];
    return new IfcGridPlacement(expressID, type, PlacementRelTo, PlacementLocation, PlacementRefDirection);
  }
  ToTape() {
    let args = [];
    args.push(this.PlacementRelTo);
    ;
    args.push(this.PlacementLocation);
    ;
    args.push(this.PlacementRefDirection);
    ;
    return args;
  }
}, "IfcGridPlacement");
var IfcGroup = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    return new IfcGroup(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    return args;
  }
}, "IfcGroup");
var IfcHalfSpaceSolid = /* @__PURE__ */ __name(class {
  constructor(expressID, type, BaseSurface, AgreementFlag) {
    this.expressID = expressID;
    this.type = type;
    this.BaseSurface = BaseSurface;
    this.AgreementFlag = AgreementFlag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BaseSurface = tape[ptr++];
    let AgreementFlag = tape[ptr++];
    return new IfcHalfSpaceSolid(expressID, type, BaseSurface, AgreementFlag);
  }
  ToTape() {
    let args = [];
    args.push(this.BaseSurface);
    ;
    args.push(this.AgreementFlag);
    ;
    return args;
  }
}, "IfcHalfSpaceSolid");
var IfcHeatExchanger = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcHeatExchanger(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcHeatExchanger");
var IfcHeatExchangerType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcHeatExchangerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcHeatExchangerType");
var IfcHumidifier = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcHumidifier(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcHumidifier");
var IfcHumidifierType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcHumidifierType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcHumidifierType");
var IfcIShapeProfileDef = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ProfileType, ProfileName, Position, OverallWidth, OverallDepth, WebThickness, FlangeThickness, FilletRadius, FlangeEdgeRadius, FlangeSlope) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.OverallWidth = OverallWidth;
    this.OverallDepth = OverallDepth;
    this.WebThickness = WebThickness;
    this.FlangeThickness = FlangeThickness;
    this.FilletRadius = FilletRadius;
    this.FlangeEdgeRadius = FlangeEdgeRadius;
    this.FlangeSlope = FlangeSlope;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let OverallWidth = tape[ptr++];
    let OverallDepth = tape[ptr++];
    let WebThickness = tape[ptr++];
    let FlangeThickness = tape[ptr++];
    let FilletRadius = tape[ptr++];
    let FlangeEdgeRadius = tape[ptr++];
    let FlangeSlope = tape[ptr++];
    return new IfcIShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, OverallWidth, OverallDepth, WebThickness, FlangeThickness, FilletRadius, FlangeEdgeRadius, FlangeSlope);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Position);
    ;
    args.push(this.OverallWidth);
    ;
    args.push(this.OverallDepth);
    ;
    args.push(this.WebThickness);
    ;
    args.push(this.FlangeThickness);
    ;
    args.push(this.FilletRadius);
    ;
    args.push(this.FlangeEdgeRadius);
    ;
    args.push(this.FlangeSlope);
    ;
    return args;
  }
}, "IfcIShapeProfileDef");
var IfcImageTexture = /* @__PURE__ */ __name(class {
  constructor(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, URLReference) {
    this.expressID = expressID;
    this.type = type;
    this.RepeatS = RepeatS;
    this.RepeatT = RepeatT;
    this.Mode = Mode;
    this.TextureTransform = TextureTransform;
    this.Parameter = Parameter;
    this.URLReference = URLReference;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let RepeatS = tape[ptr++];
    let RepeatT = tape[ptr++];
    let Mode = tape[ptr++];
    let TextureTransform = tape[ptr++];
    let Parameter = tape[ptr++];
    let URLReference = tape[ptr++];
    return new IfcImageTexture(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, URLReference);
  }
  ToTape() {
    let args = [];
    args.push(this.RepeatS);
    ;
    args.push(this.RepeatT);
    ;
    args.push(this.Mode);
    ;
    args.push(this.TextureTransform);
    ;
    args.push(this.Parameter);
    ;
    args.push(this.URLReference);
    ;
    return args;
  }
}, "IfcImageTexture");
var IfcIndexedColourMap = /* @__PURE__ */ __name(class {
  constructor(expressID, type, MappedTo, Opacity, Colours, ColourIndex) {
    this.expressID = expressID;
    this.type = type;
    this.MappedTo = MappedTo;
    this.Opacity = Opacity;
    this.Colours = Colours;
    this.ColourIndex = ColourIndex;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let MappedTo = tape[ptr++];
    let Opacity = tape[ptr++];
    let Colours = tape[ptr++];
    let ColourIndex = tape[ptr++];
    return new IfcIndexedColourMap(expressID, type, MappedTo, Opacity, Colours, ColourIndex);
  }
  ToTape() {
    let args = [];
    args.push(this.MappedTo);
    ;
    args.push(this.Opacity);
    ;
    args.push(this.Colours);
    ;
    args.push(this.ColourIndex);
    ;
    return args;
  }
}, "IfcIndexedColourMap");
var IfcIndexedPolyCurve = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Points, Segments, SelfIntersect) {
    this.expressID = expressID;
    this.type = type;
    this.Points = Points;
    this.Segments = Segments;
    this.SelfIntersect = SelfIntersect;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Points = tape[ptr++];
    let Segments = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    return new IfcIndexedPolyCurve(expressID, type, Points, Segments, SelfIntersect);
  }
  ToTape() {
    let args = [];
    args.push(this.Points);
    ;
    args.push(this.Segments);
    ;
    args.push(this.SelfIntersect);
    ;
    return args;
  }
}, "IfcIndexedPolyCurve");
var IfcIndexedPolygonalFace = /* @__PURE__ */ __name(class {
  constructor(expressID, type, CoordIndex) {
    this.expressID = expressID;
    this.type = type;
    this.CoordIndex = CoordIndex;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let CoordIndex = tape[ptr++];
    return new IfcIndexedPolygonalFace(expressID, type, CoordIndex);
  }
  ToTape() {
    let args = [];
    args.push(this.CoordIndex);
    ;
    return args;
  }
}, "IfcIndexedPolygonalFace");
var IfcIndexedPolygonalFaceWithVoids = /* @__PURE__ */ __name(class {
  constructor(expressID, type, CoordIndex, InnerCoordIndices) {
    this.expressID = expressID;
    this.type = type;
    this.CoordIndex = CoordIndex;
    this.InnerCoordIndices = InnerCoordIndices;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let CoordIndex = tape[ptr++];
    let InnerCoordIndices = tape[ptr++];
    return new IfcIndexedPolygonalFaceWithVoids(expressID, type, CoordIndex, InnerCoordIndices);
  }
  ToTape() {
    let args = [];
    args.push(this.CoordIndex);
    ;
    args.push(this.InnerCoordIndices);
    ;
    return args;
  }
}, "IfcIndexedPolygonalFaceWithVoids");
var IfcIndexedTextureMap = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Maps, MappedTo, TexCoords) {
    this.expressID = expressID;
    this.type = type;
    this.Maps = Maps;
    this.MappedTo = MappedTo;
    this.TexCoords = TexCoords;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Maps = tape[ptr++];
    let MappedTo = tape[ptr++];
    let TexCoords = tape[ptr++];
    return new IfcIndexedTextureMap(expressID, type, Maps, MappedTo, TexCoords);
  }
  ToTape() {
    let args = [];
    args.push(this.Maps);
    ;
    args.push(this.MappedTo);
    ;
    args.push(this.TexCoords);
    ;
    return args;
  }
}, "IfcIndexedTextureMap");
var IfcIndexedTriangleTextureMap = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Maps, MappedTo, TexCoords, TexCoordIndex) {
    this.expressID = expressID;
    this.type = type;
    this.Maps = Maps;
    this.MappedTo = MappedTo;
    this.TexCoords = TexCoords;
    this.TexCoordIndex = TexCoordIndex;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Maps = tape[ptr++];
    let MappedTo = tape[ptr++];
    let TexCoords = tape[ptr++];
    let TexCoordIndex = tape[ptr++];
    return new IfcIndexedTriangleTextureMap(expressID, type, Maps, MappedTo, TexCoords, TexCoordIndex);
  }
  ToTape() {
    let args = [];
    args.push(this.Maps);
    ;
    args.push(this.MappedTo);
    ;
    args.push(this.TexCoords);
    ;
    args.push(this.TexCoordIndex);
    ;
    return args;
  }
}, "IfcIndexedTriangleTextureMap");
var IfcInterceptor = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcInterceptor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcInterceptor");
var IfcInterceptorType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcInterceptorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcInterceptorType");
var IfcIntersectionCurve = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation) {
    this.expressID = expressID;
    this.type = type;
    this.Curve3D = Curve3D;
    this.AssociatedGeometry = AssociatedGeometry;
    this.MasterRepresentation = MasterRepresentation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Curve3D = tape[ptr++];
    let AssociatedGeometry = tape[ptr++];
    let MasterRepresentation = tape[ptr++];
    return new IfcIntersectionCurve(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation);
  }
  ToTape() {
    let args = [];
    args.push(this.Curve3D);
    ;
    args.push(this.AssociatedGeometry);
    ;
    args.push(this.MasterRepresentation);
    ;
    return args;
  }
}, "IfcIntersectionCurve");
var IfcInventory = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, Jurisdiction, ResponsiblePersons, LastUpdateDate, CurrentValue, OriginalValue) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.PredefinedType = PredefinedType;
    this.Jurisdiction = Jurisdiction;
    this.ResponsiblePersons = ResponsiblePersons;
    this.LastUpdateDate = LastUpdateDate;
    this.CurrentValue = CurrentValue;
    this.OriginalValue = OriginalValue;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Jurisdiction = tape[ptr++];
    let ResponsiblePersons = tape[ptr++];
    let LastUpdateDate = tape[ptr++];
    let CurrentValue = tape[ptr++];
    let OriginalValue = tape[ptr++];
    return new IfcInventory(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, Jurisdiction, ResponsiblePersons, LastUpdateDate, CurrentValue, OriginalValue);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.Jurisdiction);
    ;
    args.push(this.ResponsiblePersons);
    ;
    args.push(this.LastUpdateDate);
    ;
    args.push(this.CurrentValue);
    ;
    args.push(this.OriginalValue);
    ;
    return args;
  }
}, "IfcInventory");
var IfcIrregularTimeSeries = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit, Values) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.StartTime = StartTime;
    this.EndTime = EndTime;
    this.TimeSeriesDataType = TimeSeriesDataType;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.Unit = Unit;
    this.Values = Values;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let StartTime = tape[ptr++];
    let EndTime = tape[ptr++];
    let TimeSeriesDataType = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let Unit = tape[ptr++];
    let Values = tape[ptr++];
    return new IfcIrregularTimeSeries(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit, Values);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.StartTime);
    ;
    args.push(this.EndTime);
    ;
    args.push(this.TimeSeriesDataType);
    ;
    args.push(this.DataOrigin);
    ;
    args.push(this.UserDefinedDataOrigin);
    ;
    args.push(this.Unit);
    ;
    args.push(this.Values);
    ;
    return args;
  }
}, "IfcIrregularTimeSeries");
var IfcIrregularTimeSeriesValue = /* @__PURE__ */ __name(class {
  constructor(expressID, type, TimeStamp, ListValues) {
    this.expressID = expressID;
    this.type = type;
    this.TimeStamp = TimeStamp;
    this.ListValues = ListValues;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TimeStamp = tape[ptr++];
    let ListValues = tape[ptr++];
    return new IfcIrregularTimeSeriesValue(expressID, type, TimeStamp, ListValues);
  }
  ToTape() {
    let args = [];
    args.push(this.TimeStamp);
    ;
    args.push(this.ListValues);
    ;
    return args;
  }
}, "IfcIrregularTimeSeriesValue");
var IfcJunctionBox = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcJunctionBox(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcJunctionBox");
var IfcJunctionBoxType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcJunctionBoxType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcJunctionBoxType");
var IfcLShapeProfileDef = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ProfileType, ProfileName, Position, Depth, Width, Thickness, FilletRadius, EdgeRadius, LegSlope) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.Depth = Depth;
    this.Width = Width;
    this.Thickness = Thickness;
    this.FilletRadius = FilletRadius;
    this.EdgeRadius = EdgeRadius;
    this.LegSlope = LegSlope;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let Depth = tape[ptr++];
    let Width = tape[ptr++];
    let Thickness = tape[ptr++];
    let FilletRadius = tape[ptr++];
    let EdgeRadius = tape[ptr++];
    let LegSlope = tape[ptr++];
    return new IfcLShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, Width, Thickness, FilletRadius, EdgeRadius, LegSlope);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Position);
    ;
    args.push(this.Depth);
    ;
    args.push(this.Width);
    ;
    args.push(this.Thickness);
    ;
    args.push(this.FilletRadius);
    ;
    args.push(this.EdgeRadius);
    ;
    args.push(this.LegSlope);
    ;
    return args;
  }
}, "IfcLShapeProfileDef");
var IfcLaborResource = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.Usage = Usage;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let Usage = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcLaborResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.Usage);
    ;
    args.push(this.BaseCosts);
    ;
    args.push(this.BaseQuantity);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcLaborResource");
var IfcLaborResourceType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ResourceType = ResourceType;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ResourceType = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcLaborResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.ResourceType);
    ;
    args.push(this.BaseCosts);
    ;
    args.push(this.BaseQuantity);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcLaborResourceType");
var IfcLagTime = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, LagValue, DurationType) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.LagValue = LagValue;
    this.DurationType = DurationType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let LagValue = tape[ptr++];
    let DurationType = tape[ptr++];
    return new IfcLagTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, LagValue, DurationType);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.DataOrigin);
    ;
    args.push(this.UserDefinedDataOrigin);
    ;
    args.push(this.LagValue);
    ;
    args.push(this.DurationType);
    ;
    return args;
  }
}, "IfcLagTime");
var IfcLamp = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcLamp(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcLamp");
var IfcLampType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcLampType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcLampType");
var IfcLibraryInformation = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Version, Publisher, VersionDate, Location, Description) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Version = Version;
    this.Publisher = Publisher;
    this.VersionDate = VersionDate;
    this.Location = Location;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Version = tape[ptr++];
    let Publisher = tape[ptr++];
    let VersionDate = tape[ptr++];
    let Location = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcLibraryInformation(expressID, type, Name, Version, Publisher, VersionDate, Location, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Version);
    ;
    args.push(this.Publisher);
    ;
    args.push(this.VersionDate);
    ;
    args.push(this.Location);
    ;
    args.push(this.Description);
    ;
    return args;
  }
}, "IfcLibraryInformation");
var IfcLibraryReference = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Location, Identification, Name, Description, Language, ReferencedLibrary) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Identification = Identification;
    this.Name = Name;
    this.Description = Description;
    this.Language = Language;
    this.ReferencedLibrary = ReferencedLibrary;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Language = tape[ptr++];
    let ReferencedLibrary = tape[ptr++];
    return new IfcLibraryReference(expressID, type, Location, Identification, Name, Description, Language, ReferencedLibrary);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    ;
    args.push(this.Identification);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Language);
    ;
    args.push(this.ReferencedLibrary);
    ;
    return args;
  }
}, "IfcLibraryReference");
var IfcLightDistributionData = /* @__PURE__ */ __name(class {
  constructor(expressID, type, MainPlaneAngle, SecondaryPlaneAngle, LuminousIntensity) {
    this.expressID = expressID;
    this.type = type;
    this.MainPlaneAngle = MainPlaneAngle;
    this.SecondaryPlaneAngle = SecondaryPlaneAngle;
    this.LuminousIntensity = LuminousIntensity;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let MainPlaneAngle = tape[ptr++];
    let SecondaryPlaneAngle = tape[ptr++];
    let LuminousIntensity = tape[ptr++];
    return new IfcLightDistributionData(expressID, type, MainPlaneAngle, SecondaryPlaneAngle, LuminousIntensity);
  }
  ToTape() {
    let args = [];
    args.push(this.MainPlaneAngle);
    ;
    args.push(this.SecondaryPlaneAngle);
    ;
    args.push(this.LuminousIntensity);
    ;
    return args;
  }
}, "IfcLightDistributionData");
var IfcLightFixture = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcLightFixture(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcLightFixture");
var IfcLightFixtureType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcLightFixtureType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcLightFixtureType");
var IfcLightIntensityDistribution = /* @__PURE__ */ __name(class {
  constructor(expressID, type, LightDistributionCurve, DistributionData) {
    this.expressID = expressID;
    this.type = type;
    this.LightDistributionCurve = LightDistributionCurve;
    this.DistributionData = DistributionData;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let LightDistributionCurve = tape[ptr++];
    let DistributionData = tape[ptr++];
    return new IfcLightIntensityDistribution(expressID, type, LightDistributionCurve, DistributionData);
  }
  ToTape() {
    let args = [];
    args.push(this.LightDistributionCurve);
    ;
    args.push(this.DistributionData);
    ;
    return args;
  }
}, "IfcLightIntensityDistribution");
var IfcLightSource = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.LightColour = LightColour;
    this.AmbientIntensity = AmbientIntensity;
    this.Intensity = Intensity;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let LightColour = tape[ptr++];
    let AmbientIntensity = tape[ptr++];
    let Intensity = tape[ptr++];
    return new IfcLightSource(expressID, type, Name, LightColour, AmbientIntensity, Intensity);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.LightColour);
    ;
    args.push(this.AmbientIntensity);
    ;
    args.push(this.Intensity);
    ;
    return args;
  }
}, "IfcLightSource");
var IfcLightSourceAmbient = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.LightColour = LightColour;
    this.AmbientIntensity = AmbientIntensity;
    this.Intensity = Intensity;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let LightColour = tape[ptr++];
    let AmbientIntensity = tape[ptr++];
    let Intensity = tape[ptr++];
    return new IfcLightSourceAmbient(expressID, type, Name, LightColour, AmbientIntensity, Intensity);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.LightColour);
    ;
    args.push(this.AmbientIntensity);
    ;
    args.push(this.Intensity);
    ;
    return args;
  }
}, "IfcLightSourceAmbient");
var IfcLightSourceDirectional = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Orientation) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.LightColour = LightColour;
    this.AmbientIntensity = AmbientIntensity;
    this.Intensity = Intensity;
    this.Orientation = Orientation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let LightColour = tape[ptr++];
    let AmbientIntensity = tape[ptr++];
    let Intensity = tape[ptr++];
    let Orientation = tape[ptr++];
    return new IfcLightSourceDirectional(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Orientation);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.LightColour);
    ;
    args.push(this.AmbientIntensity);
    ;
    args.push(this.Intensity);
    ;
    args.push(this.Orientation);
    ;
    return args;
  }
}, "IfcLightSourceDirectional");
var IfcLightSourceGoniometric = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, ColourAppearance, ColourTemperature, LuminousFlux, LightEmissionSource, LightDistributionDataSource) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.LightColour = LightColour;
    this.AmbientIntensity = AmbientIntensity;
    this.Intensity = Intensity;
    this.Position = Position;
    this.ColourAppearance = ColourAppearance;
    this.ColourTemperature = ColourTemperature;
    this.LuminousFlux = LuminousFlux;
    this.LightEmissionSource = LightEmissionSource;
    this.LightDistributionDataSource = LightDistributionDataSource;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let LightColour = tape[ptr++];
    let AmbientIntensity = tape[ptr++];
    let Intensity = tape[ptr++];
    let Position = tape[ptr++];
    let ColourAppearance = tape[ptr++];
    let ColourTemperature = tape[ptr++];
    let LuminousFlux = tape[ptr++];
    let LightEmissionSource = tape[ptr++];
    let LightDistributionDataSource = tape[ptr++];
    return new IfcLightSourceGoniometric(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, ColourAppearance, ColourTemperature, LuminousFlux, LightEmissionSource, LightDistributionDataSource);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.LightColour);
    ;
    args.push(this.AmbientIntensity);
    ;
    args.push(this.Intensity);
    ;
    args.push(this.Position);
    ;
    args.push(this.ColourAppearance);
    ;
    args.push(this.ColourTemperature);
    ;
    args.push(this.LuminousFlux);
    ;
    args.push(this.LightEmissionSource);
    ;
    args.push(this.LightDistributionDataSource);
    ;
    return args;
  }
}, "IfcLightSourceGoniometric");
var IfcLightSourcePositional = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, Radius, ConstantAttenuation, DistanceAttenuation, QuadricAttenuation) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.LightColour = LightColour;
    this.AmbientIntensity = AmbientIntensity;
    this.Intensity = Intensity;
    this.Position = Position;
    this.Radius = Radius;
    this.ConstantAttenuation = ConstantAttenuation;
    this.DistanceAttenuation = DistanceAttenuation;
    this.QuadricAttenuation = QuadricAttenuation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let LightColour = tape[ptr++];
    let AmbientIntensity = tape[ptr++];
    let Intensity = tape[ptr++];
    let Position = tape[ptr++];
    let Radius = tape[ptr++];
    let ConstantAttenuation = tape[ptr++];
    let DistanceAttenuation = tape[ptr++];
    let QuadricAttenuation = tape[ptr++];
    return new IfcLightSourcePositional(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, Radius, ConstantAttenuation, DistanceAttenuation, QuadricAttenuation);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.LightColour);
    ;
    args.push(this.AmbientIntensity);
    ;
    args.push(this.Intensity);
    ;
    args.push(this.Position);
    ;
    args.push(this.Radius);
    ;
    args.push(this.ConstantAttenuation);
    ;
    args.push(this.DistanceAttenuation);
    ;
    args.push(this.QuadricAttenuation);
    ;
    return args;
  }
}, "IfcLightSourcePositional");
var IfcLightSourceSpot = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, Radius, ConstantAttenuation, DistanceAttenuation, QuadricAttenuation, Orientation, ConcentrationExponent, SpreadAngle, BeamWidthAngle) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.LightColour = LightColour;
    this.AmbientIntensity = AmbientIntensity;
    this.Intensity = Intensity;
    this.Position = Position;
    this.Radius = Radius;
    this.ConstantAttenuation = ConstantAttenuation;
    this.DistanceAttenuation = DistanceAttenuation;
    this.QuadricAttenuation = QuadricAttenuation;
    this.Orientation = Orientation;
    this.ConcentrationExponent = ConcentrationExponent;
    this.SpreadAngle = SpreadAngle;
    this.BeamWidthAngle = BeamWidthAngle;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let LightColour = tape[ptr++];
    let AmbientIntensity = tape[ptr++];
    let Intensity = tape[ptr++];
    let Position = tape[ptr++];
    let Radius = tape[ptr++];
    let ConstantAttenuation = tape[ptr++];
    let DistanceAttenuation = tape[ptr++];
    let QuadricAttenuation = tape[ptr++];
    let Orientation = tape[ptr++];
    let ConcentrationExponent = tape[ptr++];
    let SpreadAngle = tape[ptr++];
    let BeamWidthAngle = tape[ptr++];
    return new IfcLightSourceSpot(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, Radius, ConstantAttenuation, DistanceAttenuation, QuadricAttenuation, Orientation, ConcentrationExponent, SpreadAngle, BeamWidthAngle);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.LightColour);
    ;
    args.push(this.AmbientIntensity);
    ;
    args.push(this.Intensity);
    ;
    args.push(this.Position);
    ;
    args.push(this.Radius);
    ;
    args.push(this.ConstantAttenuation);
    ;
    args.push(this.DistanceAttenuation);
    ;
    args.push(this.QuadricAttenuation);
    ;
    args.push(this.Orientation);
    ;
    args.push(this.ConcentrationExponent);
    ;
    args.push(this.SpreadAngle);
    ;
    args.push(this.BeamWidthAngle);
    ;
    return args;
  }
}, "IfcLightSourceSpot");
var IfcLine = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Pnt, Dir) {
    this.expressID = expressID;
    this.type = type;
    this.Pnt = Pnt;
    this.Dir = Dir;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Pnt = tape[ptr++];
    let Dir = tape[ptr++];
    return new IfcLine(expressID, type, Pnt, Dir);
  }
  ToTape() {
    let args = [];
    args.push(this.Pnt);
    ;
    args.push(this.Dir);
    ;
    return args;
  }
}, "IfcLine");
var IfcLineSegment2D = /* @__PURE__ */ __name(class {
  constructor(expressID, type, StartPoint, StartDirection, SegmentLength) {
    this.expressID = expressID;
    this.type = type;
    this.StartPoint = StartPoint;
    this.StartDirection = StartDirection;
    this.SegmentLength = SegmentLength;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let StartPoint = tape[ptr++];
    let StartDirection = tape[ptr++];
    let SegmentLength = tape[ptr++];
    return new IfcLineSegment2D(expressID, type, StartPoint, StartDirection, SegmentLength);
  }
  ToTape() {
    let args = [];
    args.push(this.StartPoint);
    ;
    args.push(this.StartDirection);
    ;
    args.push(this.SegmentLength);
    ;
    return args;
  }
}, "IfcLineSegment2D");
var IfcLinearPlacement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, PlacementRelTo, PlacementMeasuredAlong, Distance, Orientation, CartesianPosition) {
    this.expressID = expressID;
    this.type = type;
    this.PlacementRelTo = PlacementRelTo;
    this.PlacementMeasuredAlong = PlacementMeasuredAlong;
    this.Distance = Distance;
    this.Orientation = Orientation;
    this.CartesianPosition = CartesianPosition;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let PlacementRelTo = tape[ptr++];
    let PlacementMeasuredAlong = tape[ptr++];
    let Distance = tape[ptr++];
    let Orientation = tape[ptr++];
    let CartesianPosition = tape[ptr++];
    return new IfcLinearPlacement(expressID, type, PlacementRelTo, PlacementMeasuredAlong, Distance, Orientation, CartesianPosition);
  }
  ToTape() {
    let args = [];
    args.push(this.PlacementRelTo);
    ;
    args.push(this.PlacementMeasuredAlong);
    ;
    args.push(this.Distance);
    ;
    args.push(this.Orientation);
    ;
    args.push(this.CartesianPosition);
    ;
    return args;
  }
}, "IfcLinearPlacement");
var IfcLinearPositioningElement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Axis) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Axis = Axis;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Axis = tape[ptr++];
    return new IfcLinearPositioningElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Axis);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Axis);
    ;
    return args;
  }
}, "IfcLinearPositioningElement");
var IfcLocalPlacement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, PlacementRelTo, RelativePlacement) {
    this.expressID = expressID;
    this.type = type;
    this.PlacementRelTo = PlacementRelTo;
    this.RelativePlacement = RelativePlacement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let PlacementRelTo = tape[ptr++];
    let RelativePlacement = tape[ptr++];
    return new IfcLocalPlacement(expressID, type, PlacementRelTo, RelativePlacement);
  }
  ToTape() {
    let args = [];
    args.push(this.PlacementRelTo);
    ;
    args.push(this.RelativePlacement);
    ;
    return args;
  }
}, "IfcLocalPlacement");
var IfcLoop = /* @__PURE__ */ __name(class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcLoop(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
}, "IfcLoop");
var IfcManifoldSolidBrep = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Outer) {
    this.expressID = expressID;
    this.type = type;
    this.Outer = Outer;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Outer = tape[ptr++];
    return new IfcManifoldSolidBrep(expressID, type, Outer);
  }
  ToTape() {
    let args = [];
    args.push(this.Outer);
    ;
    return args;
  }
}, "IfcManifoldSolidBrep");
var IfcMapConversion = /* @__PURE__ */ __name(class {
  constructor(expressID, type, SourceCRS, TargetCRS, Eastings, Northings, OrthogonalHeight, XAxisAbscissa, XAxisOrdinate, Scale) {
    this.expressID = expressID;
    this.type = type;
    this.SourceCRS = SourceCRS;
    this.TargetCRS = TargetCRS;
    this.Eastings = Eastings;
    this.Northings = Northings;
    this.OrthogonalHeight = OrthogonalHeight;
    this.XAxisAbscissa = XAxisAbscissa;
    this.XAxisOrdinate = XAxisOrdinate;
    this.Scale = Scale;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SourceCRS = tape[ptr++];
    let TargetCRS = tape[ptr++];
    let Eastings = tape[ptr++];
    let Northings = tape[ptr++];
    let OrthogonalHeight = tape[ptr++];
    let XAxisAbscissa = tape[ptr++];
    let XAxisOrdinate = tape[ptr++];
    let Scale = tape[ptr++];
    return new IfcMapConversion(expressID, type, SourceCRS, TargetCRS, Eastings, Northings, OrthogonalHeight, XAxisAbscissa, XAxisOrdinate, Scale);
  }
  ToTape() {
    let args = [];
    args.push(this.SourceCRS);
    ;
    args.push(this.TargetCRS);
    ;
    args.push(this.Eastings);
    ;
    args.push(this.Northings);
    ;
    args.push(this.OrthogonalHeight);
    ;
    args.push(this.XAxisAbscissa);
    ;
    args.push(this.XAxisOrdinate);
    ;
    args.push(this.Scale);
    ;
    return args;
  }
}, "IfcMapConversion");
var IfcMappedItem = /* @__PURE__ */ __name(class {
  constructor(expressID, type, MappingSource, MappingTarget) {
    this.expressID = expressID;
    this.type = type;
    this.MappingSource = MappingSource;
    this.MappingTarget = MappingTarget;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let MappingSource = tape[ptr++];
    let MappingTarget = tape[ptr++];
    return new IfcMappedItem(expressID, type, MappingSource, MappingTarget);
  }
  ToTape() {
    let args = [];
    args.push(this.MappingSource);
    ;
    args.push(this.MappingTarget);
    ;
    return args;
  }
}, "IfcMappedItem");
var IfcMaterial = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, Category) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Category = Category;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Category = tape[ptr++];
    return new IfcMaterial(expressID, type, Name, Description, Category);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Category);
    ;
    return args;
  }
}, "IfcMaterial");
var IfcMaterialClassificationRelationship = /* @__PURE__ */ __name(class {
  constructor(expressID, type, MaterialClassifications, ClassifiedMaterial) {
    this.expressID = expressID;
    this.type = type;
    this.MaterialClassifications = MaterialClassifications;
    this.ClassifiedMaterial = ClassifiedMaterial;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let MaterialClassifications = tape[ptr++];
    let ClassifiedMaterial = tape[ptr++];
    return new IfcMaterialClassificationRelationship(expressID, type, MaterialClassifications, ClassifiedMaterial);
  }
  ToTape() {
    let args = [];
    args.push(this.MaterialClassifications);
    ;
    args.push(this.ClassifiedMaterial);
    ;
    return args;
  }
}, "IfcMaterialClassificationRelationship");
var IfcMaterialConstituent = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, Material, Fraction, Category) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Material = Material;
    this.Fraction = Fraction;
    this.Category = Category;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Material = tape[ptr++];
    let Fraction = tape[ptr++];
    let Category = tape[ptr++];
    return new IfcMaterialConstituent(expressID, type, Name, Description, Material, Fraction, Category);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Material);
    ;
    args.push(this.Fraction);
    ;
    args.push(this.Category);
    ;
    return args;
  }
}, "IfcMaterialConstituent");
var IfcMaterialConstituentSet = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, MaterialConstituents) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.MaterialConstituents = MaterialConstituents;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let MaterialConstituents = tape[ptr++];
    return new IfcMaterialConstituentSet(expressID, type, Name, Description, MaterialConstituents);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.MaterialConstituents);
    ;
    return args;
  }
}, "IfcMaterialConstituentSet");
var IfcMaterialDefinition = /* @__PURE__ */ __name(class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcMaterialDefinition(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
}, "IfcMaterialDefinition");
var IfcMaterialDefinitionRepresentation = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, Representations, RepresentedMaterial) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Representations = Representations;
    this.RepresentedMaterial = RepresentedMaterial;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Representations = tape[ptr++];
    let RepresentedMaterial = tape[ptr++];
    return new IfcMaterialDefinitionRepresentation(expressID, type, Name, Description, Representations, RepresentedMaterial);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Representations);
    ;
    args.push(this.RepresentedMaterial);
    ;
    return args;
  }
}, "IfcMaterialDefinitionRepresentation");
var IfcMaterialLayer = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Material, LayerThickness, IsVentilated, Name, Description, Category, Priority) {
    this.expressID = expressID;
    this.type = type;
    this.Material = Material;
    this.LayerThickness = LayerThickness;
    this.IsVentilated = IsVentilated;
    this.Name = Name;
    this.Description = Description;
    this.Category = Category;
    this.Priority = Priority;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Material = tape[ptr++];
    let LayerThickness = tape[ptr++];
    let IsVentilated = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Category = tape[ptr++];
    let Priority = tape[ptr++];
    return new IfcMaterialLayer(expressID, type, Material, LayerThickness, IsVentilated, Name, Description, Category, Priority);
  }
  ToTape() {
    let args = [];
    args.push(this.Material);
    ;
    args.push(this.LayerThickness);
    ;
    args.push(this.IsVentilated);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Category);
    ;
    args.push(this.Priority);
    ;
    return args;
  }
}, "IfcMaterialLayer");
var IfcMaterialLayerSet = /* @__PURE__ */ __name(class {
  constructor(expressID, type, MaterialLayers, LayerSetName, Description) {
    this.expressID = expressID;
    this.type = type;
    this.MaterialLayers = MaterialLayers;
    this.LayerSetName = LayerSetName;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let MaterialLayers = tape[ptr++];
    let LayerSetName = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcMaterialLayerSet(expressID, type, MaterialLayers, LayerSetName, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.MaterialLayers);
    ;
    args.push(this.LayerSetName);
    ;
    args.push(this.Description);
    ;
    return args;
  }
}, "IfcMaterialLayerSet");
var IfcMaterialLayerSetUsage = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ForLayerSet, LayerSetDirection, DirectionSense, OffsetFromReferenceLine, ReferenceExtent) {
    this.expressID = expressID;
    this.type = type;
    this.ForLayerSet = ForLayerSet;
    this.LayerSetDirection = LayerSetDirection;
    this.DirectionSense = DirectionSense;
    this.OffsetFromReferenceLine = OffsetFromReferenceLine;
    this.ReferenceExtent = ReferenceExtent;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ForLayerSet = tape[ptr++];
    let LayerSetDirection = tape[ptr++];
    let DirectionSense = tape[ptr++];
    let OffsetFromReferenceLine = tape[ptr++];
    let ReferenceExtent = tape[ptr++];
    return new IfcMaterialLayerSetUsage(expressID, type, ForLayerSet, LayerSetDirection, DirectionSense, OffsetFromReferenceLine, ReferenceExtent);
  }
  ToTape() {
    let args = [];
    args.push(this.ForLayerSet);
    ;
    args.push(this.LayerSetDirection);
    ;
    args.push(this.DirectionSense);
    ;
    args.push(this.OffsetFromReferenceLine);
    ;
    args.push(this.ReferenceExtent);
    ;
    return args;
  }
}, "IfcMaterialLayerSetUsage");
var IfcMaterialLayerWithOffsets = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Material, LayerThickness, IsVentilated, Name, Description, Category, Priority, OffsetDirection, OffsetValues) {
    this.expressID = expressID;
    this.type = type;
    this.Material = Material;
    this.LayerThickness = LayerThickness;
    this.IsVentilated = IsVentilated;
    this.Name = Name;
    this.Description = Description;
    this.Category = Category;
    this.Priority = Priority;
    this.OffsetDirection = OffsetDirection;
    this.OffsetValues = OffsetValues;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Material = tape[ptr++];
    let LayerThickness = tape[ptr++];
    let IsVentilated = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Category = tape[ptr++];
    let Priority = tape[ptr++];
    let OffsetDirection = tape[ptr++];
    let OffsetValues = tape[ptr++];
    return new IfcMaterialLayerWithOffsets(expressID, type, Material, LayerThickness, IsVentilated, Name, Description, Category, Priority, OffsetDirection, OffsetValues);
  }
  ToTape() {
    let args = [];
    args.push(this.Material);
    ;
    args.push(this.LayerThickness);
    ;
    args.push(this.IsVentilated);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Category);
    ;
    args.push(this.Priority);
    ;
    args.push(this.OffsetDirection);
    ;
    args.push(this.OffsetValues);
    ;
    return args;
  }
}, "IfcMaterialLayerWithOffsets");
var IfcMaterialList = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Materials) {
    this.expressID = expressID;
    this.type = type;
    this.Materials = Materials;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Materials = tape[ptr++];
    return new IfcMaterialList(expressID, type, Materials);
  }
  ToTape() {
    let args = [];
    args.push(this.Materials);
    ;
    return args;
  }
}, "IfcMaterialList");
var IfcMaterialProfile = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, Material, Profile, Priority, Category) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Material = Material;
    this.Profile = Profile;
    this.Priority = Priority;
    this.Category = Category;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Material = tape[ptr++];
    let Profile = tape[ptr++];
    let Priority = tape[ptr++];
    let Category = tape[ptr++];
    return new IfcMaterialProfile(expressID, type, Name, Description, Material, Profile, Priority, Category);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Material);
    ;
    args.push(this.Profile);
    ;
    args.push(this.Priority);
    ;
    args.push(this.Category);
    ;
    return args;
  }
}, "IfcMaterialProfile");
var IfcMaterialProfileSet = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, MaterialProfiles, CompositeProfile) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.MaterialProfiles = MaterialProfiles;
    this.CompositeProfile = CompositeProfile;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let MaterialProfiles = tape[ptr++];
    let CompositeProfile = tape[ptr++];
    return new IfcMaterialProfileSet(expressID, type, Name, Description, MaterialProfiles, CompositeProfile);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.MaterialProfiles);
    ;
    args.push(this.CompositeProfile);
    ;
    return args;
  }
}, "IfcMaterialProfileSet");
var IfcMaterialProfileSetUsage = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ForProfileSet, CardinalPoint, ReferenceExtent) {
    this.expressID = expressID;
    this.type = type;
    this.ForProfileSet = ForProfileSet;
    this.CardinalPoint = CardinalPoint;
    this.ReferenceExtent = ReferenceExtent;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ForProfileSet = tape[ptr++];
    let CardinalPoint = tape[ptr++];
    let ReferenceExtent = tape[ptr++];
    return new IfcMaterialProfileSetUsage(expressID, type, ForProfileSet, CardinalPoint, ReferenceExtent);
  }
  ToTape() {
    let args = [];
    args.push(this.ForProfileSet);
    ;
    args.push(this.CardinalPoint);
    ;
    args.push(this.ReferenceExtent);
    ;
    return args;
  }
}, "IfcMaterialProfileSetUsage");
var IfcMaterialProfileSetUsageTapering = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ForProfileSet, CardinalPoint, ReferenceExtent, ForProfileEndSet, CardinalEndPoint) {
    this.expressID = expressID;
    this.type = type;
    this.ForProfileSet = ForProfileSet;
    this.CardinalPoint = CardinalPoint;
    this.ReferenceExtent = ReferenceExtent;
    this.ForProfileEndSet = ForProfileEndSet;
    this.CardinalEndPoint = CardinalEndPoint;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ForProfileSet = tape[ptr++];
    let CardinalPoint = tape[ptr++];
    let ReferenceExtent = tape[ptr++];
    let ForProfileEndSet = tape[ptr++];
    let CardinalEndPoint = tape[ptr++];
    return new IfcMaterialProfileSetUsageTapering(expressID, type, ForProfileSet, CardinalPoint, ReferenceExtent, ForProfileEndSet, CardinalEndPoint);
  }
  ToTape() {
    let args = [];
    args.push(this.ForProfileSet);
    ;
    args.push(this.CardinalPoint);
    ;
    args.push(this.ReferenceExtent);
    ;
    args.push(this.ForProfileEndSet);
    ;
    args.push(this.CardinalEndPoint);
    ;
    return args;
  }
}, "IfcMaterialProfileSetUsageTapering");
var IfcMaterialProfileWithOffsets = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, Material, Profile, Priority, Category, OffsetValues) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Material = Material;
    this.Profile = Profile;
    this.Priority = Priority;
    this.Category = Category;
    this.OffsetValues = OffsetValues;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Material = tape[ptr++];
    let Profile = tape[ptr++];
    let Priority = tape[ptr++];
    let Category = tape[ptr++];
    let OffsetValues = tape[ptr++];
    return new IfcMaterialProfileWithOffsets(expressID, type, Name, Description, Material, Profile, Priority, Category, OffsetValues);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Material);
    ;
    args.push(this.Profile);
    ;
    args.push(this.Priority);
    ;
    args.push(this.Category);
    ;
    args.push(this.OffsetValues);
    ;
    return args;
  }
}, "IfcMaterialProfileWithOffsets");
var IfcMaterialProperties = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, Properties2, Material) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Properties = Properties2;
    this.Material = Material;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Properties2 = tape[ptr++];
    let Material = tape[ptr++];
    return new IfcMaterialProperties(expressID, type, Name, Description, Properties2, Material);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Properties);
    ;
    args.push(this.Material);
    ;
    return args;
  }
}, "IfcMaterialProperties");
var IfcMaterialRelationship = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, RelatingMaterial, RelatedMaterials, Expression) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.RelatingMaterial = RelatingMaterial;
    this.RelatedMaterials = RelatedMaterials;
    this.Expression = Expression;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingMaterial = tape[ptr++];
    let RelatedMaterials = tape[ptr++];
    let Expression = tape[ptr++];
    return new IfcMaterialRelationship(expressID, type, Name, Description, RelatingMaterial, RelatedMaterials, Expression);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingMaterial);
    ;
    args.push(this.RelatedMaterials);
    ;
    args.push(this.Expression);
    ;
    return args;
  }
}, "IfcMaterialRelationship");
var IfcMaterialUsageDefinition = /* @__PURE__ */ __name(class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcMaterialUsageDefinition(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
}, "IfcMaterialUsageDefinition");
var IfcMeasureWithUnit = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ValueComponent, UnitComponent) {
    this.expressID = expressID;
    this.type = type;
    this.ValueComponent = ValueComponent;
    this.UnitComponent = UnitComponent;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ValueComponent = tape[ptr++];
    let UnitComponent = tape[ptr++];
    return new IfcMeasureWithUnit(expressID, type, ValueComponent, UnitComponent);
  }
  ToTape() {
    let args = [];
    args.push(this.ValueComponent);
    ;
    args.push(this.UnitComponent);
    ;
    return args;
  }
}, "IfcMeasureWithUnit");
var IfcMechanicalFastener = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, NominalDiameter, NominalLength, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.NominalDiameter = NominalDiameter;
    this.NominalLength = NominalLength;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let NominalDiameter = tape[ptr++];
    let NominalLength = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcMechanicalFastener(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, NominalDiameter, NominalLength, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.NominalDiameter);
    ;
    args.push(this.NominalLength);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcMechanicalFastener");
var IfcMechanicalFastenerType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, NominalLength) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
    this.NominalDiameter = NominalDiameter;
    this.NominalLength = NominalLength;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let NominalDiameter = tape[ptr++];
    let NominalLength = tape[ptr++];
    return new IfcMechanicalFastenerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, NominalLength);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.NominalDiameter);
    ;
    args.push(this.NominalLength);
    ;
    return args;
  }
}, "IfcMechanicalFastenerType");
var IfcMedicalDevice = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcMedicalDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcMedicalDevice");
var IfcMedicalDeviceType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcMedicalDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcMedicalDeviceType");
var IfcMember = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcMember(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcMember");
var IfcMemberStandardCase = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcMemberStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcMemberStandardCase");
var IfcMemberType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcMemberType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcMemberType");
var IfcMetric = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade, Benchmark, ValueSource, DataValue, ReferencePath) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.ConstraintGrade = ConstraintGrade;
    this.ConstraintSource = ConstraintSource;
    this.CreatingActor = CreatingActor;
    this.CreationTime = CreationTime;
    this.UserDefinedGrade = UserDefinedGrade;
    this.Benchmark = Benchmark;
    this.ValueSource = ValueSource;
    this.DataValue = DataValue;
    this.ReferencePath = ReferencePath;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ConstraintGrade = tape[ptr++];
    let ConstraintSource = tape[ptr++];
    let CreatingActor = tape[ptr++];
    let CreationTime = tape[ptr++];
    let UserDefinedGrade = tape[ptr++];
    let Benchmark = tape[ptr++];
    let ValueSource = tape[ptr++];
    let DataValue = tape[ptr++];
    let ReferencePath = tape[ptr++];
    return new IfcMetric(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade, Benchmark, ValueSource, DataValue, ReferencePath);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ConstraintGrade);
    ;
    args.push(this.ConstraintSource);
    ;
    args.push(this.CreatingActor);
    ;
    args.push(this.CreationTime);
    ;
    args.push(this.UserDefinedGrade);
    ;
    args.push(this.Benchmark);
    ;
    args.push(this.ValueSource);
    ;
    args.push(this.DataValue);
    ;
    args.push(this.ReferencePath);
    ;
    return args;
  }
}, "IfcMetric");
var IfcMirroredProfileDef = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ProfileType, ProfileName, ParentProfile, Operator, Label) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.ParentProfile = ParentProfile;
    this.Operator = Operator;
    this.Label = Label;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let ParentProfile = tape[ptr++];
    let Operator = tape[ptr++];
    let Label = tape[ptr++];
    return new IfcMirroredProfileDef(expressID, type, ProfileType, ProfileName, ParentProfile, Operator, Label);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.ParentProfile);
    ;
    args.push(this.Operator);
    ;
    args.push(this.Label);
    ;
    return args;
  }
}, "IfcMirroredProfileDef");
var IfcMonetaryUnit = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Currency) {
    this.expressID = expressID;
    this.type = type;
    this.Currency = Currency;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Currency = tape[ptr++];
    return new IfcMonetaryUnit(expressID, type, Currency);
  }
  ToTape() {
    let args = [];
    args.push(this.Currency);
    ;
    return args;
  }
}, "IfcMonetaryUnit");
var IfcMotorConnection = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcMotorConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcMotorConnection");
var IfcMotorConnectionType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcMotorConnectionType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcMotorConnectionType");
var IfcNamedUnit = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Dimensions, UnitType) {
    this.expressID = expressID;
    this.type = type;
    this.Dimensions = Dimensions;
    this.UnitType = UnitType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Dimensions = tape[ptr++];
    let UnitType = tape[ptr++];
    return new IfcNamedUnit(expressID, type, Dimensions, UnitType);
  }
  ToTape() {
    let args = [];
    args.push(this.Dimensions);
    ;
    args.push(this.UnitType);
    ;
    return args;
  }
}, "IfcNamedUnit");
var IfcObject = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    return new IfcObject(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    return args;
  }
}, "IfcObject");
var IfcObjectDefinition = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcObjectDefinition(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    return args;
  }
}, "IfcObjectDefinition");
var IfcObjectPlacement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, PlacementRelTo) {
    this.expressID = expressID;
    this.type = type;
    this.PlacementRelTo = PlacementRelTo;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let PlacementRelTo = tape[ptr++];
    return new IfcObjectPlacement(expressID, type, PlacementRelTo);
  }
  ToTape() {
    let args = [];
    args.push(this.PlacementRelTo);
    ;
    return args;
  }
}, "IfcObjectPlacement");
var IfcObjective = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade, BenchmarkValues, LogicalAggregator, ObjectiveQualifier, UserDefinedQualifier) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.ConstraintGrade = ConstraintGrade;
    this.ConstraintSource = ConstraintSource;
    this.CreatingActor = CreatingActor;
    this.CreationTime = CreationTime;
    this.UserDefinedGrade = UserDefinedGrade;
    this.BenchmarkValues = BenchmarkValues;
    this.LogicalAggregator = LogicalAggregator;
    this.ObjectiveQualifier = ObjectiveQualifier;
    this.UserDefinedQualifier = UserDefinedQualifier;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ConstraintGrade = tape[ptr++];
    let ConstraintSource = tape[ptr++];
    let CreatingActor = tape[ptr++];
    let CreationTime = tape[ptr++];
    let UserDefinedGrade = tape[ptr++];
    let BenchmarkValues = tape[ptr++];
    let LogicalAggregator = tape[ptr++];
    let ObjectiveQualifier = tape[ptr++];
    let UserDefinedQualifier = tape[ptr++];
    return new IfcObjective(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade, BenchmarkValues, LogicalAggregator, ObjectiveQualifier, UserDefinedQualifier);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ConstraintGrade);
    ;
    args.push(this.ConstraintSource);
    ;
    args.push(this.CreatingActor);
    ;
    args.push(this.CreationTime);
    ;
    args.push(this.UserDefinedGrade);
    ;
    args.push(this.BenchmarkValues);
    ;
    args.push(this.LogicalAggregator);
    ;
    args.push(this.ObjectiveQualifier);
    ;
    args.push(this.UserDefinedQualifier);
    ;
    return args;
  }
}, "IfcObjective");
var IfcOccupant = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheActor, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.TheActor = TheActor;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let TheActor = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcOccupant(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheActor, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.TheActor);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcOccupant");
var IfcOffsetCurve = /* @__PURE__ */ __name(class {
  constructor(expressID, type, BasisCurve) {
    this.expressID = expressID;
    this.type = type;
    this.BasisCurve = BasisCurve;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisCurve = tape[ptr++];
    return new IfcOffsetCurve(expressID, type, BasisCurve);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisCurve);
    ;
    return args;
  }
}, "IfcOffsetCurve");
var IfcOffsetCurve2D = /* @__PURE__ */ __name(class {
  constructor(expressID, type, BasisCurve, Distance, SelfIntersect) {
    this.expressID = expressID;
    this.type = type;
    this.BasisCurve = BasisCurve;
    this.Distance = Distance;
    this.SelfIntersect = SelfIntersect;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisCurve = tape[ptr++];
    let Distance = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    return new IfcOffsetCurve2D(expressID, type, BasisCurve, Distance, SelfIntersect);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisCurve);
    ;
    args.push(this.Distance);
    ;
    args.push(this.SelfIntersect);
    ;
    return args;
  }
}, "IfcOffsetCurve2D");
var IfcOffsetCurve3D = /* @__PURE__ */ __name(class {
  constructor(expressID, type, BasisCurve, Distance, SelfIntersect, RefDirection) {
    this.expressID = expressID;
    this.type = type;
    this.BasisCurve = BasisCurve;
    this.Distance = Distance;
    this.SelfIntersect = SelfIntersect;
    this.RefDirection = RefDirection;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisCurve = tape[ptr++];
    let Distance = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    let RefDirection = tape[ptr++];
    return new IfcOffsetCurve3D(expressID, type, BasisCurve, Distance, SelfIntersect, RefDirection);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisCurve);
    ;
    args.push(this.Distance);
    ;
    args.push(this.SelfIntersect);
    ;
    args.push(this.RefDirection);
    ;
    return args;
  }
}, "IfcOffsetCurve3D");
var IfcOffsetCurveByDistances = /* @__PURE__ */ __name(class {
  constructor(expressID, type, BasisCurve, OffsetValues, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.BasisCurve = BasisCurve;
    this.OffsetValues = OffsetValues;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisCurve = tape[ptr++];
    let OffsetValues = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcOffsetCurveByDistances(expressID, type, BasisCurve, OffsetValues, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisCurve);
    ;
    args.push(this.OffsetValues);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
}, "IfcOffsetCurveByDistances");
var IfcOpenShell = /* @__PURE__ */ __name(class {
  constructor(expressID, type, CfsFaces) {
    this.expressID = expressID;
    this.type = type;
    this.CfsFaces = CfsFaces;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let CfsFaces = tape[ptr++];
    return new IfcOpenShell(expressID, type, CfsFaces);
  }
  ToTape() {
    let args = [];
    args.push(this.CfsFaces);
    ;
    return args;
  }
}, "IfcOpenShell");
var IfcOpeningElement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcOpeningElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcOpeningElement");
var IfcOpeningStandardCase = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcOpeningStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcOpeningStandardCase");
var IfcOrganization = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Identification, Name, Description, Roles, Addresses) {
    this.expressID = expressID;
    this.type = type;
    this.Identification = Identification;
    this.Name = Name;
    this.Description = Description;
    this.Roles = Roles;
    this.Addresses = Addresses;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Roles = tape[ptr++];
    let Addresses = tape[ptr++];
    return new IfcOrganization(expressID, type, Identification, Name, Description, Roles, Addresses);
  }
  ToTape() {
    let args = [];
    args.push(this.Identification);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Roles);
    ;
    args.push(this.Addresses);
    ;
    return args;
  }
}, "IfcOrganization");
var IfcOrganizationRelationship = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, RelatingOrganization, RelatedOrganizations) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.RelatingOrganization = RelatingOrganization;
    this.RelatedOrganizations = RelatedOrganizations;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingOrganization = tape[ptr++];
    let RelatedOrganizations = tape[ptr++];
    return new IfcOrganizationRelationship(expressID, type, Name, Description, RelatingOrganization, RelatedOrganizations);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingOrganization);
    ;
    args.push(this.RelatedOrganizations);
    ;
    return args;
  }
}, "IfcOrganizationRelationship");
var IfcOrientationExpression = /* @__PURE__ */ __name(class {
  constructor(expressID, type, LateralAxisDirection, VerticalAxisDirection) {
    this.expressID = expressID;
    this.type = type;
    this.LateralAxisDirection = LateralAxisDirection;
    this.VerticalAxisDirection = VerticalAxisDirection;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let LateralAxisDirection = tape[ptr++];
    let VerticalAxisDirection = tape[ptr++];
    return new IfcOrientationExpression(expressID, type, LateralAxisDirection, VerticalAxisDirection);
  }
  ToTape() {
    let args = [];
    args.push(this.LateralAxisDirection);
    ;
    args.push(this.VerticalAxisDirection);
    ;
    return args;
  }
}, "IfcOrientationExpression");
var IfcOrientedEdge = /* @__PURE__ */ __name(class {
  constructor(expressID, type, EdgeStart, EdgeEnd, EdgeElement, Orientation) {
    this.expressID = expressID;
    this.type = type;
    this.EdgeStart = EdgeStart;
    this.EdgeEnd = EdgeEnd;
    this.EdgeElement = EdgeElement;
    this.Orientation = Orientation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let EdgeStart = tape[ptr++];
    let EdgeEnd = tape[ptr++];
    let EdgeElement = tape[ptr++];
    let Orientation = tape[ptr++];
    return new IfcOrientedEdge(expressID, type, EdgeStart, EdgeEnd, EdgeElement, Orientation);
  }
  ToTape() {
    let args = [];
    args.push(this.EdgeStart);
    ;
    args.push(this.EdgeEnd);
    ;
    args.push(this.EdgeElement);
    ;
    args.push(this.Orientation);
    ;
    return args;
  }
}, "IfcOrientedEdge");
var IfcOuterBoundaryCurve = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Segments, SelfIntersect) {
    this.expressID = expressID;
    this.type = type;
    this.Segments = Segments;
    this.SelfIntersect = SelfIntersect;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Segments = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    return new IfcOuterBoundaryCurve(expressID, type, Segments, SelfIntersect);
  }
  ToTape() {
    let args = [];
    args.push(this.Segments);
    ;
    args.push(this.SelfIntersect);
    ;
    return args;
  }
}, "IfcOuterBoundaryCurve");
var IfcOutlet = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcOutlet(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcOutlet");
var IfcOutletType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcOutletType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcOutletType");
var IfcOwnerHistory = /* @__PURE__ */ __name(class {
  constructor(expressID, type, OwningUser, OwningApplication, State, ChangeAction, LastModifiedDate, LastModifyingUser, LastModifyingApplication, CreationDate) {
    this.expressID = expressID;
    this.type = type;
    this.OwningUser = OwningUser;
    this.OwningApplication = OwningApplication;
    this.State = State;
    this.ChangeAction = ChangeAction;
    this.LastModifiedDate = LastModifiedDate;
    this.LastModifyingUser = LastModifyingUser;
    this.LastModifyingApplication = LastModifyingApplication;
    this.CreationDate = CreationDate;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let OwningUser = tape[ptr++];
    let OwningApplication = tape[ptr++];
    let State = tape[ptr++];
    let ChangeAction = tape[ptr++];
    let LastModifiedDate = tape[ptr++];
    let LastModifyingUser = tape[ptr++];
    let LastModifyingApplication = tape[ptr++];
    let CreationDate = tape[ptr++];
    return new IfcOwnerHistory(expressID, type, OwningUser, OwningApplication, State, ChangeAction, LastModifiedDate, LastModifyingUser, LastModifyingApplication, CreationDate);
  }
  ToTape() {
    let args = [];
    args.push(this.OwningUser);
    ;
    args.push(this.OwningApplication);
    ;
    args.push(this.State);
    ;
    args.push(this.ChangeAction);
    ;
    args.push(this.LastModifiedDate);
    ;
    args.push(this.LastModifyingUser);
    ;
    args.push(this.LastModifyingApplication);
    ;
    args.push(this.CreationDate);
    ;
    return args;
  }
}, "IfcOwnerHistory");
var IfcParameterizedProfileDef = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ProfileType, ProfileName, Position) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    return new IfcParameterizedProfileDef(expressID, type, ProfileType, ProfileName, Position);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Position);
    ;
    return args;
  }
}, "IfcParameterizedProfileDef");
var IfcPath = /* @__PURE__ */ __name(class {
  constructor(expressID, type, EdgeList) {
    this.expressID = expressID;
    this.type = type;
    this.EdgeList = EdgeList;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let EdgeList = tape[ptr++];
    return new IfcPath(expressID, type, EdgeList);
  }
  ToTape() {
    let args = [];
    args.push(this.EdgeList);
    ;
    return args;
  }
}, "IfcPath");
var IfcPcurve = /* @__PURE__ */ __name(class {
  constructor(expressID, type, BasisSurface, ReferenceCurve) {
    this.expressID = expressID;
    this.type = type;
    this.BasisSurface = BasisSurface;
    this.ReferenceCurve = ReferenceCurve;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisSurface = tape[ptr++];
    let ReferenceCurve = tape[ptr++];
    return new IfcPcurve(expressID, type, BasisSurface, ReferenceCurve);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisSurface);
    ;
    args.push(this.ReferenceCurve);
    ;
    return args;
  }
}, "IfcPcurve");
var IfcPerformanceHistory = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LifeCyclePhase, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LifeCyclePhase = LifeCyclePhase;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LifeCyclePhase = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPerformanceHistory(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LifeCyclePhase, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LifeCyclePhase);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcPerformanceHistory");
var IfcPermeableCoveringProperties = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, OperationType, PanelPosition, FrameDepth, FrameThickness, ShapeAspectStyle) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.OperationType = OperationType;
    this.PanelPosition = PanelPosition;
    this.FrameDepth = FrameDepth;
    this.FrameThickness = FrameThickness;
    this.ShapeAspectStyle = ShapeAspectStyle;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let OperationType = tape[ptr++];
    let PanelPosition = tape[ptr++];
    let FrameDepth = tape[ptr++];
    let FrameThickness = tape[ptr++];
    let ShapeAspectStyle = tape[ptr++];
    return new IfcPermeableCoveringProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, OperationType, PanelPosition, FrameDepth, FrameThickness, ShapeAspectStyle);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.OperationType);
    ;
    args.push(this.PanelPosition);
    ;
    args.push(this.FrameDepth);
    ;
    args.push(this.FrameThickness);
    ;
    args.push(this.ShapeAspectStyle);
    ;
    return args;
  }
}, "IfcPermeableCoveringProperties");
var IfcPermit = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.PredefinedType = PredefinedType;
    this.Status = Status;
    this.LongDescription = LongDescription;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Status = tape[ptr++];
    let LongDescription = tape[ptr++];
    return new IfcPermit(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.Status);
    ;
    args.push(this.LongDescription);
    ;
    return args;
  }
}, "IfcPermit");
var IfcPerson = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Identification, FamilyName, GivenName, MiddleNames, PrefixTitles, SuffixTitles, Roles, Addresses) {
    this.expressID = expressID;
    this.type = type;
    this.Identification = Identification;
    this.FamilyName = FamilyName;
    this.GivenName = GivenName;
    this.MiddleNames = MiddleNames;
    this.PrefixTitles = PrefixTitles;
    this.SuffixTitles = SuffixTitles;
    this.Roles = Roles;
    this.Addresses = Addresses;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Identification = tape[ptr++];
    let FamilyName = tape[ptr++];
    let GivenName = tape[ptr++];
    let MiddleNames = tape[ptr++];
    let PrefixTitles = tape[ptr++];
    let SuffixTitles = tape[ptr++];
    let Roles = tape[ptr++];
    let Addresses = tape[ptr++];
    return new IfcPerson(expressID, type, Identification, FamilyName, GivenName, MiddleNames, PrefixTitles, SuffixTitles, Roles, Addresses);
  }
  ToTape() {
    let args = [];
    args.push(this.Identification);
    ;
    args.push(this.FamilyName);
    ;
    args.push(this.GivenName);
    ;
    args.push(this.MiddleNames);
    ;
    args.push(this.PrefixTitles);
    ;
    args.push(this.SuffixTitles);
    ;
    args.push(this.Roles);
    ;
    args.push(this.Addresses);
    ;
    return args;
  }
}, "IfcPerson");
var IfcPersonAndOrganization = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ThePerson, TheOrganization, Roles) {
    this.expressID = expressID;
    this.type = type;
    this.ThePerson = ThePerson;
    this.TheOrganization = TheOrganization;
    this.Roles = Roles;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ThePerson = tape[ptr++];
    let TheOrganization = tape[ptr++];
    let Roles = tape[ptr++];
    return new IfcPersonAndOrganization(expressID, type, ThePerson, TheOrganization, Roles);
  }
  ToTape() {
    let args = [];
    args.push(this.ThePerson);
    ;
    args.push(this.TheOrganization);
    ;
    args.push(this.Roles);
    ;
    return args;
  }
}, "IfcPersonAndOrganization");
var IfcPhysicalComplexQuantity = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, HasQuantities, Discrimination, Quality, Usage) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.HasQuantities = HasQuantities;
    this.Discrimination = Discrimination;
    this.Quality = Quality;
    this.Usage = Usage;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let HasQuantities = tape[ptr++];
    let Discrimination = tape[ptr++];
    let Quality = tape[ptr++];
    let Usage = tape[ptr++];
    return new IfcPhysicalComplexQuantity(expressID, type, Name, Description, HasQuantities, Discrimination, Quality, Usage);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.HasQuantities);
    ;
    args.push(this.Discrimination);
    ;
    args.push(this.Quality);
    ;
    args.push(this.Usage);
    ;
    return args;
  }
}, "IfcPhysicalComplexQuantity");
var IfcPhysicalQuantity = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcPhysicalQuantity(expressID, type, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    return args;
  }
}, "IfcPhysicalQuantity");
var IfcPhysicalSimpleQuantity = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, Unit) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Unit = Unit;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Unit = tape[ptr++];
    return new IfcPhysicalSimpleQuantity(expressID, type, Name, Description, Unit);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Unit);
    ;
    return args;
  }
}, "IfcPhysicalSimpleQuantity");
var IfcPile = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType, ConstructionType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
    this.ConstructionType = ConstructionType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let ConstructionType = tape[ptr++];
    return new IfcPile(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType, ConstructionType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.ConstructionType);
    ;
    return args;
  }
}, "IfcPile");
var IfcPileType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPileType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcPileType");
var IfcPipeFitting = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPipeFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcPipeFitting");
var IfcPipeFittingType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPipeFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcPipeFittingType");
var IfcPipeSegment = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPipeSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcPipeSegment");
var IfcPipeSegmentType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPipeSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcPipeSegmentType");
var IfcPixelTexture = /* @__PURE__ */ __name(class {
  constructor(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, Width, Height, ColourComponents, Pixel) {
    this.expressID = expressID;
    this.type = type;
    this.RepeatS = RepeatS;
    this.RepeatT = RepeatT;
    this.Mode = Mode;
    this.TextureTransform = TextureTransform;
    this.Parameter = Parameter;
    this.Width = Width;
    this.Height = Height;
    this.ColourComponents = ColourComponents;
    this.Pixel = Pixel;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let RepeatS = tape[ptr++];
    let RepeatT = tape[ptr++];
    let Mode = tape[ptr++];
    let TextureTransform = tape[ptr++];
    let Parameter = tape[ptr++];
    let Width = tape[ptr++];
    let Height = tape[ptr++];
    let ColourComponents = tape[ptr++];
    let Pixel = tape[ptr++];
    return new IfcPixelTexture(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, Width, Height, ColourComponents, Pixel);
  }
  ToTape() {
    let args = [];
    args.push(this.RepeatS);
    ;
    args.push(this.RepeatT);
    ;
    args.push(this.Mode);
    ;
    args.push(this.TextureTransform);
    ;
    args.push(this.Parameter);
    ;
    args.push(this.Width);
    ;
    args.push(this.Height);
    ;
    args.push(this.ColourComponents);
    ;
    args.push(this.Pixel);
    ;
    return args;
  }
}, "IfcPixelTexture");
var IfcPlacement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Location) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    return new IfcPlacement(expressID, type, Location);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    ;
    return args;
  }
}, "IfcPlacement");
var IfcPlanarBox = /* @__PURE__ */ __name(class {
  constructor(expressID, type, SizeInX, SizeInY, Placement) {
    this.expressID = expressID;
    this.type = type;
    this.SizeInX = SizeInX;
    this.SizeInY = SizeInY;
    this.Placement = Placement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SizeInX = tape[ptr++];
    let SizeInY = tape[ptr++];
    let Placement = tape[ptr++];
    return new IfcPlanarBox(expressID, type, SizeInX, SizeInY, Placement);
  }
  ToTape() {
    let args = [];
    args.push(this.SizeInX);
    ;
    args.push(this.SizeInY);
    ;
    args.push(this.Placement);
    ;
    return args;
  }
}, "IfcPlanarBox");
var IfcPlanarExtent = /* @__PURE__ */ __name(class {
  constructor(expressID, type, SizeInX, SizeInY) {
    this.expressID = expressID;
    this.type = type;
    this.SizeInX = SizeInX;
    this.SizeInY = SizeInY;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SizeInX = tape[ptr++];
    let SizeInY = tape[ptr++];
    return new IfcPlanarExtent(expressID, type, SizeInX, SizeInY);
  }
  ToTape() {
    let args = [];
    args.push(this.SizeInX);
    ;
    args.push(this.SizeInY);
    ;
    return args;
  }
}, "IfcPlanarExtent");
var IfcPlane = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Position) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    return new IfcPlane(expressID, type, Position);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    ;
    return args;
  }
}, "IfcPlane");
var IfcPlate = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPlate(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcPlate");
var IfcPlateStandardCase = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPlateStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcPlateStandardCase");
var IfcPlateType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPlateType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcPlateType");
var IfcPoint = /* @__PURE__ */ __name(class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcPoint(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
}, "IfcPoint");
var IfcPointOnCurve = /* @__PURE__ */ __name(class {
  constructor(expressID, type, BasisCurve, PointParameter) {
    this.expressID = expressID;
    this.type = type;
    this.BasisCurve = BasisCurve;
    this.PointParameter = PointParameter;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisCurve = tape[ptr++];
    let PointParameter = tape[ptr++];
    return new IfcPointOnCurve(expressID, type, BasisCurve, PointParameter);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisCurve);
    ;
    args.push(this.PointParameter);
    ;
    return args;
  }
}, "IfcPointOnCurve");
var IfcPointOnSurface = /* @__PURE__ */ __name(class {
  constructor(expressID, type, BasisSurface, PointParameterU, PointParameterV) {
    this.expressID = expressID;
    this.type = type;
    this.BasisSurface = BasisSurface;
    this.PointParameterU = PointParameterU;
    this.PointParameterV = PointParameterV;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisSurface = tape[ptr++];
    let PointParameterU = tape[ptr++];
    let PointParameterV = tape[ptr++];
    return new IfcPointOnSurface(expressID, type, BasisSurface, PointParameterU, PointParameterV);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisSurface);
    ;
    args.push(this.PointParameterU);
    ;
    args.push(this.PointParameterV);
    ;
    return args;
  }
}, "IfcPointOnSurface");
var IfcPolyLoop = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Polygon) {
    this.expressID = expressID;
    this.type = type;
    this.Polygon = Polygon;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Polygon = tape[ptr++];
    return new IfcPolyLoop(expressID, type, Polygon);
  }
  ToTape() {
    let args = [];
    args.push(this.Polygon);
    ;
    return args;
  }
}, "IfcPolyLoop");
var IfcPolygonalBoundedHalfSpace = /* @__PURE__ */ __name(class {
  constructor(expressID, type, BaseSurface, AgreementFlag, Position, PolygonalBoundary) {
    this.expressID = expressID;
    this.type = type;
    this.BaseSurface = BaseSurface;
    this.AgreementFlag = AgreementFlag;
    this.Position = Position;
    this.PolygonalBoundary = PolygonalBoundary;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BaseSurface = tape[ptr++];
    let AgreementFlag = tape[ptr++];
    let Position = tape[ptr++];
    let PolygonalBoundary = tape[ptr++];
    return new IfcPolygonalBoundedHalfSpace(expressID, type, BaseSurface, AgreementFlag, Position, PolygonalBoundary);
  }
  ToTape() {
    let args = [];
    args.push(this.BaseSurface);
    ;
    args.push(this.AgreementFlag);
    ;
    args.push(this.Position);
    ;
    args.push(this.PolygonalBoundary);
    ;
    return args;
  }
}, "IfcPolygonalBoundedHalfSpace");
var IfcPolygonalFaceSet = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Coordinates, Closed, Faces, PnIndex) {
    this.expressID = expressID;
    this.type = type;
    this.Coordinates = Coordinates;
    this.Closed = Closed;
    this.Faces = Faces;
    this.PnIndex = PnIndex;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Coordinates = tape[ptr++];
    let Closed = tape[ptr++];
    let Faces = tape[ptr++];
    let PnIndex = tape[ptr++];
    return new IfcPolygonalFaceSet(expressID, type, Coordinates, Closed, Faces, PnIndex);
  }
  ToTape() {
    let args = [];
    args.push(this.Coordinates);
    ;
    args.push(this.Closed);
    ;
    args.push(this.Faces);
    ;
    args.push(this.PnIndex);
    ;
    return args;
  }
}, "IfcPolygonalFaceSet");
var IfcPolyline = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Points) {
    this.expressID = expressID;
    this.type = type;
    this.Points = Points;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Points = tape[ptr++];
    return new IfcPolyline(expressID, type, Points);
  }
  ToTape() {
    let args = [];
    args.push(this.Points);
    ;
    return args;
  }
}, "IfcPolyline");
var IfcPort = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    return new IfcPort(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    return args;
  }
}, "IfcPort");
var IfcPositioningElement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    return new IfcPositioningElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    return args;
  }
}, "IfcPositioningElement");
var IfcPostalAddress = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Purpose, Description, UserDefinedPurpose, InternalLocation, AddressLines, PostalBox, Town, Region, PostalCode, Country) {
    this.expressID = expressID;
    this.type = type;
    this.Purpose = Purpose;
    this.Description = Description;
    this.UserDefinedPurpose = UserDefinedPurpose;
    this.InternalLocation = InternalLocation;
    this.AddressLines = AddressLines;
    this.PostalBox = PostalBox;
    this.Town = Town;
    this.Region = Region;
    this.PostalCode = PostalCode;
    this.Country = Country;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Purpose = tape[ptr++];
    let Description = tape[ptr++];
    let UserDefinedPurpose = tape[ptr++];
    let InternalLocation = tape[ptr++];
    let AddressLines = tape[ptr++];
    let PostalBox = tape[ptr++];
    let Town = tape[ptr++];
    let Region = tape[ptr++];
    let PostalCode = tape[ptr++];
    let Country = tape[ptr++];
    return new IfcPostalAddress(expressID, type, Purpose, Description, UserDefinedPurpose, InternalLocation, AddressLines, PostalBox, Town, Region, PostalCode, Country);
  }
  ToTape() {
    let args = [];
    args.push(this.Purpose);
    ;
    args.push(this.Description);
    ;
    args.push(this.UserDefinedPurpose);
    ;
    args.push(this.InternalLocation);
    ;
    args.push(this.AddressLines);
    ;
    args.push(this.PostalBox);
    ;
    args.push(this.Town);
    ;
    args.push(this.Region);
    ;
    args.push(this.PostalCode);
    ;
    args.push(this.Country);
    ;
    return args;
  }
}, "IfcPostalAddress");
var IfcPreDefinedColour = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcPreDefinedColour(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    return args;
  }
}, "IfcPreDefinedColour");
var IfcPreDefinedCurveFont = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcPreDefinedCurveFont(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    return args;
  }
}, "IfcPreDefinedCurveFont");
var IfcPreDefinedItem = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcPreDefinedItem(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    return args;
  }
}, "IfcPreDefinedItem");
var IfcPreDefinedProperties = /* @__PURE__ */ __name(class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcPreDefinedProperties(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
}, "IfcPreDefinedProperties");
var IfcPreDefinedPropertySet = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcPreDefinedPropertySet(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    return args;
  }
}, "IfcPreDefinedPropertySet");
var IfcPreDefinedTextFont = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcPreDefinedTextFont(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    return args;
  }
}, "IfcPreDefinedTextFont");
var IfcPresentationItem = /* @__PURE__ */ __name(class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcPresentationItem(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
}, "IfcPresentationItem");
var IfcPresentationLayerAssignment = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, AssignedItems, Identifier) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.AssignedItems = AssignedItems;
    this.Identifier = Identifier;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let AssignedItems = tape[ptr++];
    let Identifier = tape[ptr++];
    return new IfcPresentationLayerAssignment(expressID, type, Name, Description, AssignedItems, Identifier);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.AssignedItems);
    ;
    args.push(this.Identifier);
    ;
    return args;
  }
}, "IfcPresentationLayerAssignment");
var IfcPresentationLayerWithStyle = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, AssignedItems, Identifier, LayerOn, LayerFrozen, LayerBlocked, LayerStyles) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.AssignedItems = AssignedItems;
    this.Identifier = Identifier;
    this.LayerOn = LayerOn;
    this.LayerFrozen = LayerFrozen;
    this.LayerBlocked = LayerBlocked;
    this.LayerStyles = LayerStyles;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let AssignedItems = tape[ptr++];
    let Identifier = tape[ptr++];
    let LayerOn = tape[ptr++];
    let LayerFrozen = tape[ptr++];
    let LayerBlocked = tape[ptr++];
    let LayerStyles = tape[ptr++];
    return new IfcPresentationLayerWithStyle(expressID, type, Name, Description, AssignedItems, Identifier, LayerOn, LayerFrozen, LayerBlocked, LayerStyles);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.AssignedItems);
    ;
    args.push(this.Identifier);
    ;
    args.push(this.LayerOn);
    ;
    args.push(this.LayerFrozen);
    ;
    args.push(this.LayerBlocked);
    ;
    args.push(this.LayerStyles);
    ;
    return args;
  }
}, "IfcPresentationLayerWithStyle");
var IfcPresentationStyle = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcPresentationStyle(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    return args;
  }
}, "IfcPresentationStyle");
var IfcPresentationStyleAssignment = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Styles) {
    this.expressID = expressID;
    this.type = type;
    this.Styles = Styles;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Styles = tape[ptr++];
    return new IfcPresentationStyleAssignment(expressID, type, Styles);
  }
  ToTape() {
    let args = [];
    args.push(this.Styles);
    ;
    return args;
  }
}, "IfcPresentationStyleAssignment");
var IfcProcedure = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcProcedure(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcProcedure");
var IfcProcedureType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ProcessType = ProcessType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ProcessType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcProcedureType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.ProcessType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcProcedureType");
var IfcProcess = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    return new IfcProcess(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    return args;
  }
}, "IfcProcess");
var IfcProduct = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    return new IfcProduct(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    return args;
  }
}, "IfcProduct");
var IfcProductDefinitionShape = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, Representations) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Representations = Representations;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Representations = tape[ptr++];
    return new IfcProductDefinitionShape(expressID, type, Name, Description, Representations);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Representations);
    ;
    return args;
  }
}, "IfcProductDefinitionShape");
var IfcProductRepresentation = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, Representations) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Representations = Representations;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Representations = tape[ptr++];
    return new IfcProductRepresentation(expressID, type, Name, Description, Representations);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Representations);
    ;
    return args;
  }
}, "IfcProductRepresentation");
var IfcProfileDef = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ProfileType, ProfileName) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    return new IfcProfileDef(expressID, type, ProfileType, ProfileName);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    return args;
  }
}, "IfcProfileDef");
var IfcProfileProperties = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, Properties2, ProfileDefinition) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Properties = Properties2;
    this.ProfileDefinition = ProfileDefinition;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Properties2 = tape[ptr++];
    let ProfileDefinition = tape[ptr++];
    return new IfcProfileProperties(expressID, type, Name, Description, Properties2, ProfileDefinition);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Properties);
    ;
    args.push(this.ProfileDefinition);
    ;
    return args;
  }
}, "IfcProfileProperties");
var IfcProject = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.LongName = LongName;
    this.Phase = Phase;
    this.RepresentationContexts = RepresentationContexts;
    this.UnitsInContext = UnitsInContext;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let LongName = tape[ptr++];
    let Phase = tape[ptr++];
    let RepresentationContexts = tape[ptr++];
    let UnitsInContext = tape[ptr++];
    return new IfcProject(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.LongName);
    ;
    args.push(this.Phase);
    ;
    args.push(this.RepresentationContexts);
    ;
    args.push(this.UnitsInContext);
    ;
    return args;
  }
}, "IfcProject");
var IfcProjectLibrary = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.LongName = LongName;
    this.Phase = Phase;
    this.RepresentationContexts = RepresentationContexts;
    this.UnitsInContext = UnitsInContext;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let LongName = tape[ptr++];
    let Phase = tape[ptr++];
    let RepresentationContexts = tape[ptr++];
    let UnitsInContext = tape[ptr++];
    return new IfcProjectLibrary(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.LongName);
    ;
    args.push(this.Phase);
    ;
    args.push(this.RepresentationContexts);
    ;
    args.push(this.UnitsInContext);
    ;
    return args;
  }
}, "IfcProjectLibrary");
var IfcProjectOrder = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.PredefinedType = PredefinedType;
    this.Status = Status;
    this.LongDescription = LongDescription;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Status = tape[ptr++];
    let LongDescription = tape[ptr++];
    return new IfcProjectOrder(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.Status);
    ;
    args.push(this.LongDescription);
    ;
    return args;
  }
}, "IfcProjectOrder");
var IfcProjectedCRS = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, GeodeticDatum, VerticalDatum, MapProjection, MapZone, MapUnit) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.GeodeticDatum = GeodeticDatum;
    this.VerticalDatum = VerticalDatum;
    this.MapProjection = MapProjection;
    this.MapZone = MapZone;
    this.MapUnit = MapUnit;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let GeodeticDatum = tape[ptr++];
    let VerticalDatum = tape[ptr++];
    let MapProjection = tape[ptr++];
    let MapZone = tape[ptr++];
    let MapUnit = tape[ptr++];
    return new IfcProjectedCRS(expressID, type, Name, Description, GeodeticDatum, VerticalDatum, MapProjection, MapZone, MapUnit);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.GeodeticDatum);
    ;
    args.push(this.VerticalDatum);
    ;
    args.push(this.MapProjection);
    ;
    args.push(this.MapZone);
    ;
    args.push(this.MapUnit);
    ;
    return args;
  }
}, "IfcProjectedCRS");
var IfcProjectionElement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcProjectionElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcProjectionElement");
var IfcProperty = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcProperty(expressID, type, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    return args;
  }
}, "IfcProperty");
var IfcPropertyAbstraction = /* @__PURE__ */ __name(class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcPropertyAbstraction(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
}, "IfcPropertyAbstraction");
var IfcPropertyBoundedValue = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, UpperBoundValue, LowerBoundValue, Unit, SetPointValue) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.UpperBoundValue = UpperBoundValue;
    this.LowerBoundValue = LowerBoundValue;
    this.Unit = Unit;
    this.SetPointValue = SetPointValue;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let UpperBoundValue = tape[ptr++];
    let LowerBoundValue = tape[ptr++];
    let Unit = tape[ptr++];
    let SetPointValue = tape[ptr++];
    return new IfcPropertyBoundedValue(expressID, type, Name, Description, UpperBoundValue, LowerBoundValue, Unit, SetPointValue);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.UpperBoundValue);
    ;
    args.push(this.LowerBoundValue);
    ;
    args.push(this.Unit);
    ;
    args.push(this.SetPointValue);
    ;
    return args;
  }
}, "IfcPropertyBoundedValue");
var IfcPropertyDefinition = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcPropertyDefinition(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    return args;
  }
}, "IfcPropertyDefinition");
var IfcPropertyDependencyRelationship = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, DependingProperty, DependantProperty, Expression) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.DependingProperty = DependingProperty;
    this.DependantProperty = DependantProperty;
    this.Expression = Expression;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let DependingProperty = tape[ptr++];
    let DependantProperty = tape[ptr++];
    let Expression = tape[ptr++];
    return new IfcPropertyDependencyRelationship(expressID, type, Name, Description, DependingProperty, DependantProperty, Expression);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.DependingProperty);
    ;
    args.push(this.DependantProperty);
    ;
    args.push(this.Expression);
    ;
    return args;
  }
}, "IfcPropertyDependencyRelationship");
var IfcPropertyEnumeratedValue = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, EnumerationValues, EnumerationReference) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.EnumerationValues = EnumerationValues;
    this.EnumerationReference = EnumerationReference;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let EnumerationValues = tape[ptr++];
    let EnumerationReference = tape[ptr++];
    return new IfcPropertyEnumeratedValue(expressID, type, Name, Description, EnumerationValues, EnumerationReference);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.EnumerationValues);
    ;
    args.push(this.EnumerationReference);
    ;
    return args;
  }
}, "IfcPropertyEnumeratedValue");
var IfcPropertyEnumeration = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, EnumerationValues, Unit) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.EnumerationValues = EnumerationValues;
    this.Unit = Unit;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let EnumerationValues = tape[ptr++];
    let Unit = tape[ptr++];
    return new IfcPropertyEnumeration(expressID, type, Name, EnumerationValues, Unit);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.EnumerationValues);
    ;
    args.push(this.Unit);
    ;
    return args;
  }
}, "IfcPropertyEnumeration");
var IfcPropertyListValue = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, ListValues, Unit) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.ListValues = ListValues;
    this.Unit = Unit;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ListValues = tape[ptr++];
    let Unit = tape[ptr++];
    return new IfcPropertyListValue(expressID, type, Name, Description, ListValues, Unit);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ListValues);
    ;
    args.push(this.Unit);
    ;
    return args;
  }
}, "IfcPropertyListValue");
var IfcPropertyReferenceValue = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, UsageName, PropertyReference) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.UsageName = UsageName;
    this.PropertyReference = PropertyReference;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let UsageName = tape[ptr++];
    let PropertyReference = tape[ptr++];
    return new IfcPropertyReferenceValue(expressID, type, Name, Description, UsageName, PropertyReference);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.UsageName);
    ;
    args.push(this.PropertyReference);
    ;
    return args;
  }
}, "IfcPropertyReferenceValue");
var IfcPropertySet = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, HasProperties) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.HasProperties = HasProperties;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let HasProperties = tape[ptr++];
    return new IfcPropertySet(expressID, type, GlobalId, OwnerHistory, Name, Description, HasProperties);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.HasProperties);
    ;
    return args;
  }
}, "IfcPropertySet");
var IfcPropertySetDefinition = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcPropertySetDefinition(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    return args;
  }
}, "IfcPropertySetDefinition");
var IfcPropertySetTemplate = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, TemplateType, ApplicableEntity, HasPropertyTemplates) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.TemplateType = TemplateType;
    this.ApplicableEntity = ApplicableEntity;
    this.HasPropertyTemplates = HasPropertyTemplates;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let TemplateType = tape[ptr++];
    let ApplicableEntity = tape[ptr++];
    let HasPropertyTemplates = tape[ptr++];
    return new IfcPropertySetTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description, TemplateType, ApplicableEntity, HasPropertyTemplates);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.TemplateType);
    ;
    args.push(this.ApplicableEntity);
    ;
    args.push(this.HasPropertyTemplates);
    ;
    return args;
  }
}, "IfcPropertySetTemplate");
var IfcPropertySingleValue = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, NominalValue, Unit) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.NominalValue = NominalValue;
    this.Unit = Unit;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let NominalValue = tape[ptr++];
    let Unit = tape[ptr++];
    return new IfcPropertySingleValue(expressID, type, Name, Description, NominalValue, Unit);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.NominalValue);
    ;
    args.push(this.Unit);
    ;
    return args;
  }
}, "IfcPropertySingleValue");
var IfcPropertyTableValue = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, DefiningValues, DefinedValues, Expression, DefiningUnit, DefinedUnit, CurveInterpolation) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.DefiningValues = DefiningValues;
    this.DefinedValues = DefinedValues;
    this.Expression = Expression;
    this.DefiningUnit = DefiningUnit;
    this.DefinedUnit = DefinedUnit;
    this.CurveInterpolation = CurveInterpolation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let DefiningValues = tape[ptr++];
    let DefinedValues = tape[ptr++];
    let Expression = tape[ptr++];
    let DefiningUnit = tape[ptr++];
    let DefinedUnit = tape[ptr++];
    let CurveInterpolation = tape[ptr++];
    return new IfcPropertyTableValue(expressID, type, Name, Description, DefiningValues, DefinedValues, Expression, DefiningUnit, DefinedUnit, CurveInterpolation);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.DefiningValues);
    ;
    args.push(this.DefinedValues);
    ;
    args.push(this.Expression);
    ;
    args.push(this.DefiningUnit);
    ;
    args.push(this.DefinedUnit);
    ;
    args.push(this.CurveInterpolation);
    ;
    return args;
  }
}, "IfcPropertyTableValue");
var IfcPropertyTemplate = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcPropertyTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    return args;
  }
}, "IfcPropertyTemplate");
var IfcPropertyTemplateDefinition = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcPropertyTemplateDefinition(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    return args;
  }
}, "IfcPropertyTemplateDefinition");
var IfcProtectiveDevice = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcProtectiveDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcProtectiveDevice");
var IfcProtectiveDeviceTrippingUnit = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcProtectiveDeviceTrippingUnit(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcProtectiveDeviceTrippingUnit");
var IfcProtectiveDeviceTrippingUnitType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcProtectiveDeviceTrippingUnitType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcProtectiveDeviceTrippingUnitType");
var IfcProtectiveDeviceType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcProtectiveDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcProtectiveDeviceType");
var IfcProxy = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, ProxyType, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.ProxyType = ProxyType;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let ProxyType = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcProxy(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, ProxyType, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.ProxyType);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
}, "IfcProxy");
var IfcPump = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPump(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcPump");
var IfcPumpType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPumpType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcPumpType");
var IfcQuantityArea = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, Unit, AreaValue, Formula) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Unit = Unit;
    this.AreaValue = AreaValue;
    this.Formula = Formula;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Unit = tape[ptr++];
    let AreaValue = tape[ptr++];
    let Formula = tape[ptr++];
    return new IfcQuantityArea(expressID, type, Name, Description, Unit, AreaValue, Formula);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Unit);
    ;
    args.push(this.AreaValue);
    ;
    args.push(this.Formula);
    ;
    return args;
  }
}, "IfcQuantityArea");
var IfcQuantityCount = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, Unit, CountValue, Formula) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Unit = Unit;
    this.CountValue = CountValue;
    this.Formula = Formula;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Unit = tape[ptr++];
    let CountValue = tape[ptr++];
    let Formula = tape[ptr++];
    return new IfcQuantityCount(expressID, type, Name, Description, Unit, CountValue, Formula);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Unit);
    ;
    args.push(this.CountValue);
    ;
    args.push(this.Formula);
    ;
    return args;
  }
}, "IfcQuantityCount");
var IfcQuantityLength = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, Unit, LengthValue, Formula) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Unit = Unit;
    this.LengthValue = LengthValue;
    this.Formula = Formula;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Unit = tape[ptr++];
    let LengthValue = tape[ptr++];
    let Formula = tape[ptr++];
    return new IfcQuantityLength(expressID, type, Name, Description, Unit, LengthValue, Formula);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Unit);
    ;
    args.push(this.LengthValue);
    ;
    args.push(this.Formula);
    ;
    return args;
  }
}, "IfcQuantityLength");
var IfcQuantitySet = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcQuantitySet(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    return args;
  }
}, "IfcQuantitySet");
var IfcQuantityTime = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, Unit, TimeValue, Formula) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Unit = Unit;
    this.TimeValue = TimeValue;
    this.Formula = Formula;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Unit = tape[ptr++];
    let TimeValue = tape[ptr++];
    let Formula = tape[ptr++];
    return new IfcQuantityTime(expressID, type, Name, Description, Unit, TimeValue, Formula);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Unit);
    ;
    args.push(this.TimeValue);
    ;
    args.push(this.Formula);
    ;
    return args;
  }
}, "IfcQuantityTime");
var IfcQuantityVolume = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, Unit, VolumeValue, Formula) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Unit = Unit;
    this.VolumeValue = VolumeValue;
    this.Formula = Formula;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Unit = tape[ptr++];
    let VolumeValue = tape[ptr++];
    let Formula = tape[ptr++];
    return new IfcQuantityVolume(expressID, type, Name, Description, Unit, VolumeValue, Formula);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Unit);
    ;
    args.push(this.VolumeValue);
    ;
    args.push(this.Formula);
    ;
    return args;
  }
}, "IfcQuantityVolume");
var IfcQuantityWeight = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, Unit, WeightValue, Formula) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Unit = Unit;
    this.WeightValue = WeightValue;
    this.Formula = Formula;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Unit = tape[ptr++];
    let WeightValue = tape[ptr++];
    let Formula = tape[ptr++];
    return new IfcQuantityWeight(expressID, type, Name, Description, Unit, WeightValue, Formula);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Unit);
    ;
    args.push(this.WeightValue);
    ;
    args.push(this.Formula);
    ;
    return args;
  }
}, "IfcQuantityWeight");
var IfcRailing = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcRailing(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcRailing");
var IfcRailingType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcRailingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcRailingType");
var IfcRamp = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcRamp(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcRamp");
var IfcRampFlight = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcRampFlight(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcRampFlight");
var IfcRampFlightType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcRampFlightType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcRampFlightType");
var IfcRampType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcRampType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcRampType");
var IfcRationalBSplineCurveWithKnots = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect, KnotMultiplicities, Knots, KnotSpec, WeightsData) {
    this.expressID = expressID;
    this.type = type;
    this.Degree = Degree;
    this.ControlPointsList = ControlPointsList;
    this.CurveForm = CurveForm;
    this.ClosedCurve = ClosedCurve;
    this.SelfIntersect = SelfIntersect;
    this.KnotMultiplicities = KnotMultiplicities;
    this.Knots = Knots;
    this.KnotSpec = KnotSpec;
    this.WeightsData = WeightsData;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Degree = tape[ptr++];
    let ControlPointsList = tape[ptr++];
    let CurveForm = tape[ptr++];
    let ClosedCurve = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    let KnotMultiplicities = tape[ptr++];
    let Knots = tape[ptr++];
    let KnotSpec = tape[ptr++];
    let WeightsData = tape[ptr++];
    return new IfcRationalBSplineCurveWithKnots(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect, KnotMultiplicities, Knots, KnotSpec, WeightsData);
  }
  ToTape() {
    let args = [];
    args.push(this.Degree);
    ;
    args.push(this.ControlPointsList);
    ;
    args.push(this.CurveForm);
    ;
    args.push(this.ClosedCurve);
    ;
    args.push(this.SelfIntersect);
    ;
    args.push(this.KnotMultiplicities);
    ;
    args.push(this.Knots);
    ;
    args.push(this.KnotSpec);
    ;
    args.push(this.WeightsData);
    ;
    return args;
  }
}, "IfcRationalBSplineCurveWithKnots");
var IfcRationalBSplineSurfaceWithKnots = /* @__PURE__ */ __name(class {
  constructor(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect, UMultiplicities, VMultiplicities, UKnots, VKnots, KnotSpec, WeightsData) {
    this.expressID = expressID;
    this.type = type;
    this.UDegree = UDegree;
    this.VDegree = VDegree;
    this.ControlPointsList = ControlPointsList;
    this.SurfaceForm = SurfaceForm;
    this.UClosed = UClosed;
    this.VClosed = VClosed;
    this.SelfIntersect = SelfIntersect;
    this.UMultiplicities = UMultiplicities;
    this.VMultiplicities = VMultiplicities;
    this.UKnots = UKnots;
    this.VKnots = VKnots;
    this.KnotSpec = KnotSpec;
    this.WeightsData = WeightsData;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let UDegree = tape[ptr++];
    let VDegree = tape[ptr++];
    let ControlPointsList = tape[ptr++];
    let SurfaceForm = tape[ptr++];
    let UClosed = tape[ptr++];
    let VClosed = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    let UMultiplicities = tape[ptr++];
    let VMultiplicities = tape[ptr++];
    let UKnots = tape[ptr++];
    let VKnots = tape[ptr++];
    let KnotSpec = tape[ptr++];
    let WeightsData = tape[ptr++];
    return new IfcRationalBSplineSurfaceWithKnots(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect, UMultiplicities, VMultiplicities, UKnots, VKnots, KnotSpec, WeightsData);
  }
  ToTape() {
    let args = [];
    args.push(this.UDegree);
    ;
    args.push(this.VDegree);
    ;
    args.push(this.ControlPointsList);
    ;
    args.push(this.SurfaceForm);
    ;
    args.push(this.UClosed);
    ;
    args.push(this.VClosed);
    ;
    args.push(this.SelfIntersect);
    ;
    args.push(this.UMultiplicities);
    ;
    args.push(this.VMultiplicities);
    ;
    args.push(this.UKnots);
    ;
    args.push(this.VKnots);
    ;
    args.push(this.KnotSpec);
    ;
    args.push(this.WeightsData);
    ;
    return args;
  }
}, "IfcRationalBSplineSurfaceWithKnots");
var IfcRectangleHollowProfileDef = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ProfileType, ProfileName, Position, XDim, YDim, WallThickness, InnerFilletRadius, OuterFilletRadius) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.XDim = XDim;
    this.YDim = YDim;
    this.WallThickness = WallThickness;
    this.InnerFilletRadius = InnerFilletRadius;
    this.OuterFilletRadius = OuterFilletRadius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let XDim = tape[ptr++];
    let YDim = tape[ptr++];
    let WallThickness = tape[ptr++];
    let InnerFilletRadius = tape[ptr++];
    let OuterFilletRadius = tape[ptr++];
    return new IfcRectangleHollowProfileDef(expressID, type, ProfileType, ProfileName, Position, XDim, YDim, WallThickness, InnerFilletRadius, OuterFilletRadius);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Position);
    ;
    args.push(this.XDim);
    ;
    args.push(this.YDim);
    ;
    args.push(this.WallThickness);
    ;
    args.push(this.InnerFilletRadius);
    ;
    args.push(this.OuterFilletRadius);
    ;
    return args;
  }
}, "IfcRectangleHollowProfileDef");
var IfcRectangleProfileDef = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ProfileType, ProfileName, Position, XDim, YDim) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.XDim = XDim;
    this.YDim = YDim;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let XDim = tape[ptr++];
    let YDim = tape[ptr++];
    return new IfcRectangleProfileDef(expressID, type, ProfileType, ProfileName, Position, XDim, YDim);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Position);
    ;
    args.push(this.XDim);
    ;
    args.push(this.YDim);
    ;
    return args;
  }
}, "IfcRectangleProfileDef");
var IfcRectangularPyramid = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Position, XLength, YLength, Height) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.XLength = XLength;
    this.YLength = YLength;
    this.Height = Height;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let XLength = tape[ptr++];
    let YLength = tape[ptr++];
    let Height = tape[ptr++];
    return new IfcRectangularPyramid(expressID, type, Position, XLength, YLength, Height);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    ;
    args.push(this.XLength);
    ;
    args.push(this.YLength);
    ;
    args.push(this.Height);
    ;
    return args;
  }
}, "IfcRectangularPyramid");
var IfcRectangularTrimmedSurface = /* @__PURE__ */ __name(class {
  constructor(expressID, type, BasisSurface, U1, V1, U2, V2, Usense, Vsense) {
    this.expressID = expressID;
    this.type = type;
    this.BasisSurface = BasisSurface;
    this.U1 = U1;
    this.V1 = V1;
    this.U2 = U2;
    this.V2 = V2;
    this.Usense = Usense;
    this.Vsense = Vsense;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisSurface = tape[ptr++];
    let U1 = tape[ptr++];
    let V1 = tape[ptr++];
    let U2 = tape[ptr++];
    let V2 = tape[ptr++];
    let Usense = tape[ptr++];
    let Vsense = tape[ptr++];
    return new IfcRectangularTrimmedSurface(expressID, type, BasisSurface, U1, V1, U2, V2, Usense, Vsense);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisSurface);
    ;
    args.push(this.U1);
    ;
    args.push(this.V1);
    ;
    args.push(this.U2);
    ;
    args.push(this.V2);
    ;
    args.push(this.Usense);
    ;
    args.push(this.Vsense);
    ;
    return args;
  }
}, "IfcRectangularTrimmedSurface");
var IfcRecurrencePattern = /* @__PURE__ */ __name(class {
  constructor(expressID, type, RecurrenceType, DayComponent, WeekdayComponent, MonthComponent, Position, Interval, Occurrences, TimePeriods) {
    this.expressID = expressID;
    this.type = type;
    this.RecurrenceType = RecurrenceType;
    this.DayComponent = DayComponent;
    this.WeekdayComponent = WeekdayComponent;
    this.MonthComponent = MonthComponent;
    this.Position = Position;
    this.Interval = Interval;
    this.Occurrences = Occurrences;
    this.TimePeriods = TimePeriods;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let RecurrenceType = tape[ptr++];
    let DayComponent = tape[ptr++];
    let WeekdayComponent = tape[ptr++];
    let MonthComponent = tape[ptr++];
    let Position = tape[ptr++];
    let Interval = tape[ptr++];
    let Occurrences = tape[ptr++];
    let TimePeriods = tape[ptr++];
    return new IfcRecurrencePattern(expressID, type, RecurrenceType, DayComponent, WeekdayComponent, MonthComponent, Position, Interval, Occurrences, TimePeriods);
  }
  ToTape() {
    let args = [];
    args.push(this.RecurrenceType);
    ;
    args.push(this.DayComponent);
    ;
    args.push(this.WeekdayComponent);
    ;
    args.push(this.MonthComponent);
    ;
    args.push(this.Position);
    ;
    args.push(this.Interval);
    ;
    args.push(this.Occurrences);
    ;
    args.push(this.TimePeriods);
    ;
    return args;
  }
}, "IfcRecurrencePattern");
var IfcReference = /* @__PURE__ */ __name(class {
  constructor(expressID, type, TypeIdentifier, AttributeIdentifier, InstanceName, ListPositions, InnerReference) {
    this.expressID = expressID;
    this.type = type;
    this.TypeIdentifier = TypeIdentifier;
    this.AttributeIdentifier = AttributeIdentifier;
    this.InstanceName = InstanceName;
    this.ListPositions = ListPositions;
    this.InnerReference = InnerReference;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TypeIdentifier = tape[ptr++];
    let AttributeIdentifier = tape[ptr++];
    let InstanceName = tape[ptr++];
    let ListPositions = tape[ptr++];
    let InnerReference = tape[ptr++];
    return new IfcReference(expressID, type, TypeIdentifier, AttributeIdentifier, InstanceName, ListPositions, InnerReference);
  }
  ToTape() {
    let args = [];
    args.push(this.TypeIdentifier);
    ;
    args.push(this.AttributeIdentifier);
    ;
    args.push(this.InstanceName);
    ;
    args.push(this.ListPositions);
    ;
    args.push(this.InnerReference);
    ;
    return args;
  }
}, "IfcReference");
var IfcReferent = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, RestartDistance) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.PredefinedType = PredefinedType;
    this.RestartDistance = RestartDistance;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let RestartDistance = tape[ptr++];
    return new IfcReferent(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, RestartDistance);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.RestartDistance);
    ;
    return args;
  }
}, "IfcReferent");
var IfcRegularTimeSeries = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit, TimeStep, Values) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.StartTime = StartTime;
    this.EndTime = EndTime;
    this.TimeSeriesDataType = TimeSeriesDataType;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.Unit = Unit;
    this.TimeStep = TimeStep;
    this.Values = Values;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let StartTime = tape[ptr++];
    let EndTime = tape[ptr++];
    let TimeSeriesDataType = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let Unit = tape[ptr++];
    let TimeStep = tape[ptr++];
    let Values = tape[ptr++];
    return new IfcRegularTimeSeries(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit, TimeStep, Values);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.StartTime);
    ;
    args.push(this.EndTime);
    ;
    args.push(this.TimeSeriesDataType);
    ;
    args.push(this.DataOrigin);
    ;
    args.push(this.UserDefinedDataOrigin);
    ;
    args.push(this.Unit);
    ;
    args.push(this.TimeStep);
    ;
    args.push(this.Values);
    ;
    return args;
  }
}, "IfcRegularTimeSeries");
var IfcReinforcementBarProperties = /* @__PURE__ */ __name(class {
  constructor(expressID, type, TotalCrossSectionArea, SteelGrade, BarSurface, EffectiveDepth, NominalBarDiameter, BarCount) {
    this.expressID = expressID;
    this.type = type;
    this.TotalCrossSectionArea = TotalCrossSectionArea;
    this.SteelGrade = SteelGrade;
    this.BarSurface = BarSurface;
    this.EffectiveDepth = EffectiveDepth;
    this.NominalBarDiameter = NominalBarDiameter;
    this.BarCount = BarCount;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TotalCrossSectionArea = tape[ptr++];
    let SteelGrade = tape[ptr++];
    let BarSurface = tape[ptr++];
    let EffectiveDepth = tape[ptr++];
    let NominalBarDiameter = tape[ptr++];
    let BarCount = tape[ptr++];
    return new IfcReinforcementBarProperties(expressID, type, TotalCrossSectionArea, SteelGrade, BarSurface, EffectiveDepth, NominalBarDiameter, BarCount);
  }
  ToTape() {
    let args = [];
    args.push(this.TotalCrossSectionArea);
    ;
    args.push(this.SteelGrade);
    ;
    args.push(this.BarSurface);
    ;
    args.push(this.EffectiveDepth);
    ;
    args.push(this.NominalBarDiameter);
    ;
    args.push(this.BarCount);
    ;
    return args;
  }
}, "IfcReinforcementBarProperties");
var IfcReinforcementDefinitionProperties = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, DefinitionType, ReinforcementSectionDefinitions) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.DefinitionType = DefinitionType;
    this.ReinforcementSectionDefinitions = ReinforcementSectionDefinitions;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let DefinitionType = tape[ptr++];
    let ReinforcementSectionDefinitions = tape[ptr++];
    return new IfcReinforcementDefinitionProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, DefinitionType, ReinforcementSectionDefinitions);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.DefinitionType);
    ;
    args.push(this.ReinforcementSectionDefinitions);
    ;
    return args;
  }
}, "IfcReinforcementDefinitionProperties");
var IfcReinforcingBar = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, NominalDiameter, CrossSectionArea, BarLength, PredefinedType, BarSurface) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.SteelGrade = SteelGrade;
    this.NominalDiameter = NominalDiameter;
    this.CrossSectionArea = CrossSectionArea;
    this.BarLength = BarLength;
    this.PredefinedType = PredefinedType;
    this.BarSurface = BarSurface;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let SteelGrade = tape[ptr++];
    let NominalDiameter = tape[ptr++];
    let CrossSectionArea = tape[ptr++];
    let BarLength = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let BarSurface = tape[ptr++];
    return new IfcReinforcingBar(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, NominalDiameter, CrossSectionArea, BarLength, PredefinedType, BarSurface);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.SteelGrade);
    ;
    args.push(this.NominalDiameter);
    ;
    args.push(this.CrossSectionArea);
    ;
    args.push(this.BarLength);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.BarSurface);
    ;
    return args;
  }
}, "IfcReinforcingBar");
var IfcReinforcingBarType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, CrossSectionArea, BarLength, BarSurface, BendingShapeCode, BendingParameters) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
    this.NominalDiameter = NominalDiameter;
    this.CrossSectionArea = CrossSectionArea;
    this.BarLength = BarLength;
    this.BarSurface = BarSurface;
    this.BendingShapeCode = BendingShapeCode;
    this.BendingParameters = BendingParameters;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let NominalDiameter = tape[ptr++];
    let CrossSectionArea = tape[ptr++];
    let BarLength = tape[ptr++];
    let BarSurface = tape[ptr++];
    let BendingShapeCode = tape[ptr++];
    let BendingParameters = tape[ptr++];
    return new IfcReinforcingBarType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, CrossSectionArea, BarLength, BarSurface, BendingShapeCode, BendingParameters);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.NominalDiameter);
    ;
    args.push(this.CrossSectionArea);
    ;
    args.push(this.BarLength);
    ;
    args.push(this.BarSurface);
    ;
    args.push(this.BendingShapeCode);
    ;
    args.push(this.BendingParameters);
    ;
    return args;
  }
}, "IfcReinforcingBarType");
var IfcReinforcingElement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.SteelGrade = SteelGrade;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let SteelGrade = tape[ptr++];
    return new IfcReinforcingElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.SteelGrade);
    ;
    return args;
  }
}, "IfcReinforcingElement");
var IfcReinforcingElementType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcReinforcingElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
}, "IfcReinforcingElementType");
var IfcReinforcingMesh = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, MeshLength, MeshWidth, LongitudinalBarNominalDiameter, TransverseBarNominalDiameter, LongitudinalBarCrossSectionArea, TransverseBarCrossSectionArea, LongitudinalBarSpacing, TransverseBarSpacing, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.SteelGrade = SteelGrade;
    this.MeshLength = MeshLength;
    this.MeshWidth = MeshWidth;
    this.LongitudinalBarNominalDiameter = LongitudinalBarNominalDiameter;
    this.TransverseBarNominalDiameter = TransverseBarNominalDiameter;
    this.LongitudinalBarCrossSectionArea = LongitudinalBarCrossSectionArea;
    this.TransverseBarCrossSectionArea = TransverseBarCrossSectionArea;
    this.LongitudinalBarSpacing = LongitudinalBarSpacing;
    this.TransverseBarSpacing = TransverseBarSpacing;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let SteelGrade = tape[ptr++];
    let MeshLength = tape[ptr++];
    let MeshWidth = tape[ptr++];
    let LongitudinalBarNominalDiameter = tape[ptr++];
    let TransverseBarNominalDiameter = tape[ptr++];
    let LongitudinalBarCrossSectionArea = tape[ptr++];
    let TransverseBarCrossSectionArea = tape[ptr++];
    let LongitudinalBarSpacing = tape[ptr++];
    let TransverseBarSpacing = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcReinforcingMesh(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, MeshLength, MeshWidth, LongitudinalBarNominalDiameter, TransverseBarNominalDiameter, LongitudinalBarCrossSectionArea, TransverseBarCrossSectionArea, LongitudinalBarSpacing, TransverseBarSpacing, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.SteelGrade);
    ;
    args.push(this.MeshLength);
    ;
    args.push(this.MeshWidth);
    ;
    args.push(this.LongitudinalBarNominalDiameter);
    ;
    args.push(this.TransverseBarNominalDiameter);
    ;
    args.push(this.LongitudinalBarCrossSectionArea);
    ;
    args.push(this.TransverseBarCrossSectionArea);
    ;
    args.push(this.LongitudinalBarSpacing);
    ;
    args.push(this.TransverseBarSpacing);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcReinforcingMesh");
var IfcReinforcingMeshType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, MeshLength, MeshWidth, LongitudinalBarNominalDiameter, TransverseBarNominalDiameter, LongitudinalBarCrossSectionArea, TransverseBarCrossSectionArea, LongitudinalBarSpacing, TransverseBarSpacing, BendingShapeCode, BendingParameters) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
    this.MeshLength = MeshLength;
    this.MeshWidth = MeshWidth;
    this.LongitudinalBarNominalDiameter = LongitudinalBarNominalDiameter;
    this.TransverseBarNominalDiameter = TransverseBarNominalDiameter;
    this.LongitudinalBarCrossSectionArea = LongitudinalBarCrossSectionArea;
    this.TransverseBarCrossSectionArea = TransverseBarCrossSectionArea;
    this.LongitudinalBarSpacing = LongitudinalBarSpacing;
    this.TransverseBarSpacing = TransverseBarSpacing;
    this.BendingShapeCode = BendingShapeCode;
    this.BendingParameters = BendingParameters;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let MeshLength = tape[ptr++];
    let MeshWidth = tape[ptr++];
    let LongitudinalBarNominalDiameter = tape[ptr++];
    let TransverseBarNominalDiameter = tape[ptr++];
    let LongitudinalBarCrossSectionArea = tape[ptr++];
    let TransverseBarCrossSectionArea = tape[ptr++];
    let LongitudinalBarSpacing = tape[ptr++];
    let TransverseBarSpacing = tape[ptr++];
    let BendingShapeCode = tape[ptr++];
    let BendingParameters = tape[ptr++];
    return new IfcReinforcingMeshType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, MeshLength, MeshWidth, LongitudinalBarNominalDiameter, TransverseBarNominalDiameter, LongitudinalBarCrossSectionArea, TransverseBarCrossSectionArea, LongitudinalBarSpacing, TransverseBarSpacing, BendingShapeCode, BendingParameters);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.MeshLength);
    ;
    args.push(this.MeshWidth);
    ;
    args.push(this.LongitudinalBarNominalDiameter);
    ;
    args.push(this.TransverseBarNominalDiameter);
    ;
    args.push(this.LongitudinalBarCrossSectionArea);
    ;
    args.push(this.TransverseBarCrossSectionArea);
    ;
    args.push(this.LongitudinalBarSpacing);
    ;
    args.push(this.TransverseBarSpacing);
    ;
    args.push(this.BendingShapeCode);
    ;
    args.push(this.BendingParameters);
    ;
    return args;
  }
}, "IfcReinforcingMeshType");
var IfcRelAggregates = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingObject, RelatedObjects) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingObject = RelatingObject;
    this.RelatedObjects = RelatedObjects;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingObject = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    return new IfcRelAggregates(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingObject, RelatedObjects);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingObject);
    ;
    args.push(this.RelatedObjects);
    ;
    return args;
  }
}, "IfcRelAggregates");
var IfcRelAssigns = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatedObjectsType = RelatedObjectsType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatedObjectsType = tape[ptr++];
    return new IfcRelAssigns(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    args.push(this.RelatedObjectsType);
    ;
    return args;
  }
}, "IfcRelAssigns");
var IfcRelAssignsToActor = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingActor, ActingRole) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatedObjectsType = RelatedObjectsType;
    this.RelatingActor = RelatingActor;
    this.ActingRole = ActingRole;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatedObjectsType = tape[ptr++];
    let RelatingActor = tape[ptr++];
    let ActingRole = tape[ptr++];
    return new IfcRelAssignsToActor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingActor, ActingRole);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    args.push(this.RelatedObjectsType);
    ;
    args.push(this.RelatingActor);
    ;
    args.push(this.ActingRole);
    ;
    return args;
  }
}, "IfcRelAssignsToActor");
var IfcRelAssignsToControl = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingControl) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatedObjectsType = RelatedObjectsType;
    this.RelatingControl = RelatingControl;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatedObjectsType = tape[ptr++];
    let RelatingControl = tape[ptr++];
    return new IfcRelAssignsToControl(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingControl);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    args.push(this.RelatedObjectsType);
    ;
    args.push(this.RelatingControl);
    ;
    return args;
  }
}, "IfcRelAssignsToControl");
var IfcRelAssignsToGroup = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingGroup) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatedObjectsType = RelatedObjectsType;
    this.RelatingGroup = RelatingGroup;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatedObjectsType = tape[ptr++];
    let RelatingGroup = tape[ptr++];
    return new IfcRelAssignsToGroup(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingGroup);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    args.push(this.RelatedObjectsType);
    ;
    args.push(this.RelatingGroup);
    ;
    return args;
  }
}, "IfcRelAssignsToGroup");
var IfcRelAssignsToGroupByFactor = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingGroup, Factor) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatedObjectsType = RelatedObjectsType;
    this.RelatingGroup = RelatingGroup;
    this.Factor = Factor;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatedObjectsType = tape[ptr++];
    let RelatingGroup = tape[ptr++];
    let Factor = tape[ptr++];
    return new IfcRelAssignsToGroupByFactor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingGroup, Factor);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    args.push(this.RelatedObjectsType);
    ;
    args.push(this.RelatingGroup);
    ;
    args.push(this.Factor);
    ;
    return args;
  }
}, "IfcRelAssignsToGroupByFactor");
var IfcRelAssignsToProcess = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingProcess, QuantityInProcess) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatedObjectsType = RelatedObjectsType;
    this.RelatingProcess = RelatingProcess;
    this.QuantityInProcess = QuantityInProcess;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatedObjectsType = tape[ptr++];
    let RelatingProcess = tape[ptr++];
    let QuantityInProcess = tape[ptr++];
    return new IfcRelAssignsToProcess(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingProcess, QuantityInProcess);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    args.push(this.RelatedObjectsType);
    ;
    args.push(this.RelatingProcess);
    ;
    args.push(this.QuantityInProcess);
    ;
    return args;
  }
}, "IfcRelAssignsToProcess");
var IfcRelAssignsToProduct = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingProduct) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatedObjectsType = RelatedObjectsType;
    this.RelatingProduct = RelatingProduct;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatedObjectsType = tape[ptr++];
    let RelatingProduct = tape[ptr++];
    return new IfcRelAssignsToProduct(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingProduct);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    args.push(this.RelatedObjectsType);
    ;
    args.push(this.RelatingProduct);
    ;
    return args;
  }
}, "IfcRelAssignsToProduct");
var IfcRelAssignsToResource = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingResource) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatedObjectsType = RelatedObjectsType;
    this.RelatingResource = RelatingResource;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatedObjectsType = tape[ptr++];
    let RelatingResource = tape[ptr++];
    return new IfcRelAssignsToResource(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingResource);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    args.push(this.RelatedObjectsType);
    ;
    args.push(this.RelatingResource);
    ;
    return args;
  }
}, "IfcRelAssignsToResource");
var IfcRelAssociates = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    return new IfcRelAssociates(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    return args;
  }
}, "IfcRelAssociates");
var IfcRelAssociatesApproval = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingApproval) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatingApproval = RelatingApproval;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatingApproval = tape[ptr++];
    return new IfcRelAssociatesApproval(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingApproval);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    args.push(this.RelatingApproval);
    ;
    return args;
  }
}, "IfcRelAssociatesApproval");
var IfcRelAssociatesClassification = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingClassification) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatingClassification = RelatingClassification;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatingClassification = tape[ptr++];
    return new IfcRelAssociatesClassification(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingClassification);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    args.push(this.RelatingClassification);
    ;
    return args;
  }
}, "IfcRelAssociatesClassification");
var IfcRelAssociatesConstraint = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, Intent, RelatingConstraint) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.Intent = Intent;
    this.RelatingConstraint = RelatingConstraint;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let Intent = tape[ptr++];
    let RelatingConstraint = tape[ptr++];
    return new IfcRelAssociatesConstraint(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, Intent, RelatingConstraint);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    args.push(this.Intent);
    ;
    args.push(this.RelatingConstraint);
    ;
    return args;
  }
}, "IfcRelAssociatesConstraint");
var IfcRelAssociatesDocument = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingDocument) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatingDocument = RelatingDocument;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatingDocument = tape[ptr++];
    return new IfcRelAssociatesDocument(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingDocument);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    args.push(this.RelatingDocument);
    ;
    return args;
  }
}, "IfcRelAssociatesDocument");
var IfcRelAssociatesLibrary = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingLibrary) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatingLibrary = RelatingLibrary;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatingLibrary = tape[ptr++];
    return new IfcRelAssociatesLibrary(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingLibrary);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    args.push(this.RelatingLibrary);
    ;
    return args;
  }
}, "IfcRelAssociatesLibrary");
var IfcRelAssociatesMaterial = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingMaterial) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatingMaterial = RelatingMaterial;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatingMaterial = tape[ptr++];
    return new IfcRelAssociatesMaterial(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingMaterial);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    args.push(this.RelatingMaterial);
    ;
    return args;
  }
}, "IfcRelAssociatesMaterial");
var IfcRelConnects = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcRelConnects(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    return args;
  }
}, "IfcRelConnects");
var IfcRelConnectsElements = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ConnectionGeometry = ConnectionGeometry;
    this.RelatingElement = RelatingElement;
    this.RelatedElement = RelatedElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ConnectionGeometry = tape[ptr++];
    let RelatingElement = tape[ptr++];
    let RelatedElement = tape[ptr++];
    return new IfcRelConnectsElements(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ConnectionGeometry);
    ;
    args.push(this.RelatingElement);
    ;
    args.push(this.RelatedElement);
    ;
    return args;
  }
}, "IfcRelConnectsElements");
var IfcRelConnectsPathElements = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement, RelatingPriorities, RelatedPriorities, RelatedConnectionType, RelatingConnectionType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ConnectionGeometry = ConnectionGeometry;
    this.RelatingElement = RelatingElement;
    this.RelatedElement = RelatedElement;
    this.RelatingPriorities = RelatingPriorities;
    this.RelatedPriorities = RelatedPriorities;
    this.RelatedConnectionType = RelatedConnectionType;
    this.RelatingConnectionType = RelatingConnectionType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ConnectionGeometry = tape[ptr++];
    let RelatingElement = tape[ptr++];
    let RelatedElement = tape[ptr++];
    let RelatingPriorities = tape[ptr++];
    let RelatedPriorities = tape[ptr++];
    let RelatedConnectionType = tape[ptr++];
    let RelatingConnectionType = tape[ptr++];
    return new IfcRelConnectsPathElements(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement, RelatingPriorities, RelatedPriorities, RelatedConnectionType, RelatingConnectionType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ConnectionGeometry);
    ;
    args.push(this.RelatingElement);
    ;
    args.push(this.RelatedElement);
    ;
    args.push(this.RelatingPriorities);
    ;
    args.push(this.RelatedPriorities);
    ;
    args.push(this.RelatedConnectionType);
    ;
    args.push(this.RelatingConnectionType);
    ;
    return args;
  }
}, "IfcRelConnectsPathElements");
var IfcRelConnectsPortToElement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPort, RelatedElement) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingPort = RelatingPort;
    this.RelatedElement = RelatedElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingPort = tape[ptr++];
    let RelatedElement = tape[ptr++];
    return new IfcRelConnectsPortToElement(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPort, RelatedElement);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingPort);
    ;
    args.push(this.RelatedElement);
    ;
    return args;
  }
}, "IfcRelConnectsPortToElement");
var IfcRelConnectsPorts = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPort, RelatedPort, RealizingElement) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingPort = RelatingPort;
    this.RelatedPort = RelatedPort;
    this.RealizingElement = RealizingElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingPort = tape[ptr++];
    let RelatedPort = tape[ptr++];
    let RealizingElement = tape[ptr++];
    return new IfcRelConnectsPorts(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPort, RelatedPort, RealizingElement);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingPort);
    ;
    args.push(this.RelatedPort);
    ;
    args.push(this.RealizingElement);
    ;
    return args;
  }
}, "IfcRelConnectsPorts");
var IfcRelConnectsStructuralActivity = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedStructuralActivity) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingElement = RelatingElement;
    this.RelatedStructuralActivity = RelatedStructuralActivity;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingElement = tape[ptr++];
    let RelatedStructuralActivity = tape[ptr++];
    return new IfcRelConnectsStructuralActivity(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedStructuralActivity);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingElement);
    ;
    args.push(this.RelatedStructuralActivity);
    ;
    return args;
  }
}, "IfcRelConnectsStructuralActivity");
var IfcRelConnectsStructuralMember = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingStructuralMember, RelatedStructuralConnection, AppliedCondition, AdditionalConditions, SupportedLength, ConditionCoordinateSystem) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingStructuralMember = RelatingStructuralMember;
    this.RelatedStructuralConnection = RelatedStructuralConnection;
    this.AppliedCondition = AppliedCondition;
    this.AdditionalConditions = AdditionalConditions;
    this.SupportedLength = SupportedLength;
    this.ConditionCoordinateSystem = ConditionCoordinateSystem;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingStructuralMember = tape[ptr++];
    let RelatedStructuralConnection = tape[ptr++];
    let AppliedCondition = tape[ptr++];
    let AdditionalConditions = tape[ptr++];
    let SupportedLength = tape[ptr++];
    let ConditionCoordinateSystem = tape[ptr++];
    return new IfcRelConnectsStructuralMember(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingStructuralMember, RelatedStructuralConnection, AppliedCondition, AdditionalConditions, SupportedLength, ConditionCoordinateSystem);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingStructuralMember);
    ;
    args.push(this.RelatedStructuralConnection);
    ;
    args.push(this.AppliedCondition);
    ;
    args.push(this.AdditionalConditions);
    ;
    args.push(this.SupportedLength);
    ;
    args.push(this.ConditionCoordinateSystem);
    ;
    return args;
  }
}, "IfcRelConnectsStructuralMember");
var IfcRelConnectsWithEccentricity = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingStructuralMember, RelatedStructuralConnection, AppliedCondition, AdditionalConditions, SupportedLength, ConditionCoordinateSystem, ConnectionConstraint) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingStructuralMember = RelatingStructuralMember;
    this.RelatedStructuralConnection = RelatedStructuralConnection;
    this.AppliedCondition = AppliedCondition;
    this.AdditionalConditions = AdditionalConditions;
    this.SupportedLength = SupportedLength;
    this.ConditionCoordinateSystem = ConditionCoordinateSystem;
    this.ConnectionConstraint = ConnectionConstraint;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingStructuralMember = tape[ptr++];
    let RelatedStructuralConnection = tape[ptr++];
    let AppliedCondition = tape[ptr++];
    let AdditionalConditions = tape[ptr++];
    let SupportedLength = tape[ptr++];
    let ConditionCoordinateSystem = tape[ptr++];
    let ConnectionConstraint = tape[ptr++];
    return new IfcRelConnectsWithEccentricity(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingStructuralMember, RelatedStructuralConnection, AppliedCondition, AdditionalConditions, SupportedLength, ConditionCoordinateSystem, ConnectionConstraint);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingStructuralMember);
    ;
    args.push(this.RelatedStructuralConnection);
    ;
    args.push(this.AppliedCondition);
    ;
    args.push(this.AdditionalConditions);
    ;
    args.push(this.SupportedLength);
    ;
    args.push(this.ConditionCoordinateSystem);
    ;
    args.push(this.ConnectionConstraint);
    ;
    return args;
  }
}, "IfcRelConnectsWithEccentricity");
var IfcRelConnectsWithRealizingElements = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement, RealizingElements, ConnectionType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ConnectionGeometry = ConnectionGeometry;
    this.RelatingElement = RelatingElement;
    this.RelatedElement = RelatedElement;
    this.RealizingElements = RealizingElements;
    this.ConnectionType = ConnectionType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ConnectionGeometry = tape[ptr++];
    let RelatingElement = tape[ptr++];
    let RelatedElement = tape[ptr++];
    let RealizingElements = tape[ptr++];
    let ConnectionType = tape[ptr++];
    return new IfcRelConnectsWithRealizingElements(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement, RealizingElements, ConnectionType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ConnectionGeometry);
    ;
    args.push(this.RelatingElement);
    ;
    args.push(this.RelatedElement);
    ;
    args.push(this.RealizingElements);
    ;
    args.push(this.ConnectionType);
    ;
    return args;
  }
}, "IfcRelConnectsWithRealizingElements");
var IfcRelContainedInSpatialStructure = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedElements, RelatingStructure) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedElements = RelatedElements;
    this.RelatingStructure = RelatingStructure;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedElements = tape[ptr++];
    let RelatingStructure = tape[ptr++];
    return new IfcRelContainedInSpatialStructure(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedElements, RelatingStructure);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedElements);
    ;
    args.push(this.RelatingStructure);
    ;
    return args;
  }
}, "IfcRelContainedInSpatialStructure");
var IfcRelCoversBldgElements = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingBuildingElement, RelatedCoverings) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingBuildingElement = RelatingBuildingElement;
    this.RelatedCoverings = RelatedCoverings;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingBuildingElement = tape[ptr++];
    let RelatedCoverings = tape[ptr++];
    return new IfcRelCoversBldgElements(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingBuildingElement, RelatedCoverings);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingBuildingElement);
    ;
    args.push(this.RelatedCoverings);
    ;
    return args;
  }
}, "IfcRelCoversBldgElements");
var IfcRelCoversSpaces = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedCoverings) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingSpace = RelatingSpace;
    this.RelatedCoverings = RelatedCoverings;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingSpace = tape[ptr++];
    let RelatedCoverings = tape[ptr++];
    return new IfcRelCoversSpaces(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedCoverings);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingSpace);
    ;
    args.push(this.RelatedCoverings);
    ;
    return args;
  }
}, "IfcRelCoversSpaces");
var IfcRelDeclares = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingContext, RelatedDefinitions) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingContext = RelatingContext;
    this.RelatedDefinitions = RelatedDefinitions;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingContext = tape[ptr++];
    let RelatedDefinitions = tape[ptr++];
    return new IfcRelDeclares(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingContext, RelatedDefinitions);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingContext);
    ;
    args.push(this.RelatedDefinitions);
    ;
    return args;
  }
}, "IfcRelDeclares");
var IfcRelDecomposes = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcRelDecomposes(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    return args;
  }
}, "IfcRelDecomposes");
var IfcRelDefines = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcRelDefines(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    return args;
  }
}, "IfcRelDefines");
var IfcRelDefinesByObject = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingObject) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatingObject = RelatingObject;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatingObject = tape[ptr++];
    return new IfcRelDefinesByObject(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingObject);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    args.push(this.RelatingObject);
    ;
    return args;
  }
}, "IfcRelDefinesByObject");
var IfcRelDefinesByProperties = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingPropertyDefinition) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatingPropertyDefinition = RelatingPropertyDefinition;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatingPropertyDefinition = tape[ptr++];
    return new IfcRelDefinesByProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingPropertyDefinition);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    args.push(this.RelatingPropertyDefinition);
    ;
    return args;
  }
}, "IfcRelDefinesByProperties");
var IfcRelDefinesByTemplate = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedPropertySets, RelatingTemplate) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedPropertySets = RelatedPropertySets;
    this.RelatingTemplate = RelatingTemplate;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedPropertySets = tape[ptr++];
    let RelatingTemplate = tape[ptr++];
    return new IfcRelDefinesByTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedPropertySets, RelatingTemplate);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedPropertySets);
    ;
    args.push(this.RelatingTemplate);
    ;
    return args;
  }
}, "IfcRelDefinesByTemplate");
var IfcRelDefinesByType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatingType = RelatingType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatingType = tape[ptr++];
    return new IfcRelDefinesByType(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedObjects);
    ;
    args.push(this.RelatingType);
    ;
    return args;
  }
}, "IfcRelDefinesByType");
var IfcRelFillsElement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingOpeningElement, RelatedBuildingElement) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingOpeningElement = RelatingOpeningElement;
    this.RelatedBuildingElement = RelatedBuildingElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingOpeningElement = tape[ptr++];
    let RelatedBuildingElement = tape[ptr++];
    return new IfcRelFillsElement(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingOpeningElement, RelatedBuildingElement);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingOpeningElement);
    ;
    args.push(this.RelatedBuildingElement);
    ;
    return args;
  }
}, "IfcRelFillsElement");
var IfcRelFlowControlElements = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedControlElements, RelatingFlowElement) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedControlElements = RelatedControlElements;
    this.RelatingFlowElement = RelatingFlowElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedControlElements = tape[ptr++];
    let RelatingFlowElement = tape[ptr++];
    return new IfcRelFlowControlElements(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedControlElements, RelatingFlowElement);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedControlElements);
    ;
    args.push(this.RelatingFlowElement);
    ;
    return args;
  }
}, "IfcRelFlowControlElements");
var IfcRelInterferesElements = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedElement, InterferenceGeometry, InterferenceType, ImpliedOrder) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingElement = RelatingElement;
    this.RelatedElement = RelatedElement;
    this.InterferenceGeometry = InterferenceGeometry;
    this.InterferenceType = InterferenceType;
    this.ImpliedOrder = ImpliedOrder;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingElement = tape[ptr++];
    let RelatedElement = tape[ptr++];
    let InterferenceGeometry = tape[ptr++];
    let InterferenceType = tape[ptr++];
    let ImpliedOrder = tape[ptr++];
    return new IfcRelInterferesElements(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedElement, InterferenceGeometry, InterferenceType, ImpliedOrder);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingElement);
    ;
    args.push(this.RelatedElement);
    ;
    args.push(this.InterferenceGeometry);
    ;
    args.push(this.InterferenceType);
    ;
    args.push(this.ImpliedOrder);
    ;
    return args;
  }
}, "IfcRelInterferesElements");
var IfcRelNests = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingObject, RelatedObjects) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingObject = RelatingObject;
    this.RelatedObjects = RelatedObjects;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingObject = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    return new IfcRelNests(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingObject, RelatedObjects);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingObject);
    ;
    args.push(this.RelatedObjects);
    ;
    return args;
  }
}, "IfcRelNests");
var IfcRelPositions = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPositioningElement, RelatedProducts) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingPositioningElement = RelatingPositioningElement;
    this.RelatedProducts = RelatedProducts;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingPositioningElement = tape[ptr++];
    let RelatedProducts = tape[ptr++];
    return new IfcRelPositions(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPositioningElement, RelatedProducts);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingPositioningElement);
    ;
    args.push(this.RelatedProducts);
    ;
    return args;
  }
}, "IfcRelPositions");
var IfcRelProjectsElement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedFeatureElement) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingElement = RelatingElement;
    this.RelatedFeatureElement = RelatedFeatureElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingElement = tape[ptr++];
    let RelatedFeatureElement = tape[ptr++];
    return new IfcRelProjectsElement(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedFeatureElement);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingElement);
    ;
    args.push(this.RelatedFeatureElement);
    ;
    return args;
  }
}, "IfcRelProjectsElement");
var IfcRelReferencedInSpatialStructure = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedElements, RelatingStructure) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedElements = RelatedElements;
    this.RelatingStructure = RelatingStructure;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedElements = tape[ptr++];
    let RelatingStructure = tape[ptr++];
    return new IfcRelReferencedInSpatialStructure(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedElements, RelatingStructure);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedElements);
    ;
    args.push(this.RelatingStructure);
    ;
    return args;
  }
}, "IfcRelReferencedInSpatialStructure");
var IfcRelSequence = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingProcess, RelatedProcess, TimeLag, SequenceType, UserDefinedSequenceType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingProcess = RelatingProcess;
    this.RelatedProcess = RelatedProcess;
    this.TimeLag = TimeLag;
    this.SequenceType = SequenceType;
    this.UserDefinedSequenceType = UserDefinedSequenceType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingProcess = tape[ptr++];
    let RelatedProcess = tape[ptr++];
    let TimeLag = tape[ptr++];
    let SequenceType = tape[ptr++];
    let UserDefinedSequenceType = tape[ptr++];
    return new IfcRelSequence(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingProcess, RelatedProcess, TimeLag, SequenceType, UserDefinedSequenceType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingProcess);
    ;
    args.push(this.RelatedProcess);
    ;
    args.push(this.TimeLag);
    ;
    args.push(this.SequenceType);
    ;
    args.push(this.UserDefinedSequenceType);
    ;
    return args;
  }
}, "IfcRelSequence");
var IfcRelServicesBuildings = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSystem, RelatedBuildings) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingSystem = RelatingSystem;
    this.RelatedBuildings = RelatedBuildings;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingSystem = tape[ptr++];
    let RelatedBuildings = tape[ptr++];
    return new IfcRelServicesBuildings(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSystem, RelatedBuildings);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingSystem);
    ;
    args.push(this.RelatedBuildings);
    ;
    return args;
  }
}, "IfcRelServicesBuildings");
var IfcRelSpaceBoundary = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingSpace = RelatingSpace;
    this.RelatedBuildingElement = RelatedBuildingElement;
    this.ConnectionGeometry = ConnectionGeometry;
    this.PhysicalOrVirtualBoundary = PhysicalOrVirtualBoundary;
    this.InternalOrExternalBoundary = InternalOrExternalBoundary;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingSpace = tape[ptr++];
    let RelatedBuildingElement = tape[ptr++];
    let ConnectionGeometry = tape[ptr++];
    let PhysicalOrVirtualBoundary = tape[ptr++];
    let InternalOrExternalBoundary = tape[ptr++];
    return new IfcRelSpaceBoundary(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingSpace);
    ;
    args.push(this.RelatedBuildingElement);
    ;
    args.push(this.ConnectionGeometry);
    ;
    args.push(this.PhysicalOrVirtualBoundary);
    ;
    args.push(this.InternalOrExternalBoundary);
    ;
    return args;
  }
}, "IfcRelSpaceBoundary");
var IfcRelSpaceBoundary1stLevel = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary, ParentBoundary) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingSpace = RelatingSpace;
    this.RelatedBuildingElement = RelatedBuildingElement;
    this.ConnectionGeometry = ConnectionGeometry;
    this.PhysicalOrVirtualBoundary = PhysicalOrVirtualBoundary;
    this.InternalOrExternalBoundary = InternalOrExternalBoundary;
    this.ParentBoundary = ParentBoundary;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingSpace = tape[ptr++];
    let RelatedBuildingElement = tape[ptr++];
    let ConnectionGeometry = tape[ptr++];
    let PhysicalOrVirtualBoundary = tape[ptr++];
    let InternalOrExternalBoundary = tape[ptr++];
    let ParentBoundary = tape[ptr++];
    return new IfcRelSpaceBoundary1stLevel(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary, ParentBoundary);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingSpace);
    ;
    args.push(this.RelatedBuildingElement);
    ;
    args.push(this.ConnectionGeometry);
    ;
    args.push(this.PhysicalOrVirtualBoundary);
    ;
    args.push(this.InternalOrExternalBoundary);
    ;
    args.push(this.ParentBoundary);
    ;
    return args;
  }
}, "IfcRelSpaceBoundary1stLevel");
var IfcRelSpaceBoundary2ndLevel = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary, ParentBoundary, CorrespondingBoundary) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingSpace = RelatingSpace;
    this.RelatedBuildingElement = RelatedBuildingElement;
    this.ConnectionGeometry = ConnectionGeometry;
    this.PhysicalOrVirtualBoundary = PhysicalOrVirtualBoundary;
    this.InternalOrExternalBoundary = InternalOrExternalBoundary;
    this.ParentBoundary = ParentBoundary;
    this.CorrespondingBoundary = CorrespondingBoundary;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingSpace = tape[ptr++];
    let RelatedBuildingElement = tape[ptr++];
    let ConnectionGeometry = tape[ptr++];
    let PhysicalOrVirtualBoundary = tape[ptr++];
    let InternalOrExternalBoundary = tape[ptr++];
    let ParentBoundary = tape[ptr++];
    let CorrespondingBoundary = tape[ptr++];
    return new IfcRelSpaceBoundary2ndLevel(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary, ParentBoundary, CorrespondingBoundary);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingSpace);
    ;
    args.push(this.RelatedBuildingElement);
    ;
    args.push(this.ConnectionGeometry);
    ;
    args.push(this.PhysicalOrVirtualBoundary);
    ;
    args.push(this.InternalOrExternalBoundary);
    ;
    args.push(this.ParentBoundary);
    ;
    args.push(this.CorrespondingBoundary);
    ;
    return args;
  }
}, "IfcRelSpaceBoundary2ndLevel");
var IfcRelVoidsElement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingBuildingElement, RelatedOpeningElement) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingBuildingElement = RelatingBuildingElement;
    this.RelatedOpeningElement = RelatedOpeningElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingBuildingElement = tape[ptr++];
    let RelatedOpeningElement = tape[ptr++];
    return new IfcRelVoidsElement(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingBuildingElement, RelatedOpeningElement);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingBuildingElement);
    ;
    args.push(this.RelatedOpeningElement);
    ;
    return args;
  }
}, "IfcRelVoidsElement");
var IfcRelationship = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcRelationship(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    return args;
  }
}, "IfcRelationship");
var IfcReparametrisedCompositeCurveSegment = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Transition, SameSense, ParentCurve, ParamLength) {
    this.expressID = expressID;
    this.type = type;
    this.Transition = Transition;
    this.SameSense = SameSense;
    this.ParentCurve = ParentCurve;
    this.ParamLength = ParamLength;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Transition = tape[ptr++];
    let SameSense = tape[ptr++];
    let ParentCurve = tape[ptr++];
    let ParamLength = tape[ptr++];
    return new IfcReparametrisedCompositeCurveSegment(expressID, type, Transition, SameSense, ParentCurve, ParamLength);
  }
  ToTape() {
    let args = [];
    args.push(this.Transition);
    ;
    args.push(this.SameSense);
    ;
    args.push(this.ParentCurve);
    ;
    args.push(this.ParamLength);
    ;
    return args;
  }
}, "IfcReparametrisedCompositeCurveSegment");
var IfcRepresentation = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
    this.expressID = expressID;
    this.type = type;
    this.ContextOfItems = ContextOfItems;
    this.RepresentationIdentifier = RepresentationIdentifier;
    this.RepresentationType = RepresentationType;
    this.Items = Items;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextOfItems = tape[ptr++];
    let RepresentationIdentifier = tape[ptr++];
    let RepresentationType = tape[ptr++];
    let Items = tape[ptr++];
    return new IfcRepresentation(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextOfItems);
    ;
    args.push(this.RepresentationIdentifier);
    ;
    args.push(this.RepresentationType);
    ;
    args.push(this.Items);
    ;
    return args;
  }
}, "IfcRepresentation");
var IfcRepresentationContext = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ContextIdentifier, ContextType) {
    this.expressID = expressID;
    this.type = type;
    this.ContextIdentifier = ContextIdentifier;
    this.ContextType = ContextType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextIdentifier = tape[ptr++];
    let ContextType = tape[ptr++];
    return new IfcRepresentationContext(expressID, type, ContextIdentifier, ContextType);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextIdentifier);
    ;
    args.push(this.ContextType);
    ;
    return args;
  }
}, "IfcRepresentationContext");
var IfcRepresentationItem = /* @__PURE__ */ __name(class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcRepresentationItem(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
}, "IfcRepresentationItem");
var IfcRepresentationMap = /* @__PURE__ */ __name(class {
  constructor(expressID, type, MappingOrigin, MappedRepresentation) {
    this.expressID = expressID;
    this.type = type;
    this.MappingOrigin = MappingOrigin;
    this.MappedRepresentation = MappedRepresentation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let MappingOrigin = tape[ptr++];
    let MappedRepresentation = tape[ptr++];
    return new IfcRepresentationMap(expressID, type, MappingOrigin, MappedRepresentation);
  }
  ToTape() {
    let args = [];
    args.push(this.MappingOrigin);
    ;
    args.push(this.MappedRepresentation);
    ;
    return args;
  }
}, "IfcRepresentationMap");
var IfcResource = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    return new IfcResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    return args;
  }
}, "IfcResource");
var IfcResourceApprovalRelationship = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, RelatedResourceObjects, RelatingApproval) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.RelatedResourceObjects = RelatedResourceObjects;
    this.RelatingApproval = RelatingApproval;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedResourceObjects = tape[ptr++];
    let RelatingApproval = tape[ptr++];
    return new IfcResourceApprovalRelationship(expressID, type, Name, Description, RelatedResourceObjects, RelatingApproval);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatedResourceObjects);
    ;
    args.push(this.RelatingApproval);
    ;
    return args;
  }
}, "IfcResourceApprovalRelationship");
var IfcResourceConstraintRelationship = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, RelatingConstraint, RelatedResourceObjects) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.RelatingConstraint = RelatingConstraint;
    this.RelatedResourceObjects = RelatedResourceObjects;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingConstraint = tape[ptr++];
    let RelatedResourceObjects = tape[ptr++];
    return new IfcResourceConstraintRelationship(expressID, type, Name, Description, RelatingConstraint, RelatedResourceObjects);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.RelatingConstraint);
    ;
    args.push(this.RelatedResourceObjects);
    ;
    return args;
  }
}, "IfcResourceConstraintRelationship");
var IfcResourceLevelRelationship = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcResourceLevelRelationship(expressID, type, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    return args;
  }
}, "IfcResourceLevelRelationship");
var IfcResourceTime = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, ScheduleWork, ScheduleUsage, ScheduleStart, ScheduleFinish, ScheduleContour, LevelingDelay, IsOverAllocated, StatusTime, ActualWork, ActualUsage, ActualStart, ActualFinish, RemainingWork, RemainingUsage, Completion) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.ScheduleWork = ScheduleWork;
    this.ScheduleUsage = ScheduleUsage;
    this.ScheduleStart = ScheduleStart;
    this.ScheduleFinish = ScheduleFinish;
    this.ScheduleContour = ScheduleContour;
    this.LevelingDelay = LevelingDelay;
    this.IsOverAllocated = IsOverAllocated;
    this.StatusTime = StatusTime;
    this.ActualWork = ActualWork;
    this.ActualUsage = ActualUsage;
    this.ActualStart = ActualStart;
    this.ActualFinish = ActualFinish;
    this.RemainingWork = RemainingWork;
    this.RemainingUsage = RemainingUsage;
    this.Completion = Completion;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let ScheduleWork = tape[ptr++];
    let ScheduleUsage = tape[ptr++];
    let ScheduleStart = tape[ptr++];
    let ScheduleFinish = tape[ptr++];
    let ScheduleContour = tape[ptr++];
    let LevelingDelay = tape[ptr++];
    let IsOverAllocated = tape[ptr++];
    let StatusTime = tape[ptr++];
    let ActualWork = tape[ptr++];
    let ActualUsage = tape[ptr++];
    let ActualStart = tape[ptr++];
    let ActualFinish = tape[ptr++];
    let RemainingWork = tape[ptr++];
    let RemainingUsage = tape[ptr++];
    let Completion = tape[ptr++];
    return new IfcResourceTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, ScheduleWork, ScheduleUsage, ScheduleStart, ScheduleFinish, ScheduleContour, LevelingDelay, IsOverAllocated, StatusTime, ActualWork, ActualUsage, ActualStart, ActualFinish, RemainingWork, RemainingUsage, Completion);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.DataOrigin);
    ;
    args.push(this.UserDefinedDataOrigin);
    ;
    args.push(this.ScheduleWork);
    ;
    args.push(this.ScheduleUsage);
    ;
    args.push(this.ScheduleStart);
    ;
    args.push(this.ScheduleFinish);
    ;
    args.push(this.ScheduleContour);
    ;
    args.push(this.LevelingDelay);
    ;
    args.push(this.IsOverAllocated);
    ;
    args.push(this.StatusTime);
    ;
    args.push(this.ActualWork);
    ;
    args.push(this.ActualUsage);
    ;
    args.push(this.ActualStart);
    ;
    args.push(this.ActualFinish);
    ;
    args.push(this.RemainingWork);
    ;
    args.push(this.RemainingUsage);
    ;
    args.push(this.Completion);
    ;
    return args;
  }
}, "IfcResourceTime");
var IfcRevolvedAreaSolid = /* @__PURE__ */ __name(class {
  constructor(expressID, type, SweptArea, Position, Axis, Angle) {
    this.expressID = expressID;
    this.type = type;
    this.SweptArea = SweptArea;
    this.Position = Position;
    this.Axis = Axis;
    this.Angle = Angle;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptArea = tape[ptr++];
    let Position = tape[ptr++];
    let Axis = tape[ptr++];
    let Angle = tape[ptr++];
    return new IfcRevolvedAreaSolid(expressID, type, SweptArea, Position, Axis, Angle);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptArea);
    ;
    args.push(this.Position);
    ;
    args.push(this.Axis);
    ;
    args.push(this.Angle);
    ;
    return args;
  }
}, "IfcRevolvedAreaSolid");
var IfcRevolvedAreaSolidTapered = /* @__PURE__ */ __name(class {
  constructor(expressID, type, SweptArea, Position, Axis, Angle, EndSweptArea) {
    this.expressID = expressID;
    this.type = type;
    this.SweptArea = SweptArea;
    this.Position = Position;
    this.Axis = Axis;
    this.Angle = Angle;
    this.EndSweptArea = EndSweptArea;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptArea = tape[ptr++];
    let Position = tape[ptr++];
    let Axis = tape[ptr++];
    let Angle = tape[ptr++];
    let EndSweptArea = tape[ptr++];
    return new IfcRevolvedAreaSolidTapered(expressID, type, SweptArea, Position, Axis, Angle, EndSweptArea);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptArea);
    ;
    args.push(this.Position);
    ;
    args.push(this.Axis);
    ;
    args.push(this.Angle);
    ;
    args.push(this.EndSweptArea);
    ;
    return args;
  }
}, "IfcRevolvedAreaSolidTapered");
var IfcRightCircularCone = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Position, Height, BottomRadius) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.Height = Height;
    this.BottomRadius = BottomRadius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let Height = tape[ptr++];
    let BottomRadius = tape[ptr++];
    return new IfcRightCircularCone(expressID, type, Position, Height, BottomRadius);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    ;
    args.push(this.Height);
    ;
    args.push(this.BottomRadius);
    ;
    return args;
  }
}, "IfcRightCircularCone");
var IfcRightCircularCylinder = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Position, Height, Radius) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.Height = Height;
    this.Radius = Radius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let Height = tape[ptr++];
    let Radius = tape[ptr++];
    return new IfcRightCircularCylinder(expressID, type, Position, Height, Radius);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    ;
    args.push(this.Height);
    ;
    args.push(this.Radius);
    ;
    return args;
  }
}, "IfcRightCircularCylinder");
var IfcRoof = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcRoof(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcRoof");
var IfcRoofType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcRoofType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcRoofType");
var IfcRoot = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcRoot(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    return args;
  }
}, "IfcRoot");
var IfcRoundedRectangleProfileDef = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ProfileType, ProfileName, Position, XDim, YDim, RoundingRadius) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.XDim = XDim;
    this.YDim = YDim;
    this.RoundingRadius = RoundingRadius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let XDim = tape[ptr++];
    let YDim = tape[ptr++];
    let RoundingRadius = tape[ptr++];
    return new IfcRoundedRectangleProfileDef(expressID, type, ProfileType, ProfileName, Position, XDim, YDim, RoundingRadius);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Position);
    ;
    args.push(this.XDim);
    ;
    args.push(this.YDim);
    ;
    args.push(this.RoundingRadius);
    ;
    return args;
  }
}, "IfcRoundedRectangleProfileDef");
var IfcSIUnit = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Dimensions, UnitType, Prefix, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Dimensions = Dimensions;
    this.UnitType = UnitType;
    this.Prefix = Prefix;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Dimensions = tape[ptr++];
    let UnitType = tape[ptr++];
    let Prefix = tape[ptr++];
    let Name = tape[ptr++];
    return new IfcSIUnit(expressID, type, Dimensions, UnitType, Prefix, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Dimensions);
    ;
    args.push(this.UnitType);
    ;
    args.push(this.Prefix);
    ;
    args.push(this.Name);
    ;
    return args;
  }
}, "IfcSIUnit");
var IfcSanitaryTerminal = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSanitaryTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcSanitaryTerminal");
var IfcSanitaryTerminalType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSanitaryTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcSanitaryTerminalType");
var IfcSchedulingTime = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    return new IfcSchedulingTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.DataOrigin);
    ;
    args.push(this.UserDefinedDataOrigin);
    ;
    return args;
  }
}, "IfcSchedulingTime");
var IfcSeamCurve = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation) {
    this.expressID = expressID;
    this.type = type;
    this.Curve3D = Curve3D;
    this.AssociatedGeometry = AssociatedGeometry;
    this.MasterRepresentation = MasterRepresentation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Curve3D = tape[ptr++];
    let AssociatedGeometry = tape[ptr++];
    let MasterRepresentation = tape[ptr++];
    return new IfcSeamCurve(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation);
  }
  ToTape() {
    let args = [];
    args.push(this.Curve3D);
    ;
    args.push(this.AssociatedGeometry);
    ;
    args.push(this.MasterRepresentation);
    ;
    return args;
  }
}, "IfcSeamCurve");
var IfcSectionProperties = /* @__PURE__ */ __name(class {
  constructor(expressID, type, SectionType, StartProfile, EndProfile) {
    this.expressID = expressID;
    this.type = type;
    this.SectionType = SectionType;
    this.StartProfile = StartProfile;
    this.EndProfile = EndProfile;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SectionType = tape[ptr++];
    let StartProfile = tape[ptr++];
    let EndProfile = tape[ptr++];
    return new IfcSectionProperties(expressID, type, SectionType, StartProfile, EndProfile);
  }
  ToTape() {
    let args = [];
    args.push(this.SectionType);
    ;
    args.push(this.StartProfile);
    ;
    args.push(this.EndProfile);
    ;
    return args;
  }
}, "IfcSectionProperties");
var IfcSectionReinforcementProperties = /* @__PURE__ */ __name(class {
  constructor(expressID, type, LongitudinalStartPosition, LongitudinalEndPosition, TransversePosition, ReinforcementRole, SectionDefinition, CrossSectionReinforcementDefinitions) {
    this.expressID = expressID;
    this.type = type;
    this.LongitudinalStartPosition = LongitudinalStartPosition;
    this.LongitudinalEndPosition = LongitudinalEndPosition;
    this.TransversePosition = TransversePosition;
    this.ReinforcementRole = ReinforcementRole;
    this.SectionDefinition = SectionDefinition;
    this.CrossSectionReinforcementDefinitions = CrossSectionReinforcementDefinitions;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let LongitudinalStartPosition = tape[ptr++];
    let LongitudinalEndPosition = tape[ptr++];
    let TransversePosition = tape[ptr++];
    let ReinforcementRole = tape[ptr++];
    let SectionDefinition = tape[ptr++];
    let CrossSectionReinforcementDefinitions = tape[ptr++];
    return new IfcSectionReinforcementProperties(expressID, type, LongitudinalStartPosition, LongitudinalEndPosition, TransversePosition, ReinforcementRole, SectionDefinition, CrossSectionReinforcementDefinitions);
  }
  ToTape() {
    let args = [];
    args.push(this.LongitudinalStartPosition);
    ;
    args.push(this.LongitudinalEndPosition);
    ;
    args.push(this.TransversePosition);
    ;
    args.push(this.ReinforcementRole);
    ;
    args.push(this.SectionDefinition);
    ;
    args.push(this.CrossSectionReinforcementDefinitions);
    ;
    return args;
  }
}, "IfcSectionReinforcementProperties");
var IfcSectionedSolid = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Directrix, CrossSections) {
    this.expressID = expressID;
    this.type = type;
    this.Directrix = Directrix;
    this.CrossSections = CrossSections;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Directrix = tape[ptr++];
    let CrossSections = tape[ptr++];
    return new IfcSectionedSolid(expressID, type, Directrix, CrossSections);
  }
  ToTape() {
    let args = [];
    args.push(this.Directrix);
    ;
    args.push(this.CrossSections);
    ;
    return args;
  }
}, "IfcSectionedSolid");
var IfcSectionedSolidHorizontal = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Directrix, CrossSections, CrossSectionPositions, FixedAxisVertical) {
    this.expressID = expressID;
    this.type = type;
    this.Directrix = Directrix;
    this.CrossSections = CrossSections;
    this.CrossSectionPositions = CrossSectionPositions;
    this.FixedAxisVertical = FixedAxisVertical;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Directrix = tape[ptr++];
    let CrossSections = tape[ptr++];
    let CrossSectionPositions = tape[ptr++];
    let FixedAxisVertical = tape[ptr++];
    return new IfcSectionedSolidHorizontal(expressID, type, Directrix, CrossSections, CrossSectionPositions, FixedAxisVertical);
  }
  ToTape() {
    let args = [];
    args.push(this.Directrix);
    ;
    args.push(this.CrossSections);
    ;
    args.push(this.CrossSectionPositions);
    ;
    args.push(this.FixedAxisVertical);
    ;
    return args;
  }
}, "IfcSectionedSolidHorizontal");
var IfcSectionedSpine = /* @__PURE__ */ __name(class {
  constructor(expressID, type, SpineCurve, CrossSections, CrossSectionPositions) {
    this.expressID = expressID;
    this.type = type;
    this.SpineCurve = SpineCurve;
    this.CrossSections = CrossSections;
    this.CrossSectionPositions = CrossSectionPositions;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SpineCurve = tape[ptr++];
    let CrossSections = tape[ptr++];
    let CrossSectionPositions = tape[ptr++];
    return new IfcSectionedSpine(expressID, type, SpineCurve, CrossSections, CrossSectionPositions);
  }
  ToTape() {
    let args = [];
    args.push(this.SpineCurve);
    ;
    args.push(this.CrossSections);
    ;
    args.push(this.CrossSectionPositions);
    ;
    return args;
  }
}, "IfcSectionedSpine");
var IfcSensor = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSensor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcSensor");
var IfcSensorType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSensorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcSensorType");
var IfcShadingDevice = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcShadingDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcShadingDevice");
var IfcShadingDeviceType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcShadingDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcShadingDeviceType");
var IfcShapeAspect = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ShapeRepresentations, Name, Description, ProductDefinitional, PartOfProductDefinitionShape) {
    this.expressID = expressID;
    this.type = type;
    this.ShapeRepresentations = ShapeRepresentations;
    this.Name = Name;
    this.Description = Description;
    this.ProductDefinitional = ProductDefinitional;
    this.PartOfProductDefinitionShape = PartOfProductDefinitionShape;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ShapeRepresentations = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ProductDefinitional = tape[ptr++];
    let PartOfProductDefinitionShape = tape[ptr++];
    return new IfcShapeAspect(expressID, type, ShapeRepresentations, Name, Description, ProductDefinitional, PartOfProductDefinitionShape);
  }
  ToTape() {
    let args = [];
    args.push(this.ShapeRepresentations);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ProductDefinitional);
    ;
    args.push(this.PartOfProductDefinitionShape);
    ;
    return args;
  }
}, "IfcShapeAspect");
var IfcShapeModel = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
    this.expressID = expressID;
    this.type = type;
    this.ContextOfItems = ContextOfItems;
    this.RepresentationIdentifier = RepresentationIdentifier;
    this.RepresentationType = RepresentationType;
    this.Items = Items;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextOfItems = tape[ptr++];
    let RepresentationIdentifier = tape[ptr++];
    let RepresentationType = tape[ptr++];
    let Items = tape[ptr++];
    return new IfcShapeModel(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextOfItems);
    ;
    args.push(this.RepresentationIdentifier);
    ;
    args.push(this.RepresentationType);
    ;
    args.push(this.Items);
    ;
    return args;
  }
}, "IfcShapeModel");
var IfcShapeRepresentation = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
    this.expressID = expressID;
    this.type = type;
    this.ContextOfItems = ContextOfItems;
    this.RepresentationIdentifier = RepresentationIdentifier;
    this.RepresentationType = RepresentationType;
    this.Items = Items;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextOfItems = tape[ptr++];
    let RepresentationIdentifier = tape[ptr++];
    let RepresentationType = tape[ptr++];
    let Items = tape[ptr++];
    return new IfcShapeRepresentation(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextOfItems);
    ;
    args.push(this.RepresentationIdentifier);
    ;
    args.push(this.RepresentationType);
    ;
    args.push(this.Items);
    ;
    return args;
  }
}, "IfcShapeRepresentation");
var IfcShellBasedSurfaceModel = /* @__PURE__ */ __name(class {
  constructor(expressID, type, SbsmBoundary) {
    this.expressID = expressID;
    this.type = type;
    this.SbsmBoundary = SbsmBoundary;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SbsmBoundary = tape[ptr++];
    return new IfcShellBasedSurfaceModel(expressID, type, SbsmBoundary);
  }
  ToTape() {
    let args = [];
    args.push(this.SbsmBoundary);
    ;
    return args;
  }
}, "IfcShellBasedSurfaceModel");
var IfcSimpleProperty = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcSimpleProperty(expressID, type, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    return args;
  }
}, "IfcSimpleProperty");
var IfcSimplePropertyTemplate = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, TemplateType, PrimaryMeasureType, SecondaryMeasureType, Enumerators, PrimaryUnit, SecondaryUnit, Expression, AccessState) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.TemplateType = TemplateType;
    this.PrimaryMeasureType = PrimaryMeasureType;
    this.SecondaryMeasureType = SecondaryMeasureType;
    this.Enumerators = Enumerators;
    this.PrimaryUnit = PrimaryUnit;
    this.SecondaryUnit = SecondaryUnit;
    this.Expression = Expression;
    this.AccessState = AccessState;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let TemplateType = tape[ptr++];
    let PrimaryMeasureType = tape[ptr++];
    let SecondaryMeasureType = tape[ptr++];
    let Enumerators = tape[ptr++];
    let PrimaryUnit = tape[ptr++];
    let SecondaryUnit = tape[ptr++];
    let Expression = tape[ptr++];
    let AccessState = tape[ptr++];
    return new IfcSimplePropertyTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description, TemplateType, PrimaryMeasureType, SecondaryMeasureType, Enumerators, PrimaryUnit, SecondaryUnit, Expression, AccessState);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.TemplateType);
    ;
    args.push(this.PrimaryMeasureType);
    ;
    args.push(this.SecondaryMeasureType);
    ;
    args.push(this.Enumerators);
    ;
    args.push(this.PrimaryUnit);
    ;
    args.push(this.SecondaryUnit);
    ;
    args.push(this.Expression);
    ;
    args.push(this.AccessState);
    ;
    return args;
  }
}, "IfcSimplePropertyTemplate");
var IfcSite = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, RefLatitude, RefLongitude, RefElevation, LandTitleNumber, SiteAddress) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
    this.RefLatitude = RefLatitude;
    this.RefLongitude = RefLongitude;
    this.RefElevation = RefElevation;
    this.LandTitleNumber = LandTitleNumber;
    this.SiteAddress = SiteAddress;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    let RefLatitude = tape[ptr++];
    let RefLongitude = tape[ptr++];
    let RefElevation = tape[ptr++];
    let LandTitleNumber = tape[ptr++];
    let SiteAddress = tape[ptr++];
    return new IfcSite(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, RefLatitude, RefLongitude, RefElevation, LandTitleNumber, SiteAddress);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.LongName);
    ;
    args.push(this.CompositionType);
    ;
    args.push(this.RefLatitude);
    ;
    args.push(this.RefLongitude);
    ;
    args.push(this.RefElevation);
    ;
    args.push(this.LandTitleNumber);
    ;
    args.push(this.SiteAddress);
    ;
    return args;
  }
}, "IfcSite");
var IfcSlab = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSlab(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcSlab");
var IfcSlabElementedCase = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSlabElementedCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcSlabElementedCase");
var IfcSlabStandardCase = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSlabStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcSlabStandardCase");
var IfcSlabType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSlabType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcSlabType");
var IfcSlippageConnectionCondition = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, SlippageX, SlippageY, SlippageZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.SlippageX = SlippageX;
    this.SlippageY = SlippageY;
    this.SlippageZ = SlippageZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let SlippageX = tape[ptr++];
    let SlippageY = tape[ptr++];
    let SlippageZ = tape[ptr++];
    return new IfcSlippageConnectionCondition(expressID, type, Name, SlippageX, SlippageY, SlippageZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.SlippageX);
    ;
    args.push(this.SlippageY);
    ;
    args.push(this.SlippageZ);
    ;
    return args;
  }
}, "IfcSlippageConnectionCondition");
var IfcSolarDevice = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSolarDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcSolarDevice");
var IfcSolarDeviceType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSolarDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcSolarDeviceType");
var IfcSolidModel = /* @__PURE__ */ __name(class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcSolidModel(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
}, "IfcSolidModel");
var IfcSpace = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType, ElevationWithFlooring) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
    this.PredefinedType = PredefinedType;
    this.ElevationWithFlooring = ElevationWithFlooring;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let ElevationWithFlooring = tape[ptr++];
    return new IfcSpace(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType, ElevationWithFlooring);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.LongName);
    ;
    args.push(this.CompositionType);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.ElevationWithFlooring);
    ;
    return args;
  }
}, "IfcSpace");
var IfcSpaceHeater = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSpaceHeater(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcSpaceHeater");
var IfcSpaceHeaterType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSpaceHeaterType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcSpaceHeaterType");
var IfcSpaceType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, LongName) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
    this.LongName = LongName;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let LongName = tape[ptr++];
    return new IfcSpaceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, LongName);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.LongName);
    ;
    return args;
  }
}, "IfcSpaceType");
var IfcSpatialElement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    return new IfcSpatialElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.LongName);
    ;
    return args;
  }
}, "IfcSpatialElement");
var IfcSpatialElementType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcSpatialElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
}, "IfcSpatialElementType");
var IfcSpatialStructureElement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    return new IfcSpatialStructureElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.LongName);
    ;
    args.push(this.CompositionType);
    ;
    return args;
  }
}, "IfcSpatialStructureElement");
var IfcSpatialStructureElementType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcSpatialStructureElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    return args;
  }
}, "IfcSpatialStructureElementType");
var IfcSpatialZone = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSpatialZone(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.LongName);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcSpatialZone");
var IfcSpatialZoneType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, LongName) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
    this.LongName = LongName;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let LongName = tape[ptr++];
    return new IfcSpatialZoneType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, LongName);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.LongName);
    ;
    return args;
  }
}, "IfcSpatialZoneType");
var IfcSphere = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Position, Radius) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.Radius = Radius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let Radius = tape[ptr++];
    return new IfcSphere(expressID, type, Position, Radius);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    ;
    args.push(this.Radius);
    ;
    return args;
  }
}, "IfcSphere");
var IfcSphericalSurface = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Position, Radius) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.Radius = Radius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let Radius = tape[ptr++];
    return new IfcSphericalSurface(expressID, type, Position, Radius);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    ;
    args.push(this.Radius);
    ;
    return args;
  }
}, "IfcSphericalSurface");
var IfcStackTerminal = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStackTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcStackTerminal");
var IfcStackTerminalType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStackTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcStackTerminalType");
var IfcStair = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStair(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcStair");
var IfcStairFlight = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, NumberOfRisers, NumberOfTreads, RiserHeight, TreadLength, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.NumberOfRisers = NumberOfRisers;
    this.NumberOfTreads = NumberOfTreads;
    this.RiserHeight = RiserHeight;
    this.TreadLength = TreadLength;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let NumberOfRisers = tape[ptr++];
    let NumberOfTreads = tape[ptr++];
    let RiserHeight = tape[ptr++];
    let TreadLength = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStairFlight(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, NumberOfRisers, NumberOfTreads, RiserHeight, TreadLength, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.NumberOfRisers);
    ;
    args.push(this.NumberOfTreads);
    ;
    args.push(this.RiserHeight);
    ;
    args.push(this.TreadLength);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcStairFlight");
var IfcStairFlightType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStairFlightType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcStairFlightType");
var IfcStairType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStairType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcStairType");
var IfcStructuralAction = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
    this.DestabilizingLoad = DestabilizingLoad;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    let DestabilizingLoad = tape[ptr++];
    return new IfcStructuralAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.AppliedLoad);
    ;
    args.push(this.GlobalOrLocal);
    ;
    args.push(this.DestabilizingLoad);
    ;
    return args;
  }
}, "IfcStructuralAction");
var IfcStructuralActivity = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    return new IfcStructuralActivity(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.AppliedLoad);
    ;
    args.push(this.GlobalOrLocal);
    ;
    return args;
  }
}, "IfcStructuralActivity");
var IfcStructuralAnalysisModel = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, OrientationOf2DPlane, LoadedBy, HasResults, SharedPlacement) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.PredefinedType = PredefinedType;
    this.OrientationOf2DPlane = OrientationOf2DPlane;
    this.LoadedBy = LoadedBy;
    this.HasResults = HasResults;
    this.SharedPlacement = SharedPlacement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let OrientationOf2DPlane = tape[ptr++];
    let LoadedBy = tape[ptr++];
    let HasResults = tape[ptr++];
    let SharedPlacement = tape[ptr++];
    return new IfcStructuralAnalysisModel(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, OrientationOf2DPlane, LoadedBy, HasResults, SharedPlacement);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.OrientationOf2DPlane);
    ;
    args.push(this.LoadedBy);
    ;
    args.push(this.HasResults);
    ;
    args.push(this.SharedPlacement);
    ;
    return args;
  }
}, "IfcStructuralAnalysisModel");
var IfcStructuralConnection = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedCondition = AppliedCondition;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedCondition = tape[ptr++];
    return new IfcStructuralConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.AppliedCondition);
    ;
    return args;
  }
}, "IfcStructuralConnection");
var IfcStructuralConnectionCondition = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcStructuralConnectionCondition(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    return args;
  }
}, "IfcStructuralConnectionCondition");
var IfcStructuralCurveAction = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
    this.DestabilizingLoad = DestabilizingLoad;
    this.ProjectedOrTrue = ProjectedOrTrue;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    let DestabilizingLoad = tape[ptr++];
    let ProjectedOrTrue = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStructuralCurveAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.AppliedLoad);
    ;
    args.push(this.GlobalOrLocal);
    ;
    args.push(this.DestabilizingLoad);
    ;
    args.push(this.ProjectedOrTrue);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcStructuralCurveAction");
var IfcStructuralCurveConnection = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition, Axis) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedCondition = AppliedCondition;
    this.Axis = Axis;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedCondition = tape[ptr++];
    let Axis = tape[ptr++];
    return new IfcStructuralCurveConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition, Axis);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.AppliedCondition);
    ;
    args.push(this.Axis);
    ;
    return args;
  }
}, "IfcStructuralCurveConnection");
var IfcStructuralCurveMember = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Axis) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.PredefinedType = PredefinedType;
    this.Axis = Axis;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Axis = tape[ptr++];
    return new IfcStructuralCurveMember(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Axis);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.Axis);
    ;
    return args;
  }
}, "IfcStructuralCurveMember");
var IfcStructuralCurveMemberVarying = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Axis) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.PredefinedType = PredefinedType;
    this.Axis = Axis;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Axis = tape[ptr++];
    return new IfcStructuralCurveMemberVarying(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Axis);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.Axis);
    ;
    return args;
  }
}, "IfcStructuralCurveMemberVarying");
var IfcStructuralCurveReaction = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStructuralCurveReaction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.AppliedLoad);
    ;
    args.push(this.GlobalOrLocal);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcStructuralCurveReaction");
var IfcStructuralItem = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    return new IfcStructuralItem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    return args;
  }
}, "IfcStructuralItem");
var IfcStructuralLinearAction = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
    this.DestabilizingLoad = DestabilizingLoad;
    this.ProjectedOrTrue = ProjectedOrTrue;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    let DestabilizingLoad = tape[ptr++];
    let ProjectedOrTrue = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStructuralLinearAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.AppliedLoad);
    ;
    args.push(this.GlobalOrLocal);
    ;
    args.push(this.DestabilizingLoad);
    ;
    args.push(this.ProjectedOrTrue);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcStructuralLinearAction");
var IfcStructuralLoad = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcStructuralLoad(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    return args;
  }
}, "IfcStructuralLoad");
var IfcStructuralLoadCase = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, ActionType, ActionSource, Coefficient, Purpose, SelfWeightCoefficients) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.PredefinedType = PredefinedType;
    this.ActionType = ActionType;
    this.ActionSource = ActionSource;
    this.Coefficient = Coefficient;
    this.Purpose = Purpose;
    this.SelfWeightCoefficients = SelfWeightCoefficients;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let ActionType = tape[ptr++];
    let ActionSource = tape[ptr++];
    let Coefficient = tape[ptr++];
    let Purpose = tape[ptr++];
    let SelfWeightCoefficients = tape[ptr++];
    return new IfcStructuralLoadCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, ActionType, ActionSource, Coefficient, Purpose, SelfWeightCoefficients);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.ActionType);
    ;
    args.push(this.ActionSource);
    ;
    args.push(this.Coefficient);
    ;
    args.push(this.Purpose);
    ;
    args.push(this.SelfWeightCoefficients);
    ;
    return args;
  }
}, "IfcStructuralLoadCase");
var IfcStructuralLoadConfiguration = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Values, Locations) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Values = Values;
    this.Locations = Locations;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Values = tape[ptr++];
    let Locations = tape[ptr++];
    return new IfcStructuralLoadConfiguration(expressID, type, Name, Values, Locations);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Values);
    ;
    args.push(this.Locations);
    ;
    return args;
  }
}, "IfcStructuralLoadConfiguration");
var IfcStructuralLoadGroup = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, ActionType, ActionSource, Coefficient, Purpose) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.PredefinedType = PredefinedType;
    this.ActionType = ActionType;
    this.ActionSource = ActionSource;
    this.Coefficient = Coefficient;
    this.Purpose = Purpose;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let ActionType = tape[ptr++];
    let ActionSource = tape[ptr++];
    let Coefficient = tape[ptr++];
    let Purpose = tape[ptr++];
    return new IfcStructuralLoadGroup(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, ActionType, ActionSource, Coefficient, Purpose);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.ActionType);
    ;
    args.push(this.ActionSource);
    ;
    args.push(this.Coefficient);
    ;
    args.push(this.Purpose);
    ;
    return args;
  }
}, "IfcStructuralLoadGroup");
var IfcStructuralLoadLinearForce = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, LinearForceX, LinearForceY, LinearForceZ, LinearMomentX, LinearMomentY, LinearMomentZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.LinearForceX = LinearForceX;
    this.LinearForceY = LinearForceY;
    this.LinearForceZ = LinearForceZ;
    this.LinearMomentX = LinearMomentX;
    this.LinearMomentY = LinearMomentY;
    this.LinearMomentZ = LinearMomentZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let LinearForceX = tape[ptr++];
    let LinearForceY = tape[ptr++];
    let LinearForceZ = tape[ptr++];
    let LinearMomentX = tape[ptr++];
    let LinearMomentY = tape[ptr++];
    let LinearMomentZ = tape[ptr++];
    return new IfcStructuralLoadLinearForce(expressID, type, Name, LinearForceX, LinearForceY, LinearForceZ, LinearMomentX, LinearMomentY, LinearMomentZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.LinearForceX);
    ;
    args.push(this.LinearForceY);
    ;
    args.push(this.LinearForceZ);
    ;
    args.push(this.LinearMomentX);
    ;
    args.push(this.LinearMomentY);
    ;
    args.push(this.LinearMomentZ);
    ;
    return args;
  }
}, "IfcStructuralLoadLinearForce");
var IfcStructuralLoadOrResult = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcStructuralLoadOrResult(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    return args;
  }
}, "IfcStructuralLoadOrResult");
var IfcStructuralLoadPlanarForce = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, PlanarForceX, PlanarForceY, PlanarForceZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.PlanarForceX = PlanarForceX;
    this.PlanarForceY = PlanarForceY;
    this.PlanarForceZ = PlanarForceZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let PlanarForceX = tape[ptr++];
    let PlanarForceY = tape[ptr++];
    let PlanarForceZ = tape[ptr++];
    return new IfcStructuralLoadPlanarForce(expressID, type, Name, PlanarForceX, PlanarForceY, PlanarForceZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.PlanarForceX);
    ;
    args.push(this.PlanarForceY);
    ;
    args.push(this.PlanarForceZ);
    ;
    return args;
  }
}, "IfcStructuralLoadPlanarForce");
var IfcStructuralLoadSingleDisplacement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, DisplacementX, DisplacementY, DisplacementZ, RotationalDisplacementRX, RotationalDisplacementRY, RotationalDisplacementRZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DisplacementX = DisplacementX;
    this.DisplacementY = DisplacementY;
    this.DisplacementZ = DisplacementZ;
    this.RotationalDisplacementRX = RotationalDisplacementRX;
    this.RotationalDisplacementRY = RotationalDisplacementRY;
    this.RotationalDisplacementRZ = RotationalDisplacementRZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DisplacementX = tape[ptr++];
    let DisplacementY = tape[ptr++];
    let DisplacementZ = tape[ptr++];
    let RotationalDisplacementRX = tape[ptr++];
    let RotationalDisplacementRY = tape[ptr++];
    let RotationalDisplacementRZ = tape[ptr++];
    return new IfcStructuralLoadSingleDisplacement(expressID, type, Name, DisplacementX, DisplacementY, DisplacementZ, RotationalDisplacementRX, RotationalDisplacementRY, RotationalDisplacementRZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.DisplacementX);
    ;
    args.push(this.DisplacementY);
    ;
    args.push(this.DisplacementZ);
    ;
    args.push(this.RotationalDisplacementRX);
    ;
    args.push(this.RotationalDisplacementRY);
    ;
    args.push(this.RotationalDisplacementRZ);
    ;
    return args;
  }
}, "IfcStructuralLoadSingleDisplacement");
var IfcStructuralLoadSingleDisplacementDistortion = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, DisplacementX, DisplacementY, DisplacementZ, RotationalDisplacementRX, RotationalDisplacementRY, RotationalDisplacementRZ, Distortion) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DisplacementX = DisplacementX;
    this.DisplacementY = DisplacementY;
    this.DisplacementZ = DisplacementZ;
    this.RotationalDisplacementRX = RotationalDisplacementRX;
    this.RotationalDisplacementRY = RotationalDisplacementRY;
    this.RotationalDisplacementRZ = RotationalDisplacementRZ;
    this.Distortion = Distortion;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DisplacementX = tape[ptr++];
    let DisplacementY = tape[ptr++];
    let DisplacementZ = tape[ptr++];
    let RotationalDisplacementRX = tape[ptr++];
    let RotationalDisplacementRY = tape[ptr++];
    let RotationalDisplacementRZ = tape[ptr++];
    let Distortion = tape[ptr++];
    return new IfcStructuralLoadSingleDisplacementDistortion(expressID, type, Name, DisplacementX, DisplacementY, DisplacementZ, RotationalDisplacementRX, RotationalDisplacementRY, RotationalDisplacementRZ, Distortion);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.DisplacementX);
    ;
    args.push(this.DisplacementY);
    ;
    args.push(this.DisplacementZ);
    ;
    args.push(this.RotationalDisplacementRX);
    ;
    args.push(this.RotationalDisplacementRY);
    ;
    args.push(this.RotationalDisplacementRZ);
    ;
    args.push(this.Distortion);
    ;
    return args;
  }
}, "IfcStructuralLoadSingleDisplacementDistortion");
var IfcStructuralLoadSingleForce = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, ForceX, ForceY, ForceZ, MomentX, MomentY, MomentZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.ForceX = ForceX;
    this.ForceY = ForceY;
    this.ForceZ = ForceZ;
    this.MomentX = MomentX;
    this.MomentY = MomentY;
    this.MomentZ = MomentZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let ForceX = tape[ptr++];
    let ForceY = tape[ptr++];
    let ForceZ = tape[ptr++];
    let MomentX = tape[ptr++];
    let MomentY = tape[ptr++];
    let MomentZ = tape[ptr++];
    return new IfcStructuralLoadSingleForce(expressID, type, Name, ForceX, ForceY, ForceZ, MomentX, MomentY, MomentZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.ForceX);
    ;
    args.push(this.ForceY);
    ;
    args.push(this.ForceZ);
    ;
    args.push(this.MomentX);
    ;
    args.push(this.MomentY);
    ;
    args.push(this.MomentZ);
    ;
    return args;
  }
}, "IfcStructuralLoadSingleForce");
var IfcStructuralLoadSingleForceWarping = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, ForceX, ForceY, ForceZ, MomentX, MomentY, MomentZ, WarpingMoment) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.ForceX = ForceX;
    this.ForceY = ForceY;
    this.ForceZ = ForceZ;
    this.MomentX = MomentX;
    this.MomentY = MomentY;
    this.MomentZ = MomentZ;
    this.WarpingMoment = WarpingMoment;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let ForceX = tape[ptr++];
    let ForceY = tape[ptr++];
    let ForceZ = tape[ptr++];
    let MomentX = tape[ptr++];
    let MomentY = tape[ptr++];
    let MomentZ = tape[ptr++];
    let WarpingMoment = tape[ptr++];
    return new IfcStructuralLoadSingleForceWarping(expressID, type, Name, ForceX, ForceY, ForceZ, MomentX, MomentY, MomentZ, WarpingMoment);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.ForceX);
    ;
    args.push(this.ForceY);
    ;
    args.push(this.ForceZ);
    ;
    args.push(this.MomentX);
    ;
    args.push(this.MomentY);
    ;
    args.push(this.MomentZ);
    ;
    args.push(this.WarpingMoment);
    ;
    return args;
  }
}, "IfcStructuralLoadSingleForceWarping");
var IfcStructuralLoadStatic = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcStructuralLoadStatic(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    return args;
  }
}, "IfcStructuralLoadStatic");
var IfcStructuralLoadTemperature = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, DeltaTConstant, DeltaTY, DeltaTZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DeltaTConstant = DeltaTConstant;
    this.DeltaTY = DeltaTY;
    this.DeltaTZ = DeltaTZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DeltaTConstant = tape[ptr++];
    let DeltaTY = tape[ptr++];
    let DeltaTZ = tape[ptr++];
    return new IfcStructuralLoadTemperature(expressID, type, Name, DeltaTConstant, DeltaTY, DeltaTZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.DeltaTConstant);
    ;
    args.push(this.DeltaTY);
    ;
    args.push(this.DeltaTZ);
    ;
    return args;
  }
}, "IfcStructuralLoadTemperature");
var IfcStructuralMember = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    return new IfcStructuralMember(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    return args;
  }
}, "IfcStructuralMember");
var IfcStructuralPlanarAction = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
    this.DestabilizingLoad = DestabilizingLoad;
    this.ProjectedOrTrue = ProjectedOrTrue;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    let DestabilizingLoad = tape[ptr++];
    let ProjectedOrTrue = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStructuralPlanarAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.AppliedLoad);
    ;
    args.push(this.GlobalOrLocal);
    ;
    args.push(this.DestabilizingLoad);
    ;
    args.push(this.ProjectedOrTrue);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcStructuralPlanarAction");
var IfcStructuralPointAction = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
    this.DestabilizingLoad = DestabilizingLoad;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    let DestabilizingLoad = tape[ptr++];
    return new IfcStructuralPointAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.AppliedLoad);
    ;
    args.push(this.GlobalOrLocal);
    ;
    args.push(this.DestabilizingLoad);
    ;
    return args;
  }
}, "IfcStructuralPointAction");
var IfcStructuralPointConnection = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition, ConditionCoordinateSystem) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedCondition = AppliedCondition;
    this.ConditionCoordinateSystem = ConditionCoordinateSystem;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedCondition = tape[ptr++];
    let ConditionCoordinateSystem = tape[ptr++];
    return new IfcStructuralPointConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition, ConditionCoordinateSystem);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.AppliedCondition);
    ;
    args.push(this.ConditionCoordinateSystem);
    ;
    return args;
  }
}, "IfcStructuralPointConnection");
var IfcStructuralPointReaction = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    return new IfcStructuralPointReaction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.AppliedLoad);
    ;
    args.push(this.GlobalOrLocal);
    ;
    return args;
  }
}, "IfcStructuralPointReaction");
var IfcStructuralReaction = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    return new IfcStructuralReaction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.AppliedLoad);
    ;
    args.push(this.GlobalOrLocal);
    ;
    return args;
  }
}, "IfcStructuralReaction");
var IfcStructuralResultGroup = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheoryType, ResultForLoadGroup, IsLinear) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.TheoryType = TheoryType;
    this.ResultForLoadGroup = ResultForLoadGroup;
    this.IsLinear = IsLinear;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let TheoryType = tape[ptr++];
    let ResultForLoadGroup = tape[ptr++];
    let IsLinear = tape[ptr++];
    return new IfcStructuralResultGroup(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheoryType, ResultForLoadGroup, IsLinear);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.TheoryType);
    ;
    args.push(this.ResultForLoadGroup);
    ;
    args.push(this.IsLinear);
    ;
    return args;
  }
}, "IfcStructuralResultGroup");
var IfcStructuralSurfaceAction = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
    this.DestabilizingLoad = DestabilizingLoad;
    this.ProjectedOrTrue = ProjectedOrTrue;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    let DestabilizingLoad = tape[ptr++];
    let ProjectedOrTrue = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStructuralSurfaceAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.AppliedLoad);
    ;
    args.push(this.GlobalOrLocal);
    ;
    args.push(this.DestabilizingLoad);
    ;
    args.push(this.ProjectedOrTrue);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcStructuralSurfaceAction");
var IfcStructuralSurfaceConnection = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedCondition = AppliedCondition;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedCondition = tape[ptr++];
    return new IfcStructuralSurfaceConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.AppliedCondition);
    ;
    return args;
  }
}, "IfcStructuralSurfaceConnection");
var IfcStructuralSurfaceMember = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Thickness) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.PredefinedType = PredefinedType;
    this.Thickness = Thickness;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Thickness = tape[ptr++];
    return new IfcStructuralSurfaceMember(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Thickness);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.Thickness);
    ;
    return args;
  }
}, "IfcStructuralSurfaceMember");
var IfcStructuralSurfaceMemberVarying = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Thickness) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.PredefinedType = PredefinedType;
    this.Thickness = Thickness;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Thickness = tape[ptr++];
    return new IfcStructuralSurfaceMemberVarying(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Thickness);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.Thickness);
    ;
    return args;
  }
}, "IfcStructuralSurfaceMemberVarying");
var IfcStructuralSurfaceReaction = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStructuralSurfaceReaction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.AppliedLoad);
    ;
    args.push(this.GlobalOrLocal);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcStructuralSurfaceReaction");
var IfcStyleModel = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
    this.expressID = expressID;
    this.type = type;
    this.ContextOfItems = ContextOfItems;
    this.RepresentationIdentifier = RepresentationIdentifier;
    this.RepresentationType = RepresentationType;
    this.Items = Items;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextOfItems = tape[ptr++];
    let RepresentationIdentifier = tape[ptr++];
    let RepresentationType = tape[ptr++];
    let Items = tape[ptr++];
    return new IfcStyleModel(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextOfItems);
    ;
    args.push(this.RepresentationIdentifier);
    ;
    args.push(this.RepresentationType);
    ;
    args.push(this.Items);
    ;
    return args;
  }
}, "IfcStyleModel");
var IfcStyledItem = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Item, Styles, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Item = Item;
    this.Styles = Styles;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Item = tape[ptr++];
    let Styles = tape[ptr++];
    let Name = tape[ptr++];
    return new IfcStyledItem(expressID, type, Item, Styles, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Item);
    ;
    args.push(this.Styles);
    ;
    args.push(this.Name);
    ;
    return args;
  }
}, "IfcStyledItem");
var IfcStyledRepresentation = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
    this.expressID = expressID;
    this.type = type;
    this.ContextOfItems = ContextOfItems;
    this.RepresentationIdentifier = RepresentationIdentifier;
    this.RepresentationType = RepresentationType;
    this.Items = Items;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextOfItems = tape[ptr++];
    let RepresentationIdentifier = tape[ptr++];
    let RepresentationType = tape[ptr++];
    let Items = tape[ptr++];
    return new IfcStyledRepresentation(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextOfItems);
    ;
    args.push(this.RepresentationIdentifier);
    ;
    args.push(this.RepresentationType);
    ;
    args.push(this.Items);
    ;
    return args;
  }
}, "IfcStyledRepresentation");
var IfcSubContractResource = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.Usage = Usage;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let Usage = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSubContractResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.Usage);
    ;
    args.push(this.BaseCosts);
    ;
    args.push(this.BaseQuantity);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcSubContractResource");
var IfcSubContractResourceType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ResourceType = ResourceType;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ResourceType = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSubContractResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.ResourceType);
    ;
    args.push(this.BaseCosts);
    ;
    args.push(this.BaseQuantity);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcSubContractResourceType");
var IfcSubedge = /* @__PURE__ */ __name(class {
  constructor(expressID, type, EdgeStart, EdgeEnd, ParentEdge) {
    this.expressID = expressID;
    this.type = type;
    this.EdgeStart = EdgeStart;
    this.EdgeEnd = EdgeEnd;
    this.ParentEdge = ParentEdge;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let EdgeStart = tape[ptr++];
    let EdgeEnd = tape[ptr++];
    let ParentEdge = tape[ptr++];
    return new IfcSubedge(expressID, type, EdgeStart, EdgeEnd, ParentEdge);
  }
  ToTape() {
    let args = [];
    args.push(this.EdgeStart);
    ;
    args.push(this.EdgeEnd);
    ;
    args.push(this.ParentEdge);
    ;
    return args;
  }
}, "IfcSubedge");
var IfcSurface = /* @__PURE__ */ __name(class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcSurface(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
}, "IfcSurface");
var IfcSurfaceCurve = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation) {
    this.expressID = expressID;
    this.type = type;
    this.Curve3D = Curve3D;
    this.AssociatedGeometry = AssociatedGeometry;
    this.MasterRepresentation = MasterRepresentation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Curve3D = tape[ptr++];
    let AssociatedGeometry = tape[ptr++];
    let MasterRepresentation = tape[ptr++];
    return new IfcSurfaceCurve(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation);
  }
  ToTape() {
    let args = [];
    args.push(this.Curve3D);
    ;
    args.push(this.AssociatedGeometry);
    ;
    args.push(this.MasterRepresentation);
    ;
    return args;
  }
}, "IfcSurfaceCurve");
var IfcSurfaceCurveSweptAreaSolid = /* @__PURE__ */ __name(class {
  constructor(expressID, type, SweptArea, Position, Directrix, StartParam, EndParam, ReferenceSurface) {
    this.expressID = expressID;
    this.type = type;
    this.SweptArea = SweptArea;
    this.Position = Position;
    this.Directrix = Directrix;
    this.StartParam = StartParam;
    this.EndParam = EndParam;
    this.ReferenceSurface = ReferenceSurface;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptArea = tape[ptr++];
    let Position = tape[ptr++];
    let Directrix = tape[ptr++];
    let StartParam = tape[ptr++];
    let EndParam = tape[ptr++];
    let ReferenceSurface = tape[ptr++];
    return new IfcSurfaceCurveSweptAreaSolid(expressID, type, SweptArea, Position, Directrix, StartParam, EndParam, ReferenceSurface);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptArea);
    ;
    args.push(this.Position);
    ;
    args.push(this.Directrix);
    ;
    args.push(this.StartParam);
    ;
    args.push(this.EndParam);
    ;
    args.push(this.ReferenceSurface);
    ;
    return args;
  }
}, "IfcSurfaceCurveSweptAreaSolid");
var IfcSurfaceFeature = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSurfaceFeature(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcSurfaceFeature");
var IfcSurfaceOfLinearExtrusion = /* @__PURE__ */ __name(class {
  constructor(expressID, type, SweptCurve, Position, ExtrudedDirection, Depth) {
    this.expressID = expressID;
    this.type = type;
    this.SweptCurve = SweptCurve;
    this.Position = Position;
    this.ExtrudedDirection = ExtrudedDirection;
    this.Depth = Depth;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptCurve = tape[ptr++];
    let Position = tape[ptr++];
    let ExtrudedDirection = tape[ptr++];
    let Depth = tape[ptr++];
    return new IfcSurfaceOfLinearExtrusion(expressID, type, SweptCurve, Position, ExtrudedDirection, Depth);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptCurve);
    ;
    args.push(this.Position);
    ;
    args.push(this.ExtrudedDirection);
    ;
    args.push(this.Depth);
    ;
    return args;
  }
}, "IfcSurfaceOfLinearExtrusion");
var IfcSurfaceOfRevolution = /* @__PURE__ */ __name(class {
  constructor(expressID, type, SweptCurve, Position, AxisPosition) {
    this.expressID = expressID;
    this.type = type;
    this.SweptCurve = SweptCurve;
    this.Position = Position;
    this.AxisPosition = AxisPosition;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptCurve = tape[ptr++];
    let Position = tape[ptr++];
    let AxisPosition = tape[ptr++];
    return new IfcSurfaceOfRevolution(expressID, type, SweptCurve, Position, AxisPosition);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptCurve);
    ;
    args.push(this.Position);
    ;
    args.push(this.AxisPosition);
    ;
    return args;
  }
}, "IfcSurfaceOfRevolution");
var IfcSurfaceReinforcementArea = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, SurfaceReinforcement1, SurfaceReinforcement2, ShearReinforcement) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.SurfaceReinforcement1 = SurfaceReinforcement1;
    this.SurfaceReinforcement2 = SurfaceReinforcement2;
    this.ShearReinforcement = ShearReinforcement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let SurfaceReinforcement1 = tape[ptr++];
    let SurfaceReinforcement2 = tape[ptr++];
    let ShearReinforcement = tape[ptr++];
    return new IfcSurfaceReinforcementArea(expressID, type, Name, SurfaceReinforcement1, SurfaceReinforcement2, ShearReinforcement);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.SurfaceReinforcement1);
    ;
    args.push(this.SurfaceReinforcement2);
    ;
    args.push(this.ShearReinforcement);
    ;
    return args;
  }
}, "IfcSurfaceReinforcementArea");
var IfcSurfaceStyle = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Side, Styles) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Side = Side;
    this.Styles = Styles;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Side = tape[ptr++];
    let Styles = tape[ptr++];
    return new IfcSurfaceStyle(expressID, type, Name, Side, Styles);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Side);
    ;
    args.push(this.Styles);
    ;
    return args;
  }
}, "IfcSurfaceStyle");
var IfcSurfaceStyleLighting = /* @__PURE__ */ __name(class {
  constructor(expressID, type, DiffuseTransmissionColour, DiffuseReflectionColour, TransmissionColour, ReflectanceColour) {
    this.expressID = expressID;
    this.type = type;
    this.DiffuseTransmissionColour = DiffuseTransmissionColour;
    this.DiffuseReflectionColour = DiffuseReflectionColour;
    this.TransmissionColour = TransmissionColour;
    this.ReflectanceColour = ReflectanceColour;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let DiffuseTransmissionColour = tape[ptr++];
    let DiffuseReflectionColour = tape[ptr++];
    let TransmissionColour = tape[ptr++];
    let ReflectanceColour = tape[ptr++];
    return new IfcSurfaceStyleLighting(expressID, type, DiffuseTransmissionColour, DiffuseReflectionColour, TransmissionColour, ReflectanceColour);
  }
  ToTape() {
    let args = [];
    args.push(this.DiffuseTransmissionColour);
    ;
    args.push(this.DiffuseReflectionColour);
    ;
    args.push(this.TransmissionColour);
    ;
    args.push(this.ReflectanceColour);
    ;
    return args;
  }
}, "IfcSurfaceStyleLighting");
var IfcSurfaceStyleRefraction = /* @__PURE__ */ __name(class {
  constructor(expressID, type, RefractionIndex, DispersionFactor) {
    this.expressID = expressID;
    this.type = type;
    this.RefractionIndex = RefractionIndex;
    this.DispersionFactor = DispersionFactor;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let RefractionIndex = tape[ptr++];
    let DispersionFactor = tape[ptr++];
    return new IfcSurfaceStyleRefraction(expressID, type, RefractionIndex, DispersionFactor);
  }
  ToTape() {
    let args = [];
    args.push(this.RefractionIndex);
    ;
    args.push(this.DispersionFactor);
    ;
    return args;
  }
}, "IfcSurfaceStyleRefraction");
var IfcSurfaceStyleRendering = /* @__PURE__ */ __name(class {
  constructor(expressID, type, SurfaceColour, Transparency, DiffuseColour, TransmissionColour, DiffuseTransmissionColour, ReflectionColour, SpecularColour, SpecularHighlight, ReflectanceMethod) {
    this.expressID = expressID;
    this.type = type;
    this.SurfaceColour = SurfaceColour;
    this.Transparency = Transparency;
    this.DiffuseColour = DiffuseColour;
    this.TransmissionColour = TransmissionColour;
    this.DiffuseTransmissionColour = DiffuseTransmissionColour;
    this.ReflectionColour = ReflectionColour;
    this.SpecularColour = SpecularColour;
    this.SpecularHighlight = SpecularHighlight;
    this.ReflectanceMethod = ReflectanceMethod;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SurfaceColour = tape[ptr++];
    let Transparency = tape[ptr++];
    let DiffuseColour = tape[ptr++];
    let TransmissionColour = tape[ptr++];
    let DiffuseTransmissionColour = tape[ptr++];
    let ReflectionColour = tape[ptr++];
    let SpecularColour = tape[ptr++];
    let SpecularHighlight = tape[ptr++];
    let ReflectanceMethod = tape[ptr++];
    return new IfcSurfaceStyleRendering(expressID, type, SurfaceColour, Transparency, DiffuseColour, TransmissionColour, DiffuseTransmissionColour, ReflectionColour, SpecularColour, SpecularHighlight, ReflectanceMethod);
  }
  ToTape() {
    let args = [];
    args.push(this.SurfaceColour);
    ;
    args.push(this.Transparency);
    ;
    args.push(this.DiffuseColour);
    ;
    args.push(this.TransmissionColour);
    ;
    args.push(this.DiffuseTransmissionColour);
    ;
    args.push(this.ReflectionColour);
    ;
    args.push(this.SpecularColour);
    ;
    args.push(this.SpecularHighlight);
    ;
    args.push(this.ReflectanceMethod);
    ;
    return args;
  }
}, "IfcSurfaceStyleRendering");
var IfcSurfaceStyleShading = /* @__PURE__ */ __name(class {
  constructor(expressID, type, SurfaceColour, Transparency) {
    this.expressID = expressID;
    this.type = type;
    this.SurfaceColour = SurfaceColour;
    this.Transparency = Transparency;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SurfaceColour = tape[ptr++];
    let Transparency = tape[ptr++];
    return new IfcSurfaceStyleShading(expressID, type, SurfaceColour, Transparency);
  }
  ToTape() {
    let args = [];
    args.push(this.SurfaceColour);
    ;
    args.push(this.Transparency);
    ;
    return args;
  }
}, "IfcSurfaceStyleShading");
var IfcSurfaceStyleWithTextures = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Textures) {
    this.expressID = expressID;
    this.type = type;
    this.Textures = Textures;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Textures = tape[ptr++];
    return new IfcSurfaceStyleWithTextures(expressID, type, Textures);
  }
  ToTape() {
    let args = [];
    args.push(this.Textures);
    ;
    return args;
  }
}, "IfcSurfaceStyleWithTextures");
var IfcSurfaceTexture = /* @__PURE__ */ __name(class {
  constructor(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter) {
    this.expressID = expressID;
    this.type = type;
    this.RepeatS = RepeatS;
    this.RepeatT = RepeatT;
    this.Mode = Mode;
    this.TextureTransform = TextureTransform;
    this.Parameter = Parameter;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let RepeatS = tape[ptr++];
    let RepeatT = tape[ptr++];
    let Mode = tape[ptr++];
    let TextureTransform = tape[ptr++];
    let Parameter = tape[ptr++];
    return new IfcSurfaceTexture(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter);
  }
  ToTape() {
    let args = [];
    args.push(this.RepeatS);
    ;
    args.push(this.RepeatT);
    ;
    args.push(this.Mode);
    ;
    args.push(this.TextureTransform);
    ;
    args.push(this.Parameter);
    ;
    return args;
  }
}, "IfcSurfaceTexture");
var IfcSweptAreaSolid = /* @__PURE__ */ __name(class {
  constructor(expressID, type, SweptArea, Position) {
    this.expressID = expressID;
    this.type = type;
    this.SweptArea = SweptArea;
    this.Position = Position;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptArea = tape[ptr++];
    let Position = tape[ptr++];
    return new IfcSweptAreaSolid(expressID, type, SweptArea, Position);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptArea);
    ;
    args.push(this.Position);
    ;
    return args;
  }
}, "IfcSweptAreaSolid");
var IfcSweptDiskSolid = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Directrix, Radius, InnerRadius, StartParam, EndParam) {
    this.expressID = expressID;
    this.type = type;
    this.Directrix = Directrix;
    this.Radius = Radius;
    this.InnerRadius = InnerRadius;
    this.StartParam = StartParam;
    this.EndParam = EndParam;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Directrix = tape[ptr++];
    let Radius = tape[ptr++];
    let InnerRadius = tape[ptr++];
    let StartParam = tape[ptr++];
    let EndParam = tape[ptr++];
    return new IfcSweptDiskSolid(expressID, type, Directrix, Radius, InnerRadius, StartParam, EndParam);
  }
  ToTape() {
    let args = [];
    args.push(this.Directrix);
    ;
    args.push(this.Radius);
    ;
    args.push(this.InnerRadius);
    ;
    args.push(this.StartParam);
    ;
    args.push(this.EndParam);
    ;
    return args;
  }
}, "IfcSweptDiskSolid");
var IfcSweptDiskSolidPolygonal = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Directrix, Radius, InnerRadius, StartParam, EndParam, FilletRadius) {
    this.expressID = expressID;
    this.type = type;
    this.Directrix = Directrix;
    this.Radius = Radius;
    this.InnerRadius = InnerRadius;
    this.StartParam = StartParam;
    this.EndParam = EndParam;
    this.FilletRadius = FilletRadius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Directrix = tape[ptr++];
    let Radius = tape[ptr++];
    let InnerRadius = tape[ptr++];
    let StartParam = tape[ptr++];
    let EndParam = tape[ptr++];
    let FilletRadius = tape[ptr++];
    return new IfcSweptDiskSolidPolygonal(expressID, type, Directrix, Radius, InnerRadius, StartParam, EndParam, FilletRadius);
  }
  ToTape() {
    let args = [];
    args.push(this.Directrix);
    ;
    args.push(this.Radius);
    ;
    args.push(this.InnerRadius);
    ;
    args.push(this.StartParam);
    ;
    args.push(this.EndParam);
    ;
    args.push(this.FilletRadius);
    ;
    return args;
  }
}, "IfcSweptDiskSolidPolygonal");
var IfcSweptSurface = /* @__PURE__ */ __name(class {
  constructor(expressID, type, SweptCurve, Position) {
    this.expressID = expressID;
    this.type = type;
    this.SweptCurve = SweptCurve;
    this.Position = Position;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptCurve = tape[ptr++];
    let Position = tape[ptr++];
    return new IfcSweptSurface(expressID, type, SweptCurve, Position);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptCurve);
    ;
    args.push(this.Position);
    ;
    return args;
  }
}, "IfcSweptSurface");
var IfcSwitchingDevice = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSwitchingDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcSwitchingDevice");
var IfcSwitchingDeviceType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSwitchingDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcSwitchingDeviceType");
var IfcSystem = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    return new IfcSystem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    return args;
  }
}, "IfcSystem");
var IfcSystemFurnitureElement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSystemFurnitureElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcSystemFurnitureElement");
var IfcSystemFurnitureElementType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSystemFurnitureElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcSystemFurnitureElementType");
var IfcTShapeProfileDef = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, FlangeEdgeRadius, WebEdgeRadius, WebSlope, FlangeSlope) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.Depth = Depth;
    this.FlangeWidth = FlangeWidth;
    this.WebThickness = WebThickness;
    this.FlangeThickness = FlangeThickness;
    this.FilletRadius = FilletRadius;
    this.FlangeEdgeRadius = FlangeEdgeRadius;
    this.WebEdgeRadius = WebEdgeRadius;
    this.WebSlope = WebSlope;
    this.FlangeSlope = FlangeSlope;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let Depth = tape[ptr++];
    let FlangeWidth = tape[ptr++];
    let WebThickness = tape[ptr++];
    let FlangeThickness = tape[ptr++];
    let FilletRadius = tape[ptr++];
    let FlangeEdgeRadius = tape[ptr++];
    let WebEdgeRadius = tape[ptr++];
    let WebSlope = tape[ptr++];
    let FlangeSlope = tape[ptr++];
    return new IfcTShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, FlangeEdgeRadius, WebEdgeRadius, WebSlope, FlangeSlope);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Position);
    ;
    args.push(this.Depth);
    ;
    args.push(this.FlangeWidth);
    ;
    args.push(this.WebThickness);
    ;
    args.push(this.FlangeThickness);
    ;
    args.push(this.FilletRadius);
    ;
    args.push(this.FlangeEdgeRadius);
    ;
    args.push(this.WebEdgeRadius);
    ;
    args.push(this.WebSlope);
    ;
    args.push(this.FlangeSlope);
    ;
    return args;
  }
}, "IfcTShapeProfileDef");
var IfcTable = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Rows, Columns) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Rows = Rows;
    this.Columns = Columns;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Rows = tape[ptr++];
    let Columns = tape[ptr++];
    return new IfcTable(expressID, type, Name, Rows, Columns);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Rows);
    ;
    args.push(this.Columns);
    ;
    return args;
  }
}, "IfcTable");
var IfcTableColumn = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Identifier, Name, Description, Unit, ReferencePath) {
    this.expressID = expressID;
    this.type = type;
    this.Identifier = Identifier;
    this.Name = Name;
    this.Description = Description;
    this.Unit = Unit;
    this.ReferencePath = ReferencePath;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Identifier = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Unit = tape[ptr++];
    let ReferencePath = tape[ptr++];
    return new IfcTableColumn(expressID, type, Identifier, Name, Description, Unit, ReferencePath);
  }
  ToTape() {
    let args = [];
    args.push(this.Identifier);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.Unit);
    ;
    args.push(this.ReferencePath);
    ;
    return args;
  }
}, "IfcTableColumn");
var IfcTableRow = /* @__PURE__ */ __name(class {
  constructor(expressID, type, RowCells, IsHeading) {
    this.expressID = expressID;
    this.type = type;
    this.RowCells = RowCells;
    this.IsHeading = IsHeading;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let RowCells = tape[ptr++];
    let IsHeading = tape[ptr++];
    return new IfcTableRow(expressID, type, RowCells, IsHeading);
  }
  ToTape() {
    let args = [];
    args.push(this.RowCells);
    ;
    args.push(this.IsHeading);
    ;
    return args;
  }
}, "IfcTableRow");
var IfcTank = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTank(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcTank");
var IfcTankType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTankType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcTankType");
var IfcTask = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Status, WorkMethod, IsMilestone, Priority, TaskTime, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.Status = Status;
    this.WorkMethod = WorkMethod;
    this.IsMilestone = IsMilestone;
    this.Priority = Priority;
    this.TaskTime = TaskTime;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let Status = tape[ptr++];
    let WorkMethod = tape[ptr++];
    let IsMilestone = tape[ptr++];
    let Priority = tape[ptr++];
    let TaskTime = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTask(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Status, WorkMethod, IsMilestone, Priority, TaskTime, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.Status);
    ;
    args.push(this.WorkMethod);
    ;
    args.push(this.IsMilestone);
    ;
    args.push(this.Priority);
    ;
    args.push(this.TaskTime);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcTask");
var IfcTaskTime = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, DurationType, ScheduleDuration, ScheduleStart, ScheduleFinish, EarlyStart, EarlyFinish, LateStart, LateFinish, FreeFloat, TotalFloat, IsCritical, StatusTime, ActualDuration, ActualStart, ActualFinish, RemainingTime, Completion) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.DurationType = DurationType;
    this.ScheduleDuration = ScheduleDuration;
    this.ScheduleStart = ScheduleStart;
    this.ScheduleFinish = ScheduleFinish;
    this.EarlyStart = EarlyStart;
    this.EarlyFinish = EarlyFinish;
    this.LateStart = LateStart;
    this.LateFinish = LateFinish;
    this.FreeFloat = FreeFloat;
    this.TotalFloat = TotalFloat;
    this.IsCritical = IsCritical;
    this.StatusTime = StatusTime;
    this.ActualDuration = ActualDuration;
    this.ActualStart = ActualStart;
    this.ActualFinish = ActualFinish;
    this.RemainingTime = RemainingTime;
    this.Completion = Completion;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let DurationType = tape[ptr++];
    let ScheduleDuration = tape[ptr++];
    let ScheduleStart = tape[ptr++];
    let ScheduleFinish = tape[ptr++];
    let EarlyStart = tape[ptr++];
    let EarlyFinish = tape[ptr++];
    let LateStart = tape[ptr++];
    let LateFinish = tape[ptr++];
    let FreeFloat = tape[ptr++];
    let TotalFloat = tape[ptr++];
    let IsCritical = tape[ptr++];
    let StatusTime = tape[ptr++];
    let ActualDuration = tape[ptr++];
    let ActualStart = tape[ptr++];
    let ActualFinish = tape[ptr++];
    let RemainingTime = tape[ptr++];
    let Completion = tape[ptr++];
    return new IfcTaskTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, DurationType, ScheduleDuration, ScheduleStart, ScheduleFinish, EarlyStart, EarlyFinish, LateStart, LateFinish, FreeFloat, TotalFloat, IsCritical, StatusTime, ActualDuration, ActualStart, ActualFinish, RemainingTime, Completion);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.DataOrigin);
    ;
    args.push(this.UserDefinedDataOrigin);
    ;
    args.push(this.DurationType);
    ;
    args.push(this.ScheduleDuration);
    ;
    args.push(this.ScheduleStart);
    ;
    args.push(this.ScheduleFinish);
    ;
    args.push(this.EarlyStart);
    ;
    args.push(this.EarlyFinish);
    ;
    args.push(this.LateStart);
    ;
    args.push(this.LateFinish);
    ;
    args.push(this.FreeFloat);
    ;
    args.push(this.TotalFloat);
    ;
    args.push(this.IsCritical);
    ;
    args.push(this.StatusTime);
    ;
    args.push(this.ActualDuration);
    ;
    args.push(this.ActualStart);
    ;
    args.push(this.ActualFinish);
    ;
    args.push(this.RemainingTime);
    ;
    args.push(this.Completion);
    ;
    return args;
  }
}, "IfcTaskTime");
var IfcTaskTimeRecurring = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, DurationType, ScheduleDuration, ScheduleStart, ScheduleFinish, EarlyStart, EarlyFinish, LateStart, LateFinish, FreeFloat, TotalFloat, IsCritical, StatusTime, ActualDuration, ActualStart, ActualFinish, RemainingTime, Completion, Recurrence) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.DurationType = DurationType;
    this.ScheduleDuration = ScheduleDuration;
    this.ScheduleStart = ScheduleStart;
    this.ScheduleFinish = ScheduleFinish;
    this.EarlyStart = EarlyStart;
    this.EarlyFinish = EarlyFinish;
    this.LateStart = LateStart;
    this.LateFinish = LateFinish;
    this.FreeFloat = FreeFloat;
    this.TotalFloat = TotalFloat;
    this.IsCritical = IsCritical;
    this.StatusTime = StatusTime;
    this.ActualDuration = ActualDuration;
    this.ActualStart = ActualStart;
    this.ActualFinish = ActualFinish;
    this.RemainingTime = RemainingTime;
    this.Completion = Completion;
    this.Recurrence = Recurrence;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let DurationType = tape[ptr++];
    let ScheduleDuration = tape[ptr++];
    let ScheduleStart = tape[ptr++];
    let ScheduleFinish = tape[ptr++];
    let EarlyStart = tape[ptr++];
    let EarlyFinish = tape[ptr++];
    let LateStart = tape[ptr++];
    let LateFinish = tape[ptr++];
    let FreeFloat = tape[ptr++];
    let TotalFloat = tape[ptr++];
    let IsCritical = tape[ptr++];
    let StatusTime = tape[ptr++];
    let ActualDuration = tape[ptr++];
    let ActualStart = tape[ptr++];
    let ActualFinish = tape[ptr++];
    let RemainingTime = tape[ptr++];
    let Completion = tape[ptr++];
    let Recurrence = tape[ptr++];
    return new IfcTaskTimeRecurring(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, DurationType, ScheduleDuration, ScheduleStart, ScheduleFinish, EarlyStart, EarlyFinish, LateStart, LateFinish, FreeFloat, TotalFloat, IsCritical, StatusTime, ActualDuration, ActualStart, ActualFinish, RemainingTime, Completion, Recurrence);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.DataOrigin);
    ;
    args.push(this.UserDefinedDataOrigin);
    ;
    args.push(this.DurationType);
    ;
    args.push(this.ScheduleDuration);
    ;
    args.push(this.ScheduleStart);
    ;
    args.push(this.ScheduleFinish);
    ;
    args.push(this.EarlyStart);
    ;
    args.push(this.EarlyFinish);
    ;
    args.push(this.LateStart);
    ;
    args.push(this.LateFinish);
    ;
    args.push(this.FreeFloat);
    ;
    args.push(this.TotalFloat);
    ;
    args.push(this.IsCritical);
    ;
    args.push(this.StatusTime);
    ;
    args.push(this.ActualDuration);
    ;
    args.push(this.ActualStart);
    ;
    args.push(this.ActualFinish);
    ;
    args.push(this.RemainingTime);
    ;
    args.push(this.Completion);
    ;
    args.push(this.Recurrence);
    ;
    return args;
  }
}, "IfcTaskTimeRecurring");
var IfcTaskType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType, WorkMethod) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ProcessType = ProcessType;
    this.PredefinedType = PredefinedType;
    this.WorkMethod = WorkMethod;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ProcessType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let WorkMethod = tape[ptr++];
    return new IfcTaskType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType, WorkMethod);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.ProcessType);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.WorkMethod);
    ;
    return args;
  }
}, "IfcTaskType");
var IfcTelecomAddress = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Purpose, Description, UserDefinedPurpose, TelephoneNumbers, FacsimileNumbers, PagerNumber, ElectronicMailAddresses, WWWHomePageURL, MessagingIDs) {
    this.expressID = expressID;
    this.type = type;
    this.Purpose = Purpose;
    this.Description = Description;
    this.UserDefinedPurpose = UserDefinedPurpose;
    this.TelephoneNumbers = TelephoneNumbers;
    this.FacsimileNumbers = FacsimileNumbers;
    this.PagerNumber = PagerNumber;
    this.ElectronicMailAddresses = ElectronicMailAddresses;
    this.WWWHomePageURL = WWWHomePageURL;
    this.MessagingIDs = MessagingIDs;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Purpose = tape[ptr++];
    let Description = tape[ptr++];
    let UserDefinedPurpose = tape[ptr++];
    let TelephoneNumbers = tape[ptr++];
    let FacsimileNumbers = tape[ptr++];
    let PagerNumber = tape[ptr++];
    let ElectronicMailAddresses = tape[ptr++];
    let WWWHomePageURL = tape[ptr++];
    let MessagingIDs = tape[ptr++];
    return new IfcTelecomAddress(expressID, type, Purpose, Description, UserDefinedPurpose, TelephoneNumbers, FacsimileNumbers, PagerNumber, ElectronicMailAddresses, WWWHomePageURL, MessagingIDs);
  }
  ToTape() {
    let args = [];
    args.push(this.Purpose);
    ;
    args.push(this.Description);
    ;
    args.push(this.UserDefinedPurpose);
    ;
    args.push(this.TelephoneNumbers);
    ;
    args.push(this.FacsimileNumbers);
    ;
    args.push(this.PagerNumber);
    ;
    args.push(this.ElectronicMailAddresses);
    ;
    args.push(this.WWWHomePageURL);
    ;
    args.push(this.MessagingIDs);
    ;
    return args;
  }
}, "IfcTelecomAddress");
var IfcTendon = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType, NominalDiameter, CrossSectionArea, TensionForce, PreStress, FrictionCoefficient, AnchorageSlip, MinCurvatureRadius) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.SteelGrade = SteelGrade;
    this.PredefinedType = PredefinedType;
    this.NominalDiameter = NominalDiameter;
    this.CrossSectionArea = CrossSectionArea;
    this.TensionForce = TensionForce;
    this.PreStress = PreStress;
    this.FrictionCoefficient = FrictionCoefficient;
    this.AnchorageSlip = AnchorageSlip;
    this.MinCurvatureRadius = MinCurvatureRadius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let SteelGrade = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let NominalDiameter = tape[ptr++];
    let CrossSectionArea = tape[ptr++];
    let TensionForce = tape[ptr++];
    let PreStress = tape[ptr++];
    let FrictionCoefficient = tape[ptr++];
    let AnchorageSlip = tape[ptr++];
    let MinCurvatureRadius = tape[ptr++];
    return new IfcTendon(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType, NominalDiameter, CrossSectionArea, TensionForce, PreStress, FrictionCoefficient, AnchorageSlip, MinCurvatureRadius);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.SteelGrade);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.NominalDiameter);
    ;
    args.push(this.CrossSectionArea);
    ;
    args.push(this.TensionForce);
    ;
    args.push(this.PreStress);
    ;
    args.push(this.FrictionCoefficient);
    ;
    args.push(this.AnchorageSlip);
    ;
    args.push(this.MinCurvatureRadius);
    ;
    return args;
  }
}, "IfcTendon");
var IfcTendonAnchor = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.SteelGrade = SteelGrade;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let SteelGrade = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTendonAnchor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.SteelGrade);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcTendonAnchor");
var IfcTendonAnchorType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTendonAnchorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcTendonAnchorType");
var IfcTendonConduit = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.SteelGrade = SteelGrade;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let SteelGrade = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTendonConduit(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.SteelGrade);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcTendonConduit");
var IfcTendonConduitType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTendonConduitType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcTendonConduitType");
var IfcTendonType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, CrossSectionArea, SheathDiameter) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
    this.NominalDiameter = NominalDiameter;
    this.CrossSectionArea = CrossSectionArea;
    this.SheathDiameter = SheathDiameter;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let NominalDiameter = tape[ptr++];
    let CrossSectionArea = tape[ptr++];
    let SheathDiameter = tape[ptr++];
    return new IfcTendonType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, CrossSectionArea, SheathDiameter);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.NominalDiameter);
    ;
    args.push(this.CrossSectionArea);
    ;
    args.push(this.SheathDiameter);
    ;
    return args;
  }
}, "IfcTendonType");
var IfcTessellatedFaceSet = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Coordinates) {
    this.expressID = expressID;
    this.type = type;
    this.Coordinates = Coordinates;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Coordinates = tape[ptr++];
    return new IfcTessellatedFaceSet(expressID, type, Coordinates);
  }
  ToTape() {
    let args = [];
    args.push(this.Coordinates);
    ;
    return args;
  }
}, "IfcTessellatedFaceSet");
var IfcTessellatedItem = /* @__PURE__ */ __name(class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcTessellatedItem(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
}, "IfcTessellatedItem");
var IfcTextLiteral = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Literal, Placement, Path) {
    this.expressID = expressID;
    this.type = type;
    this.Literal = Literal;
    this.Placement = Placement;
    this.Path = Path;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Literal = tape[ptr++];
    let Placement = tape[ptr++];
    let Path = tape[ptr++];
    return new IfcTextLiteral(expressID, type, Literal, Placement, Path);
  }
  ToTape() {
    let args = [];
    args.push(this.Literal);
    ;
    args.push(this.Placement);
    ;
    args.push(this.Path);
    ;
    return args;
  }
}, "IfcTextLiteral");
var IfcTextLiteralWithExtent = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Literal, Placement, Path, Extent, BoxAlignment) {
    this.expressID = expressID;
    this.type = type;
    this.Literal = Literal;
    this.Placement = Placement;
    this.Path = Path;
    this.Extent = Extent;
    this.BoxAlignment = BoxAlignment;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Literal = tape[ptr++];
    let Placement = tape[ptr++];
    let Path = tape[ptr++];
    let Extent = tape[ptr++];
    let BoxAlignment = tape[ptr++];
    return new IfcTextLiteralWithExtent(expressID, type, Literal, Placement, Path, Extent, BoxAlignment);
  }
  ToTape() {
    let args = [];
    args.push(this.Literal);
    ;
    args.push(this.Placement);
    ;
    args.push(this.Path);
    ;
    args.push(this.Extent);
    ;
    args.push(this.BoxAlignment);
    ;
    return args;
  }
}, "IfcTextLiteralWithExtent");
var IfcTextStyle = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, TextCharacterAppearance, TextStyle, TextFontStyle, ModelOrDraughting) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.TextCharacterAppearance = TextCharacterAppearance;
    this.TextStyle = TextStyle;
    this.TextFontStyle = TextFontStyle;
    this.ModelOrDraughting = ModelOrDraughting;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let TextCharacterAppearance = tape[ptr++];
    let TextStyle = tape[ptr++];
    let TextFontStyle = tape[ptr++];
    let ModelOrDraughting = tape[ptr++];
    return new IfcTextStyle(expressID, type, Name, TextCharacterAppearance, TextStyle, TextFontStyle, ModelOrDraughting);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.TextCharacterAppearance);
    ;
    args.push(this.TextStyle);
    ;
    args.push(this.TextFontStyle);
    ;
    args.push(this.ModelOrDraughting);
    ;
    return args;
  }
}, "IfcTextStyle");
var IfcTextStyleFontModel = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, FontFamily, FontStyle, FontVariant, FontWeight, FontSize) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.FontFamily = FontFamily;
    this.FontStyle = FontStyle;
    this.FontVariant = FontVariant;
    this.FontWeight = FontWeight;
    this.FontSize = FontSize;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let FontFamily = tape[ptr++];
    let FontStyle = tape[ptr++];
    let FontVariant = tape[ptr++];
    let FontWeight = tape[ptr++];
    let FontSize = tape[ptr++];
    return new IfcTextStyleFontModel(expressID, type, Name, FontFamily, FontStyle, FontVariant, FontWeight, FontSize);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.FontFamily);
    ;
    args.push(this.FontStyle);
    ;
    args.push(this.FontVariant);
    ;
    args.push(this.FontWeight);
    ;
    args.push(this.FontSize);
    ;
    return args;
  }
}, "IfcTextStyleFontModel");
var IfcTextStyleForDefinedFont = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Colour, BackgroundColour) {
    this.expressID = expressID;
    this.type = type;
    this.Colour = Colour;
    this.BackgroundColour = BackgroundColour;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Colour = tape[ptr++];
    let BackgroundColour = tape[ptr++];
    return new IfcTextStyleForDefinedFont(expressID, type, Colour, BackgroundColour);
  }
  ToTape() {
    let args = [];
    args.push(this.Colour);
    ;
    args.push(this.BackgroundColour);
    ;
    return args;
  }
}, "IfcTextStyleForDefinedFont");
var IfcTextStyleTextModel = /* @__PURE__ */ __name(class {
  constructor(expressID, type, TextIndent, TextAlign, TextDecoration, LetterSpacing, WordSpacing, TextTransform, LineHeight) {
    this.expressID = expressID;
    this.type = type;
    this.TextIndent = TextIndent;
    this.TextAlign = TextAlign;
    this.TextDecoration = TextDecoration;
    this.LetterSpacing = LetterSpacing;
    this.WordSpacing = WordSpacing;
    this.TextTransform = TextTransform;
    this.LineHeight = LineHeight;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TextIndent = tape[ptr++];
    let TextAlign = tape[ptr++];
    let TextDecoration = tape[ptr++];
    let LetterSpacing = tape[ptr++];
    let WordSpacing = tape[ptr++];
    let TextTransform = tape[ptr++];
    let LineHeight = tape[ptr++];
    return new IfcTextStyleTextModel(expressID, type, TextIndent, TextAlign, TextDecoration, LetterSpacing, WordSpacing, TextTransform, LineHeight);
  }
  ToTape() {
    let args = [];
    args.push(this.TextIndent);
    ;
    args.push(this.TextAlign);
    ;
    args.push(this.TextDecoration);
    ;
    args.push(this.LetterSpacing);
    ;
    args.push(this.WordSpacing);
    ;
    args.push(this.TextTransform);
    ;
    args.push(this.LineHeight);
    ;
    return args;
  }
}, "IfcTextStyleTextModel");
var IfcTextureCoordinate = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Maps) {
    this.expressID = expressID;
    this.type = type;
    this.Maps = Maps;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Maps = tape[ptr++];
    return new IfcTextureCoordinate(expressID, type, Maps);
  }
  ToTape() {
    let args = [];
    args.push(this.Maps);
    ;
    return args;
  }
}, "IfcTextureCoordinate");
var IfcTextureCoordinateGenerator = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Maps, Mode, Parameter) {
    this.expressID = expressID;
    this.type = type;
    this.Maps = Maps;
    this.Mode = Mode;
    this.Parameter = Parameter;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Maps = tape[ptr++];
    let Mode = tape[ptr++];
    let Parameter = tape[ptr++];
    return new IfcTextureCoordinateGenerator(expressID, type, Maps, Mode, Parameter);
  }
  ToTape() {
    let args = [];
    args.push(this.Maps);
    ;
    args.push(this.Mode);
    ;
    args.push(this.Parameter);
    ;
    return args;
  }
}, "IfcTextureCoordinateGenerator");
var IfcTextureMap = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Maps, Vertices, MappedTo) {
    this.expressID = expressID;
    this.type = type;
    this.Maps = Maps;
    this.Vertices = Vertices;
    this.MappedTo = MappedTo;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Maps = tape[ptr++];
    let Vertices = tape[ptr++];
    let MappedTo = tape[ptr++];
    return new IfcTextureMap(expressID, type, Maps, Vertices, MappedTo);
  }
  ToTape() {
    let args = [];
    args.push(this.Maps);
    ;
    args.push(this.Vertices);
    ;
    args.push(this.MappedTo);
    ;
    return args;
  }
}, "IfcTextureMap");
var IfcTextureVertex = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Coordinates) {
    this.expressID = expressID;
    this.type = type;
    this.Coordinates = Coordinates;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Coordinates = tape[ptr++];
    return new IfcTextureVertex(expressID, type, Coordinates);
  }
  ToTape() {
    let args = [];
    args.push(this.Coordinates);
    ;
    return args;
  }
}, "IfcTextureVertex");
var IfcTextureVertexList = /* @__PURE__ */ __name(class {
  constructor(expressID, type, TexCoordsList) {
    this.expressID = expressID;
    this.type = type;
    this.TexCoordsList = TexCoordsList;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TexCoordsList = tape[ptr++];
    return new IfcTextureVertexList(expressID, type, TexCoordsList);
  }
  ToTape() {
    let args = [];
    args.push(this.TexCoordsList);
    ;
    return args;
  }
}, "IfcTextureVertexList");
var IfcTimePeriod = /* @__PURE__ */ __name(class {
  constructor(expressID, type, StartTime, EndTime) {
    this.expressID = expressID;
    this.type = type;
    this.StartTime = StartTime;
    this.EndTime = EndTime;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let StartTime = tape[ptr++];
    let EndTime = tape[ptr++];
    return new IfcTimePeriod(expressID, type, StartTime, EndTime);
  }
  ToTape() {
    let args = [];
    args.push(this.StartTime);
    ;
    args.push(this.EndTime);
    ;
    return args;
  }
}, "IfcTimePeriod");
var IfcTimeSeries = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.StartTime = StartTime;
    this.EndTime = EndTime;
    this.TimeSeriesDataType = TimeSeriesDataType;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.Unit = Unit;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let StartTime = tape[ptr++];
    let EndTime = tape[ptr++];
    let TimeSeriesDataType = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let Unit = tape[ptr++];
    return new IfcTimeSeries(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.StartTime);
    ;
    args.push(this.EndTime);
    ;
    args.push(this.TimeSeriesDataType);
    ;
    args.push(this.DataOrigin);
    ;
    args.push(this.UserDefinedDataOrigin);
    ;
    args.push(this.Unit);
    ;
    return args;
  }
}, "IfcTimeSeries");
var IfcTimeSeriesValue = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ListValues) {
    this.expressID = expressID;
    this.type = type;
    this.ListValues = ListValues;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ListValues = tape[ptr++];
    return new IfcTimeSeriesValue(expressID, type, ListValues);
  }
  ToTape() {
    let args = [];
    args.push(this.ListValues);
    ;
    return args;
  }
}, "IfcTimeSeriesValue");
var IfcTopologicalRepresentationItem = /* @__PURE__ */ __name(class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcTopologicalRepresentationItem(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
}, "IfcTopologicalRepresentationItem");
var IfcTopologyRepresentation = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
    this.expressID = expressID;
    this.type = type;
    this.ContextOfItems = ContextOfItems;
    this.RepresentationIdentifier = RepresentationIdentifier;
    this.RepresentationType = RepresentationType;
    this.Items = Items;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextOfItems = tape[ptr++];
    let RepresentationIdentifier = tape[ptr++];
    let RepresentationType = tape[ptr++];
    let Items = tape[ptr++];
    return new IfcTopologyRepresentation(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextOfItems);
    ;
    args.push(this.RepresentationIdentifier);
    ;
    args.push(this.RepresentationType);
    ;
    args.push(this.Items);
    ;
    return args;
  }
}, "IfcTopologyRepresentation");
var IfcToroidalSurface = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Position, MajorRadius, MinorRadius) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.MajorRadius = MajorRadius;
    this.MinorRadius = MinorRadius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let MajorRadius = tape[ptr++];
    let MinorRadius = tape[ptr++];
    return new IfcToroidalSurface(expressID, type, Position, MajorRadius, MinorRadius);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    ;
    args.push(this.MajorRadius);
    ;
    args.push(this.MinorRadius);
    ;
    return args;
  }
}, "IfcToroidalSurface");
var IfcTransformer = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTransformer(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcTransformer");
var IfcTransformerType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTransformerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcTransformerType");
var IfcTransitionCurveSegment2D = /* @__PURE__ */ __name(class {
  constructor(expressID, type, StartPoint, StartDirection, SegmentLength, StartRadius, EndRadius, IsStartRadiusCCW, IsEndRadiusCCW, TransitionCurveType) {
    this.expressID = expressID;
    this.type = type;
    this.StartPoint = StartPoint;
    this.StartDirection = StartDirection;
    this.SegmentLength = SegmentLength;
    this.StartRadius = StartRadius;
    this.EndRadius = EndRadius;
    this.IsStartRadiusCCW = IsStartRadiusCCW;
    this.IsEndRadiusCCW = IsEndRadiusCCW;
    this.TransitionCurveType = TransitionCurveType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let StartPoint = tape[ptr++];
    let StartDirection = tape[ptr++];
    let SegmentLength = tape[ptr++];
    let StartRadius = tape[ptr++];
    let EndRadius = tape[ptr++];
    let IsStartRadiusCCW = tape[ptr++];
    let IsEndRadiusCCW = tape[ptr++];
    let TransitionCurveType = tape[ptr++];
    return new IfcTransitionCurveSegment2D(expressID, type, StartPoint, StartDirection, SegmentLength, StartRadius, EndRadius, IsStartRadiusCCW, IsEndRadiusCCW, TransitionCurveType);
  }
  ToTape() {
    let args = [];
    args.push(this.StartPoint);
    ;
    args.push(this.StartDirection);
    ;
    args.push(this.SegmentLength);
    ;
    args.push(this.StartRadius);
    ;
    args.push(this.EndRadius);
    ;
    args.push(this.IsStartRadiusCCW);
    ;
    args.push(this.IsEndRadiusCCW);
    ;
    args.push(this.TransitionCurveType);
    ;
    return args;
  }
}, "IfcTransitionCurveSegment2D");
var IfcTransportElement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTransportElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcTransportElement");
var IfcTransportElementType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTransportElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcTransportElementType");
var IfcTrapeziumProfileDef = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ProfileType, ProfileName, Position, BottomXDim, TopXDim, YDim, TopXOffset) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.BottomXDim = BottomXDim;
    this.TopXDim = TopXDim;
    this.YDim = YDim;
    this.TopXOffset = TopXOffset;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let BottomXDim = tape[ptr++];
    let TopXDim = tape[ptr++];
    let YDim = tape[ptr++];
    let TopXOffset = tape[ptr++];
    return new IfcTrapeziumProfileDef(expressID, type, ProfileType, ProfileName, Position, BottomXDim, TopXDim, YDim, TopXOffset);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Position);
    ;
    args.push(this.BottomXDim);
    ;
    args.push(this.TopXDim);
    ;
    args.push(this.YDim);
    ;
    args.push(this.TopXOffset);
    ;
    return args;
  }
}, "IfcTrapeziumProfileDef");
var IfcTriangulatedFaceSet = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Coordinates, Normals, Closed, CoordIndex, PnIndex) {
    this.expressID = expressID;
    this.type = type;
    this.Coordinates = Coordinates;
    this.Normals = Normals;
    this.Closed = Closed;
    this.CoordIndex = CoordIndex;
    this.PnIndex = PnIndex;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Coordinates = tape[ptr++];
    let Normals = tape[ptr++];
    let Closed = tape[ptr++];
    let CoordIndex = tape[ptr++];
    let PnIndex = tape[ptr++];
    return new IfcTriangulatedFaceSet(expressID, type, Coordinates, Normals, Closed, CoordIndex, PnIndex);
  }
  ToTape() {
    let args = [];
    args.push(this.Coordinates);
    ;
    args.push(this.Normals);
    ;
    args.push(this.Closed);
    ;
    args.push(this.CoordIndex);
    ;
    args.push(this.PnIndex);
    ;
    return args;
  }
}, "IfcTriangulatedFaceSet");
var IfcTriangulatedIrregularNetwork = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Coordinates, Normals, Closed, CoordIndex, PnIndex, Flags) {
    this.expressID = expressID;
    this.type = type;
    this.Coordinates = Coordinates;
    this.Normals = Normals;
    this.Closed = Closed;
    this.CoordIndex = CoordIndex;
    this.PnIndex = PnIndex;
    this.Flags = Flags;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Coordinates = tape[ptr++];
    let Normals = tape[ptr++];
    let Closed = tape[ptr++];
    let CoordIndex = tape[ptr++];
    let PnIndex = tape[ptr++];
    let Flags = tape[ptr++];
    return new IfcTriangulatedIrregularNetwork(expressID, type, Coordinates, Normals, Closed, CoordIndex, PnIndex, Flags);
  }
  ToTape() {
    let args = [];
    args.push(this.Coordinates);
    ;
    args.push(this.Normals);
    ;
    args.push(this.Closed);
    ;
    args.push(this.CoordIndex);
    ;
    args.push(this.PnIndex);
    ;
    args.push(this.Flags);
    ;
    return args;
  }
}, "IfcTriangulatedIrregularNetwork");
var IfcTrimmedCurve = /* @__PURE__ */ __name(class {
  constructor(expressID, type, BasisCurve, Trim1, Trim2, SenseAgreement, MasterRepresentation) {
    this.expressID = expressID;
    this.type = type;
    this.BasisCurve = BasisCurve;
    this.Trim1 = Trim1;
    this.Trim2 = Trim2;
    this.SenseAgreement = SenseAgreement;
    this.MasterRepresentation = MasterRepresentation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisCurve = tape[ptr++];
    let Trim1 = tape[ptr++];
    let Trim2 = tape[ptr++];
    let SenseAgreement = tape[ptr++];
    let MasterRepresentation = tape[ptr++];
    return new IfcTrimmedCurve(expressID, type, BasisCurve, Trim1, Trim2, SenseAgreement, MasterRepresentation);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisCurve);
    ;
    args.push(this.Trim1);
    ;
    args.push(this.Trim2);
    ;
    args.push(this.SenseAgreement);
    ;
    args.push(this.MasterRepresentation);
    ;
    return args;
  }
}, "IfcTrimmedCurve");
var IfcTubeBundle = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTubeBundle(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcTubeBundle");
var IfcTubeBundleType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTubeBundleType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcTubeBundleType");
var IfcTypeObject = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    return new IfcTypeObject(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    return args;
  }
}, "IfcTypeObject");
var IfcTypeProcess = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ProcessType = ProcessType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ProcessType = tape[ptr++];
    return new IfcTypeProcess(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.ProcessType);
    ;
    return args;
  }
}, "IfcTypeProcess");
var IfcTypeProduct = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcTypeProduct(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
}, "IfcTypeProduct");
var IfcTypeResource = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ResourceType = ResourceType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ResourceType = tape[ptr++];
    return new IfcTypeResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.Identification);
    ;
    args.push(this.LongDescription);
    ;
    args.push(this.ResourceType);
    ;
    return args;
  }
}, "IfcTypeResource");
var IfcUShapeProfileDef = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, EdgeRadius, FlangeSlope) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.Depth = Depth;
    this.FlangeWidth = FlangeWidth;
    this.WebThickness = WebThickness;
    this.FlangeThickness = FlangeThickness;
    this.FilletRadius = FilletRadius;
    this.EdgeRadius = EdgeRadius;
    this.FlangeSlope = FlangeSlope;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let Depth = tape[ptr++];
    let FlangeWidth = tape[ptr++];
    let WebThickness = tape[ptr++];
    let FlangeThickness = tape[ptr++];
    let FilletRadius = tape[ptr++];
    let EdgeRadius = tape[ptr++];
    let FlangeSlope = tape[ptr++];
    return new IfcUShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, EdgeRadius, FlangeSlope);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Position);
    ;
    args.push(this.Depth);
    ;
    args.push(this.FlangeWidth);
    ;
    args.push(this.WebThickness);
    ;
    args.push(this.FlangeThickness);
    ;
    args.push(this.FilletRadius);
    ;
    args.push(this.EdgeRadius);
    ;
    args.push(this.FlangeSlope);
    ;
    return args;
  }
}, "IfcUShapeProfileDef");
var IfcUnitAssignment = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Units) {
    this.expressID = expressID;
    this.type = type;
    this.Units = Units;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Units = tape[ptr++];
    return new IfcUnitAssignment(expressID, type, Units);
  }
  ToTape() {
    let args = [];
    args.push(this.Units);
    ;
    return args;
  }
}, "IfcUnitAssignment");
var IfcUnitaryControlElement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcUnitaryControlElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcUnitaryControlElement");
var IfcUnitaryControlElementType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcUnitaryControlElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcUnitaryControlElementType");
var IfcUnitaryEquipment = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcUnitaryEquipment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcUnitaryEquipment");
var IfcUnitaryEquipmentType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcUnitaryEquipmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcUnitaryEquipmentType");
var IfcValve = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcValve(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcValve");
var IfcValveType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcValveType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcValveType");
var IfcVector = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Orientation, Magnitude) {
    this.expressID = expressID;
    this.type = type;
    this.Orientation = Orientation;
    this.Magnitude = Magnitude;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Orientation = tape[ptr++];
    let Magnitude = tape[ptr++];
    return new IfcVector(expressID, type, Orientation, Magnitude);
  }
  ToTape() {
    let args = [];
    args.push(this.Orientation);
    ;
    args.push(this.Magnitude);
    ;
    return args;
  }
}, "IfcVector");
var IfcVertex = /* @__PURE__ */ __name(class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    return new IfcVertex(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
}, "IfcVertex");
var IfcVertexLoop = /* @__PURE__ */ __name(class {
  constructor(expressID, type, LoopVertex) {
    this.expressID = expressID;
    this.type = type;
    this.LoopVertex = LoopVertex;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let LoopVertex = tape[ptr++];
    return new IfcVertexLoop(expressID, type, LoopVertex);
  }
  ToTape() {
    let args = [];
    args.push(this.LoopVertex);
    ;
    return args;
  }
}, "IfcVertexLoop");
var IfcVertexPoint = /* @__PURE__ */ __name(class {
  constructor(expressID, type, VertexGeometry) {
    this.expressID = expressID;
    this.type = type;
    this.VertexGeometry = VertexGeometry;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let VertexGeometry = tape[ptr++];
    return new IfcVertexPoint(expressID, type, VertexGeometry);
  }
  ToTape() {
    let args = [];
    args.push(this.VertexGeometry);
    ;
    return args;
  }
}, "IfcVertexPoint");
var IfcVibrationDamper = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcVibrationDamper(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcVibrationDamper");
var IfcVibrationDamperType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcVibrationDamperType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcVibrationDamperType");
var IfcVibrationIsolator = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcVibrationIsolator(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcVibrationIsolator");
var IfcVibrationIsolatorType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcVibrationIsolatorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcVibrationIsolatorType");
var IfcVirtualElement = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcVirtualElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    return args;
  }
}, "IfcVirtualElement");
var IfcVirtualGridIntersection = /* @__PURE__ */ __name(class {
  constructor(expressID, type, IntersectingAxes, OffsetDistances) {
    this.expressID = expressID;
    this.type = type;
    this.IntersectingAxes = IntersectingAxes;
    this.OffsetDistances = OffsetDistances;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let IntersectingAxes = tape[ptr++];
    let OffsetDistances = tape[ptr++];
    return new IfcVirtualGridIntersection(expressID, type, IntersectingAxes, OffsetDistances);
  }
  ToTape() {
    let args = [];
    args.push(this.IntersectingAxes);
    ;
    args.push(this.OffsetDistances);
    ;
    return args;
  }
}, "IfcVirtualGridIntersection");
var IfcVoidingFeature = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcVoidingFeature(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcVoidingFeature");
var IfcWall = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWall(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcWall");
var IfcWallElementedCase = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWallElementedCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcWallElementedCase");
var IfcWallStandardCase = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWallStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcWallStandardCase");
var IfcWallType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWallType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcWallType");
var IfcWasteTerminal = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWasteTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcWasteTerminal");
var IfcWasteTerminalType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWasteTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcWasteTerminalType");
var IfcWindow = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, PartitioningType, UserDefinedPartitioningType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.OverallHeight = OverallHeight;
    this.OverallWidth = OverallWidth;
    this.PredefinedType = PredefinedType;
    this.PartitioningType = PartitioningType;
    this.UserDefinedPartitioningType = UserDefinedPartitioningType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let OverallHeight = tape[ptr++];
    let OverallWidth = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let PartitioningType = tape[ptr++];
    let UserDefinedPartitioningType = tape[ptr++];
    return new IfcWindow(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, PartitioningType, UserDefinedPartitioningType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.OverallHeight);
    ;
    args.push(this.OverallWidth);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.PartitioningType);
    ;
    args.push(this.UserDefinedPartitioningType);
    ;
    return args;
  }
}, "IfcWindow");
var IfcWindowLiningProperties = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, LiningDepth, LiningThickness, TransomThickness, MullionThickness, FirstTransomOffset, SecondTransomOffset, FirstMullionOffset, SecondMullionOffset, ShapeAspectStyle, LiningOffset, LiningToPanelOffsetX, LiningToPanelOffsetY) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.LiningDepth = LiningDepth;
    this.LiningThickness = LiningThickness;
    this.TransomThickness = TransomThickness;
    this.MullionThickness = MullionThickness;
    this.FirstTransomOffset = FirstTransomOffset;
    this.SecondTransomOffset = SecondTransomOffset;
    this.FirstMullionOffset = FirstMullionOffset;
    this.SecondMullionOffset = SecondMullionOffset;
    this.ShapeAspectStyle = ShapeAspectStyle;
    this.LiningOffset = LiningOffset;
    this.LiningToPanelOffsetX = LiningToPanelOffsetX;
    this.LiningToPanelOffsetY = LiningToPanelOffsetY;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let LiningDepth = tape[ptr++];
    let LiningThickness = tape[ptr++];
    let TransomThickness = tape[ptr++];
    let MullionThickness = tape[ptr++];
    let FirstTransomOffset = tape[ptr++];
    let SecondTransomOffset = tape[ptr++];
    let FirstMullionOffset = tape[ptr++];
    let SecondMullionOffset = tape[ptr++];
    let ShapeAspectStyle = tape[ptr++];
    let LiningOffset = tape[ptr++];
    let LiningToPanelOffsetX = tape[ptr++];
    let LiningToPanelOffsetY = tape[ptr++];
    return new IfcWindowLiningProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, LiningDepth, LiningThickness, TransomThickness, MullionThickness, FirstTransomOffset, SecondTransomOffset, FirstMullionOffset, SecondMullionOffset, ShapeAspectStyle, LiningOffset, LiningToPanelOffsetX, LiningToPanelOffsetY);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.LiningDepth);
    ;
    args.push(this.LiningThickness);
    ;
    args.push(this.TransomThickness);
    ;
    args.push(this.MullionThickness);
    ;
    args.push(this.FirstTransomOffset);
    ;
    args.push(this.SecondTransomOffset);
    ;
    args.push(this.FirstMullionOffset);
    ;
    args.push(this.SecondMullionOffset);
    ;
    args.push(this.ShapeAspectStyle);
    ;
    args.push(this.LiningOffset);
    ;
    args.push(this.LiningToPanelOffsetX);
    ;
    args.push(this.LiningToPanelOffsetY);
    ;
    return args;
  }
}, "IfcWindowLiningProperties");
var IfcWindowPanelProperties = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, OperationType, PanelPosition, FrameDepth, FrameThickness, ShapeAspectStyle) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.OperationType = OperationType;
    this.PanelPosition = PanelPosition;
    this.FrameDepth = FrameDepth;
    this.FrameThickness = FrameThickness;
    this.ShapeAspectStyle = ShapeAspectStyle;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let OperationType = tape[ptr++];
    let PanelPosition = tape[ptr++];
    let FrameDepth = tape[ptr++];
    let FrameThickness = tape[ptr++];
    let ShapeAspectStyle = tape[ptr++];
    return new IfcWindowPanelProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, OperationType, PanelPosition, FrameDepth, FrameThickness, ShapeAspectStyle);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.OperationType);
    ;
    args.push(this.PanelPosition);
    ;
    args.push(this.FrameDepth);
    ;
    args.push(this.FrameThickness);
    ;
    args.push(this.ShapeAspectStyle);
    ;
    return args;
  }
}, "IfcWindowPanelProperties");
var IfcWindowStandardCase = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, PartitioningType, UserDefinedPartitioningType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.OverallHeight = OverallHeight;
    this.OverallWidth = OverallWidth;
    this.PredefinedType = PredefinedType;
    this.PartitioningType = PartitioningType;
    this.UserDefinedPartitioningType = UserDefinedPartitioningType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let OverallHeight = tape[ptr++];
    let OverallWidth = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let PartitioningType = tape[ptr++];
    let UserDefinedPartitioningType = tape[ptr++];
    return new IfcWindowStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, PartitioningType, UserDefinedPartitioningType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.ObjectPlacement);
    ;
    args.push(this.Representation);
    ;
    args.push(this.Tag);
    ;
    args.push(this.OverallHeight);
    ;
    args.push(this.OverallWidth);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.PartitioningType);
    ;
    args.push(this.UserDefinedPartitioningType);
    ;
    return args;
  }
}, "IfcWindowStandardCase");
var IfcWindowStyle = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ConstructionType, OperationType, ParameterTakesPrecedence, Sizeable) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ConstructionType = ConstructionType;
    this.OperationType = OperationType;
    this.ParameterTakesPrecedence = ParameterTakesPrecedence;
    this.Sizeable = Sizeable;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ConstructionType = tape[ptr++];
    let OperationType = tape[ptr++];
    let ParameterTakesPrecedence = tape[ptr++];
    let Sizeable = tape[ptr++];
    return new IfcWindowStyle(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ConstructionType, OperationType, ParameterTakesPrecedence, Sizeable);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ConstructionType);
    ;
    args.push(this.OperationType);
    ;
    args.push(this.ParameterTakesPrecedence);
    ;
    args.push(this.Sizeable);
    ;
    return args;
  }
}, "IfcWindowStyle");
var IfcWindowType = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, PartitioningType, ParameterTakesPrecedence, UserDefinedPartitioningType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
    this.PartitioningType = PartitioningType;
    this.ParameterTakesPrecedence = ParameterTakesPrecedence;
    this.UserDefinedPartitioningType = UserDefinedPartitioningType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let PartitioningType = tape[ptr++];
    let ParameterTakesPrecedence = tape[ptr++];
    let UserDefinedPartitioningType = tape[ptr++];
    return new IfcWindowType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, PartitioningType, ParameterTakesPrecedence, UserDefinedPartitioningType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ApplicableOccurrence);
    ;
    args.push(this.HasPropertySets);
    ;
    args.push(this.RepresentationMaps);
    ;
    args.push(this.Tag);
    ;
    args.push(this.ElementType);
    ;
    args.push(this.PredefinedType);
    ;
    args.push(this.PartitioningType);
    ;
    args.push(this.ParameterTakesPrecedence);
    ;
    args.push(this.UserDefinedPartitioningType);
    ;
    return args;
  }
}, "IfcWindowType");
var IfcWorkCalendar = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, WorkingTimes, ExceptionTimes, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.WorkingTimes = WorkingTimes;
    this.ExceptionTimes = ExceptionTimes;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let WorkingTimes = tape[ptr++];
    let ExceptionTimes = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWorkCalendar(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, WorkingTimes, ExceptionTimes, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.WorkingTimes);
    ;
    args.push(this.ExceptionTimes);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcWorkCalendar");
var IfcWorkControl = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.CreationDate = CreationDate;
    this.Creators = Creators;
    this.Purpose = Purpose;
    this.Duration = Duration;
    this.TotalFloat = TotalFloat;
    this.StartTime = StartTime;
    this.FinishTime = FinishTime;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let CreationDate = tape[ptr++];
    let Creators = tape[ptr++];
    let Purpose = tape[ptr++];
    let Duration = tape[ptr++];
    let TotalFloat = tape[ptr++];
    let StartTime = tape[ptr++];
    let FinishTime = tape[ptr++];
    return new IfcWorkControl(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.CreationDate);
    ;
    args.push(this.Creators);
    ;
    args.push(this.Purpose);
    ;
    args.push(this.Duration);
    ;
    args.push(this.TotalFloat);
    ;
    args.push(this.StartTime);
    ;
    args.push(this.FinishTime);
    ;
    return args;
  }
}, "IfcWorkControl");
var IfcWorkPlan = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.CreationDate = CreationDate;
    this.Creators = Creators;
    this.Purpose = Purpose;
    this.Duration = Duration;
    this.TotalFloat = TotalFloat;
    this.StartTime = StartTime;
    this.FinishTime = FinishTime;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let CreationDate = tape[ptr++];
    let Creators = tape[ptr++];
    let Purpose = tape[ptr++];
    let Duration = tape[ptr++];
    let TotalFloat = tape[ptr++];
    let StartTime = tape[ptr++];
    let FinishTime = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWorkPlan(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.CreationDate);
    ;
    args.push(this.Creators);
    ;
    args.push(this.Purpose);
    ;
    args.push(this.Duration);
    ;
    args.push(this.TotalFloat);
    ;
    args.push(this.StartTime);
    ;
    args.push(this.FinishTime);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcWorkPlan");
var IfcWorkSchedule = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.CreationDate = CreationDate;
    this.Creators = Creators;
    this.Purpose = Purpose;
    this.Duration = Duration;
    this.TotalFloat = TotalFloat;
    this.StartTime = StartTime;
    this.FinishTime = FinishTime;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let CreationDate = tape[ptr++];
    let Creators = tape[ptr++];
    let Purpose = tape[ptr++];
    let Duration = tape[ptr++];
    let TotalFloat = tape[ptr++];
    let StartTime = tape[ptr++];
    let FinishTime = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWorkSchedule(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.Identification);
    ;
    args.push(this.CreationDate);
    ;
    args.push(this.Creators);
    ;
    args.push(this.Purpose);
    ;
    args.push(this.Duration);
    ;
    args.push(this.TotalFloat);
    ;
    args.push(this.StartTime);
    ;
    args.push(this.FinishTime);
    ;
    args.push(this.PredefinedType);
    ;
    return args;
  }
}, "IfcWorkSchedule");
var IfcWorkTime = /* @__PURE__ */ __name(class {
  constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, RecurrencePattern, Start, Finish) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.RecurrencePattern = RecurrencePattern;
    this.Start = Start;
    this.Finish = Finish;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let RecurrencePattern = tape[ptr++];
    let Start = tape[ptr++];
    let Finish = tape[ptr++];
    return new IfcWorkTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, RecurrencePattern, Start, Finish);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    ;
    args.push(this.DataOrigin);
    ;
    args.push(this.UserDefinedDataOrigin);
    ;
    args.push(this.RecurrencePattern);
    ;
    args.push(this.Start);
    ;
    args.push(this.Finish);
    ;
    return args;
  }
}, "IfcWorkTime");
var IfcZShapeProfileDef = /* @__PURE__ */ __name(class {
  constructor(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, EdgeRadius) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.Depth = Depth;
    this.FlangeWidth = FlangeWidth;
    this.WebThickness = WebThickness;
    this.FlangeThickness = FlangeThickness;
    this.FilletRadius = FilletRadius;
    this.EdgeRadius = EdgeRadius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let Depth = tape[ptr++];
    let FlangeWidth = tape[ptr++];
    let WebThickness = tape[ptr++];
    let FlangeThickness = tape[ptr++];
    let FilletRadius = tape[ptr++];
    let EdgeRadius = tape[ptr++];
    return new IfcZShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, EdgeRadius);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    ;
    args.push(this.ProfileName);
    ;
    args.push(this.Position);
    ;
    args.push(this.Depth);
    ;
    args.push(this.FlangeWidth);
    ;
    args.push(this.WebThickness);
    ;
    args.push(this.FlangeThickness);
    ;
    args.push(this.FilletRadius);
    ;
    args.push(this.EdgeRadius);
    ;
    return args;
  }
}, "IfcZShapeProfileDef");
var IfcZone = /* @__PURE__ */ __name(class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.LongName = LongName;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let LongName = tape[ptr++];
    return new IfcZone(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    ;
    args.push(this.OwnerHistory);
    ;
    args.push(this.Name);
    ;
    args.push(this.Description);
    ;
    args.push(this.ObjectType);
    ;
    args.push(this.LongName);
    ;
    return args;
  }
}, "IfcZone");
var IfcElements2 = {
  103090709: "IFCPROJECT",
  4097777520: "IFCSITE",
  4031249490: "IFCBUILDING",
  3124254112: "IFCBUILDINGSTOREY",
  3856911033: "IFCSPACE",
  1674181508: "IFCANNOTATION",
  25142252: "IFCCONTROLLER",
  32344328: "IFCBOILER",
  76236018: "IFCLAMP",
  90941305: "IFCPUMP",
  177149247: "IFCAIRTERMINALBOX",
  182646315: "IFCFLOWINSTRUMENT",
  263784265: "IFCFURNISHINGELEMENT",
  264262732: "IFCELECTRICGENERATOR",
  277319702: "IFCAUDIOVISUALAPPLIANCE",
  310824031: "IFCPIPEFITTING",
  331165859: "IFCSTAIR",
  342316401: "IFCDUCTFITTING",
  377706215: "IFCMECHANICALFASTENER",
  395920057: "IFCDOOR",
  402227799: "IFCELECTRICMOTOR",
  413509423: "IFCSYSTEMFURNITUREELEMENT",
  484807127: "IFCEVAPORATOR",
  486154966: "IFCWINDOWSTANDARDCASE",
  629592764: "IFCLIGHTFIXTURE",
  630975310: "IFCUNITARYCONTROLELEMENT",
  635142910: "IFCCABLECARRIERFITTING",
  639361253: "IFCCOIL",
  647756555: "IFCFASTENER",
  707683696: "IFCFLOWSTORAGEDEVICE",
  738039164: "IFCPROTECTIVEDEVICE",
  753842376: "IFCBEAM",
  812556717: "IFCTANK",
  819412036: "IFCFILTER",
  843113511: "IFCCOLUMN",
  862014818: "IFCELECTRICDISTRIBUTIONBOARD",
  900683007: "IFCFOOTING",
  905975707: "IFCCOLUMNSTANDARDCASE",
  926996030: "IFCVOIDINGFEATURE",
  979691226: "IFCREINFORCINGBAR",
  987401354: "IFCFLOWSEGMENT",
  1003880860: "IFCELECTRICTIMECONTROL",
  1051757585: "IFCCABLEFITTING",
  1052013943: "IFCDISTRIBUTIONCHAMBERELEMENT",
  1062813311: "IFCDISTRIBUTIONCONTROLELEMENT",
  1073191201: "IFCMEMBER",
  1095909175: "IFCBUILDINGELEMENTPROXY",
  1156407060: "IFCPLATESTANDARDCASE",
  1162798199: "IFCSWITCHINGDEVICE",
  1329646415: "IFCSHADINGDEVICE",
  1335981549: "IFCDISCRETEACCESSORY",
  1360408905: "IFCDUCTSILENCER",
  1404847402: "IFCSTACKTERMINAL",
  1426591983: "IFCFIRESUPPRESSIONTERMINAL",
  1437502449: "IFCMEDICALDEVICE",
  1509553395: "IFCFURNITURE",
  1529196076: "IFCSLAB",
  1620046519: "IFCTRANSPORTELEMENT",
  1634111441: "IFCAIRTERMINAL",
  1658829314: "IFCENERGYCONVERSIONDEVICE",
  1677625105: "IFCCIVILELEMENT",
  1687234759: "IFCPILE",
  1904799276: "IFCELECTRICAPPLIANCE",
  1911478936: "IFCMEMBERSTANDARDCASE",
  1945004755: "IFCDISTRIBUTIONELEMENT",
  1973544240: "IFCCOVERING",
  1999602285: "IFCSPACEHEATER",
  2016517767: "IFCROOF",
  2056796094: "IFCAIRTOAIRHEATRECOVERY",
  2058353004: "IFCFLOWCONTROLLER",
  2068733104: "IFCHUMIDIFIER",
  2176052936: "IFCJUNCTIONBOX",
  2188021234: "IFCFLOWMETER",
  2223149337: "IFCFLOWTERMINAL",
  2262370178: "IFCRAILING",
  2272882330: "IFCCONDENSER",
  2295281155: "IFCPROTECTIVEDEVICETRIPPINGUNIT",
  2320036040: "IFCREINFORCINGMESH",
  2347447852: "IFCTENDONANCHOR",
  2391383451: "IFCVIBRATIONISOLATOR",
  2391406946: "IFCWALL",
  2474470126: "IFCMOTORCONNECTION",
  2769231204: "IFCVIRTUALELEMENT",
  2814081492: "IFCENGINE",
  2906023776: "IFCBEAMSTANDARDCASE",
  2938176219: "IFCBURNER",
  2979338954: "IFCBUILDINGELEMENTPART",
  3024970846: "IFCRAMP",
  3026737570: "IFCTUBEBUNDLE",
  3027962421: "IFCSLABSTANDARDCASE",
  3040386961: "IFCDISTRIBUTIONFLOWELEMENT",
  3053780830: "IFCSANITARYTERMINAL",
  3079942009: "IFCOPENINGSTANDARDCASE",
  3087945054: "IFCALARM",
  3101698114: "IFCSURFACEFEATURE",
  3127900445: "IFCSLABELEMENTEDCASE",
  3132237377: "IFCFLOWMOVINGDEVICE",
  3171933400: "IFCPLATE",
  3221913625: "IFCCOMMUNICATIONSAPPLIANCE",
  3242481149: "IFCDOORSTANDARDCASE",
  3283111854: "IFCRAMPFLIGHT",
  3296154744: "IFCCHIMNEY",
  3304561284: "IFCWINDOW",
  3310460725: "IFCELECTRICFLOWSTORAGEDEVICE",
  3319311131: "IFCHEATEXCHANGER",
  3415622556: "IFCFAN",
  3420628829: "IFCSOLARDEVICE",
  3493046030: "IFCGEOGRAPHICELEMENT",
  3495092785: "IFCCURTAINWALL",
  3508470533: "IFCFLOWTREATMENTDEVICE",
  3512223829: "IFCWALLSTANDARDCASE",
  3518393246: "IFCDUCTSEGMENT",
  3571504051: "IFCCOMPRESSOR",
  3588315303: "IFCOPENINGELEMENT",
  3612865200: "IFCPIPESEGMENT",
  3640358203: "IFCCOOLINGTOWER",
  3651124850: "IFCPROJECTIONELEMENT",
  3694346114: "IFCOUTLET",
  3747195512: "IFCEVAPORATIVECOOLER",
  3758799889: "IFCCABLECARRIERSEGMENT",
  3824725483: "IFCTENDON",
  3825984169: "IFCTRANSFORMER",
  3902619387: "IFCCHILLER",
  4074379575: "IFCDAMPER",
  4086658281: "IFCSENSOR",
  4123344466: "IFCELEMENTASSEMBLY",
  4136498852: "IFCCOOLEDBEAM",
  4156078855: "IFCWALLELEMENTEDCASE",
  4175244083: "IFCINTERCEPTOR",
  4207607924: "IFCVALVE",
  4217484030: "IFCCABLESEGMENT",
  4237592921: "IFCWASTETERMINAL",
  4252922144: "IFCSTAIRFLIGHT",
  4278956645: "IFCFLOWFITTING",
  4288193352: "IFCACTUATOR",
  4292641817: "IFCUNITARYEQUIPMENT",
  3009204131: "IFCGRID"
};
var IfcTypesMap = {
  3821786052: "IFCACTIONREQUEST",
  2296667514: "IFCACTOR",
  3630933823: "IFCACTORROLE",
  4288193352: "IFCACTUATOR",
  2874132201: "IFCACTUATORTYPE",
  618182010: "IFCADDRESS",
  1635779807: "IFCADVANCEDBREP",
  2603310189: "IFCADVANCEDBREPWITHVOIDS",
  3406155212: "IFCADVANCEDFACE",
  1634111441: "IFCAIRTERMINAL",
  177149247: "IFCAIRTERMINALBOX",
  1411407467: "IFCAIRTERMINALBOXTYPE",
  3352864051: "IFCAIRTERMINALTYPE",
  2056796094: "IFCAIRTOAIRHEATRECOVERY",
  1871374353: "IFCAIRTOAIRHEATRECOVERYTYPE",
  3087945054: "IFCALARM",
  3001207471: "IFCALARMTYPE",
  325726236: "IFCALIGNMENT",
  749761778: "IFCALIGNMENT2DHORIZONTAL",
  3199563722: "IFCALIGNMENT2DHORIZONTALSEGMENT",
  2483840362: "IFCALIGNMENT2DSEGMENT",
  3379348081: "IFCALIGNMENT2DVERSEGCIRCULARARC",
  3239324667: "IFCALIGNMENT2DVERSEGLINE",
  4263986512: "IFCALIGNMENT2DVERSEGPARABOLICARC",
  53199957: "IFCALIGNMENT2DVERTICAL",
  2029264950: "IFCALIGNMENT2DVERTICALSEGMENT",
  3512275521: "IFCALIGNMENTCURVE",
  1674181508: "IFCANNOTATION",
  669184980: "IFCANNOTATIONFILLAREA",
  639542469: "IFCAPPLICATION",
  411424972: "IFCAPPLIEDVALUE",
  130549933: "IFCAPPROVAL",
  3869604511: "IFCAPPROVALRELATIONSHIP",
  3798115385: "IFCARBITRARYCLOSEDPROFILEDEF",
  1310608509: "IFCARBITRARYOPENPROFILEDEF",
  2705031697: "IFCARBITRARYPROFILEDEFWITHVOIDS",
  3460190687: "IFCASSET",
  3207858831: "IFCASYMMETRICISHAPEPROFILEDEF",
  277319702: "IFCAUDIOVISUALAPPLIANCE",
  1532957894: "IFCAUDIOVISUALAPPLIANCETYPE",
  4261334040: "IFCAXIS1PLACEMENT",
  3125803723: "IFCAXIS2PLACEMENT2D",
  2740243338: "IFCAXIS2PLACEMENT3D",
  1967976161: "IFCBSPLINECURVE",
  2461110595: "IFCBSPLINECURVEWITHKNOTS",
  2887950389: "IFCBSPLINESURFACE",
  167062518: "IFCBSPLINESURFACEWITHKNOTS",
  753842376: "IFCBEAM",
  2906023776: "IFCBEAMSTANDARDCASE",
  819618141: "IFCBEAMTYPE",
  4196446775: "IFCBEARING",
  3649138523: "IFCBEARINGTYPE",
  616511568: "IFCBLOBTEXTURE",
  1334484129: "IFCBLOCK",
  32344328: "IFCBOILER",
  231477066: "IFCBOILERTYPE",
  3649129432: "IFCBOOLEANCLIPPINGRESULT",
  2736907675: "IFCBOOLEANRESULT",
  4037036970: "IFCBOUNDARYCONDITION",
  1136057603: "IFCBOUNDARYCURVE",
  1560379544: "IFCBOUNDARYEDGECONDITION",
  3367102660: "IFCBOUNDARYFACECONDITION",
  1387855156: "IFCBOUNDARYNODECONDITION",
  2069777674: "IFCBOUNDARYNODECONDITIONWARPING",
  1260505505: "IFCBOUNDEDCURVE",
  4182860854: "IFCBOUNDEDSURFACE",
  2581212453: "IFCBOUNDINGBOX",
  2713105998: "IFCBOXEDHALFSPACE",
  644574406: "IFCBRIDGE",
  963979645: "IFCBRIDGEPART",
  4031249490: "IFCBUILDING",
  3299480353: "IFCBUILDINGELEMENT",
  2979338954: "IFCBUILDINGELEMENTPART",
  39481116: "IFCBUILDINGELEMENTPARTTYPE",
  1095909175: "IFCBUILDINGELEMENTPROXY",
  1909888760: "IFCBUILDINGELEMENTPROXYTYPE",
  1950629157: "IFCBUILDINGELEMENTTYPE",
  3124254112: "IFCBUILDINGSTOREY",
  1177604601: "IFCBUILDINGSYSTEM",
  2938176219: "IFCBURNER",
  2188180465: "IFCBURNERTYPE",
  2898889636: "IFCCSHAPEPROFILEDEF",
  635142910: "IFCCABLECARRIERFITTING",
  395041908: "IFCCABLECARRIERFITTINGTYPE",
  3758799889: "IFCCABLECARRIERSEGMENT",
  3293546465: "IFCCABLECARRIERSEGMENTTYPE",
  1051757585: "IFCCABLEFITTING",
  2674252688: "IFCCABLEFITTINGTYPE",
  4217484030: "IFCCABLESEGMENT",
  1285652485: "IFCCABLESEGMENTTYPE",
  3999819293: "IFCCAISSONFOUNDATION",
  3203706013: "IFCCAISSONFOUNDATIONTYPE",
  1123145078: "IFCCARTESIANPOINT",
  574549367: "IFCCARTESIANPOINTLIST",
  1675464909: "IFCCARTESIANPOINTLIST2D",
  2059837836: "IFCCARTESIANPOINTLIST3D",
  59481748: "IFCCARTESIANTRANSFORMATIONOPERATOR",
  3749851601: "IFCCARTESIANTRANSFORMATIONOPERATOR2D",
  3486308946: "IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM",
  3331915920: "IFCCARTESIANTRANSFORMATIONOPERATOR3D",
  1416205885: "IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM",
  3150382593: "IFCCENTERLINEPROFILEDEF",
  3902619387: "IFCCHILLER",
  2951183804: "IFCCHILLERTYPE",
  3296154744: "IFCCHIMNEY",
  2197970202: "IFCCHIMNEYTYPE",
  2611217952: "IFCCIRCLE",
  2937912522: "IFCCIRCLEHOLLOWPROFILEDEF",
  1383045692: "IFCCIRCLEPROFILEDEF",
  1062206242: "IFCCIRCULARARCSEGMENT2D",
  1677625105: "IFCCIVILELEMENT",
  3893394355: "IFCCIVILELEMENTTYPE",
  747523909: "IFCCLASSIFICATION",
  647927063: "IFCCLASSIFICATIONREFERENCE",
  2205249479: "IFCCLOSEDSHELL",
  639361253: "IFCCOIL",
  2301859152: "IFCCOILTYPE",
  776857604: "IFCCOLOURRGB",
  3285139300: "IFCCOLOURRGBLIST",
  3264961684: "IFCCOLOURSPECIFICATION",
  843113511: "IFCCOLUMN",
  905975707: "IFCCOLUMNSTANDARDCASE",
  300633059: "IFCCOLUMNTYPE",
  3221913625: "IFCCOMMUNICATIONSAPPLIANCE",
  400855858: "IFCCOMMUNICATIONSAPPLIANCETYPE",
  2542286263: "IFCCOMPLEXPROPERTY",
  3875453745: "IFCCOMPLEXPROPERTYTEMPLATE",
  3732776249: "IFCCOMPOSITECURVE",
  15328376: "IFCCOMPOSITECURVEONSURFACE",
  2485617015: "IFCCOMPOSITECURVESEGMENT",
  1485152156: "IFCCOMPOSITEPROFILEDEF",
  3571504051: "IFCCOMPRESSOR",
  3850581409: "IFCCOMPRESSORTYPE",
  2272882330: "IFCCONDENSER",
  2816379211: "IFCCONDENSERTYPE",
  2510884976: "IFCCONIC",
  370225590: "IFCCONNECTEDFACESET",
  1981873012: "IFCCONNECTIONCURVEGEOMETRY",
  2859738748: "IFCCONNECTIONGEOMETRY",
  45288368: "IFCCONNECTIONPOINTECCENTRICITY",
  2614616156: "IFCCONNECTIONPOINTGEOMETRY",
  2732653382: "IFCCONNECTIONSURFACEGEOMETRY",
  775493141: "IFCCONNECTIONVOLUMEGEOMETRY",
  1959218052: "IFCCONSTRAINT",
  3898045240: "IFCCONSTRUCTIONEQUIPMENTRESOURCE",
  2185764099: "IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE",
  1060000209: "IFCCONSTRUCTIONMATERIALRESOURCE",
  4105962743: "IFCCONSTRUCTIONMATERIALRESOURCETYPE",
  488727124: "IFCCONSTRUCTIONPRODUCTRESOURCE",
  1525564444: "IFCCONSTRUCTIONPRODUCTRESOURCETYPE",
  2559216714: "IFCCONSTRUCTIONRESOURCE",
  2574617495: "IFCCONSTRUCTIONRESOURCETYPE",
  3419103109: "IFCCONTEXT",
  3050246964: "IFCCONTEXTDEPENDENTUNIT",
  3293443760: "IFCCONTROL",
  25142252: "IFCCONTROLLER",
  578613899: "IFCCONTROLLERTYPE",
  2889183280: "IFCCONVERSIONBASEDUNIT",
  2713554722: "IFCCONVERSIONBASEDUNITWITHOFFSET",
  4136498852: "IFCCOOLEDBEAM",
  335055490: "IFCCOOLEDBEAMTYPE",
  3640358203: "IFCCOOLINGTOWER",
  2954562838: "IFCCOOLINGTOWERTYPE",
  1785450214: "IFCCOORDINATEOPERATION",
  1466758467: "IFCCOORDINATEREFERENCESYSTEM",
  3895139033: "IFCCOSTITEM",
  1419761937: "IFCCOSTSCHEDULE",
  602808272: "IFCCOSTVALUE",
  1973544240: "IFCCOVERING",
  1916426348: "IFCCOVERINGTYPE",
  3295246426: "IFCCREWRESOURCE",
  1815067380: "IFCCREWRESOURCETYPE",
  2506170314: "IFCCSGPRIMITIVE3D",
  2147822146: "IFCCSGSOLID",
  539742890: "IFCCURRENCYRELATIONSHIP",
  3495092785: "IFCCURTAINWALL",
  1457835157: "IFCCURTAINWALLTYPE",
  2601014836: "IFCCURVE",
  2827736869: "IFCCURVEBOUNDEDPLANE",
  2629017746: "IFCCURVEBOUNDEDSURFACE",
  1186437898: "IFCCURVESEGMENT2D",
  3800577675: "IFCCURVESTYLE",
  1105321065: "IFCCURVESTYLEFONT",
  2367409068: "IFCCURVESTYLEFONTANDSCALING",
  3510044353: "IFCCURVESTYLEFONTPATTERN",
  1213902940: "IFCCYLINDRICALSURFACE",
  4074379575: "IFCDAMPER",
  3961806047: "IFCDAMPERTYPE",
  3426335179: "IFCDEEPFOUNDATION",
  1306400036: "IFCDEEPFOUNDATIONTYPE",
  3632507154: "IFCDERIVEDPROFILEDEF",
  1765591967: "IFCDERIVEDUNIT",
  1045800335: "IFCDERIVEDUNITELEMENT",
  2949456006: "IFCDIMENSIONALEXPONENTS",
  32440307: "IFCDIRECTION",
  1335981549: "IFCDISCRETEACCESSORY",
  2635815018: "IFCDISCRETEACCESSORYTYPE",
  1945343521: "IFCDISTANCEEXPRESSION",
  1052013943: "IFCDISTRIBUTIONCHAMBERELEMENT",
  1599208980: "IFCDISTRIBUTIONCHAMBERELEMENTTYPE",
  562808652: "IFCDISTRIBUTIONCIRCUIT",
  1062813311: "IFCDISTRIBUTIONCONTROLELEMENT",
  2063403501: "IFCDISTRIBUTIONCONTROLELEMENTTYPE",
  1945004755: "IFCDISTRIBUTIONELEMENT",
  3256556792: "IFCDISTRIBUTIONELEMENTTYPE",
  3040386961: "IFCDISTRIBUTIONFLOWELEMENT",
  3849074793: "IFCDISTRIBUTIONFLOWELEMENTTYPE",
  3041715199: "IFCDISTRIBUTIONPORT",
  3205830791: "IFCDISTRIBUTIONSYSTEM",
  1154170062: "IFCDOCUMENTINFORMATION",
  770865208: "IFCDOCUMENTINFORMATIONRELATIONSHIP",
  3732053477: "IFCDOCUMENTREFERENCE",
  395920057: "IFCDOOR",
  2963535650: "IFCDOORLININGPROPERTIES",
  1714330368: "IFCDOORPANELPROPERTIES",
  3242481149: "IFCDOORSTANDARDCASE",
  526551008: "IFCDOORSTYLE",
  2323601079: "IFCDOORTYPE",
  445594917: "IFCDRAUGHTINGPREDEFINEDCOLOUR",
  4006246654: "IFCDRAUGHTINGPREDEFINEDCURVEFONT",
  342316401: "IFCDUCTFITTING",
  869906466: "IFCDUCTFITTINGTYPE",
  3518393246: "IFCDUCTSEGMENT",
  3760055223: "IFCDUCTSEGMENTTYPE",
  1360408905: "IFCDUCTSILENCER",
  2030761528: "IFCDUCTSILENCERTYPE",
  3900360178: "IFCEDGE",
  476780140: "IFCEDGECURVE",
  1472233963: "IFCEDGELOOP",
  1904799276: "IFCELECTRICAPPLIANCE",
  663422040: "IFCELECTRICAPPLIANCETYPE",
  862014818: "IFCELECTRICDISTRIBUTIONBOARD",
  2417008758: "IFCELECTRICDISTRIBUTIONBOARDTYPE",
  3310460725: "IFCELECTRICFLOWSTORAGEDEVICE",
  3277789161: "IFCELECTRICFLOWSTORAGEDEVICETYPE",
  264262732: "IFCELECTRICGENERATOR",
  1534661035: "IFCELECTRICGENERATORTYPE",
  402227799: "IFCELECTRICMOTOR",
  1217240411: "IFCELECTRICMOTORTYPE",
  1003880860: "IFCELECTRICTIMECONTROL",
  712377611: "IFCELECTRICTIMECONTROLTYPE",
  1758889154: "IFCELEMENT",
  4123344466: "IFCELEMENTASSEMBLY",
  2397081782: "IFCELEMENTASSEMBLYTYPE",
  1623761950: "IFCELEMENTCOMPONENT",
  2590856083: "IFCELEMENTCOMPONENTTYPE",
  1883228015: "IFCELEMENTQUANTITY",
  339256511: "IFCELEMENTTYPE",
  2777663545: "IFCELEMENTARYSURFACE",
  1704287377: "IFCELLIPSE",
  2835456948: "IFCELLIPSEPROFILEDEF",
  1658829314: "IFCENERGYCONVERSIONDEVICE",
  2107101300: "IFCENERGYCONVERSIONDEVICETYPE",
  2814081492: "IFCENGINE",
  132023988: "IFCENGINETYPE",
  3747195512: "IFCEVAPORATIVECOOLER",
  3174744832: "IFCEVAPORATIVECOOLERTYPE",
  484807127: "IFCEVAPORATOR",
  3390157468: "IFCEVAPORATORTYPE",
  4148101412: "IFCEVENT",
  211053100: "IFCEVENTTIME",
  4024345920: "IFCEVENTTYPE",
  297599258: "IFCEXTENDEDPROPERTIES",
  4294318154: "IFCEXTERNALINFORMATION",
  3200245327: "IFCEXTERNALREFERENCE",
  1437805879: "IFCEXTERNALREFERENCERELATIONSHIP",
  1209101575: "IFCEXTERNALSPATIALELEMENT",
  2853485674: "IFCEXTERNALSPATIALSTRUCTUREELEMENT",
  2242383968: "IFCEXTERNALLYDEFINEDHATCHSTYLE",
  1040185647: "IFCEXTERNALLYDEFINEDSURFACESTYLE",
  3548104201: "IFCEXTERNALLYDEFINEDTEXTFONT",
  477187591: "IFCEXTRUDEDAREASOLID",
  2804161546: "IFCEXTRUDEDAREASOLIDTAPERED",
  2556980723: "IFCFACE",
  2047409740: "IFCFACEBASEDSURFACEMODEL",
  1809719519: "IFCFACEBOUND",
  803316827: "IFCFACEOUTERBOUND",
  3008276851: "IFCFACESURFACE",
  807026263: "IFCFACETEDBREP",
  3737207727: "IFCFACETEDBREPWITHVOIDS",
  24185140: "IFCFACILITY",
  1310830890: "IFCFACILITYPART",
  4219587988: "IFCFAILURECONNECTIONCONDITION",
  3415622556: "IFCFAN",
  346874300: "IFCFANTYPE",
  647756555: "IFCFASTENER",
  2489546625: "IFCFASTENERTYPE",
  2827207264: "IFCFEATUREELEMENT",
  2143335405: "IFCFEATUREELEMENTADDITION",
  1287392070: "IFCFEATUREELEMENTSUBTRACTION",
  738692330: "IFCFILLAREASTYLE",
  374418227: "IFCFILLAREASTYLEHATCHING",
  315944413: "IFCFILLAREASTYLETILES",
  819412036: "IFCFILTER",
  1810631287: "IFCFILTERTYPE",
  1426591983: "IFCFIRESUPPRESSIONTERMINAL",
  4222183408: "IFCFIRESUPPRESSIONTERMINALTYPE",
  2652556860: "IFCFIXEDREFERENCESWEPTAREASOLID",
  2058353004: "IFCFLOWCONTROLLER",
  3907093117: "IFCFLOWCONTROLLERTYPE",
  4278956645: "IFCFLOWFITTING",
  3198132628: "IFCFLOWFITTINGTYPE",
  182646315: "IFCFLOWINSTRUMENT",
  4037862832: "IFCFLOWINSTRUMENTTYPE",
  2188021234: "IFCFLOWMETER",
  3815607619: "IFCFLOWMETERTYPE",
  3132237377: "IFCFLOWMOVINGDEVICE",
  1482959167: "IFCFLOWMOVINGDEVICETYPE",
  987401354: "IFCFLOWSEGMENT",
  1834744321: "IFCFLOWSEGMENTTYPE",
  707683696: "IFCFLOWSTORAGEDEVICE",
  1339347760: "IFCFLOWSTORAGEDEVICETYPE",
  2223149337: "IFCFLOWTERMINAL",
  2297155007: "IFCFLOWTERMINALTYPE",
  3508470533: "IFCFLOWTREATMENTDEVICE",
  3009222698: "IFCFLOWTREATMENTDEVICETYPE",
  900683007: "IFCFOOTING",
  1893162501: "IFCFOOTINGTYPE",
  263784265: "IFCFURNISHINGELEMENT",
  4238390223: "IFCFURNISHINGELEMENTTYPE",
  1509553395: "IFCFURNITURE",
  1268542332: "IFCFURNITURETYPE",
  3493046030: "IFCGEOGRAPHICELEMENT",
  4095422895: "IFCGEOGRAPHICELEMENTTYPE",
  987898635: "IFCGEOMETRICCURVESET",
  3448662350: "IFCGEOMETRICREPRESENTATIONCONTEXT",
  2453401579: "IFCGEOMETRICREPRESENTATIONITEM",
  4142052618: "IFCGEOMETRICREPRESENTATIONSUBCONTEXT",
  3590301190: "IFCGEOMETRICSET",
  3009204131: "IFCGRID",
  852622518: "IFCGRIDAXIS",
  178086475: "IFCGRIDPLACEMENT",
  2706460486: "IFCGROUP",
  812098782: "IFCHALFSPACESOLID",
  3319311131: "IFCHEATEXCHANGER",
  1251058090: "IFCHEATEXCHANGERTYPE",
  2068733104: "IFCHUMIDIFIER",
  1806887404: "IFCHUMIDIFIERTYPE",
  1484403080: "IFCISHAPEPROFILEDEF",
  3905492369: "IFCIMAGETEXTURE",
  3570813810: "IFCINDEXEDCOLOURMAP",
  2571569899: "IFCINDEXEDPOLYCURVE",
  178912537: "IFCINDEXEDPOLYGONALFACE",
  2294589976: "IFCINDEXEDPOLYGONALFACEWITHVOIDS",
  1437953363: "IFCINDEXEDTEXTUREMAP",
  2133299955: "IFCINDEXEDTRIANGLETEXTUREMAP",
  4175244083: "IFCINTERCEPTOR",
  3946677679: "IFCINTERCEPTORTYPE",
  3113134337: "IFCINTERSECTIONCURVE",
  2391368822: "IFCINVENTORY",
  3741457305: "IFCIRREGULARTIMESERIES",
  3020489413: "IFCIRREGULARTIMESERIESVALUE",
  2176052936: "IFCJUNCTIONBOX",
  4288270099: "IFCJUNCTIONBOXTYPE",
  572779678: "IFCLSHAPEPROFILEDEF",
  3827777499: "IFCLABORRESOURCE",
  428585644: "IFCLABORRESOURCETYPE",
  1585845231: "IFCLAGTIME",
  76236018: "IFCLAMP",
  1051575348: "IFCLAMPTYPE",
  2655187982: "IFCLIBRARYINFORMATION",
  3452421091: "IFCLIBRARYREFERENCE",
  4162380809: "IFCLIGHTDISTRIBUTIONDATA",
  629592764: "IFCLIGHTFIXTURE",
  1161773419: "IFCLIGHTFIXTURETYPE",
  1566485204: "IFCLIGHTINTENSITYDISTRIBUTION",
  1402838566: "IFCLIGHTSOURCE",
  125510826: "IFCLIGHTSOURCEAMBIENT",
  2604431987: "IFCLIGHTSOURCEDIRECTIONAL",
  4266656042: "IFCLIGHTSOURCEGONIOMETRIC",
  1520743889: "IFCLIGHTSOURCEPOSITIONAL",
  3422422726: "IFCLIGHTSOURCESPOT",
  1281925730: "IFCLINE",
  3092502836: "IFCLINESEGMENT2D",
  388784114: "IFCLINEARPLACEMENT",
  1154579445: "IFCLINEARPOSITIONINGELEMENT",
  2624227202: "IFCLOCALPLACEMENT",
  1008929658: "IFCLOOP",
  1425443689: "IFCMANIFOLDSOLIDBREP",
  3057273783: "IFCMAPCONVERSION",
  2347385850: "IFCMAPPEDITEM",
  1838606355: "IFCMATERIAL",
  1847130766: "IFCMATERIALCLASSIFICATIONRELATIONSHIP",
  3708119e3: "IFCMATERIALCONSTITUENT",
  2852063980: "IFCMATERIALCONSTITUENTSET",
  760658860: "IFCMATERIALDEFINITION",
  2022407955: "IFCMATERIALDEFINITIONREPRESENTATION",
  248100487: "IFCMATERIALLAYER",
  3303938423: "IFCMATERIALLAYERSET",
  1303795690: "IFCMATERIALLAYERSETUSAGE",
  1847252529: "IFCMATERIALLAYERWITHOFFSETS",
  2199411900: "IFCMATERIALLIST",
  2235152071: "IFCMATERIALPROFILE",
  164193824: "IFCMATERIALPROFILESET",
  3079605661: "IFCMATERIALPROFILESETUSAGE",
  3404854881: "IFCMATERIALPROFILESETUSAGETAPERING",
  552965576: "IFCMATERIALPROFILEWITHOFFSETS",
  3265635763: "IFCMATERIALPROPERTIES",
  853536259: "IFCMATERIALRELATIONSHIP",
  1507914824: "IFCMATERIALUSAGEDEFINITION",
  2597039031: "IFCMEASUREWITHUNIT",
  377706215: "IFCMECHANICALFASTENER",
  2108223431: "IFCMECHANICALFASTENERTYPE",
  1437502449: "IFCMEDICALDEVICE",
  1114901282: "IFCMEDICALDEVICETYPE",
  1073191201: "IFCMEMBER",
  1911478936: "IFCMEMBERSTANDARDCASE",
  3181161470: "IFCMEMBERTYPE",
  3368373690: "IFCMETRIC",
  2998442950: "IFCMIRROREDPROFILEDEF",
  2706619895: "IFCMONETARYUNIT",
  2474470126: "IFCMOTORCONNECTION",
  977012517: "IFCMOTORCONNECTIONTYPE",
  1918398963: "IFCNAMEDUNIT",
  3888040117: "IFCOBJECT",
  219451334: "IFCOBJECTDEFINITION",
  3701648758: "IFCOBJECTPLACEMENT",
  2251480897: "IFCOBJECTIVE",
  4143007308: "IFCOCCUPANT",
  590820931: "IFCOFFSETCURVE",
  3388369263: "IFCOFFSETCURVE2D",
  3505215534: "IFCOFFSETCURVE3D",
  2485787929: "IFCOFFSETCURVEBYDISTANCES",
  2665983363: "IFCOPENSHELL",
  3588315303: "IFCOPENINGELEMENT",
  3079942009: "IFCOPENINGSTANDARDCASE",
  4251960020: "IFCORGANIZATION",
  1411181986: "IFCORGANIZATIONRELATIONSHIP",
  643959842: "IFCORIENTATIONEXPRESSION",
  1029017970: "IFCORIENTEDEDGE",
  144952367: "IFCOUTERBOUNDARYCURVE",
  3694346114: "IFCOUTLET",
  2837617999: "IFCOUTLETTYPE",
  1207048766: "IFCOWNERHISTORY",
  2529465313: "IFCPARAMETERIZEDPROFILEDEF",
  2519244187: "IFCPATH",
  1682466193: "IFCPCURVE",
  2382730787: "IFCPERFORMANCEHISTORY",
  3566463478: "IFCPERMEABLECOVERINGPROPERTIES",
  3327091369: "IFCPERMIT",
  2077209135: "IFCPERSON",
  101040310: "IFCPERSONANDORGANIZATION",
  3021840470: "IFCPHYSICALCOMPLEXQUANTITY",
  2483315170: "IFCPHYSICALQUANTITY",
  2226359599: "IFCPHYSICALSIMPLEQUANTITY",
  1687234759: "IFCPILE",
  1158309216: "IFCPILETYPE",
  310824031: "IFCPIPEFITTING",
  804291784: "IFCPIPEFITTINGTYPE",
  3612865200: "IFCPIPESEGMENT",
  4231323485: "IFCPIPESEGMENTTYPE",
  597895409: "IFCPIXELTEXTURE",
  2004835150: "IFCPLACEMENT",
  603570806: "IFCPLANARBOX",
  1663979128: "IFCPLANAREXTENT",
  220341763: "IFCPLANE",
  3171933400: "IFCPLATE",
  1156407060: "IFCPLATESTANDARDCASE",
  4017108033: "IFCPLATETYPE",
  2067069095: "IFCPOINT",
  4022376103: "IFCPOINTONCURVE",
  1423911732: "IFCPOINTONSURFACE",
  2924175390: "IFCPOLYLOOP",
  2775532180: "IFCPOLYGONALBOUNDEDHALFSPACE",
  2839578677: "IFCPOLYGONALFACESET",
  3724593414: "IFCPOLYLINE",
  3740093272: "IFCPORT",
  1946335990: "IFCPOSITIONINGELEMENT",
  3355820592: "IFCPOSTALADDRESS",
  759155922: "IFCPREDEFINEDCOLOUR",
  2559016684: "IFCPREDEFINEDCURVEFONT",
  3727388367: "IFCPREDEFINEDITEM",
  3778827333: "IFCPREDEFINEDPROPERTIES",
  3967405729: "IFCPREDEFINEDPROPERTYSET",
  1775413392: "IFCPREDEFINEDTEXTFONT",
  677532197: "IFCPRESENTATIONITEM",
  2022622350: "IFCPRESENTATIONLAYERASSIGNMENT",
  1304840413: "IFCPRESENTATIONLAYERWITHSTYLE",
  3119450353: "IFCPRESENTATIONSTYLE",
  2417041796: "IFCPRESENTATIONSTYLEASSIGNMENT",
  2744685151: "IFCPROCEDURE",
  569719735: "IFCPROCEDURETYPE",
  2945172077: "IFCPROCESS",
  4208778838: "IFCPRODUCT",
  673634403: "IFCPRODUCTDEFINITIONSHAPE",
  2095639259: "IFCPRODUCTREPRESENTATION",
  3958567839: "IFCPROFILEDEF",
  2802850158: "IFCPROFILEPROPERTIES",
  103090709: "IFCPROJECT",
  653396225: "IFCPROJECTLIBRARY",
  2904328755: "IFCPROJECTORDER",
  3843373140: "IFCPROJECTEDCRS",
  3651124850: "IFCPROJECTIONELEMENT",
  2598011224: "IFCPROPERTY",
  986844984: "IFCPROPERTYABSTRACTION",
  871118103: "IFCPROPERTYBOUNDEDVALUE",
  1680319473: "IFCPROPERTYDEFINITION",
  148025276: "IFCPROPERTYDEPENDENCYRELATIONSHIP",
  4166981789: "IFCPROPERTYENUMERATEDVALUE",
  3710013099: "IFCPROPERTYENUMERATION",
  2752243245: "IFCPROPERTYLISTVALUE",
  941946838: "IFCPROPERTYREFERENCEVALUE",
  1451395588: "IFCPROPERTYSET",
  3357820518: "IFCPROPERTYSETDEFINITION",
  492091185: "IFCPROPERTYSETTEMPLATE",
  3650150729: "IFCPROPERTYSINGLEVALUE",
  110355661: "IFCPROPERTYTABLEVALUE",
  3521284610: "IFCPROPERTYTEMPLATE",
  1482703590: "IFCPROPERTYTEMPLATEDEFINITION",
  738039164: "IFCPROTECTIVEDEVICE",
  2295281155: "IFCPROTECTIVEDEVICETRIPPINGUNIT",
  655969474: "IFCPROTECTIVEDEVICETRIPPINGUNITTYPE",
  1842657554: "IFCPROTECTIVEDEVICETYPE",
  3219374653: "IFCPROXY",
  90941305: "IFCPUMP",
  2250791053: "IFCPUMPTYPE",
  2044713172: "IFCQUANTITYAREA",
  2093928680: "IFCQUANTITYCOUNT",
  931644368: "IFCQUANTITYLENGTH",
  2090586900: "IFCQUANTITYSET",
  3252649465: "IFCQUANTITYTIME",
  2405470396: "IFCQUANTITYVOLUME",
  825690147: "IFCQUANTITYWEIGHT",
  2262370178: "IFCRAILING",
  2893384427: "IFCRAILINGTYPE",
  3024970846: "IFCRAMP",
  3283111854: "IFCRAMPFLIGHT",
  2324767716: "IFCRAMPFLIGHTTYPE",
  1469900589: "IFCRAMPTYPE",
  1232101972: "IFCRATIONALBSPLINECURVEWITHKNOTS",
  683857671: "IFCRATIONALBSPLINESURFACEWITHKNOTS",
  2770003689: "IFCRECTANGLEHOLLOWPROFILEDEF",
  3615266464: "IFCRECTANGLEPROFILEDEF",
  2798486643: "IFCRECTANGULARPYRAMID",
  3454111270: "IFCRECTANGULARTRIMMEDSURFACE",
  3915482550: "IFCRECURRENCEPATTERN",
  2433181523: "IFCREFERENCE",
  4021432810: "IFCREFERENT",
  3413951693: "IFCREGULARTIMESERIES",
  1580146022: "IFCREINFORCEMENTBARPROPERTIES",
  3765753017: "IFCREINFORCEMENTDEFINITIONPROPERTIES",
  979691226: "IFCREINFORCINGBAR",
  2572171363: "IFCREINFORCINGBARTYPE",
  3027567501: "IFCREINFORCINGELEMENT",
  964333572: "IFCREINFORCINGELEMENTTYPE",
  2320036040: "IFCREINFORCINGMESH",
  2310774935: "IFCREINFORCINGMESHTYPE",
  160246688: "IFCRELAGGREGATES",
  3939117080: "IFCRELASSIGNS",
  1683148259: "IFCRELASSIGNSTOACTOR",
  2495723537: "IFCRELASSIGNSTOCONTROL",
  1307041759: "IFCRELASSIGNSTOGROUP",
  1027710054: "IFCRELASSIGNSTOGROUPBYFACTOR",
  4278684876: "IFCRELASSIGNSTOPROCESS",
  2857406711: "IFCRELASSIGNSTOPRODUCT",
  205026976: "IFCRELASSIGNSTORESOURCE",
  1865459582: "IFCRELASSOCIATES",
  4095574036: "IFCRELASSOCIATESAPPROVAL",
  919958153: "IFCRELASSOCIATESCLASSIFICATION",
  2728634034: "IFCRELASSOCIATESCONSTRAINT",
  982818633: "IFCRELASSOCIATESDOCUMENT",
  3840914261: "IFCRELASSOCIATESLIBRARY",
  2655215786: "IFCRELASSOCIATESMATERIAL",
  826625072: "IFCRELCONNECTS",
  1204542856: "IFCRELCONNECTSELEMENTS",
  3945020480: "IFCRELCONNECTSPATHELEMENTS",
  4201705270: "IFCRELCONNECTSPORTTOELEMENT",
  3190031847: "IFCRELCONNECTSPORTS",
  2127690289: "IFCRELCONNECTSSTRUCTURALACTIVITY",
  1638771189: "IFCRELCONNECTSSTRUCTURALMEMBER",
  504942748: "IFCRELCONNECTSWITHECCENTRICITY",
  3678494232: "IFCRELCONNECTSWITHREALIZINGELEMENTS",
  3242617779: "IFCRELCONTAINEDINSPATIALSTRUCTURE",
  886880790: "IFCRELCOVERSBLDGELEMENTS",
  2802773753: "IFCRELCOVERSSPACES",
  2565941209: "IFCRELDECLARES",
  2551354335: "IFCRELDECOMPOSES",
  693640335: "IFCRELDEFINES",
  1462361463: "IFCRELDEFINESBYOBJECT",
  4186316022: "IFCRELDEFINESBYPROPERTIES",
  307848117: "IFCRELDEFINESBYTEMPLATE",
  781010003: "IFCRELDEFINESBYTYPE",
  3940055652: "IFCRELFILLSELEMENT",
  279856033: "IFCRELFLOWCONTROLELEMENTS",
  427948657: "IFCRELINTERFERESELEMENTS",
  3268803585: "IFCRELNESTS",
  1441486842: "IFCRELPOSITIONS",
  750771296: "IFCRELPROJECTSELEMENT",
  1245217292: "IFCRELREFERENCEDINSPATIALSTRUCTURE",
  4122056220: "IFCRELSEQUENCE",
  366585022: "IFCRELSERVICESBUILDINGS",
  3451746338: "IFCRELSPACEBOUNDARY",
  3523091289: "IFCRELSPACEBOUNDARY1STLEVEL",
  1521410863: "IFCRELSPACEBOUNDARY2NDLEVEL",
  1401173127: "IFCRELVOIDSELEMENT",
  478536968: "IFCRELATIONSHIP",
  816062949: "IFCREPARAMETRISEDCOMPOSITECURVESEGMENT",
  1076942058: "IFCREPRESENTATION",
  3377609919: "IFCREPRESENTATIONCONTEXT",
  3008791417: "IFCREPRESENTATIONITEM",
  1660063152: "IFCREPRESENTATIONMAP",
  2914609552: "IFCRESOURCE",
  2943643501: "IFCRESOURCEAPPROVALRELATIONSHIP",
  1608871552: "IFCRESOURCECONSTRAINTRELATIONSHIP",
  2439245199: "IFCRESOURCELEVELRELATIONSHIP",
  1042787934: "IFCRESOURCETIME",
  1856042241: "IFCREVOLVEDAREASOLID",
  3243963512: "IFCREVOLVEDAREASOLIDTAPERED",
  4158566097: "IFCRIGHTCIRCULARCONE",
  3626867408: "IFCRIGHTCIRCULARCYLINDER",
  2016517767: "IFCROOF",
  2781568857: "IFCROOFTYPE",
  2341007311: "IFCROOT",
  2778083089: "IFCROUNDEDRECTANGLEPROFILEDEF",
  448429030: "IFCSIUNIT",
  3053780830: "IFCSANITARYTERMINAL",
  1768891740: "IFCSANITARYTERMINALTYPE",
  1054537805: "IFCSCHEDULINGTIME",
  2157484638: "IFCSEAMCURVE",
  2042790032: "IFCSECTIONPROPERTIES",
  4165799628: "IFCSECTIONREINFORCEMENTPROPERTIES",
  1862484736: "IFCSECTIONEDSOLID",
  1290935644: "IFCSECTIONEDSOLIDHORIZONTAL",
  1509187699: "IFCSECTIONEDSPINE",
  4086658281: "IFCSENSOR",
  1783015770: "IFCSENSORTYPE",
  1329646415: "IFCSHADINGDEVICE",
  4074543187: "IFCSHADINGDEVICETYPE",
  867548509: "IFCSHAPEASPECT",
  3982875396: "IFCSHAPEMODEL",
  4240577450: "IFCSHAPEREPRESENTATION",
  4124623270: "IFCSHELLBASEDSURFACEMODEL",
  3692461612: "IFCSIMPLEPROPERTY",
  3663146110: "IFCSIMPLEPROPERTYTEMPLATE",
  4097777520: "IFCSITE",
  1529196076: "IFCSLAB",
  3127900445: "IFCSLABELEMENTEDCASE",
  3027962421: "IFCSLABSTANDARDCASE",
  2533589738: "IFCSLABTYPE",
  2609359061: "IFCSLIPPAGECONNECTIONCONDITION",
  3420628829: "IFCSOLARDEVICE",
  1072016465: "IFCSOLARDEVICETYPE",
  723233188: "IFCSOLIDMODEL",
  3856911033: "IFCSPACE",
  1999602285: "IFCSPACEHEATER",
  1305183839: "IFCSPACEHEATERTYPE",
  3812236995: "IFCSPACETYPE",
  1412071761: "IFCSPATIALELEMENT",
  710998568: "IFCSPATIALELEMENTTYPE",
  2706606064: "IFCSPATIALSTRUCTUREELEMENT",
  3893378262: "IFCSPATIALSTRUCTUREELEMENTTYPE",
  463610769: "IFCSPATIALZONE",
  2481509218: "IFCSPATIALZONETYPE",
  451544542: "IFCSPHERE",
  4015995234: "IFCSPHERICALSURFACE",
  1404847402: "IFCSTACKTERMINAL",
  3112655638: "IFCSTACKTERMINALTYPE",
  331165859: "IFCSTAIR",
  4252922144: "IFCSTAIRFLIGHT",
  1039846685: "IFCSTAIRFLIGHTTYPE",
  338393293: "IFCSTAIRTYPE",
  682877961: "IFCSTRUCTURALACTION",
  3544373492: "IFCSTRUCTURALACTIVITY",
  2515109513: "IFCSTRUCTURALANALYSISMODEL",
  1179482911: "IFCSTRUCTURALCONNECTION",
  2273995522: "IFCSTRUCTURALCONNECTIONCONDITION",
  1004757350: "IFCSTRUCTURALCURVEACTION",
  4243806635: "IFCSTRUCTURALCURVECONNECTION",
  214636428: "IFCSTRUCTURALCURVEMEMBER",
  2445595289: "IFCSTRUCTURALCURVEMEMBERVARYING",
  2757150158: "IFCSTRUCTURALCURVEREACTION",
  3136571912: "IFCSTRUCTURALITEM",
  1807405624: "IFCSTRUCTURALLINEARACTION",
  2162789131: "IFCSTRUCTURALLOAD",
  385403989: "IFCSTRUCTURALLOADCASE",
  3478079324: "IFCSTRUCTURALLOADCONFIGURATION",
  1252848954: "IFCSTRUCTURALLOADGROUP",
  1595516126: "IFCSTRUCTURALLOADLINEARFORCE",
  609421318: "IFCSTRUCTURALLOADORRESULT",
  2668620305: "IFCSTRUCTURALLOADPLANARFORCE",
  2473145415: "IFCSTRUCTURALLOADSINGLEDISPLACEMENT",
  1973038258: "IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION",
  1597423693: "IFCSTRUCTURALLOADSINGLEFORCE",
  1190533807: "IFCSTRUCTURALLOADSINGLEFORCEWARPING",
  2525727697: "IFCSTRUCTURALLOADSTATIC",
  3408363356: "IFCSTRUCTURALLOADTEMPERATURE",
  530289379: "IFCSTRUCTURALMEMBER",
  1621171031: "IFCSTRUCTURALPLANARACTION",
  2082059205: "IFCSTRUCTURALPOINTACTION",
  734778138: "IFCSTRUCTURALPOINTCONNECTION",
  1235345126: "IFCSTRUCTURALPOINTREACTION",
  3689010777: "IFCSTRUCTURALREACTION",
  2986769608: "IFCSTRUCTURALRESULTGROUP",
  3657597509: "IFCSTRUCTURALSURFACEACTION",
  1975003073: "IFCSTRUCTURALSURFACECONNECTION",
  3979015343: "IFCSTRUCTURALSURFACEMEMBER",
  2218152070: "IFCSTRUCTURALSURFACEMEMBERVARYING",
  603775116: "IFCSTRUCTURALSURFACEREACTION",
  2830218821: "IFCSTYLEMODEL",
  3958052878: "IFCSTYLEDITEM",
  3049322572: "IFCSTYLEDREPRESENTATION",
  148013059: "IFCSUBCONTRACTRESOURCE",
  4095615324: "IFCSUBCONTRACTRESOURCETYPE",
  2233826070: "IFCSUBEDGE",
  2513912981: "IFCSURFACE",
  699246055: "IFCSURFACECURVE",
  2028607225: "IFCSURFACECURVESWEPTAREASOLID",
  3101698114: "IFCSURFACEFEATURE",
  2809605785: "IFCSURFACEOFLINEAREXTRUSION",
  4124788165: "IFCSURFACEOFREVOLUTION",
  2934153892: "IFCSURFACEREINFORCEMENTAREA",
  1300840506: "IFCSURFACESTYLE",
  3303107099: "IFCSURFACESTYLELIGHTING",
  1607154358: "IFCSURFACESTYLEREFRACTION",
  1878645084: "IFCSURFACESTYLERENDERING",
  846575682: "IFCSURFACESTYLESHADING",
  1351298697: "IFCSURFACESTYLEWITHTEXTURES",
  626085974: "IFCSURFACETEXTURE",
  2247615214: "IFCSWEPTAREASOLID",
  1260650574: "IFCSWEPTDISKSOLID",
  1096409881: "IFCSWEPTDISKSOLIDPOLYGONAL",
  230924584: "IFCSWEPTSURFACE",
  1162798199: "IFCSWITCHINGDEVICE",
  2315554128: "IFCSWITCHINGDEVICETYPE",
  2254336722: "IFCSYSTEM",
  413509423: "IFCSYSTEMFURNITUREELEMENT",
  1580310250: "IFCSYSTEMFURNITUREELEMENTTYPE",
  3071757647: "IFCTSHAPEPROFILEDEF",
  985171141: "IFCTABLE",
  2043862942: "IFCTABLECOLUMN",
  531007025: "IFCTABLEROW",
  812556717: "IFCTANK",
  5716631: "IFCTANKTYPE",
  3473067441: "IFCTASK",
  1549132990: "IFCTASKTIME",
  2771591690: "IFCTASKTIMERECURRING",
  3206491090: "IFCTASKTYPE",
  912023232: "IFCTELECOMADDRESS",
  3824725483: "IFCTENDON",
  2347447852: "IFCTENDONANCHOR",
  3081323446: "IFCTENDONANCHORTYPE",
  3663046924: "IFCTENDONCONDUIT",
  2281632017: "IFCTENDONCONDUITTYPE",
  2415094496: "IFCTENDONTYPE",
  2387106220: "IFCTESSELLATEDFACESET",
  901063453: "IFCTESSELLATEDITEM",
  4282788508: "IFCTEXTLITERAL",
  3124975700: "IFCTEXTLITERALWITHEXTENT",
  1447204868: "IFCTEXTSTYLE",
  1983826977: "IFCTEXTSTYLEFONTMODEL",
  2636378356: "IFCTEXTSTYLEFORDEFINEDFONT",
  1640371178: "IFCTEXTSTYLETEXTMODEL",
  280115917: "IFCTEXTURECOORDINATE",
  1742049831: "IFCTEXTURECOORDINATEGENERATOR",
  2552916305: "IFCTEXTUREMAP",
  1210645708: "IFCTEXTUREVERTEX",
  3611470254: "IFCTEXTUREVERTEXLIST",
  1199560280: "IFCTIMEPERIOD",
  3101149627: "IFCTIMESERIES",
  581633288: "IFCTIMESERIESVALUE",
  1377556343: "IFCTOPOLOGICALREPRESENTATIONITEM",
  1735638870: "IFCTOPOLOGYREPRESENTATION",
  1935646853: "IFCTOROIDALSURFACE",
  3825984169: "IFCTRANSFORMER",
  1692211062: "IFCTRANSFORMERTYPE",
  2595432518: "IFCTRANSITIONCURVESEGMENT2D",
  1620046519: "IFCTRANSPORTELEMENT",
  2097647324: "IFCTRANSPORTELEMENTTYPE",
  2715220739: "IFCTRAPEZIUMPROFILEDEF",
  2916149573: "IFCTRIANGULATEDFACESET",
  1229763772: "IFCTRIANGULATEDIRREGULARNETWORK",
  3593883385: "IFCTRIMMEDCURVE",
  3026737570: "IFCTUBEBUNDLE",
  1600972822: "IFCTUBEBUNDLETYPE",
  1628702193: "IFCTYPEOBJECT",
  3736923433: "IFCTYPEPROCESS",
  2347495698: "IFCTYPEPRODUCT",
  3698973494: "IFCTYPERESOURCE",
  427810014: "IFCUSHAPEPROFILEDEF",
  180925521: "IFCUNITASSIGNMENT",
  630975310: "IFCUNITARYCONTROLELEMENT",
  3179687236: "IFCUNITARYCONTROLELEMENTTYPE",
  4292641817: "IFCUNITARYEQUIPMENT",
  1911125066: "IFCUNITARYEQUIPMENTTYPE",
  4207607924: "IFCVALVE",
  728799441: "IFCVALVETYPE",
  1417489154: "IFCVECTOR",
  2799835756: "IFCVERTEX",
  2759199220: "IFCVERTEXLOOP",
  1907098498: "IFCVERTEXPOINT",
  1530820697: "IFCVIBRATIONDAMPER",
  3956297820: "IFCVIBRATIONDAMPERTYPE",
  2391383451: "IFCVIBRATIONISOLATOR",
  3313531582: "IFCVIBRATIONISOLATORTYPE",
  2769231204: "IFCVIRTUALELEMENT",
  891718957: "IFCVIRTUALGRIDINTERSECTION",
  926996030: "IFCVOIDINGFEATURE",
  2391406946: "IFCWALL",
  4156078855: "IFCWALLELEMENTEDCASE",
  3512223829: "IFCWALLSTANDARDCASE",
  1898987631: "IFCWALLTYPE",
  4237592921: "IFCWASTETERMINAL",
  1133259667: "IFCWASTETERMINALTYPE",
  3304561284: "IFCWINDOW",
  336235671: "IFCWINDOWLININGPROPERTIES",
  512836454: "IFCWINDOWPANELPROPERTIES",
  486154966: "IFCWINDOWSTANDARDCASE",
  1299126871: "IFCWINDOWSTYLE",
  4009809668: "IFCWINDOWTYPE",
  4088093105: "IFCWORKCALENDAR",
  1028945134: "IFCWORKCONTROL",
  4218914973: "IFCWORKPLAN",
  3342526732: "IFCWORKSCHEDULE",
  1236880293: "IFCWORKTIME",
  2543172580: "IFCZSHAPEPROFILEDEF",
  1033361043: "IFCZONE"
};
var PropsNames = {
  aggregates: {
    name: IFCRELAGGREGATES,
    relating: "RelatingObject",
    related: "RelatedObjects",
    key: "children"
  },
  spatial: {
    name: IFCRELCONTAINEDINSPATIALSTRUCTURE,
    relating: "RelatingStructure",
    related: "RelatedElements",
    key: "children"
  },
  psets: {
    name: IFCRELDEFINESBYPROPERTIES,
    relating: "RelatingPropertyDefinition",
    related: "RelatedObjects",
    key: "hasPsets"
  },
  materials: {
    name: IFCRELASSOCIATESMATERIAL,
    relating: "RelatingMaterial",
    related: "RelatedObjects",
    key: "hasMaterial"
  },
  type: {
    name: IFCRELDEFINESBYTYPE,
    relating: "RelatingType",
    related: "RelatedObjects",
    key: "hasType"
  }
};
var Properties = /* @__PURE__ */ __name(class {
  constructor(api) {
    this.api = api;
  }
  getIfcType(type) {
    return IfcTypesMap[type];
  }
  getItemProperties(modelID, id, recursive = false) {
    return __async(this, null, function* () {
      return this.api.GetLine(modelID, id, recursive);
    });
  }
  getPropertySets(modelID, elementID, recursive = false) {
    return __async(this, null, function* () {
      return yield this.getProperty(modelID, elementID, recursive, PropsNames.psets);
    });
  }
  getTypeProperties(modelID, elementID, recursive = false) {
    return __async(this, null, function* () {
      return yield this.getProperty(modelID, elementID, recursive, PropsNames.type);
    });
  }
  getMaterialsProperties(modelID, elementID, recursive = false) {
    return __async(this, null, function* () {
      return yield this.getProperty(modelID, elementID, recursive, PropsNames.materials);
    });
  }
  getSpatialStructure(modelID, includeProperties) {
    return __async(this, null, function* () {
      yield this.getAllTypesOfModel(modelID);
      const chunks = yield this.getSpatialTreeChunks(modelID);
      const allLines = yield this.api.GetLineIDsWithType(modelID, IFCPROJECT);
      const projectID = allLines.get(0);
      const project = Properties.newIfcProject(projectID);
      yield this.getSpatialNode(modelID, project, chunks, includeProperties);
      this.cleanupTypes();
      return project;
    });
  }
  getAllItemsOfType(modelID, type, verbose) {
    return __async(this, null, function* () {
      let items = [];
      const lines = yield this.api.GetLineIDsWithType(modelID, type);
      for (let i = 0; i < lines.size(); i++)
        items.push(lines.get(i));
      if (!verbose)
        return items;
      const result = [];
      for (let i = 0; i < items.length; i++) {
        result.push(yield this.api.GetLine(modelID, items[i]));
      }
      return result;
    });
  }
  getProperty(modelID, elementID, recursive = false, propName) {
    return __async(this, null, function* () {
      const propSetIds = yield this.getAllRelatedItemsOfType(modelID, elementID, propName);
      const result = [];
      for (let i = 0; i < propSetIds.length; i++) {
        result.push(yield this.api.GetLine(modelID, propSetIds[i], recursive));
      }
      return result;
    });
  }
  getChunks(modelID, chunks, propNames) {
    return __async(this, null, function* () {
      const relation = yield this.api.GetLineIDsWithType(modelID, propNames.name);
      for (let i = 0; i < relation.size(); i++) {
        const rel = yield this.api.GetLine(modelID, relation.get(i), false);
        this.saveChunk(chunks, propNames, rel);
      }
    });
  }
  static isRelated(id, rel, propNames) {
    const relatedItems = rel[propNames.related];
    if (Array.isArray(relatedItems)) {
      const values = relatedItems.map((item) => item.value);
      return values.includes(id);
    }
    return relatedItems.value === id;
  }
  static newIfcProject(id) {
    return {
      expressID: id,
      type: "IFCPROJECT",
      children: []
    };
  }
  getSpatialNode(modelID, node, treeChunks, includeProperties) {
    return __async(this, null, function* () {
      yield this.getChildren(modelID, node, treeChunks, PropsNames.aggregates, includeProperties);
      yield this.getChildren(modelID, node, treeChunks, PropsNames.spatial, includeProperties);
    });
  }
  getChildren(modelID, node, treeChunks, propNames, includeProperties) {
    return __async(this, null, function* () {
      const children = treeChunks[node.expressID];
      if (children == void 0)
        return;
      const prop = propNames.key;
      const nodes = [];
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        let node2 = this.newNode(child);
        if (includeProperties) {
          const properties = yield this.getItemProperties(modelID, node2.expressID);
          node2 = __spreadValues(__spreadValues({}, properties), node2);
        }
        yield this.getSpatialNode(modelID, node2, treeChunks, includeProperties);
        nodes.push(node2);
      }
      node[prop] = nodes;
    });
  }
  newNode(id) {
    const typeName = this.getNodeType(id);
    return {
      expressID: id,
      type: typeName,
      children: []
    };
  }
  getNodeType(id) {
    const typeID = this.types[id];
    return IfcElements2[typeID];
  }
  getSpatialTreeChunks(modelID) {
    return __async(this, null, function* () {
      const treeChunks = {};
      yield this.getChunks(modelID, treeChunks, PropsNames.aggregates);
      yield this.getChunks(modelID, treeChunks, PropsNames.spatial);
      return treeChunks;
    });
  }
  saveChunk(chunks, propNames, rel) {
    const relating = rel[propNames.relating].value;
    const related = rel[propNames.related].map((r) => r.value);
    if (chunks[relating] == void 0) {
      chunks[relating] = related;
    } else {
      chunks[relating] = chunks[relating].concat(related);
    }
  }
  getRelated(rel, propNames, IDs) {
    const element = rel[propNames.relating];
    if (!Array.isArray(element))
      IDs.push(element.value);
    else
      element.forEach((ele) => IDs.push(ele.value));
  }
  getAllRelatedItemsOfType(modelID, id, propNames) {
    return __async(this, null, function* () {
      const lines = yield this.api.GetLineIDsWithType(modelID, propNames.name);
      const IDs = [];
      for (let i = 0; i < lines.size(); i++) {
        const rel = yield this.api.GetLine(modelID, lines.get(i));
        const isRelated = Properties.isRelated(id, rel, propNames);
        if (isRelated)
          this.getRelated(rel, propNames, IDs);
      }
      return IDs;
    });
  }
  cleanupTypes() {
    this.types = {};
  }
  getAllTypesOfModel(modelID) {
    return __async(this, null, function* () {
      const result = {};
      const elements = Object.keys(IfcElements2).map((e) => parseInt(e));
      for (let i = 0; i < elements.length; i++) {
        const element = elements[i];
        const lines = yield this.api.GetLineIDsWithType(modelID, element);
        const size = lines.size();
        for (let i2 = 0; i2 < size; i2++)
          result[lines.get(i2)] = element;
      }
      this.types = result;
    });
  }
}, "Properties");
var WebIFCWasm;
if (typeof self !== "undefined" && self.crossOriginIsolated) {
  WebIFCWasm = require_web_ifc_mt();
} else {
  WebIFCWasm = require_web_ifc();
}
var STRING = 1;
var LABEL = 2;
var ENUM = 3;
var REAL = 4;
var REF = 5;
var IfcAPI2 = /* @__PURE__ */ __name(class {
  constructor() {
    this.wasmModule = void 0;
    this.fs = void 0;
    this.wasmPath = "";
    this.isWasmPathAbsolute = false;
    this.ifcGuidMap = /* @__PURE__ */ new Map();
    this.properties = new Properties(this);
  }
  Init(customLocateFileHandler) {
    return __async(this, null, function* () {
      if (WebIFCWasm) {
        let locateFileHandler = /* @__PURE__ */ __name((path, prefix) => {
          if (path.endsWith(".wasm")) {
            if (this.isWasmPathAbsolute) {
              return this.wasmPath + path;
            }
            return prefix + this.wasmPath + path;
          }
          return prefix + path;
        }, "locateFileHandler");
        this.wasmModule = yield WebIFCWasm({ noInitialRun: true, locateFile: customLocateFileHandler || locateFileHandler });
        this.fs = this.wasmModule.FS;
      } else {
        console.error(`Could not find wasm module at './web-ifc' from web-ifc-api.ts`);
      }
    });
  }
  OpenModel(data, settings) {
    let s = __spreadValues({
      COORDINATE_TO_ORIGIN: false,
      USE_FAST_BOOLS: false,
      CIRCLE_SEGMENTS_LOW: 5,
      CIRCLE_SEGMENTS_MEDIUM: 8,
      CIRCLE_SEGMENTS_HIGH: 12,
      BOOL_ABORT_THRESHOLD: 1e4
    }, settings);
    let offsetInSrc = 0;
    let result = this.wasmModule.OpenModel(s, (destPtr, destSize) => {
      let srcSize = Math.min(data.byteLength - offsetInSrc, destSize);
      let dest = this.wasmModule.HEAPU8.subarray(destPtr, destPtr + destSize);
      let src = data.subarray(offsetInSrc, offsetInSrc + srcSize);
      dest.set(src);
      offsetInSrc += srcSize;
      return srcSize;
    });
    return result;
  }
  CreateModel(settings) {
    let s = __spreadValues({
      COORDINATE_TO_ORIGIN: false,
      USE_FAST_BOOLS: false,
      CIRCLE_SEGMENTS_LOW: 5,
      CIRCLE_SEGMENTS_MEDIUM: 8,
      CIRCLE_SEGMENTS_HIGH: 12,
      BOOL_ABORT_THRESHOLD: 1e4
    }, settings);
    let result = this.wasmModule.CreateModel(s);
    return result;
  }
  ExportFileAsIFC(modelID) {
    this.wasmModule.ExportFileAsIFC(modelID);
    let result = this.fs.readFile("/export.ifc");
    this.wasmModule["FS_unlink"]("/export.ifc");
    return result;
  }
  GetGeometry(modelID, geometryExpressID) {
    return this.wasmModule.GetGeometry(modelID, geometryExpressID);
  }
  GetLine(modelID, expressID, flatten = false) {
    let rawLineData = this.GetRawLineData(modelID, expressID);
    let lineData = FromRawLineData[rawLineData.type](rawLineData);
    if (flatten) {
      this.FlattenLine(modelID, lineData);
    }
    return lineData;
  }
  GetAndClearErrors(modelID) {
    return this.wasmModule.GetAndClearErrors(modelID);
  }
  WriteLine(modelID, lineObject) {
    Object.keys(lineObject).forEach((propertyName) => {
      let property = lineObject[propertyName];
      if (property && property.expressID !== void 0) {
        this.WriteLine(modelID, property);
        lineObject[propertyName] = {
          type: 5,
          value: property.expressID
        };
      } else if (Array.isArray(property) && property.length > 0) {
        for (let i = 0; i < property.length; i++) {
          if (property[i].expressID !== void 0) {
            this.WriteLine(modelID, property[i]);
            lineObject[propertyName][i] = {
              type: 5,
              value: property[i].expressID
            };
          }
        }
      }
    });
    if (lineObject.expressID == void 0 || lineObject.type == void 0 || lineObject.ToType === void 0) {
      console.warn("Line object cannot be serialized: ", lineObject);
      return;
    }
    let rawLineData = {
      ID: lineObject.expressID,
      type: lineObject.type,
      arguments: lineObject.ToTape()
    };
    this.WriteRawLineData(modelID, rawLineData);
  }
  FlattenLine(modelID, line) {
    Object.keys(line).forEach((propertyName) => {
      let property = line[propertyName];
      if (property && property.type === 5) {
        line[propertyName] = this.GetLine(modelID, property.value, true);
      } else if (Array.isArray(property) && property.length > 0 && property[0].type === 5) {
        for (let i = 0; i < property.length; i++) {
          line[propertyName][i] = this.GetLine(modelID, property[i].value, true);
        }
      }
    });
  }
  GetRawLineData(modelID, expressID) {
    return this.wasmModule.GetLine(modelID, expressID);
  }
  WriteRawLineData(modelID, data) {
    return this.wasmModule.WriteLine(modelID, data.ID, data.type, data.arguments);
  }
  GetLineIDsWithType(modelID, type) {
    return this.wasmModule.GetLineIDsWithType(modelID, type);
  }
  GetAllLines(modelID) {
    return this.wasmModule.GetAllLines(modelID);
  }
  SetGeometryTransformation(modelID, transformationMatrix) {
    if (transformationMatrix.length != 16) {
      console.log(`Bad transformation matrix size: ${transformationMatrix.length}`);
      return;
    }
    this.wasmModule.SetGeometryTransformation(modelID, transformationMatrix);
  }
  GetCoordinationMatrix(modelID) {
    return this.wasmModule.GetCoordinationMatrix(modelID);
  }
  GetVertexArray(ptr, size) {
    return this.getSubArray(this.wasmModule.HEAPF32, ptr, size);
  }
  GetIndexArray(ptr, size) {
    return this.getSubArray(this.wasmModule.HEAPU32, ptr, size);
  }
  getSubArray(heap, startPtr, sizeBytes) {
    return heap.subarray(startPtr / 4, startPtr / 4 + sizeBytes).slice(0);
  }
  CloseModel(modelID) {
    this.ifcGuidMap.delete(modelID);
    this.wasmModule.CloseModel(modelID);
  }
  StreamAllMeshes(modelID, meshCallback) {
    this.wasmModule.StreamAllMeshes(modelID, meshCallback);
  }
  StreamAllMeshesWithTypes(modelID, types, meshCallback) {
    this.wasmModule.StreamAllMeshesWithTypes(modelID, types, meshCallback);
  }
  IsModelOpen(modelID) {
    return this.wasmModule.IsModelOpen(modelID);
  }
  LoadAllGeometry(modelID) {
    return this.wasmModule.LoadAllGeometry(modelID);
  }
  GetFlatMesh(modelID, expressID) {
    return this.wasmModule.GetFlatMesh(modelID, expressID);
  }
  CreateIfcGuidToExpressIdMapping(modelID) {
    const map = /* @__PURE__ */ new Map();
    for (let x = 0; x < IfcElements.length; x++) {
      const type = IfcElements[x];
      const lines = this.GetLineIDsWithType(modelID, type);
      const size = lines.size();
      for (let y = 0; y < size; y++) {
        const expressID = lines.get(y);
        const info = this.GetLine(modelID, expressID);
        const globalID = info.GlobalId.value;
        map.set(expressID, globalID);
        map.set(globalID, expressID);
      }
    }
    this.ifcGuidMap.set(modelID, map);
  }
  SetWasmPath(path, absolute = false) {
    this.wasmPath = path;
    this.isWasmPathAbsolute = absolute;
  }
}, "IfcAPI2");

// lib/src/strings.js
function stoi(s) {
  const i = parseInt(s);
  if (!isFinite(i)) {
    throw new Error(`Expected integer, got: ${s}`);
  }
  return i;
}
__name(stoi, "stoi");

// lib/src/IfcTypesMap.js
var namesById = {
  3821786052: "IFCACTIONREQUEST",
  2296667514: "IFCACTOR",
  3630933823: "IFCACTORROLE",
  4288193352: "IFCACTUATOR",
  2874132201: "IFCACTUATORTYPE",
  618182010: "IFCADDRESS",
  1635779807: "IFCADVANCEDBREP",
  2603310189: "IFCADVANCEDBREPWITHVOIDS",
  3406155212: "IFCADVANCEDFACE",
  1634111441: "IFCAIRTERMINAL",
  177149247: "IFCAIRTERMINALBOX",
  1411407467: "IFCAIRTERMINALBOXTYPE",
  3352864051: "IFCAIRTERMINALTYPE",
  2056796094: "IFCAIRTOAIRHEATRECOVERY",
  1871374353: "IFCAIRTOAIRHEATRECOVERYTYPE",
  3087945054: "IFCALARM",
  3001207471: "IFCALARMTYPE",
  325726236: "IFCALIGNMENT",
  749761778: "IFCALIGNMENT2DHORIZONTAL",
  3199563722: "IFCALIGNMENT2DHORIZONTALSEGMENT",
  2483840362: "IFCALIGNMENT2DSEGMENT",
  3379348081: "IFCALIGNMENT2DVERSEGCIRCULARARC",
  3239324667: "IFCALIGNMENT2DVERSEGLINE",
  4263986512: "IFCALIGNMENT2DVERSEGPARABOLICARC",
  53199957: "IFCALIGNMENT2DVERTICAL",
  2029264950: "IFCALIGNMENT2DVERTICALSEGMENT",
  3512275521: "IFCALIGNMENTCURVE",
  1674181508: "IFCANNOTATION",
  669184980: "IFCANNOTATIONFILLAREA",
  639542469: "IFCAPPLICATION",
  411424972: "IFCAPPLIEDVALUE",
  130549933: "IFCAPPROVAL",
  3869604511: "IFCAPPROVALRELATIONSHIP",
  3798115385: "IFCARBITRARYCLOSEDPROFILEDEF",
  1310608509: "IFCARBITRARYOPENPROFILEDEF",
  2705031697: "IFCARBITRARYPROFILEDEFWITHVOIDS",
  3460190687: "IFCASSET",
  3207858831: "IFCASYMMETRICISHAPEPROFILEDEF",
  277319702: "IFCAUDIOVISUALAPPLIANCE",
  1532957894: "IFCAUDIOVISUALAPPLIANCETYPE",
  4261334040: "IFCAXIS1PLACEMENT",
  3125803723: "IFCAXIS2PLACEMENT2D",
  2740243338: "IFCAXIS2PLACEMENT3D",
  1967976161: "IFCBSPLINECURVE",
  2461110595: "IFCBSPLINECURVEWITHKNOTS",
  2887950389: "IFCBSPLINESURFACE",
  167062518: "IFCBSPLINESURFACEWITHKNOTS",
  753842376: "IFCBEAM",
  2906023776: "IFCBEAMSTANDARDCASE",
  819618141: "IFCBEAMTYPE",
  4196446775: "IFCBEARING",
  3649138523: "IFCBEARINGTYPE",
  616511568: "IFCBLOBTEXTURE",
  1334484129: "IFCBLOCK",
  32344328: "IFCBOILER",
  231477066: "IFCBOILERTYPE",
  3649129432: "IFCBOOLEANCLIPPINGRESULT",
  2736907675: "IFCBOOLEANRESULT",
  4037036970: "IFCBOUNDARYCONDITION",
  1136057603: "IFCBOUNDARYCURVE",
  1560379544: "IFCBOUNDARYEDGECONDITION",
  3367102660: "IFCBOUNDARYFACECONDITION",
  1387855156: "IFCBOUNDARYNODECONDITION",
  2069777674: "IFCBOUNDARYNODECONDITIONWARPING",
  1260505505: "IFCBOUNDEDCURVE",
  4182860854: "IFCBOUNDEDSURFACE",
  2581212453: "IFCBOUNDINGBOX",
  2713105998: "IFCBOXEDHALFSPACE",
  644574406: "IFCBRIDGE",
  963979645: "IFCBRIDGEPART",
  4031249490: "IFCBUILDING",
  3299480353: "IFCBUILDINGELEMENT",
  2979338954: "IFCBUILDINGELEMENTPART",
  39481116: "IFCBUILDINGELEMENTPARTTYPE",
  1095909175: "IFCBUILDINGELEMENTPROXY",
  1909888760: "IFCBUILDINGELEMENTPROXYTYPE",
  1950629157: "IFCBUILDINGELEMENTTYPE",
  3124254112: "IFCBUILDINGSTOREY",
  1177604601: "IFCBUILDINGSYSTEM",
  2938176219: "IFCBURNER",
  2188180465: "IFCBURNERTYPE",
  2898889636: "IFCCSHAPEPROFILEDEF",
  635142910: "IFCCABLECARRIERFITTING",
  395041908: "IFCCABLECARRIERFITTINGTYPE",
  3758799889: "IFCCABLECARRIERSEGMENT",
  3293546465: "IFCCABLECARRIERSEGMENTTYPE",
  1051757585: "IFCCABLEFITTING",
  2674252688: "IFCCABLEFITTINGTYPE",
  4217484030: "IFCCABLESEGMENT",
  1285652485: "IFCCABLESEGMENTTYPE",
  3999819293: "IFCCAISSONFOUNDATION",
  3203706013: "IFCCAISSONFOUNDATIONTYPE",
  1123145078: "IFCCARTESIANPOINT",
  574549367: "IFCCARTESIANPOINTLIST",
  1675464909: "IFCCARTESIANPOINTLIST2D",
  2059837836: "IFCCARTESIANPOINTLIST3D",
  59481748: "IFCCARTESIANTRANSFORMATIONOPERATOR",
  3749851601: "IFCCARTESIANTRANSFORMATIONOPERATOR2D",
  3486308946: "IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM",
  3331915920: "IFCCARTESIANTRANSFORMATIONOPERATOR3D",
  1416205885: "IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM",
  3150382593: "IFCCENTERLINEPROFILEDEF",
  3902619387: "IFCCHILLER",
  2951183804: "IFCCHILLERTYPE",
  3296154744: "IFCCHIMNEY",
  2197970202: "IFCCHIMNEYTYPE",
  2611217952: "IFCCIRCLE",
  2937912522: "IFCCIRCLEHOLLOWPROFILEDEF",
  1383045692: "IFCCIRCLEPROFILEDEF",
  1062206242: "IFCCIRCULARARCSEGMENT2D",
  1677625105: "IFCCIVILELEMENT",
  3893394355: "IFCCIVILELEMENTTYPE",
  747523909: "IFCCLASSIFICATION",
  647927063: "IFCCLASSIFICATIONREFERENCE",
  2205249479: "IFCCLOSEDSHELL",
  639361253: "IFCCOIL",
  2301859152: "IFCCOILTYPE",
  776857604: "IFCCOLOURRGB",
  3285139300: "IFCCOLOURRGBLIST",
  3264961684: "IFCCOLOURSPECIFICATION",
  843113511: "IFCCOLUMN",
  905975707: "IFCCOLUMNSTANDARDCASE",
  300633059: "IFCCOLUMNTYPE",
  3221913625: "IFCCOMMUNICATIONSAPPLIANCE",
  400855858: "IFCCOMMUNICATIONSAPPLIANCETYPE",
  2542286263: "IFCCOMPLEXPROPERTY",
  3875453745: "IFCCOMPLEXPROPERTYTEMPLATE",
  3732776249: "IFCCOMPOSITECURVE",
  15328376: "IFCCOMPOSITECURVEONSURFACE",
  2485617015: "IFCCOMPOSITECURVESEGMENT",
  1485152156: "IFCCOMPOSITEPROFILEDEF",
  3571504051: "IFCCOMPRESSOR",
  3850581409: "IFCCOMPRESSORTYPE",
  2272882330: "IFCCONDENSER",
  2816379211: "IFCCONDENSERTYPE",
  2510884976: "IFCCONIC",
  370225590: "IFCCONNECTEDFACESET",
  1981873012: "IFCCONNECTIONCURVEGEOMETRY",
  2859738748: "IFCCONNECTIONGEOMETRY",
  45288368: "IFCCONNECTIONPOINTECCENTRICITY",
  2614616156: "IFCCONNECTIONPOINTGEOMETRY",
  2732653382: "IFCCONNECTIONSURFACEGEOMETRY",
  775493141: "IFCCONNECTIONVOLUMEGEOMETRY",
  1959218052: "IFCCONSTRAINT",
  3898045240: "IFCCONSTRUCTIONEQUIPMENTRESOURCE",
  2185764099: "IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE",
  1060000209: "IFCCONSTRUCTIONMATERIALRESOURCE",
  4105962743: "IFCCONSTRUCTIONMATERIALRESOURCETYPE",
  488727124: "IFCCONSTRUCTIONPRODUCTRESOURCE",
  1525564444: "IFCCONSTRUCTIONPRODUCTRESOURCETYPE",
  2559216714: "IFCCONSTRUCTIONRESOURCE",
  2574617495: "IFCCONSTRUCTIONRESOURCETYPE",
  3419103109: "IFCCONTEXT",
  3050246964: "IFCCONTEXTDEPENDENTUNIT",
  3293443760: "IFCCONTROL",
  25142252: "IFCCONTROLLER",
  578613899: "IFCCONTROLLERTYPE",
  2889183280: "IFCCONVERSIONBASEDUNIT",
  2713554722: "IFCCONVERSIONBASEDUNITWITHOFFSET",
  4136498852: "IFCCOOLEDBEAM",
  335055490: "IFCCOOLEDBEAMTYPE",
  3640358203: "IFCCOOLINGTOWER",
  2954562838: "IFCCOOLINGTOWERTYPE",
  1785450214: "IFCCOORDINATEOPERATION",
  1466758467: "IFCCOORDINATEREFERENCESYSTEM",
  3895139033: "IFCCOSTITEM",
  1419761937: "IFCCOSTSCHEDULE",
  602808272: "IFCCOSTVALUE",
  1973544240: "IFCCOVERING",
  1916426348: "IFCCOVERINGTYPE",
  3295246426: "IFCCREWRESOURCE",
  1815067380: "IFCCREWRESOURCETYPE",
  2506170314: "IFCCSGPRIMITIVE3D",
  2147822146: "IFCCSGSOLID",
  539742890: "IFCCURRENCYRELATIONSHIP",
  3495092785: "IFCCURTAINWALL",
  1457835157: "IFCCURTAINWALLTYPE",
  2601014836: "IFCCURVE",
  2827736869: "IFCCURVEBOUNDEDPLANE",
  2629017746: "IFCCURVEBOUNDEDSURFACE",
  1186437898: "IFCCURVESEGMENT2D",
  3800577675: "IFCCURVESTYLE",
  1105321065: "IFCCURVESTYLEFONT",
  2367409068: "IFCCURVESTYLEFONTANDSCALING",
  3510044353: "IFCCURVESTYLEFONTPATTERN",
  1213902940: "IFCCYLINDRICALSURFACE",
  4074379575: "IFCDAMPER",
  3961806047: "IFCDAMPERTYPE",
  3426335179: "IFCDEEPFOUNDATION",
  1306400036: "IFCDEEPFOUNDATIONTYPE",
  3632507154: "IFCDERIVEDPROFILEDEF",
  1765591967: "IFCDERIVEDUNIT",
  1045800335: "IFCDERIVEDUNITELEMENT",
  2949456006: "IFCDIMENSIONALEXPONENTS",
  32440307: "IFCDIRECTION",
  1335981549: "IFCDISCRETEACCESSORY",
  2635815018: "IFCDISCRETEACCESSORYTYPE",
  1945343521: "IFCDISTANCEEXPRESSION",
  1052013943: "IFCDISTRIBUTIONCHAMBERELEMENT",
  1599208980: "IFCDISTRIBUTIONCHAMBERELEMENTTYPE",
  562808652: "IFCDISTRIBUTIONCIRCUIT",
  1062813311: "IFCDISTRIBUTIONCONTROLELEMENT",
  2063403501: "IFCDISTRIBUTIONCONTROLELEMENTTYPE",
  1945004755: "IFCDISTRIBUTIONELEMENT",
  3256556792: "IFCDISTRIBUTIONELEMENTTYPE",
  3040386961: "IFCDISTRIBUTIONFLOWELEMENT",
  3849074793: "IFCDISTRIBUTIONFLOWELEMENTTYPE",
  3041715199: "IFCDISTRIBUTIONPORT",
  3205830791: "IFCDISTRIBUTIONSYSTEM",
  1154170062: "IFCDOCUMENTINFORMATION",
  770865208: "IFCDOCUMENTINFORMATIONRELATIONSHIP",
  3732053477: "IFCDOCUMENTREFERENCE",
  395920057: "IFCDOOR",
  2963535650: "IFCDOORLININGPROPERTIES",
  1714330368: "IFCDOORPANELPROPERTIES",
  3242481149: "IFCDOORSTANDARDCASE",
  526551008: "IFCDOORSTYLE",
  2323601079: "IFCDOORTYPE",
  445594917: "IFCDRAUGHTINGPREDEFINEDCOLOUR",
  4006246654: "IFCDRAUGHTINGPREDEFINEDCURVEFONT",
  342316401: "IFCDUCTFITTING",
  869906466: "IFCDUCTFITTINGTYPE",
  3518393246: "IFCDUCTSEGMENT",
  3760055223: "IFCDUCTSEGMENTTYPE",
  1360408905: "IFCDUCTSILENCER",
  2030761528: "IFCDUCTSILENCERTYPE",
  3900360178: "IFCEDGE",
  476780140: "IFCEDGECURVE",
  1472233963: "IFCEDGELOOP",
  1904799276: "IFCELECTRICAPPLIANCE",
  663422040: "IFCELECTRICAPPLIANCETYPE",
  862014818: "IFCELECTRICDISTRIBUTIONBOARD",
  2417008758: "IFCELECTRICDISTRIBUTIONBOARDTYPE",
  3310460725: "IFCELECTRICFLOWSTORAGEDEVICE",
  3277789161: "IFCELECTRICFLOWSTORAGEDEVICETYPE",
  264262732: "IFCELECTRICGENERATOR",
  1534661035: "IFCELECTRICGENERATORTYPE",
  402227799: "IFCELECTRICMOTOR",
  1217240411: "IFCELECTRICMOTORTYPE",
  1003880860: "IFCELECTRICTIMECONTROL",
  712377611: "IFCELECTRICTIMECONTROLTYPE",
  1758889154: "IFCELEMENT",
  4123344466: "IFCELEMENTASSEMBLY",
  2397081782: "IFCELEMENTASSEMBLYTYPE",
  1623761950: "IFCELEMENTCOMPONENT",
  2590856083: "IFCELEMENTCOMPONENTTYPE",
  1883228015: "IFCELEMENTQUANTITY",
  339256511: "IFCELEMENTTYPE",
  2777663545: "IFCELEMENTARYSURFACE",
  1704287377: "IFCELLIPSE",
  2835456948: "IFCELLIPSEPROFILEDEF",
  1658829314: "IFCENERGYCONVERSIONDEVICE",
  2107101300: "IFCENERGYCONVERSIONDEVICETYPE",
  2814081492: "IFCENGINE",
  132023988: "IFCENGINETYPE",
  3747195512: "IFCEVAPORATIVECOOLER",
  3174744832: "IFCEVAPORATIVECOOLERTYPE",
  484807127: "IFCEVAPORATOR",
  3390157468: "IFCEVAPORATORTYPE",
  4148101412: "IFCEVENT",
  211053100: "IFCEVENTTIME",
  4024345920: "IFCEVENTTYPE",
  297599258: "IFCEXTENDEDPROPERTIES",
  4294318154: "IFCEXTERNALINFORMATION",
  3200245327: "IFCEXTERNALREFERENCE",
  1437805879: "IFCEXTERNALREFERENCERELATIONSHIP",
  1209101575: "IFCEXTERNALSPATIALELEMENT",
  2853485674: "IFCEXTERNALSPATIALSTRUCTUREELEMENT",
  2242383968: "IFCEXTERNALLYDEFINEDHATCHSTYLE",
  1040185647: "IFCEXTERNALLYDEFINEDSURFACESTYLE",
  3548104201: "IFCEXTERNALLYDEFINEDTEXTFONT",
  477187591: "IFCEXTRUDEDAREASOLID",
  2804161546: "IFCEXTRUDEDAREASOLIDTAPERED",
  2556980723: "IFCFACE",
  2047409740: "IFCFACEBASEDSURFACEMODEL",
  1809719519: "IFCFACEBOUND",
  803316827: "IFCFACEOUTERBOUND",
  3008276851: "IFCFACESURFACE",
  807026263: "IFCFACETEDBREP",
  3737207727: "IFCFACETEDBREPWITHVOIDS",
  24185140: "IFCFACILITY",
  1310830890: "IFCFACILITYPART",
  4219587988: "IFCFAILURECONNECTIONCONDITION",
  3415622556: "IFCFAN",
  346874300: "IFCFANTYPE",
  647756555: "IFCFASTENER",
  2489546625: "IFCFASTENERTYPE",
  2827207264: "IFCFEATUREELEMENT",
  2143335405: "IFCFEATUREELEMENTADDITION",
  1287392070: "IFCFEATUREELEMENTSUBTRACTION",
  738692330: "IFCFILLAREASTYLE",
  374418227: "IFCFILLAREASTYLEHATCHING",
  315944413: "IFCFILLAREASTYLETILES",
  819412036: "IFCFILTER",
  1810631287: "IFCFILTERTYPE",
  1426591983: "IFCFIRESUPPRESSIONTERMINAL",
  4222183408: "IFCFIRESUPPRESSIONTERMINALTYPE",
  2652556860: "IFCFIXEDREFERENCESWEPTAREASOLID",
  2058353004: "IFCFLOWCONTROLLER",
  3907093117: "IFCFLOWCONTROLLERTYPE",
  4278956645: "IFCFLOWFITTING",
  3198132628: "IFCFLOWFITTINGTYPE",
  182646315: "IFCFLOWINSTRUMENT",
  4037862832: "IFCFLOWINSTRUMENTTYPE",
  2188021234: "IFCFLOWMETER",
  3815607619: "IFCFLOWMETERTYPE",
  3132237377: "IFCFLOWMOVINGDEVICE",
  1482959167: "IFCFLOWMOVINGDEVICETYPE",
  987401354: "IFCFLOWSEGMENT",
  1834744321: "IFCFLOWSEGMENTTYPE",
  707683696: "IFCFLOWSTORAGEDEVICE",
  1339347760: "IFCFLOWSTORAGEDEVICETYPE",
  2223149337: "IFCFLOWTERMINAL",
  2297155007: "IFCFLOWTERMINALTYPE",
  3508470533: "IFCFLOWTREATMENTDEVICE",
  3009222698: "IFCFLOWTREATMENTDEVICETYPE",
  900683007: "IFCFOOTING",
  1893162501: "IFCFOOTINGTYPE",
  263784265: "IFCFURNISHINGELEMENT",
  4238390223: "IFCFURNISHINGELEMENTTYPE",
  1509553395: "IFCFURNITURE",
  1268542332: "IFCFURNITURETYPE",
  3493046030: "IFCGEOGRAPHICELEMENT",
  4095422895: "IFCGEOGRAPHICELEMENTTYPE",
  987898635: "IFCGEOMETRICCURVESET",
  3448662350: "IFCGEOMETRICREPRESENTATIONCONTEXT",
  2453401579: "IFCGEOMETRICREPRESENTATIONITEM",
  4142052618: "IFCGEOMETRICREPRESENTATIONSUBCONTEXT",
  3590301190: "IFCGEOMETRICSET",
  3009204131: "IFCGRID",
  852622518: "IFCGRIDAXIS",
  178086475: "IFCGRIDPLACEMENT",
  2706460486: "IFCGROUP",
  812098782: "IFCHALFSPACESOLID",
  3319311131: "IFCHEATEXCHANGER",
  1251058090: "IFCHEATEXCHANGERTYPE",
  2068733104: "IFCHUMIDIFIER",
  1806887404: "IFCHUMIDIFIERTYPE",
  1484403080: "IFCISHAPEPROFILEDEF",
  3905492369: "IFCIMAGETEXTURE",
  3570813810: "IFCINDEXEDCOLOURMAP",
  2571569899: "IFCINDEXEDPOLYCURVE",
  178912537: "IFCINDEXEDPOLYGONALFACE",
  2294589976: "IFCINDEXEDPOLYGONALFACEWITHVOIDS",
  1437953363: "IFCINDEXEDTEXTUREMAP",
  2133299955: "IFCINDEXEDTRIANGLETEXTUREMAP",
  4175244083: "IFCINTERCEPTOR",
  3946677679: "IFCINTERCEPTORTYPE",
  3113134337: "IFCINTERSECTIONCURVE",
  2391368822: "IFCINVENTORY",
  3741457305: "IFCIRREGULARTIMESERIES",
  3020489413: "IFCIRREGULARTIMESERIESVALUE",
  2176052936: "IFCJUNCTIONBOX",
  4288270099: "IFCJUNCTIONBOXTYPE",
  572779678: "IFCLSHAPEPROFILEDEF",
  3827777499: "IFCLABORRESOURCE",
  428585644: "IFCLABORRESOURCETYPE",
  1585845231: "IFCLAGTIME",
  76236018: "IFCLAMP",
  1051575348: "IFCLAMPTYPE",
  2655187982: "IFCLIBRARYINFORMATION",
  3452421091: "IFCLIBRARYREFERENCE",
  4162380809: "IFCLIGHTDISTRIBUTIONDATA",
  629592764: "IFCLIGHTFIXTURE",
  1161773419: "IFCLIGHTFIXTURETYPE",
  1566485204: "IFCLIGHTINTENSITYDISTRIBUTION",
  1402838566: "IFCLIGHTSOURCE",
  125510826: "IFCLIGHTSOURCEAMBIENT",
  2604431987: "IFCLIGHTSOURCEDIRECTIONAL",
  4266656042: "IFCLIGHTSOURCEGONIOMETRIC",
  1520743889: "IFCLIGHTSOURCEPOSITIONAL",
  3422422726: "IFCLIGHTSOURCESPOT",
  1281925730: "IFCLINE",
  3092502836: "IFCLINESEGMENT2D",
  388784114: "IFCLINEARPLACEMENT",
  1154579445: "IFCLINEARPOSITIONINGELEMENT",
  2624227202: "IFCLOCALPLACEMENT",
  1008929658: "IFCLOOP",
  1425443689: "IFCMANIFOLDSOLIDBREP",
  3057273783: "IFCMAPCONVERSION",
  2347385850: "IFCMAPPEDITEM",
  1838606355: "IFCMATERIAL",
  1847130766: "IFCMATERIALCLASSIFICATIONRELATIONSHIP",
  3708119e3: "IFCMATERIALCONSTITUENT",
  2852063980: "IFCMATERIALCONSTITUENTSET",
  760658860: "IFCMATERIALDEFINITION",
  2022407955: "IFCMATERIALDEFINITIONREPRESENTATION",
  248100487: "IFCMATERIALLAYER",
  3303938423: "IFCMATERIALLAYERSET",
  1303795690: "IFCMATERIALLAYERSETUSAGE",
  1847252529: "IFCMATERIALLAYERWITHOFFSETS",
  2199411900: "IFCMATERIALLIST",
  2235152071: "IFCMATERIALPROFILE",
  164193824: "IFCMATERIALPROFILESET",
  3079605661: "IFCMATERIALPROFILESETUSAGE",
  3404854881: "IFCMATERIALPROFILESETUSAGETAPERING",
  552965576: "IFCMATERIALPROFILEWITHOFFSETS",
  3265635763: "IFCMATERIALPROPERTIES",
  853536259: "IFCMATERIALRELATIONSHIP",
  1507914824: "IFCMATERIALUSAGEDEFINITION",
  2597039031: "IFCMEASUREWITHUNIT",
  377706215: "IFCMECHANICALFASTENER",
  2108223431: "IFCMECHANICALFASTENERTYPE",
  1437502449: "IFCMEDICALDEVICE",
  1114901282: "IFCMEDICALDEVICETYPE",
  1073191201: "IFCMEMBER",
  1911478936: "IFCMEMBERSTANDARDCASE",
  3181161470: "IFCMEMBERTYPE",
  3368373690: "IFCMETRIC",
  2998442950: "IFCMIRROREDPROFILEDEF",
  2706619895: "IFCMONETARYUNIT",
  2474470126: "IFCMOTORCONNECTION",
  977012517: "IFCMOTORCONNECTIONTYPE",
  1918398963: "IFCNAMEDUNIT",
  3888040117: "IFCOBJECT",
  219451334: "IFCOBJECTDEFINITION",
  3701648758: "IFCOBJECTPLACEMENT",
  2251480897: "IFCOBJECTIVE",
  4143007308: "IFCOCCUPANT",
  590820931: "IFCOFFSETCURVE",
  3388369263: "IFCOFFSETCURVE2D",
  3505215534: "IFCOFFSETCURVE3D",
  2485787929: "IFCOFFSETCURVEBYDISTANCES",
  2665983363: "IFCOPENSHELL",
  3588315303: "IFCOPENINGELEMENT",
  3079942009: "IFCOPENINGSTANDARDCASE",
  4251960020: "IFCORGANIZATION",
  1411181986: "IFCORGANIZATIONRELATIONSHIP",
  643959842: "IFCORIENTATIONEXPRESSION",
  1029017970: "IFCORIENTEDEDGE",
  144952367: "IFCOUTERBOUNDARYCURVE",
  3694346114: "IFCOUTLET",
  2837617999: "IFCOUTLETTYPE",
  1207048766: "IFCOWNERHISTORY",
  2529465313: "IFCPARAMETERIZEDPROFILEDEF",
  2519244187: "IFCPATH",
  1682466193: "IFCPCURVE",
  2382730787: "IFCPERFORMANCEHISTORY",
  3566463478: "IFCPERMEABLECOVERINGPROPERTIES",
  3327091369: "IFCPERMIT",
  2077209135: "IFCPERSON",
  101040310: "IFCPERSONANDORGANIZATION",
  3021840470: "IFCPHYSICALCOMPLEXQUANTITY",
  2483315170: "IFCPHYSICALQUANTITY",
  2226359599: "IFCPHYSICALSIMPLEQUANTITY",
  1687234759: "IFCPILE",
  1158309216: "IFCPILETYPE",
  310824031: "IFCPIPEFITTING",
  804291784: "IFCPIPEFITTINGTYPE",
  3612865200: "IFCPIPESEGMENT",
  4231323485: "IFCPIPESEGMENTTYPE",
  597895409: "IFCPIXELTEXTURE",
  2004835150: "IFCPLACEMENT",
  603570806: "IFCPLANARBOX",
  1663979128: "IFCPLANAREXTENT",
  220341763: "IFCPLANE",
  3171933400: "IFCPLATE",
  1156407060: "IFCPLATESTANDARDCASE",
  4017108033: "IFCPLATETYPE",
  2067069095: "IFCPOINT",
  4022376103: "IFCPOINTONCURVE",
  1423911732: "IFCPOINTONSURFACE",
  2924175390: "IFCPOLYLOOP",
  2775532180: "IFCPOLYGONALBOUNDEDHALFSPACE",
  2839578677: "IFCPOLYGONALFACESET",
  3724593414: "IFCPOLYLINE",
  3740093272: "IFCPORT",
  1946335990: "IFCPOSITIONINGELEMENT",
  3355820592: "IFCPOSTALADDRESS",
  759155922: "IFCPREDEFINEDCOLOUR",
  2559016684: "IFCPREDEFINEDCURVEFONT",
  3727388367: "IFCPREDEFINEDITEM",
  3778827333: "IFCPREDEFINEDPROPERTIES",
  3967405729: "IFCPREDEFINEDPROPERTYSET",
  1775413392: "IFCPREDEFINEDTEXTFONT",
  677532197: "IFCPRESENTATIONITEM",
  2022622350: "IFCPRESENTATIONLAYERASSIGNMENT",
  1304840413: "IFCPRESENTATIONLAYERWITHSTYLE",
  3119450353: "IFCPRESENTATIONSTYLE",
  2417041796: "IFCPRESENTATIONSTYLEASSIGNMENT",
  2744685151: "IFCPROCEDURE",
  569719735: "IFCPROCEDURETYPE",
  2945172077: "IFCPROCESS",
  4208778838: "IFCPRODUCT",
  673634403: "IFCPRODUCTDEFINITIONSHAPE",
  2095639259: "IFCPRODUCTREPRESENTATION",
  3958567839: "IFCPROFILEDEF",
  2802850158: "IFCPROFILEPROPERTIES",
  103090709: "IFCPROJECT",
  653396225: "IFCPROJECTLIBRARY",
  2904328755: "IFCPROJECTORDER",
  3843373140: "IFCPROJECTEDCRS",
  3651124850: "IFCPROJECTIONELEMENT",
  2598011224: "IFCPROPERTY",
  986844984: "IFCPROPERTYABSTRACTION",
  871118103: "IFCPROPERTYBOUNDEDVALUE",
  1680319473: "IFCPROPERTYDEFINITION",
  148025276: "IFCPROPERTYDEPENDENCYRELATIONSHIP",
  4166981789: "IFCPROPERTYENUMERATEDVALUE",
  3710013099: "IFCPROPERTYENUMERATION",
  2752243245: "IFCPROPERTYLISTVALUE",
  941946838: "IFCPROPERTYREFERENCEVALUE",
  1451395588: "IFCPROPERTYSET",
  3357820518: "IFCPROPERTYSETDEFINITION",
  492091185: "IFCPROPERTYSETTEMPLATE",
  3650150729: "IFCPROPERTYSINGLEVALUE",
  110355661: "IFCPROPERTYTABLEVALUE",
  3521284610: "IFCPROPERTYTEMPLATE",
  1482703590: "IFCPROPERTYTEMPLATEDEFINITION",
  738039164: "IFCPROTECTIVEDEVICE",
  2295281155: "IFCPROTECTIVEDEVICETRIPPINGUNIT",
  655969474: "IFCPROTECTIVEDEVICETRIPPINGUNITTYPE",
  1842657554: "IFCPROTECTIVEDEVICETYPE",
  3219374653: "IFCPROXY",
  90941305: "IFCPUMP",
  2250791053: "IFCPUMPTYPE",
  2044713172: "IFCQUANTITYAREA",
  2093928680: "IFCQUANTITYCOUNT",
  931644368: "IFCQUANTITYLENGTH",
  2090586900: "IFCQUANTITYSET",
  3252649465: "IFCQUANTITYTIME",
  2405470396: "IFCQUANTITYVOLUME",
  825690147: "IFCQUANTITYWEIGHT",
  2262370178: "IFCRAILING",
  2893384427: "IFCRAILINGTYPE",
  3024970846: "IFCRAMP",
  3283111854: "IFCRAMPFLIGHT",
  2324767716: "IFCRAMPFLIGHTTYPE",
  1469900589: "IFCRAMPTYPE",
  1232101972: "IFCRATIONALBSPLINECURVEWITHKNOTS",
  683857671: "IFCRATIONALBSPLINESURFACEWITHKNOTS",
  2770003689: "IFCRECTANGLEHOLLOWPROFILEDEF",
  3615266464: "IFCRECTANGLEPROFILEDEF",
  2798486643: "IFCRECTANGULARPYRAMID",
  3454111270: "IFCRECTANGULARTRIMMEDSURFACE",
  3915482550: "IFCRECURRENCEPATTERN",
  2433181523: "IFCREFERENCE",
  4021432810: "IFCREFERENT",
  3413951693: "IFCREGULARTIMESERIES",
  1580146022: "IFCREINFORCEMENTBARPROPERTIES",
  3765753017: "IFCREINFORCEMENTDEFINITIONPROPERTIES",
  979691226: "IFCREINFORCINGBAR",
  2572171363: "IFCREINFORCINGBARTYPE",
  3027567501: "IFCREINFORCINGELEMENT",
  964333572: "IFCREINFORCINGELEMENTTYPE",
  2320036040: "IFCREINFORCINGMESH",
  2310774935: "IFCREINFORCINGMESHTYPE",
  160246688: "IFCRELAGGREGATES",
  3939117080: "IFCRELASSIGNS",
  1683148259: "IFCRELASSIGNSTOACTOR",
  2495723537: "IFCRELASSIGNSTOCONTROL",
  1307041759: "IFCRELASSIGNSTOGROUP",
  1027710054: "IFCRELASSIGNSTOGROUPBYFACTOR",
  4278684876: "IFCRELASSIGNSTOPROCESS",
  2857406711: "IFCRELASSIGNSTOPRODUCT",
  205026976: "IFCRELASSIGNSTORESOURCE",
  1865459582: "IFCRELASSOCIATES",
  4095574036: "IFCRELASSOCIATESAPPROVAL",
  919958153: "IFCRELASSOCIATESCLASSIFICATION",
  2728634034: "IFCRELASSOCIATESCONSTRAINT",
  982818633: "IFCRELASSOCIATESDOCUMENT",
  3840914261: "IFCRELASSOCIATESLIBRARY",
  2655215786: "IFCRELASSOCIATESMATERIAL",
  826625072: "IFCRELCONNECTS",
  1204542856: "IFCRELCONNECTSELEMENTS",
  3945020480: "IFCRELCONNECTSPATHELEMENTS",
  4201705270: "IFCRELCONNECTSPORTTOELEMENT",
  3190031847: "IFCRELCONNECTSPORTS",
  2127690289: "IFCRELCONNECTSSTRUCTURALACTIVITY",
  1638771189: "IFCRELCONNECTSSTRUCTURALMEMBER",
  504942748: "IFCRELCONNECTSWITHECCENTRICITY",
  3678494232: "IFCRELCONNECTSWITHREALIZINGELEMENTS",
  3242617779: "IFCRELCONTAINEDINSPATIALSTRUCTURE",
  886880790: "IFCRELCOVERSBLDGELEMENTS",
  2802773753: "IFCRELCOVERSSPACES",
  2565941209: "IFCRELDECLARES",
  2551354335: "IFCRELDECOMPOSES",
  693640335: "IFCRELDEFINES",
  1462361463: "IFCRELDEFINESBYOBJECT",
  4186316022: "IFCRELDEFINESBYPROPERTIES",
  307848117: "IFCRELDEFINESBYTEMPLATE",
  781010003: "IFCRELDEFINESBYTYPE",
  3940055652: "IFCRELFILLSELEMENT",
  279856033: "IFCRELFLOWCONTROLELEMENTS",
  427948657: "IFCRELINTERFERESELEMENTS",
  3268803585: "IFCRELNESTS",
  1441486842: "IFCRELPOSITIONS",
  750771296: "IFCRELPROJECTSELEMENT",
  1245217292: "IFCRELREFERENCEDINSPATIALSTRUCTURE",
  4122056220: "IFCRELSEQUENCE",
  366585022: "IFCRELSERVICESBUILDINGS",
  3451746338: "IFCRELSPACEBOUNDARY",
  3523091289: "IFCRELSPACEBOUNDARY1STLEVEL",
  1521410863: "IFCRELSPACEBOUNDARY2NDLEVEL",
  1401173127: "IFCRELVOIDSELEMENT",
  478536968: "IFCRELATIONSHIP",
  816062949: "IFCREPARAMETRISEDCOMPOSITECURVESEGMENT",
  1076942058: "IFCREPRESENTATION",
  3377609919: "IFCREPRESENTATIONCONTEXT",
  3008791417: "IFCREPRESENTATIONITEM",
  1660063152: "IFCREPRESENTATIONMAP",
  2914609552: "IFCRESOURCE",
  2943643501: "IFCRESOURCEAPPROVALRELATIONSHIP",
  1608871552: "IFCRESOURCECONSTRAINTRELATIONSHIP",
  2439245199: "IFCRESOURCELEVELRELATIONSHIP",
  1042787934: "IFCRESOURCETIME",
  1856042241: "IFCREVOLVEDAREASOLID",
  3243963512: "IFCREVOLVEDAREASOLIDTAPERED",
  4158566097: "IFCRIGHTCIRCULARCONE",
  3626867408: "IFCRIGHTCIRCULARCYLINDER",
  2016517767: "IFCROOF",
  2781568857: "IFCROOFTYPE",
  2341007311: "IFCROOT",
  2778083089: "IFCROUNDEDRECTANGLEPROFILEDEF",
  448429030: "IFCSIUNIT",
  3053780830: "IFCSANITARYTERMINAL",
  1768891740: "IFCSANITARYTERMINALTYPE",
  1054537805: "IFCSCHEDULINGTIME",
  2157484638: "IFCSEAMCURVE",
  2042790032: "IFCSECTIONPROPERTIES",
  4165799628: "IFCSECTIONREINFORCEMENTPROPERTIES",
  1862484736: "IFCSECTIONEDSOLID",
  1290935644: "IFCSECTIONEDSOLIDHORIZONTAL",
  1509187699: "IFCSECTIONEDSPINE",
  4086658281: "IFCSENSOR",
  1783015770: "IFCSENSORTYPE",
  1329646415: "IFCSHADINGDEVICE",
  4074543187: "IFCSHADINGDEVICETYPE",
  867548509: "IFCSHAPEASPECT",
  3982875396: "IFCSHAPEMODEL",
  4240577450: "IFCSHAPEREPRESENTATION",
  4124623270: "IFCSHELLBASEDSURFACEMODEL",
  3692461612: "IFCSIMPLEPROPERTY",
  3663146110: "IFCSIMPLEPROPERTYTEMPLATE",
  4097777520: "IFCSITE",
  1529196076: "IFCSLAB",
  3127900445: "IFCSLABELEMENTEDCASE",
  3027962421: "IFCSLABSTANDARDCASE",
  2533589738: "IFCSLABTYPE",
  2609359061: "IFCSLIPPAGECONNECTIONCONDITION",
  3420628829: "IFCSOLARDEVICE",
  1072016465: "IFCSOLARDEVICETYPE",
  723233188: "IFCSOLIDMODEL",
  3856911033: "IFCSPACE",
  1999602285: "IFCSPACEHEATER",
  1305183839: "IFCSPACEHEATERTYPE",
  3812236995: "IFCSPACETYPE",
  1412071761: "IFCSPATIALELEMENT",
  710998568: "IFCSPATIALELEMENTTYPE",
  2706606064: "IFCSPATIALSTRUCTUREELEMENT",
  3893378262: "IFCSPATIALSTRUCTUREELEMENTTYPE",
  463610769: "IFCSPATIALZONE",
  2481509218: "IFCSPATIALZONETYPE",
  451544542: "IFCSPHERE",
  4015995234: "IFCSPHERICALSURFACE",
  1404847402: "IFCSTACKTERMINAL",
  3112655638: "IFCSTACKTERMINALTYPE",
  331165859: "IFCSTAIR",
  4252922144: "IFCSTAIRFLIGHT",
  1039846685: "IFCSTAIRFLIGHTTYPE",
  338393293: "IFCSTAIRTYPE",
  682877961: "IFCSTRUCTURALACTION",
  3544373492: "IFCSTRUCTURALACTIVITY",
  2515109513: "IFCSTRUCTURALANALYSISMODEL",
  1179482911: "IFCSTRUCTURALCONNECTION",
  2273995522: "IFCSTRUCTURALCONNECTIONCONDITION",
  1004757350: "IFCSTRUCTURALCURVEACTION",
  4243806635: "IFCSTRUCTURALCURVECONNECTION",
  214636428: "IFCSTRUCTURALCURVEMEMBER",
  2445595289: "IFCSTRUCTURALCURVEMEMBERVARYING",
  2757150158: "IFCSTRUCTURALCURVEREACTION",
  3136571912: "IFCSTRUCTURALITEM",
  1807405624: "IFCSTRUCTURALLINEARACTION",
  2162789131: "IFCSTRUCTURALLOAD",
  385403989: "IFCSTRUCTURALLOADCASE",
  3478079324: "IFCSTRUCTURALLOADCONFIGURATION",
  1252848954: "IFCSTRUCTURALLOADGROUP",
  1595516126: "IFCSTRUCTURALLOADLINEARFORCE",
  609421318: "IFCSTRUCTURALLOADORRESULT",
  2668620305: "IFCSTRUCTURALLOADPLANARFORCE",
  2473145415: "IFCSTRUCTURALLOADSINGLEDISPLACEMENT",
  1973038258: "IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION",
  1597423693: "IFCSTRUCTURALLOADSINGLEFORCE",
  1190533807: "IFCSTRUCTURALLOADSINGLEFORCEWARPING",
  2525727697: "IFCSTRUCTURALLOADSTATIC",
  3408363356: "IFCSTRUCTURALLOADTEMPERATURE",
  530289379: "IFCSTRUCTURALMEMBER",
  1621171031: "IFCSTRUCTURALPLANARACTION",
  2082059205: "IFCSTRUCTURALPOINTACTION",
  734778138: "IFCSTRUCTURALPOINTCONNECTION",
  1235345126: "IFCSTRUCTURALPOINTREACTION",
  3689010777: "IFCSTRUCTURALREACTION",
  2986769608: "IFCSTRUCTURALRESULTGROUP",
  3657597509: "IFCSTRUCTURALSURFACEACTION",
  1975003073: "IFCSTRUCTURALSURFACECONNECTION",
  3979015343: "IFCSTRUCTURALSURFACEMEMBER",
  2218152070: "IFCSTRUCTURALSURFACEMEMBERVARYING",
  603775116: "IFCSTRUCTURALSURFACEREACTION",
  2830218821: "IFCSTYLEMODEL",
  3958052878: "IFCSTYLEDITEM",
  3049322572: "IFCSTYLEDREPRESENTATION",
  148013059: "IFCSUBCONTRACTRESOURCE",
  4095615324: "IFCSUBCONTRACTRESOURCETYPE",
  2233826070: "IFCSUBEDGE",
  2513912981: "IFCSURFACE",
  699246055: "IFCSURFACECURVE",
  2028607225: "IFCSURFACECURVESWEPTAREASOLID",
  3101698114: "IFCSURFACEFEATURE",
  2809605785: "IFCSURFACEOFLINEAREXTRUSION",
  4124788165: "IFCSURFACEOFREVOLUTION",
  2934153892: "IFCSURFACEREINFORCEMENTAREA",
  1300840506: "IFCSURFACESTYLE",
  3303107099: "IFCSURFACESTYLELIGHTING",
  1607154358: "IFCSURFACESTYLEREFRACTION",
  1878645084: "IFCSURFACESTYLERENDERING",
  846575682: "IFCSURFACESTYLESHADING",
  1351298697: "IFCSURFACESTYLEWITHTEXTURES",
  626085974: "IFCSURFACETEXTURE",
  2247615214: "IFCSWEPTAREASOLID",
  1260650574: "IFCSWEPTDISKSOLID",
  1096409881: "IFCSWEPTDISKSOLIDPOLYGONAL",
  230924584: "IFCSWEPTSURFACE",
  1162798199: "IFCSWITCHINGDEVICE",
  2315554128: "IFCSWITCHINGDEVICETYPE",
  2254336722: "IFCSYSTEM",
  413509423: "IFCSYSTEMFURNITUREELEMENT",
  1580310250: "IFCSYSTEMFURNITUREELEMENTTYPE",
  3071757647: "IFCTSHAPEPROFILEDEF",
  985171141: "IFCTABLE",
  2043862942: "IFCTABLECOLUMN",
  531007025: "IFCTABLEROW",
  812556717: "IFCTANK",
  5716631: "IFCTANKTYPE",
  3473067441: "IFCTASK",
  1549132990: "IFCTASKTIME",
  2771591690: "IFCTASKTIMERECURRING",
  3206491090: "IFCTASKTYPE",
  912023232: "IFCTELECOMADDRESS",
  3824725483: "IFCTENDON",
  2347447852: "IFCTENDONANCHOR",
  3081323446: "IFCTENDONANCHORTYPE",
  3663046924: "IFCTENDONCONDUIT",
  2281632017: "IFCTENDONCONDUITTYPE",
  2415094496: "IFCTENDONTYPE",
  2387106220: "IFCTESSELLATEDFACESET",
  901063453: "IFCTESSELLATEDITEM",
  4282788508: "IFCTEXTLITERAL",
  3124975700: "IFCTEXTLITERALWITHEXTENT",
  1447204868: "IFCTEXTSTYLE",
  1983826977: "IFCTEXTSTYLEFONTMODEL",
  2636378356: "IFCTEXTSTYLEFORDEFINEDFONT",
  1640371178: "IFCTEXTSTYLETEXTMODEL",
  280115917: "IFCTEXTURECOORDINATE",
  1742049831: "IFCTEXTURECOORDINATEGENERATOR",
  2552916305: "IFCTEXTUREMAP",
  1210645708: "IFCTEXTUREVERTEX",
  3611470254: "IFCTEXTUREVERTEXLIST",
  1199560280: "IFCTIMEPERIOD",
  3101149627: "IFCTIMESERIES",
  581633288: "IFCTIMESERIESVALUE",
  1377556343: "IFCTOPOLOGICALREPRESENTATIONITEM",
  1735638870: "IFCTOPOLOGYREPRESENTATION",
  1935646853: "IFCTOROIDALSURFACE",
  3825984169: "IFCTRANSFORMER",
  1692211062: "IFCTRANSFORMERTYPE",
  2595432518: "IFCTRANSITIONCURVESEGMENT2D",
  1620046519: "IFCTRANSPORTELEMENT",
  2097647324: "IFCTRANSPORTELEMENTTYPE",
  2715220739: "IFCTRAPEZIUMPROFILEDEF",
  2916149573: "IFCTRIANGULATEDFACESET",
  1229763772: "IFCTRIANGULATEDIRREGULARNETWORK",
  3593883385: "IFCTRIMMEDCURVE",
  3026737570: "IFCTUBEBUNDLE",
  1600972822: "IFCTUBEBUNDLETYPE",
  1628702193: "IFCTYPEOBJECT",
  3736923433: "IFCTYPEPROCESS",
  2347495698: "IFCTYPEPRODUCT",
  3698973494: "IFCTYPERESOURCE",
  427810014: "IFCUSHAPEPROFILEDEF",
  180925521: "IFCUNITASSIGNMENT",
  630975310: "IFCUNITARYCONTROLELEMENT",
  3179687236: "IFCUNITARYCONTROLELEMENTTYPE",
  4292641817: "IFCUNITARYEQUIPMENT",
  1911125066: "IFCUNITARYEQUIPMENTTYPE",
  4207607924: "IFCVALVE",
  728799441: "IFCVALVETYPE",
  1417489154: "IFCVECTOR",
  2799835756: "IFCVERTEX",
  2759199220: "IFCVERTEXLOOP",
  1907098498: "IFCVERTEXPOINT",
  1530820697: "IFCVIBRATIONDAMPER",
  3956297820: "IFCVIBRATIONDAMPERTYPE",
  2391383451: "IFCVIBRATIONISOLATOR",
  3313531582: "IFCVIBRATIONISOLATORTYPE",
  2769231204: "IFCVIRTUALELEMENT",
  891718957: "IFCVIRTUALGRIDINTERSECTION",
  926996030: "IFCVOIDINGFEATURE",
  2391406946: "IFCWALL",
  4156078855: "IFCWALLELEMENTEDCASE",
  3512223829: "IFCWALLSTANDARDCASE",
  1898987631: "IFCWALLTYPE",
  4237592921: "IFCWASTETERMINAL",
  1133259667: "IFCWASTETERMINALTYPE",
  3304561284: "IFCWINDOW",
  336235671: "IFCWINDOWLININGPROPERTIES",
  512836454: "IFCWINDOWPANELPROPERTIES",
  486154966: "IFCWINDOWSTANDARDCASE",
  1299126871: "IFCWINDOWSTYLE",
  4009809668: "IFCWINDOWTYPE",
  4088093105: "IFCWORKCALENDAR",
  1028945134: "IFCWORKCONTROL",
  4218914973: "IFCWORKPLAN",
  3342526732: "IFCWORKSCHEDULE",
  1236880293: "IFCWORKTIME",
  2543172580: "IFCZSHAPEPROFILEDEF",
  1033361043: "IFCZONE"
};
var idsByName = {};
for (const id in namesById) {
  if (Object.prototype.hasOwnProperty.call(namesById, id)) {
    const name = namesById[id];
    idsByName[name] = parseInt(id);
  }
}
function getName(typeId, permissive = false) {
  const name = namesById[typeId];
  if (name === void 0) {
    if (permissive) {
      return typeId;
    }
    throw new Error(`IFC type name missing for id: ${typeId}`);
  }
  return name;
}
__name(getName, "getName");
function getId(typeName, permissive = false) {
  const id = idsByName[typeName];
  if (id === void 0) {
    if (permissive) {
      return typeName;
    }
    throw new Error(`IFC type id missing for name: ${typeName}`);
  }
  return id;
}
__name(getId, "getId");

// lib/src/logger.js
var import_log4js_api = __toESM(require_lib(), 1);
var loggers = {};
var DEFAULT_LEVEL = "warn";
function getLogger(name) {
  let logger5 = loggers[name];
  if (logger5) {
    return logger5;
  }
  logger5 = import_log4js_api.default.getLogger(name);
  logger5.level = DEFAULT_LEVEL;
  loggers[name] = logger5;
  return logger5;
}
__name(getLogger, "getLogger");

// lib/src/Ifc.js
var logger = getLogger("Ifc.js");
function isTypeValue(obj) {
  if (obj === null || obj === void 0) {
    return false;
  }
  const is = definedAndNonNull(obj["type"]) && definedAndNonNull(obj["value"]);
  return is;
}
__name(isTypeValue, "isTypeValue");
function decodeIFCString(ifcString) {
  const ifcUnicodeRegEx = new RegExp("\\\\X2\\\\(.*?)\\\\X0\\\\", "uig");
  let resultString = ifcString;
  let match = ifcUnicodeRegEx.exec(ifcString);
  while (match) {
    const unicodeChar = String.fromCharCode(parseInt(match[1], 16));
    resultString = resultString.replace(match[0], unicodeChar);
    match = ifcUnicodeRegEx.exec(ifcString);
  }
  return resultString;
}
__name(decodeIFCString, "decodeIFCString");
async function deref(ref, webIfc = null, indent = "") {
  logger.debug(`${indent}deref, in...`);
  if (ref === null || ref === void 0) {
    return "null";
  }
  if (Array.isArray(ref)) {
    logger.debug(`${indent}... array`);
    await (async () => {
      for (let i = 0; i < ref.length; i++) {
        ref[i] = await deref(ref[i], webIfc, `${indent}  `);
      }
    })();
    return ref;
  } else if (typeof ref === "object") {
    logger.debug(`${indent}... ref is object: expressID: `, ref.expressID);
    if (isTypeValue(ref)) {
      logger.debug(`${indent}.... and is simple typeValue`);
      switch (ref.type) {
        case STRING:
          return decodeIFCString(ref.value);
        case LABEL:
          return ref.value;
        case ENUM:
          return ref.value;
        case REAL:
          return ref.value;
        case REF: {
          const refId = stoi(ref.value);
          const refElt = await deref(await webIfc.properties.getItemProperties(0, refId, true), webIfc);
          if (refElt.GlobalId) {
            return {
              type: refElt.type,
              ref: refElt.GlobalId
            };
          }
          return refElt;
        }
        default:
          throw new Error(`Unknown reference type: ${ref}`);
      }
    } else {
      logger.debug(`${indent}... and is complex typeValue`);
      for (const objKey in ref) {
        if (!Object.prototype.hasOwnProperty.call(ref, objKey)) {
          continue;
        }
        const val = ref[objKey];
        if (objKey === "type") {
          ref[objKey] = getName(val, true);
        } else if (objKey === "GlobalId" && val.type === 1) {
          ref[objKey] = val.value;
        } else {
          logger.debug(`${indent}.... recurse on key: ${objKey}`);
          ref[objKey] = await deref(val, webIfc, `${indent}  `);
        }
      }
      return ref;
    }
  }
  logger.debug(`${indent}simple value:`, typeof ref, ref);
  return ref;
}
__name(deref, "deref");
function definedAndNonNull(val) {
  return val !== void 0 && val !== null;
}
__name(definedAndNonNull, "definedAndNonNull");

// lib/src/IfcModel.js
var IfcModel = class {
  constructor() {
    this.webIfc = new IfcAPI2();
    this.modelId = void 0;
  }
  async open(rawFileData) {
    await this.webIfc.Init();
    this.modelId = this.webIfc.OpenModel(rawFileData);
    return true;
  }
  extractHeaders(rawFileData) {
    const dataNdx = rawFileData.indexOf(Buffer.from("DATA;"));
    if (dataNdx === -1) {
      throw new Error('IFC file has no section marked "DATA;"');
    }
    const header = Buffer.alloc(dataNdx, 0);
    rawFileData.copy(header, 0, 0, dataNdx);
  }
  getProperties() {
    return this.webIfc.properties;
  }
  getElt(expressId) {
    if (expressId === void 0) {
      throw new Error("Must provide an Express ID");
    }
    const elt = this.webIfc.GetLine(this.modelId, expressId, true);
    return elt;
  }
  async getItemProperties(eltId, recursive = false) {
    const props = await this.getProperties().getItemProperties(this.modelId, eltId, recursive);
    return props;
  }
  async getItemPropertiesAndPsets(eltId, recursive = false) {
    const props = await this.getItemProperties(eltId, recursive);
    props.__psets = await this.getProperties().getPropertySets(this.modelId, eltId, recursive);
    return props;
  }
  getAllItems() {
    const allItems = {};
    const lines = this.webIfc.GetAllLines(this.modelId);
    this.getAllItemsFromLines(lines, allItems);
    return allItems;
  }
  getAllItemsFromLines(lines, allItems) {
    for (let i = 1; i <= lines.size(); i++) {
      try {
        this.saveProperties(lines, allItems, i);
      } catch (e) {
        console.warn(e);
      }
    }
  }
  saveProperties(lines, allItems, index) {
    const itemID = lines.get(index);
    if (!itemID) {
      console.warn(`line index(${index}) not in model`);
      return;
    }
    const props = this.webIfc.GetLine(this.modelId, itemID);
    props.type = props.__proto__.constructor.name;
    allItems[itemID] = props;
  }
  getEltsOfNamedType(typeName) {
    const typeId = getId(typeName);
    if (typeId === void 0) {
      throw new Error("Unknown type name: ", typeName);
    }
    const properties = this.webIfc.GetLineIDsWithType(this.modelId, typeId);
    const lines = [];
    for (let i = 0; i < properties.size(); i++) {
      const expressID = parseInt(properties.get(i));
      lines.push(this.webIfc.GetLine(this.modelId, expressID));
    }
    return lines;
  }
  async deref(elt) {
    return await deref(elt, this.webIfc);
  }
  close() {
    this.webIfc.CloseModel(this.modelId);
  }
};
__name(IfcModel, "IfcModel");

// lib/src/utils.js
var import_json2csv = __toESM(require_json2csv_umd(), 1);
var Exception = class extends Error {
};
__name(Exception, "Exception");
var internalError = /* @__PURE__ */ __name((errOrMsg, logger5, ...rest) => {
  if (errOrMsg instanceof Error) {
    logger5.error("Error: ", errOrMsg.message);
  } else {
    logger5.error(errOrMsg, ...rest);
  }
}, "internalError");
function fieldHasValue(obj, fieldParts) {
  if (fieldParts.length === 1) {
    const value = obj[fieldParts[0]];
    if (value === null || value === void 0) {
      return false;
    }
    return true;
  } else {
    const subFieldName = fieldParts[0];
    const subFieldValue = obj[subFieldName];
    if (subFieldValue === null || subFieldValue === void 0) {
      return false;
    }
    return fieldHasValue(subFieldValue, fieldParts.slice(1));
  }
}
__name(fieldHasValue, "fieldHasValue");
function jsonToCsv(json, omitEmptyFields = false, formatOpts = null) {
  const formatFields = formatOpts ? JSON.parse(formatOpts) : null;
  const transforms = [
    (item) => {
      if (omitEmptyFields) {
        if (item === null || item === void 0) {
          return null;
        }
        if (formatFields) {
          if (!Array.isArray(formatFields)) {
            throw new Error(`Format fields must be an array, got: ${formatFields}`);
          }
          for (let i = 0; i < formatFields.length; i++) {
            const fieldParts = formatFields[i].split(".");
            if (!fieldHasValue(item, fieldParts)) {
              return null;
            }
          }
        }
      }
      return item;
    }
  ];
  if (formatFields) {
    return (0, import_json2csv.parse)(json, { fields: formatFields, transforms });
  } else {
    return (0, import_json2csv.parse)(json, { transforms });
  }
}
__name(jsonToCsv, "jsonToCsv");
function isBrowser() {
  const f = new Function("try {return this===window;}catch(e){ return false;}");
  return f();
}
__name(isBrowser, "isBrowser");
function isNode() {
  const f = new Function("try {return this===global;}catch(e){return false;}");
  return f();
}
__name(isNode, "isNode");

// lib/src/arrays.js
function stoi2(strArr) {
  const eltIds = strArr.map((str) => stoi(str));
  const nanNdx = eltIds.findIndex(Number.isNaN);
  if (nanNdx !== -1) {
    throw new Exception(`Invalid ID: ${strArr[nanNdx]}`);
  }
  return eltIds;
}
__name(stoi2, "stoi");

// lib/src/version.js
function getPackageVersion() {
  return "5.4.8";
}
__name(getPackageVersion, "getPackageVersion");

// lib/src/ops/levels/calLevSec.js
var calLevSec_exports = {};
__export(calLevSec_exports, {
  addOffsetHeight: () => addOffsetHeight,
  calSecLevels: () => calSecLevels,
  calTargetCameraZ: () => calTargetCameraZ,
  extractHeight: () => extractHeight,
  getUsage: () => getUsage
});
var logger2 = getLogger("calLevSec.js");
function getUsage() {
  return `Usage: node src/calculateSecLevels.js <file.ifc>
EXAMPLE
node calculateSecLevels.js index.ifc
OUT:
[l1x, l1y, l1z]
[l2x, l2y, l2z]
...
`;
}
__name(getUsage, "getUsage");
function calSecLevels(model, config, globalFlags, ifcProps, results) {
  logger2.debug("calSecLevels.js#calSecLevels");
  if (config.help) {
    logger2.log(getUsage());
    return { status: "error" };
  }
  const elevValuesAll = extractHeight(model);
  const offsetHeight = 0.9;
  const selLevelsHeight = addOffsetHeight(elevValuesAll, offsetHeight);
  return { status: "ok", levelHeights: selLevelsHeight };
}
__name(calSecLevels, "calSecLevels");
function extractHeight(model) {
  logger2.debug("calSecLevels.js#extractHeight");
  const ifcBuildingStorey = model.getEltsOfNamedType("IFCBUILDINGSTOREY");
  const elevValues = [];
  for (let i = 0; i < ifcBuildingStorey.length; i++) {
    elevValues[i] = ifcBuildingStorey[i].Elevation.value;
  }
  return elevValues;
}
__name(extractHeight, "extractHeight");
function addOffsetHeight(elevValues, offsetHeight) {
  logger2.debug("calSecLevels.js#addOffsetHeight");
  const offElevValues = [];
  for (let i = 0; i < elevValues.length; i++) {
    offElevValues[i] = elevValues[i] + offsetHeight;
  }
  return offElevValues;
}
__name(addOffsetHeight, "addOffsetHeight");
function calTargetCameraZ(elevValues, screenSizeCo = 3) {
  let tallestHeight = 0;
  for (let i = 0; i < elevValues.length; i++) {
    if (elevValues[i] > tallestHeight) {
      tallestHeight = elevValues[i];
    }
  }
  const cameraZ = tallestHeight * screenSizeCo;
  return cameraZ;
}
__name(calTargetCameraZ, "calTargetCameraZ");

// lib/src/ops/levels/extractLevels.js
var extractLevels_exports = {};
__export(extractLevels_exports, {
  extractLevels: () => extractLevels,
  extractRELID: () => extractRELID,
  getUsage: () => getUsage2
});

// lib/src/files.js
var fileSystem;
function getFileSystem() {
  if (!fileSystem) {
    if (isBrowser()) {
      fileSystem = Promise.resolve().then(() => __toESM(require_filer_min(), 1));
    } else if (isNode()) {
      throw new Error("Use of pluggable filesystem from getFileSystem() not yet implemented.");
    } else {
      throw new Error("Could not determine environment");
    }
  }
  return fileSystem;
}
__name(getFileSystem, "getFileSystem");

// lib/src/ops/levels/extractLevels.js
var logger3 = getLogger("extractLevels.js");
function getUsage2() {
  return `Usage: node src/extractLevel.js <file.ifc>
EXAMPLE
node extractLevel.js index.ifc
OUT:
index.ifc_Level0.ifc
index.ifc_Level1.ifc
...
`;
}
__name(getUsage2, "getUsage");
async function extractLevels(model, config, globalFlags, ifcProps, results) {
  logger3.debug("extractLevels.js#extractLevels");
  if (config.help) {
    logger3.log(getUsage2());
    return;
  }
  const relElementsGrouped = await extractRELID(model);
  await createManipulateNewIFC(config.__meta.inputFilename, relElementsGrouped);
  return { status: "ok" };
}
__name(extractLevels, "extractLevels");
function extractRELID(model) {
  logger3.debug("extractLevels.js#extractRELID");
  const ifcRelSpatial = model.getEltsOfNamedType("IFCRELCONTAINEDINSPATIALSTRUCTURE");
  const AllrelElementsArr = [];
  for (let i = 0; i < ifcRelSpatial.length; i++) {
    const relElements = ifcRelSpatial[i].RelatedElements;
    const relElementsArr = [];
    for (let j = 0; j < relElements.length; j++) {
      relElementsArr[j] = relElements[j].value;
    }
    AllrelElementsArr[i] = relElementsArr;
  }
  const relElementsGroupedAll = groupElements(AllrelElementsArr);
  return relElementsGroupedAll;
}
__name(extractRELID, "extractRELID");
function groupElements(elementArray) {
  logger3.debug("extractLevels.js#groupElements");
  const groupedElements = [];
  for (let i = 0; i < elementArray.length + 1; i++) {
    let joinedArray = [];
    joinedArray = elementArray;
    joinedArray.splice(i, 1);
    const flatElements = joinedArray.flat();
    groupedElements[i] = flatElements;
  }
  return groupedElements;
}
__name(groupElements, "groupElements");
function createManipulateNewIFC(inputIfcFilename, relatedElemGrouped) {
  logger3.debug("extractLevels.js#createManipulateNewIFC");
  for (let i = 0; i < relatedElemGrouped.length; i++) {
    const newfilename = `${inputIfcFilename}_Level-${i}.ifc`;
    copyFiles(inputIfcFilename, newfilename, relatedElemGrouped[i]);
  }
}
__name(createManipulateNewIFC, "createManipulateNewIFC");
function expressIDtoLineMap(IFCdata) {
  const expressIDMaps = /* @__PURE__ */ new Map();
  const lines = IFCdata.split("\n");
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (line.indexOf("#") !== -1 && line.indexOf("=") !== -1) {
      const data1 = line.split("#");
      const data2 = data1[1].split("=");
      const expressID = data2[0];
      expressIDMaps.set(parseInt(expressID), i);
    }
  }
  return expressIDMaps;
}
__name(expressIDtoLineMap, "expressIDtoLineMap");
function findLinesWithExpressID(IFCdata, expressIDs = []) {
  const expressIDMap = expressIDtoLineMap(IFCdata);
  const lineIndexes = [];
  for (let i = 0; i < expressIDs.length; i++) {
    try {
      lineIndexes[i] = expressIDMap.get(expressIDs[i]);
    } catch (e) {
      console.error(e);
    }
  }
  return lineIndexes;
}
__name(findLinesWithExpressID, "findLinesWithExpressID");
var removeLines = /* @__PURE__ */ __name((data, lines = []) => {
  return data.split("\n").filter((val, idx) => lines.indexOf(idx) === -1).join("\n");
}, "removeLines");
function removeLinesFromIFCwithExpressID(filename, expressIDsToRemove) {
  const fileCopiedBool = true;
  if (fileCopiedBool) {
    getFileSystem().readFile(filename, "utf8", (err, data) => {
      if (err) {
        throw err;
      }
      const linesToRemove = findLinesWithExpressID(data, expressIDsToRemove);
      getFileSystem().writeFile(filename, removeLines(data, linesToRemove), "utf8", (err2) => {
        if (err2) {
          throw err2;
        }
        logger3.log(`${filename} is ready`);
      });
    });
  } else {
    logger3.log("Files not copied yet");
  }
}
__name(removeLinesFromIFCwithExpressID, "removeLinesFromIFCwithExpressID");
function copyFiles(from, to, expressIDsToRemoveIFCRel) {
  getFileSystem().copyFileSync(from, to);
  removeLinesFromIFCwithExpressID(to, expressIDsToRemoveIFCRel);
}
__name(copyFiles, "copyFiles");

// lib/src/ops/Ops.js
var Ops = {
  EXTRACT: {
    getUsage: extractLevels_exports.getUsage,
    run: (model, config, globalFlags, ifcProps, results) => {
      return extractLevels_exports.extractLevels(model, config, globalFlags, ifcProps, results);
    }
  },
  LEVELS: {
    getUsage: calLevSec_exports.getUsage,
    run: (model, config, globalFlags, ifcProps, results) => {
      return calLevSec_exports.calSecLevels(model, config, globalFlags, ifcProps, results);
    }
  }
};
var Ops_default = Ops;

// lib/src/ops/Pipeline.js
var Pipeline = class {
  constructor(model) {
    this.model = model;
    this.stages = [];
  }
  addStage(name, config, globalFlags) {
    switch (name) {
      case "extractLevels":
        this.stages.push((ifcProps, results) => ({ extractLevels: Ops_default.EXTRACT.run(this.model, config, ifcProps, results, globalFlags) }));
        break;
      case "findLevels":
        this.stages.push((ifcProps, results) => ({ findLevels: Ops_default.LEVELS.run(this.model, config, ifcProps, results, globalFlags) }));
        break;
      default:
        throw new Error(`Unknown operation: "${name}"`);
    }
  }
  run(ifcProps) {
    const results = [];
    for (let i = 0; i < this.stages.length; i++) {
      const op = this.stages[i];
      const result = op(ifcProps, results);
      results.push(result);
    }
    return results;
  }
};
__name(Pipeline, "Pipeline");

// lib/src/ifctool.js
var logger4 = getLogger("ifctool.js");
async function processIfcBuffer(fileData, flags = {}) {
  const model = new IfcModel();
  await model.open(fileData);
  let ifcProps = null;
  try {
    ifcProps = await extractIfcProps(model, flags);
    if (ifcProps === null || ifcProps.length === 0) {
      return null;
    }
    ifcProps = await maybeDeref(model, ifcProps, flags);
    if (flags.pipeline) {
      const pipelineConfig = JSON.parse(flags.pipeline);
      if (!(pipelineConfig.stages && Array.isArray(pipelineConfig.stages))) {
        console.error('--pipeline config object must have "stages" field with array value');
      }
      pipelineConfig.__meta = flags.__meta;
      const pipeline = new Pipeline(model, pipelineConfig);
      for (let i = 0; i < pipelineConfig.stages.length; i++) {
        const stageConfig = pipelineConfig.stages[i];
        if (!stageConfig.name) {
          console.error('--pipeline stage config object must have "name" field with non-empty string value');
        }
        if (!stageConfig.config) {
          console.error('--pipeline stage config object must have "config" field with object value');
        }
        pipeline.addStage(stageConfig.name, stageConfig.config, flags);
      }
      const results = pipeline.run(ifcProps, flags);
      ifcProps = format(results, flags);
    } else {
      ifcProps = format(ifcProps, flags);
    }
  } catch (e) {
    if (e instanceof Exception) {
      internalError(e, logger4);
      return null;
    }
    throw e;
  }
  return ifcProps;
}
__name(processIfcBuffer, "processIfcBuffer");
async function extractIfcProps(model, flags) {
  let ifcProps = null;
  if (flags.elts) {
    const strIds = flags.elts.split(",");
    const eltIds = stoi2(strIds);
    ifcProps = await Promise.all(eltIds.map(async (eltId) => await model.getItemPropertiesAndPsets(eltId, true)));
    const missing = removeMismatchedIds(eltIds, ifcProps);
    if (missing.length > 0) {
      logger4.debug("Missing elts:", missing);
    }
    if (Array.isArray(ifcProps) && ifcProps.length === 1) {
      ifcProps = ifcProps[0];
    }
  } else if (flags.types) {
    const types = flags.types.split(",");
    ifcProps = types.map((t) => model.getEltsOfNamedType(t.toUpperCase())).flat();
  } else if (flags.spatialRoot) {
    logger4.warn("--spatialRoot not implemented");
  } else if (flags.newProps) {
    const itemMap = model.getAllItems();
    const itemsAsRows = [];
    itemMap.forEach((item) => itemsAsRows.push(item));
    ifcProps = itemsAsRows;
  } else {
    model.webIfc.CreateIfcGuidToExpressIdMapping(0);
    const guidsContainer = model.webIfc.ifcGuidMap;
    let guidsMap = null;
    for (const entry of guidsContainer) {
      if (typeof entry[1] === "object") {
        guidsMap = entry[1];
        break;
      }
    }
    const guids = [];
    const expressIds = [];
    for (const entry of guidsMap) {
      const val = entry[0];
      if (typeof val === "string") {
        guids.push(val);
      } else {
        expressIds.push(val);
      }
    }
    ifcProps = await Promise.all(expressIds.map(async (eltId) => {
      const propsAndPsets = await model.getItemPropertiesAndPsets(eltId, true);
      if (propsAndPsets.__psets) {
        const psetArr = flattenPsets(propsAndPsets.__psets);
        for (let i = 0; i < psetArr.length; i++) {
          const pset = psetArr[i];
          Object.assign(propsAndPsets, pset);
        }
        delete propsAndPsets["__psets"];
      }
      return propsAndPsets;
    }));
  }
  return ifcProps;
}
__name(extractIfcProps, "extractIfcProps");
async function maybeDeref(model, ifcProps, flags) {
  if (flags.deref) {
    ifcProps = await model.deref(ifcProps);
    if (Array.isArray(ifcProps)) {
      return await Promise.all(ifcProps.map((elt) => {
        return model.deref(elt);
      }));
    }
    return await model.deref(ifcProps);
  }
  return ifcProps;
}
__name(maybeDeref, "maybeDeref");
function flattenPsets(psets) {
  if (!Array.isArray(psets)) {
    logger4.warn("Expected array, got", psets);
    return void 0;
  }
  return psets.map((pset) => {
    if (!Array.isArray(pset.HasProperties)) {
      return void 0;
    }
    const namePrefix = pset.Name.value;
    const props = pset.HasProperties;
    const propSetMap = {};
    for (let i = 0; i < props.length; i++) {
      const prop = props[i];
      if (prop.type === IFCPROPERTYSINGLEVALUE) {
        propSetMap[`${namePrefix}.${prop.Name.value}`] = prop.NominalValue.value;
      }
    }
    return propSetMap;
  }).flat();
}
__name(flattenPsets, "flattenPsets");
function format(ifcProps, flags) {
  flags.omitOwnerHistory = flags.omitOwnerHistory || true;
  flags.omitRepresentation = flags.omitRepresentation || true;
  flags.omitPlacement = flags.omitPlacement || true;
  ifcProps = JSON.parse(JSON.stringify(ifcProps, (k, v) => {
    if (flags.omitExpressId && k === "expressID") {
      return void 0;
    }
    if (flags.omitOwnerHistory && k === "OwnerHistory") {
      return void 0;
    }
    if (flags.omitPlacement && k === "ObjectPlacement") {
      return void 0;
    }
    if (flags.omitRepresentation && k === "Representation") {
      return void 0;
    }
    if (flags.omitNull && (v === null || v === "null")) {
      return void 0;
    }
    return v;
  }));
  let outputJson = true;
  if (flags.out) {
    if (flags.out === "csv") {
      ifcProps = jsonToCsv(ifcProps, flags.omitNull, flags.fmt);
      outputJson = false;
    } else if (flags.out === "json") {
    } else {
      internalError(`Unsupported output format: ${flags.out}`, logger4);
      return null;
    }
  }
  if (outputJson) {
    ifcProps = createHeader(ifcProps);
    const numIndentSpaces = 2;
    ifcProps = JSON.stringify(ifcProps, null, numIndentSpaces);
  }
  return ifcProps;
}
__name(format, "format");
function createHeader(ifcProps) {
  const version = getPackageVersion();
  const header = {
    type: "ifcJSON",
    version: "0.0.1",
    schemaIdentifier: "<unknown; TODO(pablo)>",
    originatingSystem: `IFC2JSON_js ${version}`,
    preprocessorVersion: `web-ifc 0.0.34`,
    timeStamp: new Date().toISOString(),
    data: Array.isArray(ifcProps) ? ifcProps : [ifcProps]
  };
  return header;
}
__name(createHeader, "createHeader");
function removeMismatchedIds(ids, elts) {
  let missing = [];
  let i = 0;
  while (i < ids.length) {
    if (!Number.isInteger(ids[i])) {
      throw new Error("Id not a number: ", ids[i]);
    }
    if (ids[i] !== elts[i].expressID) {
      missing = missing.concat(ids.splice(i, 1));
      elts.splice(i, 1);
      continue;
    }
    i++;
  }
  return missing;
}
__name(removeMismatchedIds, "removeMismatchedIds");
export {
  extractIfcProps,
  format,
  maybeDeref,
  processIfcBuffer
};
//# sourceMappingURL=ifclib.js.map
